
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model DewKitchenCategory
 * 
 */
export type DewKitchenCategory = {
  id: number
  name: string
  createAt: Date
  updateAt: Date
}

/**
 * Model DewKitchenMenu
 * 
 */
export type DewKitchenMenu = {
  id: number
  name: string
  image: string
  price: number
  categoryName: string | null
  createAt: Date
  updateAt: Date
}

/**
 * Model DewKitchenOrder
 * 
 */
export type DewKitchenOrder = {
  id: number
  status: string
  tableId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model DewOrderItem
 * 
 */
export type DewOrderItem = {
  id: number
  menuId: number
  orderId: number | null
  quantity: number
  totalPrice: number
  createAt: Date
  updateAt: Date
}

/**
 * Model BookEx
 * 
 */
export type BookEx = {
  id: number
  title: string
}

/**
 * Model AuthorEx
 * 
 */
export type AuthorEx = {
  id: number
  name: string
}

/**
 * Model BookExOnAuthorEx
 * 
 */
export type BookExOnAuthorEx = {
  bookExampleId: number
  authorExampleId: number
}

/**
 * Model SeriesTv
 * 
 */
export type SeriesTv = {
  id: number
  name: string
}

/**
 * Model Actors
 * 
 */
export type Actors = {
  id: number
  name: string
}

/**
 * Model Dew
 * 
 */
export type Dew = {
  id: number
  name: string
  kadId: number
}

/**
 * Model Kad
 * 
 */
export type Kad = {
  id: number
  name: string
}

/**
 * Model QuizeTable
 * 
 */
export type QuizeTable = {
  id: number
  idQuestion: number
  createAt: Date
  updateAt: Date
}

/**
 * Model Question
 * 
 */
export type Question = {
  id: number
  question: string
  answer: string
  idCategory: number
  idAnswer: number
  idQuize: number
  createAt: Date
  updateAt: Date
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: number
  name: string
  createAt: Date
  updateAt: Date
}

/**
 * Model roundTable
 * 
 */
export type roundTable = {
  id: number
  score: number
  categoryId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model roundQuestionTable
 * 
 */
export type roundQuestionTable = {
  id: number
  roundId: number
  userAnswerId: number
  quizId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model QuizeCategory
 * 
 */
export type QuizeCategory = {
  id: number
  name: string
  createAt: Date
  updateAt: Date
}

/**
 * Model QuizeQuestion
 * 
 */
export type QuizeQuestion = {
  id: number
  question: string
  quizeCategoryId: number | null
  quizeAnswerId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model QuizeChoice
 * 
 */
export type QuizeChoice = {
  id: number
  choice: string
  questionId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model QuizeAnswer
 * 
 */
export type QuizeAnswer = {
  id: number
  answer: string
  choiceId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model QuizeGameRound
 * 
 */
export type QuizeGameRound = {
  id: number
  user: string
  score: number
  answerId: number
  questionId: number
  choiceId: number
}

/**
 * Model MainCompany
 * 
 */
export type MainCompany = {
  id: number
  createAt: Date
  updateAt: Date
}

/**
 * Model Branch
 * 
 */
export type Branch = {
  id: number
  ownerName: string
  tel: number
  address: string
  area: number
  totolMachine: number
  mainCompanyId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model Machine
 * 
 */
export type Machine = {
  id: number
  brand: string
  size: string
  category: string
  model: string
  mfg: string
  insurance: string
  branchId: number | null
  washHistoryId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model Program
 * 
 */
export type Program = {
  id: number
  duration: number
  price: number
  washHistoryId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model MachineOnProgram
 * 
 */
export type MachineOnProgram = {
  id: number
  machineId: number
  programId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model ProcessType
 * 
 */
export type ProcessType = {
  id: number
  description: string
  programId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model RepairHistory
 * 
 */
export type RepairHistory = {
  id: number
  time: number
  machineId: number | null
  repairDetailId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model RepairDetail
 * 
 */
export type RepairDetail = {
  id: number
  date: string
  damage: string
  cause: string
  machanics: string
  createAt: Date
  updateAt: Date
  repairHistoryId: number
}

/**
 * Model washUser
 * 
 */
export type washUser = {
  id: number
  name: string
  tel: number
  balance: number
  washHistoryId: number | null
  createAt: Date
  updateAt: Date
}

/**
 * Model WashHistory
 * 
 */
export type WashHistory = {
  id: number
  date: string
  price: number
  createAt: Date
  updateAt: Date
}

/**
 * Model Todolist
 * 
 */
export type Todolist = {
  id: number
  task: string
  notes: string | null
  status: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: number
  name: string
  image: string
  createAt: Date
  updateAt: Date
}

/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = {
  id: number
  userId: number
  message: string
  createAt: Date
  updateAt: Date
}

/**
 * Model UserRelation
 * 
 */
export type UserRelation = {
  id: number
  fromId: number
  toId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model HashTag
 * 
 */
export type HashTag = {
  id: number
  name: string
  createAt: Date
  updateAt: Date
  postOnHashTagId: number | null
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: number
  message: string
  userId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model PostOnHashTag
 * 
 */
export type PostOnHashTag = {
  id: number
  createAt: Date
  updateAt: Date
}

/**
 * Model Reply
 * 
 */
export type Reply = {
  id: number
  message: string
  postId: number
  createAt: Date
  updateAt: Date
  userId: number
}

/**
 * Model YoutubeUser
 * 
 */
export type YoutubeUser = {
  id: number
  name: string
  email: string
  image: string
  createAt: Date
  updateAt: Date
}

/**
 * Model YoutubeRole
 * 
 */
export type YoutubeRole = {
  id: number
  role: string
  createAt: Date
  updateAt: Date
}

/**
 * Model YoutubeReaction
 * 
 */
export type YoutubeReaction = {
  id: number
  reaction: string
  createAt: Date
  updateAt: Date
}

/**
 * Model YoutubeVideo
 * 
 */
export type YoutubeVideo = {
  id: number
  name: string
  description: string
  url: string
  channelId: number | null
  createAt: Date
  updateAt: Date
  youtubeReactionId: number
}

/**
 * Model YoutubeChannel
 * 
 */
export type YoutubeChannel = {
  id: number
  name: string
  image: string
  createAt: Date
  updateAt: Date
}

/**
 * Model YoutubeCommentToVideo
 * 
 */
export type YoutubeCommentToVideo = {
  id: number
  video: number
  comment: string
  commenterId: number
  createAt: Date
  updateAt: Date
}

/**
 * Model YoutubeUserToChannel
 * 
 */
export type YoutubeUserToChannel = {
  userId: number
  channelId: number
  roleId: number
  createAt: Date
  updateAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more DewKitchenCategories
 * const dewKitchenCategories = await prisma.dewKitchenCategory.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more DewKitchenCategories
   * const dewKitchenCategories = await prisma.dewKitchenCategory.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.dewKitchenCategory`: Exposes CRUD operations for the **DewKitchenCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DewKitchenCategories
    * const dewKitchenCategories = await prisma.dewKitchenCategory.findMany()
    * ```
    */
  get dewKitchenCategory(): Prisma.DewKitchenCategoryDelegate<GlobalReject>;

  /**
   * `prisma.dewKitchenMenu`: Exposes CRUD operations for the **DewKitchenMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DewKitchenMenus
    * const dewKitchenMenus = await prisma.dewKitchenMenu.findMany()
    * ```
    */
  get dewKitchenMenu(): Prisma.DewKitchenMenuDelegate<GlobalReject>;

  /**
   * `prisma.dewKitchenOrder`: Exposes CRUD operations for the **DewKitchenOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DewKitchenOrders
    * const dewKitchenOrders = await prisma.dewKitchenOrder.findMany()
    * ```
    */
  get dewKitchenOrder(): Prisma.DewKitchenOrderDelegate<GlobalReject>;

  /**
   * `prisma.dewOrderItem`: Exposes CRUD operations for the **DewOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DewOrderItems
    * const dewOrderItems = await prisma.dewOrderItem.findMany()
    * ```
    */
  get dewOrderItem(): Prisma.DewOrderItemDelegate<GlobalReject>;

  /**
   * `prisma.bookEx`: Exposes CRUD operations for the **BookEx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookExes
    * const bookExes = await prisma.bookEx.findMany()
    * ```
    */
  get bookEx(): Prisma.BookExDelegate<GlobalReject>;

  /**
   * `prisma.authorEx`: Exposes CRUD operations for the **AuthorEx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorExes
    * const authorExes = await prisma.authorEx.findMany()
    * ```
    */
  get authorEx(): Prisma.AuthorExDelegate<GlobalReject>;

  /**
   * `prisma.bookExOnAuthorEx`: Exposes CRUD operations for the **BookExOnAuthorEx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookExOnAuthorExes
    * const bookExOnAuthorExes = await prisma.bookExOnAuthorEx.findMany()
    * ```
    */
  get bookExOnAuthorEx(): Prisma.BookExOnAuthorExDelegate<GlobalReject>;

  /**
   * `prisma.seriesTv`: Exposes CRUD operations for the **SeriesTv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeriesTvs
    * const seriesTvs = await prisma.seriesTv.findMany()
    * ```
    */
  get seriesTv(): Prisma.SeriesTvDelegate<GlobalReject>;

  /**
   * `prisma.actors`: Exposes CRUD operations for the **Actors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actors
    * const actors = await prisma.actors.findMany()
    * ```
    */
  get actors(): Prisma.ActorsDelegate<GlobalReject>;

  /**
   * `prisma.dew`: Exposes CRUD operations for the **Dew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dews
    * const dews = await prisma.dew.findMany()
    * ```
    */
  get dew(): Prisma.DewDelegate<GlobalReject>;

  /**
   * `prisma.kad`: Exposes CRUD operations for the **Kad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kads
    * const kads = await prisma.kad.findMany()
    * ```
    */
  get kad(): Prisma.KadDelegate<GlobalReject>;

  /**
   * `prisma.quizeTable`: Exposes CRUD operations for the **QuizeTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeTables
    * const quizeTables = await prisma.quizeTable.findMany()
    * ```
    */
  get quizeTable(): Prisma.QuizeTableDelegate<GlobalReject>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.roundTable`: Exposes CRUD operations for the **roundTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoundTables
    * const roundTables = await prisma.roundTable.findMany()
    * ```
    */
  get roundTable(): Prisma.roundTableDelegate<GlobalReject>;

  /**
   * `prisma.roundQuestionTable`: Exposes CRUD operations for the **roundQuestionTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoundQuestionTables
    * const roundQuestionTables = await prisma.roundQuestionTable.findMany()
    * ```
    */
  get roundQuestionTable(): Prisma.roundQuestionTableDelegate<GlobalReject>;

  /**
   * `prisma.quizeCategory`: Exposes CRUD operations for the **QuizeCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeCategories
    * const quizeCategories = await prisma.quizeCategory.findMany()
    * ```
    */
  get quizeCategory(): Prisma.QuizeCategoryDelegate<GlobalReject>;

  /**
   * `prisma.quizeQuestion`: Exposes CRUD operations for the **QuizeQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeQuestions
    * const quizeQuestions = await prisma.quizeQuestion.findMany()
    * ```
    */
  get quizeQuestion(): Prisma.QuizeQuestionDelegate<GlobalReject>;

  /**
   * `prisma.quizeChoice`: Exposes CRUD operations for the **QuizeChoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeChoices
    * const quizeChoices = await prisma.quizeChoice.findMany()
    * ```
    */
  get quizeChoice(): Prisma.QuizeChoiceDelegate<GlobalReject>;

  /**
   * `prisma.quizeAnswer`: Exposes CRUD operations for the **QuizeAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeAnswers
    * const quizeAnswers = await prisma.quizeAnswer.findMany()
    * ```
    */
  get quizeAnswer(): Prisma.QuizeAnswerDelegate<GlobalReject>;

  /**
   * `prisma.quizeGameRound`: Exposes CRUD operations for the **QuizeGameRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizeGameRounds
    * const quizeGameRounds = await prisma.quizeGameRound.findMany()
    * ```
    */
  get quizeGameRound(): Prisma.QuizeGameRoundDelegate<GlobalReject>;

  /**
   * `prisma.mainCompany`: Exposes CRUD operations for the **MainCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MainCompanies
    * const mainCompanies = await prisma.mainCompany.findMany()
    * ```
    */
  get mainCompany(): Prisma.MainCompanyDelegate<GlobalReject>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<GlobalReject>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<GlobalReject>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<GlobalReject>;

  /**
   * `prisma.machineOnProgram`: Exposes CRUD operations for the **MachineOnProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineOnPrograms
    * const machineOnPrograms = await prisma.machineOnProgram.findMany()
    * ```
    */
  get machineOnProgram(): Prisma.MachineOnProgramDelegate<GlobalReject>;

  /**
   * `prisma.processType`: Exposes CRUD operations for the **ProcessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessTypes
    * const processTypes = await prisma.processType.findMany()
    * ```
    */
  get processType(): Prisma.ProcessTypeDelegate<GlobalReject>;

  /**
   * `prisma.repairHistory`: Exposes CRUD operations for the **RepairHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairHistories
    * const repairHistories = await prisma.repairHistory.findMany()
    * ```
    */
  get repairHistory(): Prisma.RepairHistoryDelegate<GlobalReject>;

  /**
   * `prisma.repairDetail`: Exposes CRUD operations for the **RepairDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepairDetails
    * const repairDetails = await prisma.repairDetail.findMany()
    * ```
    */
  get repairDetail(): Prisma.RepairDetailDelegate<GlobalReject>;

  /**
   * `prisma.washUser`: Exposes CRUD operations for the **washUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashUsers
    * const washUsers = await prisma.washUser.findMany()
    * ```
    */
  get washUser(): Prisma.washUserDelegate<GlobalReject>;

  /**
   * `prisma.washHistory`: Exposes CRUD operations for the **WashHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashHistories
    * const washHistories = await prisma.washHistory.findMany()
    * ```
    */
  get washHistory(): Prisma.WashHistoryDelegate<GlobalReject>;

  /**
   * `prisma.todolist`: Exposes CRUD operations for the **Todolist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Todolists
    * const todolists = await prisma.todolist.findMany()
    * ```
    */
  get todolist(): Prisma.TodolistDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.userRelation`: Exposes CRUD operations for the **UserRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRelations
    * const userRelations = await prisma.userRelation.findMany()
    * ```
    */
  get userRelation(): Prisma.UserRelationDelegate<GlobalReject>;

  /**
   * `prisma.hashTag`: Exposes CRUD operations for the **HashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HashTags
    * const hashTags = await prisma.hashTag.findMany()
    * ```
    */
  get hashTag(): Prisma.HashTagDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.postOnHashTag`: Exposes CRUD operations for the **PostOnHashTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostOnHashTags
    * const postOnHashTags = await prisma.postOnHashTag.findMany()
    * ```
    */
  get postOnHashTag(): Prisma.PostOnHashTagDelegate<GlobalReject>;

  /**
   * `prisma.reply`: Exposes CRUD operations for the **Reply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Replies
    * const replies = await prisma.reply.findMany()
    * ```
    */
  get reply(): Prisma.ReplyDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUser`: Exposes CRUD operations for the **YoutubeUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUsers
    * const youtubeUsers = await prisma.youtubeUser.findMany()
    * ```
    */
  get youtubeUser(): Prisma.YoutubeUserDelegate<GlobalReject>;

  /**
   * `prisma.youtubeRole`: Exposes CRUD operations for the **YoutubeRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeRoles
    * const youtubeRoles = await prisma.youtubeRole.findMany()
    * ```
    */
  get youtubeRole(): Prisma.YoutubeRoleDelegate<GlobalReject>;

  /**
   * `prisma.youtubeReaction`: Exposes CRUD operations for the **YoutubeReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeReactions
    * const youtubeReactions = await prisma.youtubeReaction.findMany()
    * ```
    */
  get youtubeReaction(): Prisma.YoutubeReactionDelegate<GlobalReject>;

  /**
   * `prisma.youtubeVideo`: Exposes CRUD operations for the **YoutubeVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeVideos
    * const youtubeVideos = await prisma.youtubeVideo.findMany()
    * ```
    */
  get youtubeVideo(): Prisma.YoutubeVideoDelegate<GlobalReject>;

  /**
   * `prisma.youtubeChannel`: Exposes CRUD operations for the **YoutubeChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeChannels
    * const youtubeChannels = await prisma.youtubeChannel.findMany()
    * ```
    */
  get youtubeChannel(): Prisma.YoutubeChannelDelegate<GlobalReject>;

  /**
   * `prisma.youtubeCommentToVideo`: Exposes CRUD operations for the **YoutubeCommentToVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeCommentToVideos
    * const youtubeCommentToVideos = await prisma.youtubeCommentToVideo.findMany()
    * ```
    */
  get youtubeCommentToVideo(): Prisma.YoutubeCommentToVideoDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUserToChannel`: Exposes CRUD operations for the **YoutubeUserToChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUserToChannels
    * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
    * ```
    */
  get youtubeUserToChannel(): Prisma.YoutubeUserToChannelDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    DewKitchenCategory: 'DewKitchenCategory',
    DewKitchenMenu: 'DewKitchenMenu',
    DewKitchenOrder: 'DewKitchenOrder',
    DewOrderItem: 'DewOrderItem',
    BookEx: 'BookEx',
    AuthorEx: 'AuthorEx',
    BookExOnAuthorEx: 'BookExOnAuthorEx',
    SeriesTv: 'SeriesTv',
    Actors: 'Actors',
    Dew: 'Dew',
    Kad: 'Kad',
    QuizeTable: 'QuizeTable',
    Question: 'Question',
    Category: 'Category',
    roundTable: 'roundTable',
    roundQuestionTable: 'roundQuestionTable',
    QuizeCategory: 'QuizeCategory',
    QuizeQuestion: 'QuizeQuestion',
    QuizeChoice: 'QuizeChoice',
    QuizeAnswer: 'QuizeAnswer',
    QuizeGameRound: 'QuizeGameRound',
    MainCompany: 'MainCompany',
    Branch: 'Branch',
    Machine: 'Machine',
    Program: 'Program',
    MachineOnProgram: 'MachineOnProgram',
    ProcessType: 'ProcessType',
    RepairHistory: 'RepairHistory',
    RepairDetail: 'RepairDetail',
    washUser: 'washUser',
    WashHistory: 'WashHistory',
    Todolist: 'Todolist',
    User: 'User',
    DirectMessage: 'DirectMessage',
    UserRelation: 'UserRelation',
    HashTag: 'HashTag',
    Post: 'Post',
    PostOnHashTag: 'PostOnHashTag',
    Reply: 'Reply',
    YoutubeUser: 'YoutubeUser',
    YoutubeRole: 'YoutubeRole',
    YoutubeReaction: 'YoutubeReaction',
    YoutubeVideo: 'YoutubeVideo',
    YoutubeChannel: 'YoutubeChannel',
    YoutubeCommentToVideo: 'YoutubeCommentToVideo',
    YoutubeUserToChannel: 'YoutubeUserToChannel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DewKitchenCategoryCountOutputType
   */


  export type DewKitchenCategoryCountOutputType = {
    menus: number
  }

  export type DewKitchenCategoryCountOutputTypeSelect = {
    menus?: boolean
  }

  export type DewKitchenCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | DewKitchenCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenCategoryCountOutputTypeArgs)
    ? DewKitchenCategoryCountOutputType 
    : S extends { select: any } & (DewKitchenCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DewKitchenCategoryCountOutputType ? DewKitchenCategoryCountOutputType[P] : never
  } 
      : DewKitchenCategoryCountOutputType




  // Custom InputTypes

  /**
   * DewKitchenCategoryCountOutputType without action
   */
  export type DewKitchenCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategoryCountOutputType
     */
    select?: DewKitchenCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type DewKitchenMenuCountOutputType
   */


  export type DewKitchenMenuCountOutputType = {
    orderItems: number
  }

  export type DewKitchenMenuCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type DewKitchenMenuCountOutputTypeGetPayload<S extends boolean | null | undefined | DewKitchenMenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenMenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenMenuCountOutputTypeArgs)
    ? DewKitchenMenuCountOutputType 
    : S extends { select: any } & (DewKitchenMenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DewKitchenMenuCountOutputType ? DewKitchenMenuCountOutputType[P] : never
  } 
      : DewKitchenMenuCountOutputType




  // Custom InputTypes

  /**
   * DewKitchenMenuCountOutputType without action
   */
  export type DewKitchenMenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenuCountOutputType
     */
    select?: DewKitchenMenuCountOutputTypeSelect | null
  }



  /**
   * Count Type DewKitchenOrderCountOutputType
   */


  export type DewKitchenOrderCountOutputType = {
    items: number
  }

  export type DewKitchenOrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type DewKitchenOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | DewKitchenOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenOrderCountOutputTypeArgs)
    ? DewKitchenOrderCountOutputType 
    : S extends { select: any } & (DewKitchenOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DewKitchenOrderCountOutputType ? DewKitchenOrderCountOutputType[P] : never
  } 
      : DewKitchenOrderCountOutputType




  // Custom InputTypes

  /**
   * DewKitchenOrderCountOutputType without action
   */
  export type DewKitchenOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrderCountOutputType
     */
    select?: DewKitchenOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type BookExCountOutputType
   */


  export type BookExCountOutputType = {
    BookExampleOnAuthorExample: number
  }

  export type BookExCountOutputTypeSelect = {
    BookExampleOnAuthorExample?: boolean
  }

  export type BookExCountOutputTypeGetPayload<S extends boolean | null | undefined | BookExCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookExCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BookExCountOutputTypeArgs)
    ? BookExCountOutputType 
    : S extends { select: any } & (BookExCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BookExCountOutputType ? BookExCountOutputType[P] : never
  } 
      : BookExCountOutputType




  // Custom InputTypes

  /**
   * BookExCountOutputType without action
   */
  export type BookExCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BookExCountOutputType
     */
    select?: BookExCountOutputTypeSelect | null
  }



  /**
   * Count Type AuthorExCountOutputType
   */


  export type AuthorExCountOutputType = {
    BookExampleOnAuthorExample: number
  }

  export type AuthorExCountOutputTypeSelect = {
    BookExampleOnAuthorExample?: boolean
  }

  export type AuthorExCountOutputTypeGetPayload<S extends boolean | null | undefined | AuthorExCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorExCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AuthorExCountOutputTypeArgs)
    ? AuthorExCountOutputType 
    : S extends { select: any } & (AuthorExCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AuthorExCountOutputType ? AuthorExCountOutputType[P] : never
  } 
      : AuthorExCountOutputType




  // Custom InputTypes

  /**
   * AuthorExCountOutputType without action
   */
  export type AuthorExCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AuthorExCountOutputType
     */
    select?: AuthorExCountOutputTypeSelect | null
  }



  /**
   * Count Type SeriesTvCountOutputType
   */


  export type SeriesTvCountOutputType = {
    actors: number
  }

  export type SeriesTvCountOutputTypeSelect = {
    actors?: boolean
  }

  export type SeriesTvCountOutputTypeGetPayload<S extends boolean | null | undefined | SeriesTvCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SeriesTvCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SeriesTvCountOutputTypeArgs)
    ? SeriesTvCountOutputType 
    : S extends { select: any } & (SeriesTvCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SeriesTvCountOutputType ? SeriesTvCountOutputType[P] : never
  } 
      : SeriesTvCountOutputType




  // Custom InputTypes

  /**
   * SeriesTvCountOutputType without action
   */
  export type SeriesTvCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SeriesTvCountOutputType
     */
    select?: SeriesTvCountOutputTypeSelect | null
  }



  /**
   * Count Type ActorsCountOutputType
   */


  export type ActorsCountOutputType = {
    seriesTv: number
  }

  export type ActorsCountOutputTypeSelect = {
    seriesTv?: boolean
  }

  export type ActorsCountOutputTypeGetPayload<S extends boolean | null | undefined | ActorsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ActorsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ActorsCountOutputTypeArgs)
    ? ActorsCountOutputType 
    : S extends { select: any } & (ActorsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ActorsCountOutputType ? ActorsCountOutputType[P] : never
  } 
      : ActorsCountOutputType




  // Custom InputTypes

  /**
   * ActorsCountOutputType without action
   */
  export type ActorsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ActorsCountOutputType
     */
    select?: ActorsCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizeCategoryCountOutputType
   */


  export type QuizeCategoryCountOutputType = {
    questions: number
  }

  export type QuizeCategoryCountOutputTypeSelect = {
    questions?: boolean
  }

  export type QuizeCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizeCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizeCategoryCountOutputTypeArgs)
    ? QuizeCategoryCountOutputType 
    : S extends { select: any } & (QuizeCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizeCategoryCountOutputType ? QuizeCategoryCountOutputType[P] : never
  } 
      : QuizeCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuizeCategoryCountOutputType without action
   */
  export type QuizeCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategoryCountOutputType
     */
    select?: QuizeCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizeQuestionCountOutputType
   */


  export type QuizeQuestionCountOutputType = {
    choices: number
  }

  export type QuizeQuestionCountOutputTypeSelect = {
    choices?: boolean
  }

  export type QuizeQuestionCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizeQuestionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeQuestionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizeQuestionCountOutputTypeArgs)
    ? QuizeQuestionCountOutputType 
    : S extends { select: any } & (QuizeQuestionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizeQuestionCountOutputType ? QuizeQuestionCountOutputType[P] : never
  } 
      : QuizeQuestionCountOutputType




  // Custom InputTypes

  /**
   * QuizeQuestionCountOutputType without action
   */
  export type QuizeQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestionCountOutputType
     */
    select?: QuizeQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type MainCompanyCountOutputType
   */


  export type MainCompanyCountOutputType = {
    branchIds: number
  }

  export type MainCompanyCountOutputTypeSelect = {
    branchIds?: boolean
  }

  export type MainCompanyCountOutputTypeGetPayload<S extends boolean | null | undefined | MainCompanyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MainCompanyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MainCompanyCountOutputTypeArgs)
    ? MainCompanyCountOutputType 
    : S extends { select: any } & (MainCompanyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MainCompanyCountOutputType ? MainCompanyCountOutputType[P] : never
  } 
      : MainCompanyCountOutputType




  // Custom InputTypes

  /**
   * MainCompanyCountOutputType without action
   */
  export type MainCompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MainCompanyCountOutputType
     */
    select?: MainCompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type BranchCountOutputType
   */


  export type BranchCountOutputType = {
    machines: number
  }

  export type BranchCountOutputTypeSelect = {
    machines?: boolean
  }

  export type BranchCountOutputTypeGetPayload<S extends boolean | null | undefined | BranchCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BranchCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BranchCountOutputTypeArgs)
    ? BranchCountOutputType 
    : S extends { select: any } & (BranchCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BranchCountOutputType ? BranchCountOutputType[P] : never
  } 
      : BranchCountOutputType




  // Custom InputTypes

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect | null
  }



  /**
   * Count Type MachineCountOutputType
   */


  export type MachineCountOutputType = {
    repairHistories: number
    machineOnPrograms: number
  }

  export type MachineCountOutputTypeSelect = {
    repairHistories?: boolean
    machineOnPrograms?: boolean
  }

  export type MachineCountOutputTypeGetPayload<S extends boolean | null | undefined | MachineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MachineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MachineCountOutputTypeArgs)
    ? MachineCountOutputType 
    : S extends { select: any } & (MachineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MachineCountOutputType ? MachineCountOutputType[P] : never
  } 
      : MachineCountOutputType




  // Custom InputTypes

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MachineCountOutputType
     */
    select?: MachineCountOutputTypeSelect | null
  }



  /**
   * Count Type ProgramCountOutputType
   */


  export type ProgramCountOutputType = {
    processes: number
    machineOnPrograms: number
  }

  export type ProgramCountOutputTypeSelect = {
    processes?: boolean
    machineOnPrograms?: boolean
  }

  export type ProgramCountOutputTypeGetPayload<S extends boolean | null | undefined | ProgramCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProgramCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProgramCountOutputTypeArgs)
    ? ProgramCountOutputType 
    : S extends { select: any } & (ProgramCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProgramCountOutputType ? ProgramCountOutputType[P] : never
  } 
      : ProgramCountOutputType




  // Custom InputTypes

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect | null
  }



  /**
   * Count Type RepairDetailCountOutputType
   */


  export type RepairDetailCountOutputType = {
    RepairHistory: number
  }

  export type RepairDetailCountOutputTypeSelect = {
    RepairHistory?: boolean
  }

  export type RepairDetailCountOutputTypeGetPayload<S extends boolean | null | undefined | RepairDetailCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairDetailCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RepairDetailCountOutputTypeArgs)
    ? RepairDetailCountOutputType 
    : S extends { select: any } & (RepairDetailCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RepairDetailCountOutputType ? RepairDetailCountOutputType[P] : never
  } 
      : RepairDetailCountOutputType




  // Custom InputTypes

  /**
   * RepairDetailCountOutputType without action
   */
  export type RepairDetailCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RepairDetailCountOutputType
     */
    select?: RepairDetailCountOutputTypeSelect | null
  }



  /**
   * Count Type WashHistoryCountOutputType
   */


  export type WashHistoryCountOutputType = {
    programs: number
    machines: number
    users: number
  }

  export type WashHistoryCountOutputTypeSelect = {
    programs?: boolean
    machines?: boolean
    users?: boolean
  }

  export type WashHistoryCountOutputTypeGetPayload<S extends boolean | null | undefined | WashHistoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WashHistoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WashHistoryCountOutputTypeArgs)
    ? WashHistoryCountOutputType 
    : S extends { select: any } & (WashHistoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WashHistoryCountOutputType ? WashHistoryCountOutputType[P] : never
  } 
      : WashHistoryCountOutputType




  // Custom InputTypes

  /**
   * WashHistoryCountOutputType without action
   */
  export type WashHistoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WashHistoryCountOutputType
     */
    select?: WashHistoryCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    directMessage: number
    fromUserRelation: number
    toUserRelation: number
    posts: number
    replies: number
  }

  export type UserCountOutputTypeSelect = {
    directMessage?: boolean
    fromUserRelation?: boolean
    toUserRelation?: boolean
    posts?: boolean
    replies?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    postOnHashTags: number
    replies: number
  }

  export type PostCountOutputTypeSelect = {
    postOnHashTags?: boolean
    replies?: boolean
  }

  export type PostCountOutputTypeGetPayload<S extends boolean | null | undefined | PostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostCountOutputTypeArgs)
    ? PostCountOutputType 
    : S extends { select: any } & (PostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostCountOutputType ? PostCountOutputType[P] : never
  } 
      : PostCountOutputType




  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect | null
  }



  /**
   * Count Type PostOnHashTagCountOutputType
   */


  export type PostOnHashTagCountOutputType = {
    posts: number
    hashTags: number
  }

  export type PostOnHashTagCountOutputTypeSelect = {
    posts?: boolean
    hashTags?: boolean
  }

  export type PostOnHashTagCountOutputTypeGetPayload<S extends boolean | null | undefined | PostOnHashTagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostOnHashTagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostOnHashTagCountOutputTypeArgs)
    ? PostOnHashTagCountOutputType 
    : S extends { select: any } & (PostOnHashTagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostOnHashTagCountOutputType ? PostOnHashTagCountOutputType[P] : never
  } 
      : PostOnHashTagCountOutputType




  // Custom InputTypes

  /**
   * PostOnHashTagCountOutputType without action
   */
  export type PostOnHashTagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTagCountOutputType
     */
    select?: PostOnHashTagCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeUserCountOutputType
   */


  export type YoutubeUserCountOutputType = {
    subtoChannels: number
    commentToVideoes: number
    UserToChannel: number
  }

  export type YoutubeUserCountOutputTypeSelect = {
    subtoChannels?: boolean
    commentToVideoes?: boolean
    UserToChannel?: boolean
  }

  export type YoutubeUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserCountOutputTypeArgs)
    ? YoutubeUserCountOutputType 
    : S extends { select: any } & (YoutubeUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeUserCountOutputType ? YoutubeUserCountOutputType[P] : never
  } 
      : YoutubeUserCountOutputType




  // Custom InputTypes

  /**
   * YoutubeUserCountOutputType without action
   */
  export type YoutubeUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserCountOutputType
     */
    select?: YoutubeUserCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeRoleCountOutputType
   */


  export type YoutubeRoleCountOutputType = {
    userToChannel: number
  }

  export type YoutubeRoleCountOutputTypeSelect = {
    userToChannel?: boolean
  }

  export type YoutubeRoleCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeRoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeRoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeRoleCountOutputTypeArgs)
    ? YoutubeRoleCountOutputType 
    : S extends { select: any } & (YoutubeRoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeRoleCountOutputType ? YoutubeRoleCountOutputType[P] : never
  } 
      : YoutubeRoleCountOutputType




  // Custom InputTypes

  /**
   * YoutubeRoleCountOutputType without action
   */
  export type YoutubeRoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRoleCountOutputType
     */
    select?: YoutubeRoleCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeReactionCountOutputType
   */


  export type YoutubeReactionCountOutputType = {
    Video: number
  }

  export type YoutubeReactionCountOutputTypeSelect = {
    Video?: boolean
  }

  export type YoutubeReactionCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeReactionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeReactionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeReactionCountOutputTypeArgs)
    ? YoutubeReactionCountOutputType 
    : S extends { select: any } & (YoutubeReactionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeReactionCountOutputType ? YoutubeReactionCountOutputType[P] : never
  } 
      : YoutubeReactionCountOutputType




  // Custom InputTypes

  /**
   * YoutubeReactionCountOutputType without action
   */
  export type YoutubeReactionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReactionCountOutputType
     */
    select?: YoutubeReactionCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeVideoCountOutputType
   */


  export type YoutubeVideoCountOutputType = {
    commentToVideoes: number
  }

  export type YoutubeVideoCountOutputTypeSelect = {
    commentToVideoes?: boolean
  }

  export type YoutubeVideoCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeVideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoCountOutputTypeArgs)
    ? YoutubeVideoCountOutputType 
    : S extends { select: any } & (YoutubeVideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeVideoCountOutputType ? YoutubeVideoCountOutputType[P] : never
  } 
      : YoutubeVideoCountOutputType




  // Custom InputTypes

  /**
   * YoutubeVideoCountOutputType without action
   */
  export type YoutubeVideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideoCountOutputType
     */
    select?: YoutubeVideoCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeChannelCountOutputType
   */


  export type YoutubeChannelCountOutputType = {
    subcribers: number
    playLists: number
    userToChannel: number
  }

  export type YoutubeChannelCountOutputTypeSelect = {
    subcribers?: boolean
    playLists?: boolean
    userToChannel?: boolean
  }

  export type YoutubeChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelCountOutputTypeArgs)
    ? YoutubeChannelCountOutputType 
    : S extends { select: any } & (YoutubeChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeChannelCountOutputType ? YoutubeChannelCountOutputType[P] : never
  } 
      : YoutubeChannelCountOutputType




  // Custom InputTypes

  /**
   * YoutubeChannelCountOutputType without action
   */
  export type YoutubeChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannelCountOutputType
     */
    select?: YoutubeChannelCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model DewKitchenCategory
   */


  export type AggregateDewKitchenCategory = {
    _count: DewKitchenCategoryCountAggregateOutputType | null
    _avg: DewKitchenCategoryAvgAggregateOutputType | null
    _sum: DewKitchenCategorySumAggregateOutputType | null
    _min: DewKitchenCategoryMinAggregateOutputType | null
    _max: DewKitchenCategoryMaxAggregateOutputType | null
  }

  export type DewKitchenCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type DewKitchenCategorySumAggregateOutputType = {
    id: number | null
  }

  export type DewKitchenCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenCategoryCountAggregateOutputType = {
    id: number
    name: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type DewKitchenCategoryAvgAggregateInputType = {
    id?: true
  }

  export type DewKitchenCategorySumAggregateInputType = {
    id?: true
  }

  export type DewKitchenCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type DewKitchenCategoryAggregateArgs = {
    /**
     * Filter which DewKitchenCategory to aggregate.
     */
    where?: DewKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenCategories to fetch.
     */
    orderBy?: Enumerable<DewKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DewKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DewKitchenCategories
    **/
    _count?: true | DewKitchenCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DewKitchenCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DewKitchenCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DewKitchenCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DewKitchenCategoryMaxAggregateInputType
  }

  export type GetDewKitchenCategoryAggregateType<T extends DewKitchenCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDewKitchenCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDewKitchenCategory[P]>
      : GetScalarType<T[P], AggregateDewKitchenCategory[P]>
  }




  export type DewKitchenCategoryGroupByArgs = {
    where?: DewKitchenCategoryWhereInput
    orderBy?: Enumerable<DewKitchenCategoryOrderByWithAggregationInput>
    by: DewKitchenCategoryScalarFieldEnum[]
    having?: DewKitchenCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DewKitchenCategoryCountAggregateInputType | true
    _avg?: DewKitchenCategoryAvgAggregateInputType
    _sum?: DewKitchenCategorySumAggregateInputType
    _min?: DewKitchenCategoryMinAggregateInputType
    _max?: DewKitchenCategoryMaxAggregateInputType
  }


  export type DewKitchenCategoryGroupByOutputType = {
    id: number
    name: string
    createAt: Date
    updateAt: Date
    _count: DewKitchenCategoryCountAggregateOutputType | null
    _avg: DewKitchenCategoryAvgAggregateOutputType | null
    _sum: DewKitchenCategorySumAggregateOutputType | null
    _min: DewKitchenCategoryMinAggregateOutputType | null
    _max: DewKitchenCategoryMaxAggregateOutputType | null
  }

  type GetDewKitchenCategoryGroupByPayload<T extends DewKitchenCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DewKitchenCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DewKitchenCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DewKitchenCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], DewKitchenCategoryGroupByOutputType[P]>
        }
      >
    >


  export type DewKitchenCategorySelect = {
    id?: boolean
    name?: boolean
    menus?: boolean | DewKitchenCategory$menusArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | DewKitchenCategoryCountOutputTypeArgs
  }


  export type DewKitchenCategoryInclude = {
    menus?: boolean | DewKitchenCategory$menusArgs
    _count?: boolean | DewKitchenCategoryCountOutputTypeArgs
  }

  export type DewKitchenCategoryGetPayload<S extends boolean | null | undefined | DewKitchenCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenCategory :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenCategoryArgs | DewKitchenCategoryFindManyArgs)
    ? DewKitchenCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menus' ? Array < DewKitchenMenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? DewKitchenCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DewKitchenCategoryArgs | DewKitchenCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menus' ? Array < DewKitchenMenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? DewKitchenCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DewKitchenCategory ? DewKitchenCategory[P] : never
  } 
      : DewKitchenCategory


  type DewKitchenCategoryCountArgs = 
    Omit<DewKitchenCategoryFindManyArgs, 'select' | 'include'> & {
      select?: DewKitchenCategoryCountAggregateInputType | true
    }

  export interface DewKitchenCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DewKitchenCategory that matches the filter.
     * @param {DewKitchenCategoryFindUniqueArgs} args - Arguments to find a DewKitchenCategory
     * @example
     * // Get one DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DewKitchenCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DewKitchenCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DewKitchenCategory'> extends True ? Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>> : Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find one DewKitchenCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DewKitchenCategoryFindUniqueOrThrowArgs} args - Arguments to find a DewKitchenCategory
     * @example
     * // Get one DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DewKitchenCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenCategoryFindUniqueOrThrowArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Find the first DewKitchenCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryFindFirstArgs} args - Arguments to find a DewKitchenCategory
     * @example
     * // Get one DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DewKitchenCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DewKitchenCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DewKitchenCategory'> extends True ? Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>> : Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find the first DewKitchenCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryFindFirstOrThrowArgs} args - Arguments to find a DewKitchenCategory
     * @example
     * // Get one DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DewKitchenCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenCategoryFindFirstOrThrowArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Find zero or more DewKitchenCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DewKitchenCategories
     * const dewKitchenCategories = await prisma.dewKitchenCategory.findMany()
     * 
     * // Get first 10 DewKitchenCategories
     * const dewKitchenCategories = await prisma.dewKitchenCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dewKitchenCategoryWithIdOnly = await prisma.dewKitchenCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DewKitchenCategoryFindManyArgs>(
      args?: SelectSubset<T, DewKitchenCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<DewKitchenCategoryGetPayload<T>>>

    /**
     * Create a DewKitchenCategory.
     * @param {DewKitchenCategoryCreateArgs} args - Arguments to create a DewKitchenCategory.
     * @example
     * // Create one DewKitchenCategory
     * const DewKitchenCategory = await prisma.dewKitchenCategory.create({
     *   data: {
     *     // ... data to create a DewKitchenCategory
     *   }
     * })
     * 
    **/
    create<T extends DewKitchenCategoryCreateArgs>(
      args: SelectSubset<T, DewKitchenCategoryCreateArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Create many DewKitchenCategories.
     *     @param {DewKitchenCategoryCreateManyArgs} args - Arguments to create many DewKitchenCategories.
     *     @example
     *     // Create many DewKitchenCategories
     *     const dewKitchenCategory = await prisma.dewKitchenCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DewKitchenCategoryCreateManyArgs>(
      args?: SelectSubset<T, DewKitchenCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DewKitchenCategory.
     * @param {DewKitchenCategoryDeleteArgs} args - Arguments to delete one DewKitchenCategory.
     * @example
     * // Delete one DewKitchenCategory
     * const DewKitchenCategory = await prisma.dewKitchenCategory.delete({
     *   where: {
     *     // ... filter to delete one DewKitchenCategory
     *   }
     * })
     * 
    **/
    delete<T extends DewKitchenCategoryDeleteArgs>(
      args: SelectSubset<T, DewKitchenCategoryDeleteArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Update one DewKitchenCategory.
     * @param {DewKitchenCategoryUpdateArgs} args - Arguments to update one DewKitchenCategory.
     * @example
     * // Update one DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DewKitchenCategoryUpdateArgs>(
      args: SelectSubset<T, DewKitchenCategoryUpdateArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Delete zero or more DewKitchenCategories.
     * @param {DewKitchenCategoryDeleteManyArgs} args - Arguments to filter DewKitchenCategories to delete.
     * @example
     * // Delete a few DewKitchenCategories
     * const { count } = await prisma.dewKitchenCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DewKitchenCategoryDeleteManyArgs>(
      args?: SelectSubset<T, DewKitchenCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DewKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DewKitchenCategories
     * const dewKitchenCategory = await prisma.dewKitchenCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DewKitchenCategoryUpdateManyArgs>(
      args: SelectSubset<T, DewKitchenCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DewKitchenCategory.
     * @param {DewKitchenCategoryUpsertArgs} args - Arguments to update or create a DewKitchenCategory.
     * @example
     * // Update or create a DewKitchenCategory
     * const dewKitchenCategory = await prisma.dewKitchenCategory.upsert({
     *   create: {
     *     // ... data to create a DewKitchenCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DewKitchenCategory we want to update
     *   }
     * })
    **/
    upsert<T extends DewKitchenCategoryUpsertArgs>(
      args: SelectSubset<T, DewKitchenCategoryUpsertArgs>
    ): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T>>

    /**
     * Count the number of DewKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryCountArgs} args - Arguments to filter DewKitchenCategories to count.
     * @example
     * // Count the number of DewKitchenCategories
     * const count = await prisma.dewKitchenCategory.count({
     *   where: {
     *     // ... the filter for the DewKitchenCategories we want to count
     *   }
     * })
    **/
    count<T extends DewKitchenCategoryCountArgs>(
      args?: Subset<T, DewKitchenCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DewKitchenCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DewKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DewKitchenCategoryAggregateArgs>(args: Subset<T, DewKitchenCategoryAggregateArgs>): Prisma.PrismaPromise<GetDewKitchenCategoryAggregateType<T>>

    /**
     * Group by DewKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DewKitchenCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DewKitchenCategoryGroupByArgs['orderBy'] }
        : { orderBy?: DewKitchenCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DewKitchenCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDewKitchenCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DewKitchenCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DewKitchenCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menus<T extends DewKitchenCategory$menusArgs= {}>(args?: Subset<T, DewKitchenCategory$menusArgs>): Prisma.PrismaPromise<Array<DewKitchenMenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DewKitchenCategory base type for findUnique actions
   */
  export type DewKitchenCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter, which DewKitchenCategory to fetch.
     */
    where: DewKitchenCategoryWhereUniqueInput
  }

  /**
   * DewKitchenCategory findUnique
   */
  export interface DewKitchenCategoryFindUniqueArgs extends DewKitchenCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenCategory findUniqueOrThrow
   */
  export type DewKitchenCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter, which DewKitchenCategory to fetch.
     */
    where: DewKitchenCategoryWhereUniqueInput
  }


  /**
   * DewKitchenCategory base type for findFirst actions
   */
  export type DewKitchenCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter, which DewKitchenCategory to fetch.
     */
    where?: DewKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenCategories to fetch.
     */
    orderBy?: Enumerable<DewKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenCategories.
     */
    cursor?: DewKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenCategories.
     */
    distinct?: Enumerable<DewKitchenCategoryScalarFieldEnum>
  }

  /**
   * DewKitchenCategory findFirst
   */
  export interface DewKitchenCategoryFindFirstArgs extends DewKitchenCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenCategory findFirstOrThrow
   */
  export type DewKitchenCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter, which DewKitchenCategory to fetch.
     */
    where?: DewKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenCategories to fetch.
     */
    orderBy?: Enumerable<DewKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenCategories.
     */
    cursor?: DewKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenCategories.
     */
    distinct?: Enumerable<DewKitchenCategoryScalarFieldEnum>
  }


  /**
   * DewKitchenCategory findMany
   */
  export type DewKitchenCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter, which DewKitchenCategories to fetch.
     */
    where?: DewKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenCategories to fetch.
     */
    orderBy?: Enumerable<DewKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DewKitchenCategories.
     */
    cursor?: DewKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenCategories.
     */
    skip?: number
    distinct?: Enumerable<DewKitchenCategoryScalarFieldEnum>
  }


  /**
   * DewKitchenCategory create
   */
  export type DewKitchenCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * The data needed to create a DewKitchenCategory.
     */
    data: XOR<DewKitchenCategoryCreateInput, DewKitchenCategoryUncheckedCreateInput>
  }


  /**
   * DewKitchenCategory createMany
   */
  export type DewKitchenCategoryCreateManyArgs = {
    /**
     * The data used to create many DewKitchenCategories.
     */
    data: Enumerable<DewKitchenCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DewKitchenCategory update
   */
  export type DewKitchenCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * The data needed to update a DewKitchenCategory.
     */
    data: XOR<DewKitchenCategoryUpdateInput, DewKitchenCategoryUncheckedUpdateInput>
    /**
     * Choose, which DewKitchenCategory to update.
     */
    where: DewKitchenCategoryWhereUniqueInput
  }


  /**
   * DewKitchenCategory updateMany
   */
  export type DewKitchenCategoryUpdateManyArgs = {
    /**
     * The data used to update DewKitchenCategories.
     */
    data: XOR<DewKitchenCategoryUpdateManyMutationInput, DewKitchenCategoryUncheckedUpdateManyInput>
    /**
     * Filter which DewKitchenCategories to update
     */
    where?: DewKitchenCategoryWhereInput
  }


  /**
   * DewKitchenCategory upsert
   */
  export type DewKitchenCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * The filter to search for the DewKitchenCategory to update in case it exists.
     */
    where: DewKitchenCategoryWhereUniqueInput
    /**
     * In case the DewKitchenCategory found by the `where` argument doesn't exist, create a new DewKitchenCategory with this data.
     */
    create: XOR<DewKitchenCategoryCreateInput, DewKitchenCategoryUncheckedCreateInput>
    /**
     * In case the DewKitchenCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DewKitchenCategoryUpdateInput, DewKitchenCategoryUncheckedUpdateInput>
  }


  /**
   * DewKitchenCategory delete
   */
  export type DewKitchenCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
    /**
     * Filter which DewKitchenCategory to delete.
     */
    where: DewKitchenCategoryWhereUniqueInput
  }


  /**
   * DewKitchenCategory deleteMany
   */
  export type DewKitchenCategoryDeleteManyArgs = {
    /**
     * Filter which DewKitchenCategories to delete
     */
    where?: DewKitchenCategoryWhereInput
  }


  /**
   * DewKitchenCategory.menus
   */
  export type DewKitchenCategory$menusArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    where?: DewKitchenMenuWhereInput
    orderBy?: Enumerable<DewKitchenMenuOrderByWithRelationInput>
    cursor?: DewKitchenMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DewKitchenMenuScalarFieldEnum>
  }


  /**
   * DewKitchenCategory without action
   */
  export type DewKitchenCategoryArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenCategory
     */
    select?: DewKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenCategoryInclude | null
  }



  /**
   * Model DewKitchenMenu
   */


  export type AggregateDewKitchenMenu = {
    _count: DewKitchenMenuCountAggregateOutputType | null
    _avg: DewKitchenMenuAvgAggregateOutputType | null
    _sum: DewKitchenMenuSumAggregateOutputType | null
    _min: DewKitchenMenuMinAggregateOutputType | null
    _max: DewKitchenMenuMaxAggregateOutputType | null
  }

  export type DewKitchenMenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type DewKitchenMenuSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type DewKitchenMenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenMenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenMenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryName: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type DewKitchenMenuAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type DewKitchenMenuSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type DewKitchenMenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenMenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenMenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type DewKitchenMenuAggregateArgs = {
    /**
     * Filter which DewKitchenMenu to aggregate.
     */
    where?: DewKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenMenus to fetch.
     */
    orderBy?: Enumerable<DewKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DewKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DewKitchenMenus
    **/
    _count?: true | DewKitchenMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DewKitchenMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DewKitchenMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DewKitchenMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DewKitchenMenuMaxAggregateInputType
  }

  export type GetDewKitchenMenuAggregateType<T extends DewKitchenMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateDewKitchenMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDewKitchenMenu[P]>
      : GetScalarType<T[P], AggregateDewKitchenMenu[P]>
  }




  export type DewKitchenMenuGroupByArgs = {
    where?: DewKitchenMenuWhereInput
    orderBy?: Enumerable<DewKitchenMenuOrderByWithAggregationInput>
    by: DewKitchenMenuScalarFieldEnum[]
    having?: DewKitchenMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DewKitchenMenuCountAggregateInputType | true
    _avg?: DewKitchenMenuAvgAggregateInputType
    _sum?: DewKitchenMenuSumAggregateInputType
    _min?: DewKitchenMenuMinAggregateInputType
    _max?: DewKitchenMenuMaxAggregateInputType
  }


  export type DewKitchenMenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryName: string | null
    createAt: Date
    updateAt: Date
    _count: DewKitchenMenuCountAggregateOutputType | null
    _avg: DewKitchenMenuAvgAggregateOutputType | null
    _sum: DewKitchenMenuSumAggregateOutputType | null
    _min: DewKitchenMenuMinAggregateOutputType | null
    _max: DewKitchenMenuMaxAggregateOutputType | null
  }

  type GetDewKitchenMenuGroupByPayload<T extends DewKitchenMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DewKitchenMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DewKitchenMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DewKitchenMenuGroupByOutputType[P]>
            : GetScalarType<T[P], DewKitchenMenuGroupByOutputType[P]>
        }
      >
    >


  export type DewKitchenMenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    categoryKey?: boolean | DewKitchenCategoryArgs
    categoryName?: boolean
    orderItems?: boolean | DewKitchenMenu$orderItemsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | DewKitchenMenuCountOutputTypeArgs
  }


  export type DewKitchenMenuInclude = {
    categoryKey?: boolean | DewKitchenCategoryArgs
    orderItems?: boolean | DewKitchenMenu$orderItemsArgs
    _count?: boolean | DewKitchenMenuCountOutputTypeArgs
  }

  export type DewKitchenMenuGetPayload<S extends boolean | null | undefined | DewKitchenMenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenMenu :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenMenuArgs | DewKitchenMenuFindManyArgs)
    ? DewKitchenMenu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'categoryKey' ? DewKitchenCategoryGetPayload<S['include'][P]> | null :
        P extends 'orderItems' ? Array < DewOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? DewKitchenMenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DewKitchenMenuArgs | DewKitchenMenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'categoryKey' ? DewKitchenCategoryGetPayload<S['select'][P]> | null :
        P extends 'orderItems' ? Array < DewOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? DewKitchenMenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DewKitchenMenu ? DewKitchenMenu[P] : never
  } 
      : DewKitchenMenu


  type DewKitchenMenuCountArgs = 
    Omit<DewKitchenMenuFindManyArgs, 'select' | 'include'> & {
      select?: DewKitchenMenuCountAggregateInputType | true
    }

  export interface DewKitchenMenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DewKitchenMenu that matches the filter.
     * @param {DewKitchenMenuFindUniqueArgs} args - Arguments to find a DewKitchenMenu
     * @example
     * // Get one DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DewKitchenMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DewKitchenMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DewKitchenMenu'> extends True ? Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>> : Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T> | null, null>

    /**
     * Find one DewKitchenMenu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DewKitchenMenuFindUniqueOrThrowArgs} args - Arguments to find a DewKitchenMenu
     * @example
     * // Get one DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DewKitchenMenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenMenuFindUniqueOrThrowArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Find the first DewKitchenMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuFindFirstArgs} args - Arguments to find a DewKitchenMenu
     * @example
     * // Get one DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DewKitchenMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DewKitchenMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DewKitchenMenu'> extends True ? Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>> : Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T> | null, null>

    /**
     * Find the first DewKitchenMenu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuFindFirstOrThrowArgs} args - Arguments to find a DewKitchenMenu
     * @example
     * // Get one DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DewKitchenMenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenMenuFindFirstOrThrowArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Find zero or more DewKitchenMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DewKitchenMenus
     * const dewKitchenMenus = await prisma.dewKitchenMenu.findMany()
     * 
     * // Get first 10 DewKitchenMenus
     * const dewKitchenMenus = await prisma.dewKitchenMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dewKitchenMenuWithIdOnly = await prisma.dewKitchenMenu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DewKitchenMenuFindManyArgs>(
      args?: SelectSubset<T, DewKitchenMenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<DewKitchenMenuGetPayload<T>>>

    /**
     * Create a DewKitchenMenu.
     * @param {DewKitchenMenuCreateArgs} args - Arguments to create a DewKitchenMenu.
     * @example
     * // Create one DewKitchenMenu
     * const DewKitchenMenu = await prisma.dewKitchenMenu.create({
     *   data: {
     *     // ... data to create a DewKitchenMenu
     *   }
     * })
     * 
    **/
    create<T extends DewKitchenMenuCreateArgs>(
      args: SelectSubset<T, DewKitchenMenuCreateArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Create many DewKitchenMenus.
     *     @param {DewKitchenMenuCreateManyArgs} args - Arguments to create many DewKitchenMenus.
     *     @example
     *     // Create many DewKitchenMenus
     *     const dewKitchenMenu = await prisma.dewKitchenMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DewKitchenMenuCreateManyArgs>(
      args?: SelectSubset<T, DewKitchenMenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DewKitchenMenu.
     * @param {DewKitchenMenuDeleteArgs} args - Arguments to delete one DewKitchenMenu.
     * @example
     * // Delete one DewKitchenMenu
     * const DewKitchenMenu = await prisma.dewKitchenMenu.delete({
     *   where: {
     *     // ... filter to delete one DewKitchenMenu
     *   }
     * })
     * 
    **/
    delete<T extends DewKitchenMenuDeleteArgs>(
      args: SelectSubset<T, DewKitchenMenuDeleteArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Update one DewKitchenMenu.
     * @param {DewKitchenMenuUpdateArgs} args - Arguments to update one DewKitchenMenu.
     * @example
     * // Update one DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DewKitchenMenuUpdateArgs>(
      args: SelectSubset<T, DewKitchenMenuUpdateArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Delete zero or more DewKitchenMenus.
     * @param {DewKitchenMenuDeleteManyArgs} args - Arguments to filter DewKitchenMenus to delete.
     * @example
     * // Delete a few DewKitchenMenus
     * const { count } = await prisma.dewKitchenMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DewKitchenMenuDeleteManyArgs>(
      args?: SelectSubset<T, DewKitchenMenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DewKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DewKitchenMenus
     * const dewKitchenMenu = await prisma.dewKitchenMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DewKitchenMenuUpdateManyArgs>(
      args: SelectSubset<T, DewKitchenMenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DewKitchenMenu.
     * @param {DewKitchenMenuUpsertArgs} args - Arguments to update or create a DewKitchenMenu.
     * @example
     * // Update or create a DewKitchenMenu
     * const dewKitchenMenu = await prisma.dewKitchenMenu.upsert({
     *   create: {
     *     // ... data to create a DewKitchenMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DewKitchenMenu we want to update
     *   }
     * })
    **/
    upsert<T extends DewKitchenMenuUpsertArgs>(
      args: SelectSubset<T, DewKitchenMenuUpsertArgs>
    ): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T>>

    /**
     * Count the number of DewKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuCountArgs} args - Arguments to filter DewKitchenMenus to count.
     * @example
     * // Count the number of DewKitchenMenus
     * const count = await prisma.dewKitchenMenu.count({
     *   where: {
     *     // ... the filter for the DewKitchenMenus we want to count
     *   }
     * })
    **/
    count<T extends DewKitchenMenuCountArgs>(
      args?: Subset<T, DewKitchenMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DewKitchenMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DewKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DewKitchenMenuAggregateArgs>(args: Subset<T, DewKitchenMenuAggregateArgs>): Prisma.PrismaPromise<GetDewKitchenMenuAggregateType<T>>

    /**
     * Group by DewKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DewKitchenMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DewKitchenMenuGroupByArgs['orderBy'] }
        : { orderBy?: DewKitchenMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DewKitchenMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDewKitchenMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DewKitchenMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DewKitchenMenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    categoryKey<T extends DewKitchenCategoryArgs= {}>(args?: Subset<T, DewKitchenCategoryArgs>): Prisma__DewKitchenCategoryClient<DewKitchenCategoryGetPayload<T> | Null>;

    orderItems<T extends DewKitchenMenu$orderItemsArgs= {}>(args?: Subset<T, DewKitchenMenu$orderItemsArgs>): Prisma.PrismaPromise<Array<DewOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DewKitchenMenu base type for findUnique actions
   */
  export type DewKitchenMenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter, which DewKitchenMenu to fetch.
     */
    where: DewKitchenMenuWhereUniqueInput
  }

  /**
   * DewKitchenMenu findUnique
   */
  export interface DewKitchenMenuFindUniqueArgs extends DewKitchenMenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenMenu findUniqueOrThrow
   */
  export type DewKitchenMenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter, which DewKitchenMenu to fetch.
     */
    where: DewKitchenMenuWhereUniqueInput
  }


  /**
   * DewKitchenMenu base type for findFirst actions
   */
  export type DewKitchenMenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter, which DewKitchenMenu to fetch.
     */
    where?: DewKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenMenus to fetch.
     */
    orderBy?: Enumerable<DewKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenMenus.
     */
    cursor?: DewKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenMenus.
     */
    distinct?: Enumerable<DewKitchenMenuScalarFieldEnum>
  }

  /**
   * DewKitchenMenu findFirst
   */
  export interface DewKitchenMenuFindFirstArgs extends DewKitchenMenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenMenu findFirstOrThrow
   */
  export type DewKitchenMenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter, which DewKitchenMenu to fetch.
     */
    where?: DewKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenMenus to fetch.
     */
    orderBy?: Enumerable<DewKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenMenus.
     */
    cursor?: DewKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenMenus.
     */
    distinct?: Enumerable<DewKitchenMenuScalarFieldEnum>
  }


  /**
   * DewKitchenMenu findMany
   */
  export type DewKitchenMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter, which DewKitchenMenus to fetch.
     */
    where?: DewKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenMenus to fetch.
     */
    orderBy?: Enumerable<DewKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DewKitchenMenus.
     */
    cursor?: DewKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenMenus.
     */
    skip?: number
    distinct?: Enumerable<DewKitchenMenuScalarFieldEnum>
  }


  /**
   * DewKitchenMenu create
   */
  export type DewKitchenMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * The data needed to create a DewKitchenMenu.
     */
    data: XOR<DewKitchenMenuCreateInput, DewKitchenMenuUncheckedCreateInput>
  }


  /**
   * DewKitchenMenu createMany
   */
  export type DewKitchenMenuCreateManyArgs = {
    /**
     * The data used to create many DewKitchenMenus.
     */
    data: Enumerable<DewKitchenMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DewKitchenMenu update
   */
  export type DewKitchenMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * The data needed to update a DewKitchenMenu.
     */
    data: XOR<DewKitchenMenuUpdateInput, DewKitchenMenuUncheckedUpdateInput>
    /**
     * Choose, which DewKitchenMenu to update.
     */
    where: DewKitchenMenuWhereUniqueInput
  }


  /**
   * DewKitchenMenu updateMany
   */
  export type DewKitchenMenuUpdateManyArgs = {
    /**
     * The data used to update DewKitchenMenus.
     */
    data: XOR<DewKitchenMenuUpdateManyMutationInput, DewKitchenMenuUncheckedUpdateManyInput>
    /**
     * Filter which DewKitchenMenus to update
     */
    where?: DewKitchenMenuWhereInput
  }


  /**
   * DewKitchenMenu upsert
   */
  export type DewKitchenMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * The filter to search for the DewKitchenMenu to update in case it exists.
     */
    where: DewKitchenMenuWhereUniqueInput
    /**
     * In case the DewKitchenMenu found by the `where` argument doesn't exist, create a new DewKitchenMenu with this data.
     */
    create: XOR<DewKitchenMenuCreateInput, DewKitchenMenuUncheckedCreateInput>
    /**
     * In case the DewKitchenMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DewKitchenMenuUpdateInput, DewKitchenMenuUncheckedUpdateInput>
  }


  /**
   * DewKitchenMenu delete
   */
  export type DewKitchenMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
    /**
     * Filter which DewKitchenMenu to delete.
     */
    where: DewKitchenMenuWhereUniqueInput
  }


  /**
   * DewKitchenMenu deleteMany
   */
  export type DewKitchenMenuDeleteManyArgs = {
    /**
     * Filter which DewKitchenMenus to delete
     */
    where?: DewKitchenMenuWhereInput
  }


  /**
   * DewKitchenMenu.orderItems
   */
  export type DewKitchenMenu$orderItemsArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    where?: DewOrderItemWhereInput
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    cursor?: DewOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DewOrderItemScalarFieldEnum>
  }


  /**
   * DewKitchenMenu without action
   */
  export type DewKitchenMenuArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenMenu
     */
    select?: DewKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenMenuInclude | null
  }



  /**
   * Model DewKitchenOrder
   */


  export type AggregateDewKitchenOrder = {
    _count: DewKitchenOrderCountAggregateOutputType | null
    _avg: DewKitchenOrderAvgAggregateOutputType | null
    _sum: DewKitchenOrderSumAggregateOutputType | null
    _min: DewKitchenOrderMinAggregateOutputType | null
    _max: DewKitchenOrderMaxAggregateOutputType | null
  }

  export type DewKitchenOrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type DewKitchenOrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type DewKitchenOrderMinAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenOrderMaxAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewKitchenOrderCountAggregateOutputType = {
    id: number
    status: number
    tableId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type DewKitchenOrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type DewKitchenOrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type DewKitchenOrderMinAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenOrderMaxAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
  }

  export type DewKitchenOrderCountAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type DewKitchenOrderAggregateArgs = {
    /**
     * Filter which DewKitchenOrder to aggregate.
     */
    where?: DewKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenOrders to fetch.
     */
    orderBy?: Enumerable<DewKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DewKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DewKitchenOrders
    **/
    _count?: true | DewKitchenOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DewKitchenOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DewKitchenOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DewKitchenOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DewKitchenOrderMaxAggregateInputType
  }

  export type GetDewKitchenOrderAggregateType<T extends DewKitchenOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateDewKitchenOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDewKitchenOrder[P]>
      : GetScalarType<T[P], AggregateDewKitchenOrder[P]>
  }




  export type DewKitchenOrderGroupByArgs = {
    where?: DewKitchenOrderWhereInput
    orderBy?: Enumerable<DewKitchenOrderOrderByWithAggregationInput>
    by: DewKitchenOrderScalarFieldEnum[]
    having?: DewKitchenOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DewKitchenOrderCountAggregateInputType | true
    _avg?: DewKitchenOrderAvgAggregateInputType
    _sum?: DewKitchenOrderSumAggregateInputType
    _min?: DewKitchenOrderMinAggregateInputType
    _max?: DewKitchenOrderMaxAggregateInputType
  }


  export type DewKitchenOrderGroupByOutputType = {
    id: number
    status: string
    tableId: number
    createAt: Date
    updateAt: Date
    _count: DewKitchenOrderCountAggregateOutputType | null
    _avg: DewKitchenOrderAvgAggregateOutputType | null
    _sum: DewKitchenOrderSumAggregateOutputType | null
    _min: DewKitchenOrderMinAggregateOutputType | null
    _max: DewKitchenOrderMaxAggregateOutputType | null
  }

  type GetDewKitchenOrderGroupByPayload<T extends DewKitchenOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DewKitchenOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DewKitchenOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DewKitchenOrderGroupByOutputType[P]>
            : GetScalarType<T[P], DewKitchenOrderGroupByOutputType[P]>
        }
      >
    >


  export type DewKitchenOrderSelect = {
    id?: boolean
    status?: boolean
    tableId?: boolean
    items?: boolean | DewKitchenOrder$itemsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | DewKitchenOrderCountOutputTypeArgs
  }


  export type DewKitchenOrderInclude = {
    items?: boolean | DewKitchenOrder$itemsArgs
    _count?: boolean | DewKitchenOrderCountOutputTypeArgs
  }

  export type DewKitchenOrderGetPayload<S extends boolean | null | undefined | DewKitchenOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewKitchenOrder :
    S extends undefined ? never :
    S extends { include: any } & (DewKitchenOrderArgs | DewKitchenOrderFindManyArgs)
    ? DewKitchenOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < DewOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? DewKitchenOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DewKitchenOrderArgs | DewKitchenOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < DewOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? DewKitchenOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof DewKitchenOrder ? DewKitchenOrder[P] : never
  } 
      : DewKitchenOrder


  type DewKitchenOrderCountArgs = 
    Omit<DewKitchenOrderFindManyArgs, 'select' | 'include'> & {
      select?: DewKitchenOrderCountAggregateInputType | true
    }

  export interface DewKitchenOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DewKitchenOrder that matches the filter.
     * @param {DewKitchenOrderFindUniqueArgs} args - Arguments to find a DewKitchenOrder
     * @example
     * // Get one DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DewKitchenOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DewKitchenOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DewKitchenOrder'> extends True ? Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>> : Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T> | null, null>

    /**
     * Find one DewKitchenOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DewKitchenOrderFindUniqueOrThrowArgs} args - Arguments to find a DewKitchenOrder
     * @example
     * // Get one DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DewKitchenOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenOrderFindUniqueOrThrowArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Find the first DewKitchenOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderFindFirstArgs} args - Arguments to find a DewKitchenOrder
     * @example
     * // Get one DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DewKitchenOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DewKitchenOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DewKitchenOrder'> extends True ? Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>> : Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T> | null, null>

    /**
     * Find the first DewKitchenOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderFindFirstOrThrowArgs} args - Arguments to find a DewKitchenOrder
     * @example
     * // Get one DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DewKitchenOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DewKitchenOrderFindFirstOrThrowArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Find zero or more DewKitchenOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DewKitchenOrders
     * const dewKitchenOrders = await prisma.dewKitchenOrder.findMany()
     * 
     * // Get first 10 DewKitchenOrders
     * const dewKitchenOrders = await prisma.dewKitchenOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dewKitchenOrderWithIdOnly = await prisma.dewKitchenOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DewKitchenOrderFindManyArgs>(
      args?: SelectSubset<T, DewKitchenOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<DewKitchenOrderGetPayload<T>>>

    /**
     * Create a DewKitchenOrder.
     * @param {DewKitchenOrderCreateArgs} args - Arguments to create a DewKitchenOrder.
     * @example
     * // Create one DewKitchenOrder
     * const DewKitchenOrder = await prisma.dewKitchenOrder.create({
     *   data: {
     *     // ... data to create a DewKitchenOrder
     *   }
     * })
     * 
    **/
    create<T extends DewKitchenOrderCreateArgs>(
      args: SelectSubset<T, DewKitchenOrderCreateArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Create many DewKitchenOrders.
     *     @param {DewKitchenOrderCreateManyArgs} args - Arguments to create many DewKitchenOrders.
     *     @example
     *     // Create many DewKitchenOrders
     *     const dewKitchenOrder = await prisma.dewKitchenOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DewKitchenOrderCreateManyArgs>(
      args?: SelectSubset<T, DewKitchenOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DewKitchenOrder.
     * @param {DewKitchenOrderDeleteArgs} args - Arguments to delete one DewKitchenOrder.
     * @example
     * // Delete one DewKitchenOrder
     * const DewKitchenOrder = await prisma.dewKitchenOrder.delete({
     *   where: {
     *     // ... filter to delete one DewKitchenOrder
     *   }
     * })
     * 
    **/
    delete<T extends DewKitchenOrderDeleteArgs>(
      args: SelectSubset<T, DewKitchenOrderDeleteArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Update one DewKitchenOrder.
     * @param {DewKitchenOrderUpdateArgs} args - Arguments to update one DewKitchenOrder.
     * @example
     * // Update one DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DewKitchenOrderUpdateArgs>(
      args: SelectSubset<T, DewKitchenOrderUpdateArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Delete zero or more DewKitchenOrders.
     * @param {DewKitchenOrderDeleteManyArgs} args - Arguments to filter DewKitchenOrders to delete.
     * @example
     * // Delete a few DewKitchenOrders
     * const { count } = await prisma.dewKitchenOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DewKitchenOrderDeleteManyArgs>(
      args?: SelectSubset<T, DewKitchenOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DewKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DewKitchenOrders
     * const dewKitchenOrder = await prisma.dewKitchenOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DewKitchenOrderUpdateManyArgs>(
      args: SelectSubset<T, DewKitchenOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DewKitchenOrder.
     * @param {DewKitchenOrderUpsertArgs} args - Arguments to update or create a DewKitchenOrder.
     * @example
     * // Update or create a DewKitchenOrder
     * const dewKitchenOrder = await prisma.dewKitchenOrder.upsert({
     *   create: {
     *     // ... data to create a DewKitchenOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DewKitchenOrder we want to update
     *   }
     * })
    **/
    upsert<T extends DewKitchenOrderUpsertArgs>(
      args: SelectSubset<T, DewKitchenOrderUpsertArgs>
    ): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T>>

    /**
     * Count the number of DewKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderCountArgs} args - Arguments to filter DewKitchenOrders to count.
     * @example
     * // Count the number of DewKitchenOrders
     * const count = await prisma.dewKitchenOrder.count({
     *   where: {
     *     // ... the filter for the DewKitchenOrders we want to count
     *   }
     * })
    **/
    count<T extends DewKitchenOrderCountArgs>(
      args?: Subset<T, DewKitchenOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DewKitchenOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DewKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DewKitchenOrderAggregateArgs>(args: Subset<T, DewKitchenOrderAggregateArgs>): Prisma.PrismaPromise<GetDewKitchenOrderAggregateType<T>>

    /**
     * Group by DewKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewKitchenOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DewKitchenOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DewKitchenOrderGroupByArgs['orderBy'] }
        : { orderBy?: DewKitchenOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DewKitchenOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDewKitchenOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DewKitchenOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DewKitchenOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends DewKitchenOrder$itemsArgs= {}>(args?: Subset<T, DewKitchenOrder$itemsArgs>): Prisma.PrismaPromise<Array<DewOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DewKitchenOrder base type for findUnique actions
   */
  export type DewKitchenOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter, which DewKitchenOrder to fetch.
     */
    where: DewKitchenOrderWhereUniqueInput
  }

  /**
   * DewKitchenOrder findUnique
   */
  export interface DewKitchenOrderFindUniqueArgs extends DewKitchenOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenOrder findUniqueOrThrow
   */
  export type DewKitchenOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter, which DewKitchenOrder to fetch.
     */
    where: DewKitchenOrderWhereUniqueInput
  }


  /**
   * DewKitchenOrder base type for findFirst actions
   */
  export type DewKitchenOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter, which DewKitchenOrder to fetch.
     */
    where?: DewKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenOrders to fetch.
     */
    orderBy?: Enumerable<DewKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenOrders.
     */
    cursor?: DewKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenOrders.
     */
    distinct?: Enumerable<DewKitchenOrderScalarFieldEnum>
  }

  /**
   * DewKitchenOrder findFirst
   */
  export interface DewKitchenOrderFindFirstArgs extends DewKitchenOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewKitchenOrder findFirstOrThrow
   */
  export type DewKitchenOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter, which DewKitchenOrder to fetch.
     */
    where?: DewKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenOrders to fetch.
     */
    orderBy?: Enumerable<DewKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewKitchenOrders.
     */
    cursor?: DewKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewKitchenOrders.
     */
    distinct?: Enumerable<DewKitchenOrderScalarFieldEnum>
  }


  /**
   * DewKitchenOrder findMany
   */
  export type DewKitchenOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter, which DewKitchenOrders to fetch.
     */
    where?: DewKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewKitchenOrders to fetch.
     */
    orderBy?: Enumerable<DewKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DewKitchenOrders.
     */
    cursor?: DewKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewKitchenOrders.
     */
    skip?: number
    distinct?: Enumerable<DewKitchenOrderScalarFieldEnum>
  }


  /**
   * DewKitchenOrder create
   */
  export type DewKitchenOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * The data needed to create a DewKitchenOrder.
     */
    data: XOR<DewKitchenOrderCreateInput, DewKitchenOrderUncheckedCreateInput>
  }


  /**
   * DewKitchenOrder createMany
   */
  export type DewKitchenOrderCreateManyArgs = {
    /**
     * The data used to create many DewKitchenOrders.
     */
    data: Enumerable<DewKitchenOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DewKitchenOrder update
   */
  export type DewKitchenOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * The data needed to update a DewKitchenOrder.
     */
    data: XOR<DewKitchenOrderUpdateInput, DewKitchenOrderUncheckedUpdateInput>
    /**
     * Choose, which DewKitchenOrder to update.
     */
    where: DewKitchenOrderWhereUniqueInput
  }


  /**
   * DewKitchenOrder updateMany
   */
  export type DewKitchenOrderUpdateManyArgs = {
    /**
     * The data used to update DewKitchenOrders.
     */
    data: XOR<DewKitchenOrderUpdateManyMutationInput, DewKitchenOrderUncheckedUpdateManyInput>
    /**
     * Filter which DewKitchenOrders to update
     */
    where?: DewKitchenOrderWhereInput
  }


  /**
   * DewKitchenOrder upsert
   */
  export type DewKitchenOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * The filter to search for the DewKitchenOrder to update in case it exists.
     */
    where: DewKitchenOrderWhereUniqueInput
    /**
     * In case the DewKitchenOrder found by the `where` argument doesn't exist, create a new DewKitchenOrder with this data.
     */
    create: XOR<DewKitchenOrderCreateInput, DewKitchenOrderUncheckedCreateInput>
    /**
     * In case the DewKitchenOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DewKitchenOrderUpdateInput, DewKitchenOrderUncheckedUpdateInput>
  }


  /**
   * DewKitchenOrder delete
   */
  export type DewKitchenOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
    /**
     * Filter which DewKitchenOrder to delete.
     */
    where: DewKitchenOrderWhereUniqueInput
  }


  /**
   * DewKitchenOrder deleteMany
   */
  export type DewKitchenOrderDeleteManyArgs = {
    /**
     * Filter which DewKitchenOrders to delete
     */
    where?: DewKitchenOrderWhereInput
  }


  /**
   * DewKitchenOrder.items
   */
  export type DewKitchenOrder$itemsArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    where?: DewOrderItemWhereInput
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    cursor?: DewOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DewOrderItemScalarFieldEnum>
  }


  /**
   * DewKitchenOrder without action
   */
  export type DewKitchenOrderArgs = {
    /**
     * Select specific fields to fetch from the DewKitchenOrder
     */
    select?: DewKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewKitchenOrderInclude | null
  }



  /**
   * Model DewOrderItem
   */


  export type AggregateDewOrderItem = {
    _count: DewOrderItemCountAggregateOutputType | null
    _avg: DewOrderItemAvgAggregateOutputType | null
    _sum: DewOrderItemSumAggregateOutputType | null
    _min: DewOrderItemMinAggregateOutputType | null
    _max: DewOrderItemMaxAggregateOutputType | null
  }

  export type DewOrderItemAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type DewOrderItemSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type DewOrderItemMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewOrderItemMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DewOrderItemCountAggregateOutputType = {
    id: number
    menuId: number
    orderId: number
    quantity: number
    totalPrice: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type DewOrderItemAvgAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type DewOrderItemSumAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type DewOrderItemMinAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createAt?: true
    updateAt?: true
  }

  export type DewOrderItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createAt?: true
    updateAt?: true
  }

  export type DewOrderItemCountAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type DewOrderItemAggregateArgs = {
    /**
     * Filter which DewOrderItem to aggregate.
     */
    where?: DewOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewOrderItems to fetch.
     */
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DewOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DewOrderItems
    **/
    _count?: true | DewOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DewOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DewOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DewOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DewOrderItemMaxAggregateInputType
  }

  export type GetDewOrderItemAggregateType<T extends DewOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDewOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDewOrderItem[P]>
      : GetScalarType<T[P], AggregateDewOrderItem[P]>
  }




  export type DewOrderItemGroupByArgs = {
    where?: DewOrderItemWhereInput
    orderBy?: Enumerable<DewOrderItemOrderByWithAggregationInput>
    by: DewOrderItemScalarFieldEnum[]
    having?: DewOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DewOrderItemCountAggregateInputType | true
    _avg?: DewOrderItemAvgAggregateInputType
    _sum?: DewOrderItemSumAggregateInputType
    _min?: DewOrderItemMinAggregateInputType
    _max?: DewOrderItemMaxAggregateInputType
  }


  export type DewOrderItemGroupByOutputType = {
    id: number
    menuId: number
    orderId: number | null
    quantity: number
    totalPrice: number
    createAt: Date
    updateAt: Date
    _count: DewOrderItemCountAggregateOutputType | null
    _avg: DewOrderItemAvgAggregateOutputType | null
    _sum: DewOrderItemSumAggregateOutputType | null
    _min: DewOrderItemMinAggregateOutputType | null
    _max: DewOrderItemMaxAggregateOutputType | null
  }

  type GetDewOrderItemGroupByPayload<T extends DewOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DewOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DewOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DewOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], DewOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type DewOrderItemSelect = {
    id?: boolean
    menu?: boolean | DewKitchenMenuArgs
    menuId?: boolean
    order?: boolean | DewKitchenOrderArgs
    orderId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type DewOrderItemInclude = {
    menu?: boolean | DewKitchenMenuArgs
    order?: boolean | DewKitchenOrderArgs
  }

  export type DewOrderItemGetPayload<S extends boolean | null | undefined | DewOrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DewOrderItem :
    S extends undefined ? never :
    S extends { include: any } & (DewOrderItemArgs | DewOrderItemFindManyArgs)
    ? DewOrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? DewKitchenMenuGetPayload<S['include'][P]> :
        P extends 'order' ? DewKitchenOrderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (DewOrderItemArgs | DewOrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? DewKitchenMenuGetPayload<S['select'][P]> :
        P extends 'order' ? DewKitchenOrderGetPayload<S['select'][P]> | null :  P extends keyof DewOrderItem ? DewOrderItem[P] : never
  } 
      : DewOrderItem


  type DewOrderItemCountArgs = 
    Omit<DewOrderItemFindManyArgs, 'select' | 'include'> & {
      select?: DewOrderItemCountAggregateInputType | true
    }

  export interface DewOrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DewOrderItem that matches the filter.
     * @param {DewOrderItemFindUniqueArgs} args - Arguments to find a DewOrderItem
     * @example
     * // Get one DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DewOrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DewOrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DewOrderItem'> extends True ? Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>> : Prisma__DewOrderItemClient<DewOrderItemGetPayload<T> | null, null>

    /**
     * Find one DewOrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DewOrderItemFindUniqueOrThrowArgs} args - Arguments to find a DewOrderItem
     * @example
     * // Get one DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DewOrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DewOrderItemFindUniqueOrThrowArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Find the first DewOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemFindFirstArgs} args - Arguments to find a DewOrderItem
     * @example
     * // Get one DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DewOrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DewOrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DewOrderItem'> extends True ? Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>> : Prisma__DewOrderItemClient<DewOrderItemGetPayload<T> | null, null>

    /**
     * Find the first DewOrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemFindFirstOrThrowArgs} args - Arguments to find a DewOrderItem
     * @example
     * // Get one DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DewOrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DewOrderItemFindFirstOrThrowArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Find zero or more DewOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DewOrderItems
     * const dewOrderItems = await prisma.dewOrderItem.findMany()
     * 
     * // Get first 10 DewOrderItems
     * const dewOrderItems = await prisma.dewOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dewOrderItemWithIdOnly = await prisma.dewOrderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DewOrderItemFindManyArgs>(
      args?: SelectSubset<T, DewOrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<DewOrderItemGetPayload<T>>>

    /**
     * Create a DewOrderItem.
     * @param {DewOrderItemCreateArgs} args - Arguments to create a DewOrderItem.
     * @example
     * // Create one DewOrderItem
     * const DewOrderItem = await prisma.dewOrderItem.create({
     *   data: {
     *     // ... data to create a DewOrderItem
     *   }
     * })
     * 
    **/
    create<T extends DewOrderItemCreateArgs>(
      args: SelectSubset<T, DewOrderItemCreateArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Create many DewOrderItems.
     *     @param {DewOrderItemCreateManyArgs} args - Arguments to create many DewOrderItems.
     *     @example
     *     // Create many DewOrderItems
     *     const dewOrderItem = await prisma.dewOrderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DewOrderItemCreateManyArgs>(
      args?: SelectSubset<T, DewOrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DewOrderItem.
     * @param {DewOrderItemDeleteArgs} args - Arguments to delete one DewOrderItem.
     * @example
     * // Delete one DewOrderItem
     * const DewOrderItem = await prisma.dewOrderItem.delete({
     *   where: {
     *     // ... filter to delete one DewOrderItem
     *   }
     * })
     * 
    **/
    delete<T extends DewOrderItemDeleteArgs>(
      args: SelectSubset<T, DewOrderItemDeleteArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Update one DewOrderItem.
     * @param {DewOrderItemUpdateArgs} args - Arguments to update one DewOrderItem.
     * @example
     * // Update one DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DewOrderItemUpdateArgs>(
      args: SelectSubset<T, DewOrderItemUpdateArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Delete zero or more DewOrderItems.
     * @param {DewOrderItemDeleteManyArgs} args - Arguments to filter DewOrderItems to delete.
     * @example
     * // Delete a few DewOrderItems
     * const { count } = await prisma.dewOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DewOrderItemDeleteManyArgs>(
      args?: SelectSubset<T, DewOrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DewOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DewOrderItems
     * const dewOrderItem = await prisma.dewOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DewOrderItemUpdateManyArgs>(
      args: SelectSubset<T, DewOrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DewOrderItem.
     * @param {DewOrderItemUpsertArgs} args - Arguments to update or create a DewOrderItem.
     * @example
     * // Update or create a DewOrderItem
     * const dewOrderItem = await prisma.dewOrderItem.upsert({
     *   create: {
     *     // ... data to create a DewOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DewOrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends DewOrderItemUpsertArgs>(
      args: SelectSubset<T, DewOrderItemUpsertArgs>
    ): Prisma__DewOrderItemClient<DewOrderItemGetPayload<T>>

    /**
     * Count the number of DewOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemCountArgs} args - Arguments to filter DewOrderItems to count.
     * @example
     * // Count the number of DewOrderItems
     * const count = await prisma.dewOrderItem.count({
     *   where: {
     *     // ... the filter for the DewOrderItems we want to count
     *   }
     * })
    **/
    count<T extends DewOrderItemCountArgs>(
      args?: Subset<T, DewOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DewOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DewOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DewOrderItemAggregateArgs>(args: Subset<T, DewOrderItemAggregateArgs>): Prisma.PrismaPromise<GetDewOrderItemAggregateType<T>>

    /**
     * Group by DewOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DewOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DewOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: DewOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DewOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDewOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DewOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DewOrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends DewKitchenMenuArgs= {}>(args?: Subset<T, DewKitchenMenuArgs>): Prisma__DewKitchenMenuClient<DewKitchenMenuGetPayload<T> | Null>;

    order<T extends DewKitchenOrderArgs= {}>(args?: Subset<T, DewKitchenOrderArgs>): Prisma__DewKitchenOrderClient<DewKitchenOrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DewOrderItem base type for findUnique actions
   */
  export type DewOrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter, which DewOrderItem to fetch.
     */
    where: DewOrderItemWhereUniqueInput
  }

  /**
   * DewOrderItem findUnique
   */
  export interface DewOrderItemFindUniqueArgs extends DewOrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewOrderItem findUniqueOrThrow
   */
  export type DewOrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter, which DewOrderItem to fetch.
     */
    where: DewOrderItemWhereUniqueInput
  }


  /**
   * DewOrderItem base type for findFirst actions
   */
  export type DewOrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter, which DewOrderItem to fetch.
     */
    where?: DewOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewOrderItems to fetch.
     */
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewOrderItems.
     */
    cursor?: DewOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewOrderItems.
     */
    distinct?: Enumerable<DewOrderItemScalarFieldEnum>
  }

  /**
   * DewOrderItem findFirst
   */
  export interface DewOrderItemFindFirstArgs extends DewOrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DewOrderItem findFirstOrThrow
   */
  export type DewOrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter, which DewOrderItem to fetch.
     */
    where?: DewOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewOrderItems to fetch.
     */
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DewOrderItems.
     */
    cursor?: DewOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DewOrderItems.
     */
    distinct?: Enumerable<DewOrderItemScalarFieldEnum>
  }


  /**
   * DewOrderItem findMany
   */
  export type DewOrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter, which DewOrderItems to fetch.
     */
    where?: DewOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DewOrderItems to fetch.
     */
    orderBy?: Enumerable<DewOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DewOrderItems.
     */
    cursor?: DewOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DewOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DewOrderItems.
     */
    skip?: number
    distinct?: Enumerable<DewOrderItemScalarFieldEnum>
  }


  /**
   * DewOrderItem create
   */
  export type DewOrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * The data needed to create a DewOrderItem.
     */
    data: XOR<DewOrderItemCreateInput, DewOrderItemUncheckedCreateInput>
  }


  /**
   * DewOrderItem createMany
   */
  export type DewOrderItemCreateManyArgs = {
    /**
     * The data used to create many DewOrderItems.
     */
    data: Enumerable<DewOrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DewOrderItem update
   */
  export type DewOrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * The data needed to update a DewOrderItem.
     */
    data: XOR<DewOrderItemUpdateInput, DewOrderItemUncheckedUpdateInput>
    /**
     * Choose, which DewOrderItem to update.
     */
    where: DewOrderItemWhereUniqueInput
  }


  /**
   * DewOrderItem updateMany
   */
  export type DewOrderItemUpdateManyArgs = {
    /**
     * The data used to update DewOrderItems.
     */
    data: XOR<DewOrderItemUpdateManyMutationInput, DewOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which DewOrderItems to update
     */
    where?: DewOrderItemWhereInput
  }


  /**
   * DewOrderItem upsert
   */
  export type DewOrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * The filter to search for the DewOrderItem to update in case it exists.
     */
    where: DewOrderItemWhereUniqueInput
    /**
     * In case the DewOrderItem found by the `where` argument doesn't exist, create a new DewOrderItem with this data.
     */
    create: XOR<DewOrderItemCreateInput, DewOrderItemUncheckedCreateInput>
    /**
     * In case the DewOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DewOrderItemUpdateInput, DewOrderItemUncheckedUpdateInput>
  }


  /**
   * DewOrderItem delete
   */
  export type DewOrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
    /**
     * Filter which DewOrderItem to delete.
     */
    where: DewOrderItemWhereUniqueInput
  }


  /**
   * DewOrderItem deleteMany
   */
  export type DewOrderItemDeleteManyArgs = {
    /**
     * Filter which DewOrderItems to delete
     */
    where?: DewOrderItemWhereInput
  }


  /**
   * DewOrderItem without action
   */
  export type DewOrderItemArgs = {
    /**
     * Select specific fields to fetch from the DewOrderItem
     */
    select?: DewOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewOrderItemInclude | null
  }



  /**
   * Model BookEx
   */


  export type AggregateBookEx = {
    _count: BookExCountAggregateOutputType | null
    _avg: BookExAvgAggregateOutputType | null
    _sum: BookExSumAggregateOutputType | null
    _min: BookExMinAggregateOutputType | null
    _max: BookExMaxAggregateOutputType | null
  }

  export type BookExAvgAggregateOutputType = {
    id: number | null
  }

  export type BookExSumAggregateOutputType = {
    id: number | null
  }

  export type BookExMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type BookExMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type BookExCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type BookExAvgAggregateInputType = {
    id?: true
  }

  export type BookExSumAggregateInputType = {
    id?: true
  }

  export type BookExMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type BookExMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type BookExCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type BookExAggregateArgs = {
    /**
     * Filter which BookEx to aggregate.
     */
    where?: BookExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExes to fetch.
     */
    orderBy?: Enumerable<BookExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookExes
    **/
    _count?: true | BookExCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookExAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookExSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookExMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookExMaxAggregateInputType
  }

  export type GetBookExAggregateType<T extends BookExAggregateArgs> = {
        [P in keyof T & keyof AggregateBookEx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookEx[P]>
      : GetScalarType<T[P], AggregateBookEx[P]>
  }




  export type BookExGroupByArgs = {
    where?: BookExWhereInput
    orderBy?: Enumerable<BookExOrderByWithAggregationInput>
    by: BookExScalarFieldEnum[]
    having?: BookExScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookExCountAggregateInputType | true
    _avg?: BookExAvgAggregateInputType
    _sum?: BookExSumAggregateInputType
    _min?: BookExMinAggregateInputType
    _max?: BookExMaxAggregateInputType
  }


  export type BookExGroupByOutputType = {
    id: number
    title: string
    _count: BookExCountAggregateOutputType | null
    _avg: BookExAvgAggregateOutputType | null
    _sum: BookExSumAggregateOutputType | null
    _min: BookExMinAggregateOutputType | null
    _max: BookExMaxAggregateOutputType | null
  }

  type GetBookExGroupByPayload<T extends BookExGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookExGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookExGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookExGroupByOutputType[P]>
            : GetScalarType<T[P], BookExGroupByOutputType[P]>
        }
      >
    >


  export type BookExSelect = {
    id?: boolean
    title?: boolean
    BookExampleOnAuthorExample?: boolean | BookEx$BookExampleOnAuthorExampleArgs
    _count?: boolean | BookExCountOutputTypeArgs
  }


  export type BookExInclude = {
    BookExampleOnAuthorExample?: boolean | BookEx$BookExampleOnAuthorExampleArgs
    _count?: boolean | BookExCountOutputTypeArgs
  }

  export type BookExGetPayload<S extends boolean | null | undefined | BookExArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookEx :
    S extends undefined ? never :
    S extends { include: any } & (BookExArgs | BookExFindManyArgs)
    ? BookEx  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'BookExampleOnAuthorExample' ? Array < BookExOnAuthorExGetPayload<S['include'][P]>>  :
        P extends '_count' ? BookExCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BookExArgs | BookExFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'BookExampleOnAuthorExample' ? Array < BookExOnAuthorExGetPayload<S['select'][P]>>  :
        P extends '_count' ? BookExCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BookEx ? BookEx[P] : never
  } 
      : BookEx


  type BookExCountArgs = 
    Omit<BookExFindManyArgs, 'select' | 'include'> & {
      select?: BookExCountAggregateInputType | true
    }

  export interface BookExDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BookEx that matches the filter.
     * @param {BookExFindUniqueArgs} args - Arguments to find a BookEx
     * @example
     * // Get one BookEx
     * const bookEx = await prisma.bookEx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookExFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookExFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BookEx'> extends True ? Prisma__BookExClient<BookExGetPayload<T>> : Prisma__BookExClient<BookExGetPayload<T> | null, null>

    /**
     * Find one BookEx that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookExFindUniqueOrThrowArgs} args - Arguments to find a BookEx
     * @example
     * // Get one BookEx
     * const bookEx = await prisma.bookEx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookExFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookExFindUniqueOrThrowArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Find the first BookEx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExFindFirstArgs} args - Arguments to find a BookEx
     * @example
     * // Get one BookEx
     * const bookEx = await prisma.bookEx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookExFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookExFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BookEx'> extends True ? Prisma__BookExClient<BookExGetPayload<T>> : Prisma__BookExClient<BookExGetPayload<T> | null, null>

    /**
     * Find the first BookEx that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExFindFirstOrThrowArgs} args - Arguments to find a BookEx
     * @example
     * // Get one BookEx
     * const bookEx = await prisma.bookEx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookExFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookExFindFirstOrThrowArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Find zero or more BookExes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookExes
     * const bookExes = await prisma.bookEx.findMany()
     * 
     * // Get first 10 BookExes
     * const bookExes = await prisma.bookEx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookExWithIdOnly = await prisma.bookEx.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookExFindManyArgs>(
      args?: SelectSubset<T, BookExFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookExGetPayload<T>>>

    /**
     * Create a BookEx.
     * @param {BookExCreateArgs} args - Arguments to create a BookEx.
     * @example
     * // Create one BookEx
     * const BookEx = await prisma.bookEx.create({
     *   data: {
     *     // ... data to create a BookEx
     *   }
     * })
     * 
    **/
    create<T extends BookExCreateArgs>(
      args: SelectSubset<T, BookExCreateArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Create many BookExes.
     *     @param {BookExCreateManyArgs} args - Arguments to create many BookExes.
     *     @example
     *     // Create many BookExes
     *     const bookEx = await prisma.bookEx.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookExCreateManyArgs>(
      args?: SelectSubset<T, BookExCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookEx.
     * @param {BookExDeleteArgs} args - Arguments to delete one BookEx.
     * @example
     * // Delete one BookEx
     * const BookEx = await prisma.bookEx.delete({
     *   where: {
     *     // ... filter to delete one BookEx
     *   }
     * })
     * 
    **/
    delete<T extends BookExDeleteArgs>(
      args: SelectSubset<T, BookExDeleteArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Update one BookEx.
     * @param {BookExUpdateArgs} args - Arguments to update one BookEx.
     * @example
     * // Update one BookEx
     * const bookEx = await prisma.bookEx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookExUpdateArgs>(
      args: SelectSubset<T, BookExUpdateArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Delete zero or more BookExes.
     * @param {BookExDeleteManyArgs} args - Arguments to filter BookExes to delete.
     * @example
     * // Delete a few BookExes
     * const { count } = await prisma.bookEx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookExDeleteManyArgs>(
      args?: SelectSubset<T, BookExDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookExes
     * const bookEx = await prisma.bookEx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookExUpdateManyArgs>(
      args: SelectSubset<T, BookExUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookEx.
     * @param {BookExUpsertArgs} args - Arguments to update or create a BookEx.
     * @example
     * // Update or create a BookEx
     * const bookEx = await prisma.bookEx.upsert({
     *   create: {
     *     // ... data to create a BookEx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookEx we want to update
     *   }
     * })
    **/
    upsert<T extends BookExUpsertArgs>(
      args: SelectSubset<T, BookExUpsertArgs>
    ): Prisma__BookExClient<BookExGetPayload<T>>

    /**
     * Count the number of BookExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExCountArgs} args - Arguments to filter BookExes to count.
     * @example
     * // Count the number of BookExes
     * const count = await prisma.bookEx.count({
     *   where: {
     *     // ... the filter for the BookExes we want to count
     *   }
     * })
    **/
    count<T extends BookExCountArgs>(
      args?: Subset<T, BookExCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookExCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookExAggregateArgs>(args: Subset<T, BookExAggregateArgs>): Prisma.PrismaPromise<GetBookExAggregateType<T>>

    /**
     * Group by BookEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookExGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookExGroupByArgs['orderBy'] }
        : { orderBy?: BookExGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookExGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookExGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BookEx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookExClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    BookExampleOnAuthorExample<T extends BookEx$BookExampleOnAuthorExampleArgs= {}>(args?: Subset<T, BookEx$BookExampleOnAuthorExampleArgs>): Prisma.PrismaPromise<Array<BookExOnAuthorExGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BookEx base type for findUnique actions
   */
  export type BookExFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter, which BookEx to fetch.
     */
    where: BookExWhereUniqueInput
  }

  /**
   * BookEx findUnique
   */
  export interface BookExFindUniqueArgs extends BookExFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookEx findUniqueOrThrow
   */
  export type BookExFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter, which BookEx to fetch.
     */
    where: BookExWhereUniqueInput
  }


  /**
   * BookEx base type for findFirst actions
   */
  export type BookExFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter, which BookEx to fetch.
     */
    where?: BookExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExes to fetch.
     */
    orderBy?: Enumerable<BookExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookExes.
     */
    cursor?: BookExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookExes.
     */
    distinct?: Enumerable<BookExScalarFieldEnum>
  }

  /**
   * BookEx findFirst
   */
  export interface BookExFindFirstArgs extends BookExFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookEx findFirstOrThrow
   */
  export type BookExFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter, which BookEx to fetch.
     */
    where?: BookExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExes to fetch.
     */
    orderBy?: Enumerable<BookExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookExes.
     */
    cursor?: BookExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookExes.
     */
    distinct?: Enumerable<BookExScalarFieldEnum>
  }


  /**
   * BookEx findMany
   */
  export type BookExFindManyArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter, which BookExes to fetch.
     */
    where?: BookExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExes to fetch.
     */
    orderBy?: Enumerable<BookExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookExes.
     */
    cursor?: BookExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExes.
     */
    skip?: number
    distinct?: Enumerable<BookExScalarFieldEnum>
  }


  /**
   * BookEx create
   */
  export type BookExCreateArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * The data needed to create a BookEx.
     */
    data: XOR<BookExCreateInput, BookExUncheckedCreateInput>
  }


  /**
   * BookEx createMany
   */
  export type BookExCreateManyArgs = {
    /**
     * The data used to create many BookExes.
     */
    data: Enumerable<BookExCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BookEx update
   */
  export type BookExUpdateArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * The data needed to update a BookEx.
     */
    data: XOR<BookExUpdateInput, BookExUncheckedUpdateInput>
    /**
     * Choose, which BookEx to update.
     */
    where: BookExWhereUniqueInput
  }


  /**
   * BookEx updateMany
   */
  export type BookExUpdateManyArgs = {
    /**
     * The data used to update BookExes.
     */
    data: XOR<BookExUpdateManyMutationInput, BookExUncheckedUpdateManyInput>
    /**
     * Filter which BookExes to update
     */
    where?: BookExWhereInput
  }


  /**
   * BookEx upsert
   */
  export type BookExUpsertArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * The filter to search for the BookEx to update in case it exists.
     */
    where: BookExWhereUniqueInput
    /**
     * In case the BookEx found by the `where` argument doesn't exist, create a new BookEx with this data.
     */
    create: XOR<BookExCreateInput, BookExUncheckedCreateInput>
    /**
     * In case the BookEx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookExUpdateInput, BookExUncheckedUpdateInput>
  }


  /**
   * BookEx delete
   */
  export type BookExDeleteArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
    /**
     * Filter which BookEx to delete.
     */
    where: BookExWhereUniqueInput
  }


  /**
   * BookEx deleteMany
   */
  export type BookExDeleteManyArgs = {
    /**
     * Filter which BookExes to delete
     */
    where?: BookExWhereInput
  }


  /**
   * BookEx.BookExampleOnAuthorExample
   */
  export type BookEx$BookExampleOnAuthorExampleArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    where?: BookExOnAuthorExWhereInput
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    cursor?: BookExOnAuthorExWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookExOnAuthorExScalarFieldEnum>
  }


  /**
   * BookEx without action
   */
  export type BookExArgs = {
    /**
     * Select specific fields to fetch from the BookEx
     */
    select?: BookExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExInclude | null
  }



  /**
   * Model AuthorEx
   */


  export type AggregateAuthorEx = {
    _count: AuthorExCountAggregateOutputType | null
    _avg: AuthorExAvgAggregateOutputType | null
    _sum: AuthorExSumAggregateOutputType | null
    _min: AuthorExMinAggregateOutputType | null
    _max: AuthorExMaxAggregateOutputType | null
  }

  export type AuthorExAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthorExSumAggregateOutputType = {
    id: number | null
  }

  export type AuthorExMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AuthorExMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AuthorExCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AuthorExAvgAggregateInputType = {
    id?: true
  }

  export type AuthorExSumAggregateInputType = {
    id?: true
  }

  export type AuthorExMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AuthorExMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AuthorExCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AuthorExAggregateArgs = {
    /**
     * Filter which AuthorEx to aggregate.
     */
    where?: AuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorExes to fetch.
     */
    orderBy?: Enumerable<AuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorExes
    **/
    _count?: true | AuthorExCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorExAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorExSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorExMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorExMaxAggregateInputType
  }

  export type GetAuthorExAggregateType<T extends AuthorExAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorEx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorEx[P]>
      : GetScalarType<T[P], AggregateAuthorEx[P]>
  }




  export type AuthorExGroupByArgs = {
    where?: AuthorExWhereInput
    orderBy?: Enumerable<AuthorExOrderByWithAggregationInput>
    by: AuthorExScalarFieldEnum[]
    having?: AuthorExScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorExCountAggregateInputType | true
    _avg?: AuthorExAvgAggregateInputType
    _sum?: AuthorExSumAggregateInputType
    _min?: AuthorExMinAggregateInputType
    _max?: AuthorExMaxAggregateInputType
  }


  export type AuthorExGroupByOutputType = {
    id: number
    name: string
    _count: AuthorExCountAggregateOutputType | null
    _avg: AuthorExAvgAggregateOutputType | null
    _sum: AuthorExSumAggregateOutputType | null
    _min: AuthorExMinAggregateOutputType | null
    _max: AuthorExMaxAggregateOutputType | null
  }

  type GetAuthorExGroupByPayload<T extends AuthorExGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthorExGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorExGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorExGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorExGroupByOutputType[P]>
        }
      >
    >


  export type AuthorExSelect = {
    id?: boolean
    name?: boolean
    BookExampleOnAuthorExample?: boolean | AuthorEx$BookExampleOnAuthorExampleArgs
    _count?: boolean | AuthorExCountOutputTypeArgs
  }


  export type AuthorExInclude = {
    BookExampleOnAuthorExample?: boolean | AuthorEx$BookExampleOnAuthorExampleArgs
    _count?: boolean | AuthorExCountOutputTypeArgs
  }

  export type AuthorExGetPayload<S extends boolean | null | undefined | AuthorExArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthorEx :
    S extends undefined ? never :
    S extends { include: any } & (AuthorExArgs | AuthorExFindManyArgs)
    ? AuthorEx  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'BookExampleOnAuthorExample' ? Array < BookExOnAuthorExGetPayload<S['include'][P]>>  :
        P extends '_count' ? AuthorExCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthorExArgs | AuthorExFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'BookExampleOnAuthorExample' ? Array < BookExOnAuthorExGetPayload<S['select'][P]>>  :
        P extends '_count' ? AuthorExCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof AuthorEx ? AuthorEx[P] : never
  } 
      : AuthorEx


  type AuthorExCountArgs = 
    Omit<AuthorExFindManyArgs, 'select' | 'include'> & {
      select?: AuthorExCountAggregateInputType | true
    }

  export interface AuthorExDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AuthorEx that matches the filter.
     * @param {AuthorExFindUniqueArgs} args - Arguments to find a AuthorEx
     * @example
     * // Get one AuthorEx
     * const authorEx = await prisma.authorEx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorExFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorExFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuthorEx'> extends True ? Prisma__AuthorExClient<AuthorExGetPayload<T>> : Prisma__AuthorExClient<AuthorExGetPayload<T> | null, null>

    /**
     * Find one AuthorEx that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthorExFindUniqueOrThrowArgs} args - Arguments to find a AuthorEx
     * @example
     * // Get one AuthorEx
     * const authorEx = await prisma.authorEx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthorExFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthorExFindUniqueOrThrowArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Find the first AuthorEx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExFindFirstArgs} args - Arguments to find a AuthorEx
     * @example
     * // Get one AuthorEx
     * const authorEx = await prisma.authorEx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorExFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorExFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuthorEx'> extends True ? Prisma__AuthorExClient<AuthorExGetPayload<T>> : Prisma__AuthorExClient<AuthorExGetPayload<T> | null, null>

    /**
     * Find the first AuthorEx that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExFindFirstOrThrowArgs} args - Arguments to find a AuthorEx
     * @example
     * // Get one AuthorEx
     * const authorEx = await prisma.authorEx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthorExFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthorExFindFirstOrThrowArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Find zero or more AuthorExes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorExes
     * const authorExes = await prisma.authorEx.findMany()
     * 
     * // Get first 10 AuthorExes
     * const authorExes = await prisma.authorEx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorExWithIdOnly = await prisma.authorEx.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthorExFindManyArgs>(
      args?: SelectSubset<T, AuthorExFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthorExGetPayload<T>>>

    /**
     * Create a AuthorEx.
     * @param {AuthorExCreateArgs} args - Arguments to create a AuthorEx.
     * @example
     * // Create one AuthorEx
     * const AuthorEx = await prisma.authorEx.create({
     *   data: {
     *     // ... data to create a AuthorEx
     *   }
     * })
     * 
    **/
    create<T extends AuthorExCreateArgs>(
      args: SelectSubset<T, AuthorExCreateArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Create many AuthorExes.
     *     @param {AuthorExCreateManyArgs} args - Arguments to create many AuthorExes.
     *     @example
     *     // Create many AuthorExes
     *     const authorEx = await prisma.authorEx.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthorExCreateManyArgs>(
      args?: SelectSubset<T, AuthorExCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuthorEx.
     * @param {AuthorExDeleteArgs} args - Arguments to delete one AuthorEx.
     * @example
     * // Delete one AuthorEx
     * const AuthorEx = await prisma.authorEx.delete({
     *   where: {
     *     // ... filter to delete one AuthorEx
     *   }
     * })
     * 
    **/
    delete<T extends AuthorExDeleteArgs>(
      args: SelectSubset<T, AuthorExDeleteArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Update one AuthorEx.
     * @param {AuthorExUpdateArgs} args - Arguments to update one AuthorEx.
     * @example
     * // Update one AuthorEx
     * const authorEx = await prisma.authorEx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorExUpdateArgs>(
      args: SelectSubset<T, AuthorExUpdateArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Delete zero or more AuthorExes.
     * @param {AuthorExDeleteManyArgs} args - Arguments to filter AuthorExes to delete.
     * @example
     * // Delete a few AuthorExes
     * const { count } = await prisma.authorEx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorExDeleteManyArgs>(
      args?: SelectSubset<T, AuthorExDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorExes
     * const authorEx = await prisma.authorEx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorExUpdateManyArgs>(
      args: SelectSubset<T, AuthorExUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorEx.
     * @param {AuthorExUpsertArgs} args - Arguments to update or create a AuthorEx.
     * @example
     * // Update or create a AuthorEx
     * const authorEx = await prisma.authorEx.upsert({
     *   create: {
     *     // ... data to create a AuthorEx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorEx we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorExUpsertArgs>(
      args: SelectSubset<T, AuthorExUpsertArgs>
    ): Prisma__AuthorExClient<AuthorExGetPayload<T>>

    /**
     * Count the number of AuthorExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExCountArgs} args - Arguments to filter AuthorExes to count.
     * @example
     * // Count the number of AuthorExes
     * const count = await prisma.authorEx.count({
     *   where: {
     *     // ... the filter for the AuthorExes we want to count
     *   }
     * })
    **/
    count<T extends AuthorExCountArgs>(
      args?: Subset<T, AuthorExCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorExCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorExAggregateArgs>(args: Subset<T, AuthorExAggregateArgs>): Prisma.PrismaPromise<GetAuthorExAggregateType<T>>

    /**
     * Group by AuthorEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorExGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorExGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorExGroupByArgs['orderBy'] }
        : { orderBy?: AuthorExGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorExGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorExGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorEx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorExClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    BookExampleOnAuthorExample<T extends AuthorEx$BookExampleOnAuthorExampleArgs= {}>(args?: Subset<T, AuthorEx$BookExampleOnAuthorExampleArgs>): Prisma.PrismaPromise<Array<BookExOnAuthorExGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuthorEx base type for findUnique actions
   */
  export type AuthorExFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter, which AuthorEx to fetch.
     */
    where: AuthorExWhereUniqueInput
  }

  /**
   * AuthorEx findUnique
   */
  export interface AuthorExFindUniqueArgs extends AuthorExFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorEx findUniqueOrThrow
   */
  export type AuthorExFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter, which AuthorEx to fetch.
     */
    where: AuthorExWhereUniqueInput
  }


  /**
   * AuthorEx base type for findFirst actions
   */
  export type AuthorExFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter, which AuthorEx to fetch.
     */
    where?: AuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorExes to fetch.
     */
    orderBy?: Enumerable<AuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorExes.
     */
    cursor?: AuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorExes.
     */
    distinct?: Enumerable<AuthorExScalarFieldEnum>
  }

  /**
   * AuthorEx findFirst
   */
  export interface AuthorExFindFirstArgs extends AuthorExFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthorEx findFirstOrThrow
   */
  export type AuthorExFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter, which AuthorEx to fetch.
     */
    where?: AuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorExes to fetch.
     */
    orderBy?: Enumerable<AuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorExes.
     */
    cursor?: AuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorExes.
     */
    distinct?: Enumerable<AuthorExScalarFieldEnum>
  }


  /**
   * AuthorEx findMany
   */
  export type AuthorExFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter, which AuthorExes to fetch.
     */
    where?: AuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorExes to fetch.
     */
    orderBy?: Enumerable<AuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorExes.
     */
    cursor?: AuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorExes.
     */
    skip?: number
    distinct?: Enumerable<AuthorExScalarFieldEnum>
  }


  /**
   * AuthorEx create
   */
  export type AuthorExCreateArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * The data needed to create a AuthorEx.
     */
    data: XOR<AuthorExCreateInput, AuthorExUncheckedCreateInput>
  }


  /**
   * AuthorEx createMany
   */
  export type AuthorExCreateManyArgs = {
    /**
     * The data used to create many AuthorExes.
     */
    data: Enumerable<AuthorExCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuthorEx update
   */
  export type AuthorExUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * The data needed to update a AuthorEx.
     */
    data: XOR<AuthorExUpdateInput, AuthorExUncheckedUpdateInput>
    /**
     * Choose, which AuthorEx to update.
     */
    where: AuthorExWhereUniqueInput
  }


  /**
   * AuthorEx updateMany
   */
  export type AuthorExUpdateManyArgs = {
    /**
     * The data used to update AuthorExes.
     */
    data: XOR<AuthorExUpdateManyMutationInput, AuthorExUncheckedUpdateManyInput>
    /**
     * Filter which AuthorExes to update
     */
    where?: AuthorExWhereInput
  }


  /**
   * AuthorEx upsert
   */
  export type AuthorExUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * The filter to search for the AuthorEx to update in case it exists.
     */
    where: AuthorExWhereUniqueInput
    /**
     * In case the AuthorEx found by the `where` argument doesn't exist, create a new AuthorEx with this data.
     */
    create: XOR<AuthorExCreateInput, AuthorExUncheckedCreateInput>
    /**
     * In case the AuthorEx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorExUpdateInput, AuthorExUncheckedUpdateInput>
  }


  /**
   * AuthorEx delete
   */
  export type AuthorExDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
    /**
     * Filter which AuthorEx to delete.
     */
    where: AuthorExWhereUniqueInput
  }


  /**
   * AuthorEx deleteMany
   */
  export type AuthorExDeleteManyArgs = {
    /**
     * Filter which AuthorExes to delete
     */
    where?: AuthorExWhereInput
  }


  /**
   * AuthorEx.BookExampleOnAuthorExample
   */
  export type AuthorEx$BookExampleOnAuthorExampleArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    where?: BookExOnAuthorExWhereInput
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    cursor?: BookExOnAuthorExWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookExOnAuthorExScalarFieldEnum>
  }


  /**
   * AuthorEx without action
   */
  export type AuthorExArgs = {
    /**
     * Select specific fields to fetch from the AuthorEx
     */
    select?: AuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthorExInclude | null
  }



  /**
   * Model BookExOnAuthorEx
   */


  export type AggregateBookExOnAuthorEx = {
    _count: BookExOnAuthorExCountAggregateOutputType | null
    _avg: BookExOnAuthorExAvgAggregateOutputType | null
    _sum: BookExOnAuthorExSumAggregateOutputType | null
    _min: BookExOnAuthorExMinAggregateOutputType | null
    _max: BookExOnAuthorExMaxAggregateOutputType | null
  }

  export type BookExOnAuthorExAvgAggregateOutputType = {
    bookExampleId: number | null
    authorExampleId: number | null
  }

  export type BookExOnAuthorExSumAggregateOutputType = {
    bookExampleId: number | null
    authorExampleId: number | null
  }

  export type BookExOnAuthorExMinAggregateOutputType = {
    bookExampleId: number | null
    authorExampleId: number | null
  }

  export type BookExOnAuthorExMaxAggregateOutputType = {
    bookExampleId: number | null
    authorExampleId: number | null
  }

  export type BookExOnAuthorExCountAggregateOutputType = {
    bookExampleId: number
    authorExampleId: number
    _all: number
  }


  export type BookExOnAuthorExAvgAggregateInputType = {
    bookExampleId?: true
    authorExampleId?: true
  }

  export type BookExOnAuthorExSumAggregateInputType = {
    bookExampleId?: true
    authorExampleId?: true
  }

  export type BookExOnAuthorExMinAggregateInputType = {
    bookExampleId?: true
    authorExampleId?: true
  }

  export type BookExOnAuthorExMaxAggregateInputType = {
    bookExampleId?: true
    authorExampleId?: true
  }

  export type BookExOnAuthorExCountAggregateInputType = {
    bookExampleId?: true
    authorExampleId?: true
    _all?: true
  }

  export type BookExOnAuthorExAggregateArgs = {
    /**
     * Filter which BookExOnAuthorEx to aggregate.
     */
    where?: BookExOnAuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExOnAuthorExes to fetch.
     */
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookExOnAuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExOnAuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExOnAuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookExOnAuthorExes
    **/
    _count?: true | BookExOnAuthorExCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookExOnAuthorExAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookExOnAuthorExSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookExOnAuthorExMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookExOnAuthorExMaxAggregateInputType
  }

  export type GetBookExOnAuthorExAggregateType<T extends BookExOnAuthorExAggregateArgs> = {
        [P in keyof T & keyof AggregateBookExOnAuthorEx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookExOnAuthorEx[P]>
      : GetScalarType<T[P], AggregateBookExOnAuthorEx[P]>
  }




  export type BookExOnAuthorExGroupByArgs = {
    where?: BookExOnAuthorExWhereInput
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithAggregationInput>
    by: BookExOnAuthorExScalarFieldEnum[]
    having?: BookExOnAuthorExScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookExOnAuthorExCountAggregateInputType | true
    _avg?: BookExOnAuthorExAvgAggregateInputType
    _sum?: BookExOnAuthorExSumAggregateInputType
    _min?: BookExOnAuthorExMinAggregateInputType
    _max?: BookExOnAuthorExMaxAggregateInputType
  }


  export type BookExOnAuthorExGroupByOutputType = {
    bookExampleId: number
    authorExampleId: number
    _count: BookExOnAuthorExCountAggregateOutputType | null
    _avg: BookExOnAuthorExAvgAggregateOutputType | null
    _sum: BookExOnAuthorExSumAggregateOutputType | null
    _min: BookExOnAuthorExMinAggregateOutputType | null
    _max: BookExOnAuthorExMaxAggregateOutputType | null
  }

  type GetBookExOnAuthorExGroupByPayload<T extends BookExOnAuthorExGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookExOnAuthorExGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookExOnAuthorExGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookExOnAuthorExGroupByOutputType[P]>
            : GetScalarType<T[P], BookExOnAuthorExGroupByOutputType[P]>
        }
      >
    >


  export type BookExOnAuthorExSelect = {
    bookExample?: boolean | BookExArgs
    bookExampleId?: boolean
    authorExample?: boolean | AuthorExArgs
    authorExampleId?: boolean
  }


  export type BookExOnAuthorExInclude = {
    bookExample?: boolean | BookExArgs
    authorExample?: boolean | AuthorExArgs
  }

  export type BookExOnAuthorExGetPayload<S extends boolean | null | undefined | BookExOnAuthorExArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BookExOnAuthorEx :
    S extends undefined ? never :
    S extends { include: any } & (BookExOnAuthorExArgs | BookExOnAuthorExFindManyArgs)
    ? BookExOnAuthorEx  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookExample' ? BookExGetPayload<S['include'][P]> :
        P extends 'authorExample' ? AuthorExGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BookExOnAuthorExArgs | BookExOnAuthorExFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookExample' ? BookExGetPayload<S['select'][P]> :
        P extends 'authorExample' ? AuthorExGetPayload<S['select'][P]> :  P extends keyof BookExOnAuthorEx ? BookExOnAuthorEx[P] : never
  } 
      : BookExOnAuthorEx


  type BookExOnAuthorExCountArgs = 
    Omit<BookExOnAuthorExFindManyArgs, 'select' | 'include'> & {
      select?: BookExOnAuthorExCountAggregateInputType | true
    }

  export interface BookExOnAuthorExDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BookExOnAuthorEx that matches the filter.
     * @param {BookExOnAuthorExFindUniqueArgs} args - Arguments to find a BookExOnAuthorEx
     * @example
     * // Get one BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookExOnAuthorExFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookExOnAuthorExFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BookExOnAuthorEx'> extends True ? Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>> : Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T> | null, null>

    /**
     * Find one BookExOnAuthorEx that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookExOnAuthorExFindUniqueOrThrowArgs} args - Arguments to find a BookExOnAuthorEx
     * @example
     * // Get one BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookExOnAuthorExFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookExOnAuthorExFindUniqueOrThrowArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Find the first BookExOnAuthorEx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExFindFirstArgs} args - Arguments to find a BookExOnAuthorEx
     * @example
     * // Get one BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookExOnAuthorExFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookExOnAuthorExFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BookExOnAuthorEx'> extends True ? Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>> : Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T> | null, null>

    /**
     * Find the first BookExOnAuthorEx that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExFindFirstOrThrowArgs} args - Arguments to find a BookExOnAuthorEx
     * @example
     * // Get one BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookExOnAuthorExFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookExOnAuthorExFindFirstOrThrowArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Find zero or more BookExOnAuthorExes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookExOnAuthorExes
     * const bookExOnAuthorExes = await prisma.bookExOnAuthorEx.findMany()
     * 
     * // Get first 10 BookExOnAuthorExes
     * const bookExOnAuthorExes = await prisma.bookExOnAuthorEx.findMany({ take: 10 })
     * 
     * // Only select the `bookExampleId`
     * const bookExOnAuthorExWithBookExampleIdOnly = await prisma.bookExOnAuthorEx.findMany({ select: { bookExampleId: true } })
     * 
    **/
    findMany<T extends BookExOnAuthorExFindManyArgs>(
      args?: SelectSubset<T, BookExOnAuthorExFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookExOnAuthorExGetPayload<T>>>

    /**
     * Create a BookExOnAuthorEx.
     * @param {BookExOnAuthorExCreateArgs} args - Arguments to create a BookExOnAuthorEx.
     * @example
     * // Create one BookExOnAuthorEx
     * const BookExOnAuthorEx = await prisma.bookExOnAuthorEx.create({
     *   data: {
     *     // ... data to create a BookExOnAuthorEx
     *   }
     * })
     * 
    **/
    create<T extends BookExOnAuthorExCreateArgs>(
      args: SelectSubset<T, BookExOnAuthorExCreateArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Create many BookExOnAuthorExes.
     *     @param {BookExOnAuthorExCreateManyArgs} args - Arguments to create many BookExOnAuthorExes.
     *     @example
     *     // Create many BookExOnAuthorExes
     *     const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookExOnAuthorExCreateManyArgs>(
      args?: SelectSubset<T, BookExOnAuthorExCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookExOnAuthorEx.
     * @param {BookExOnAuthorExDeleteArgs} args - Arguments to delete one BookExOnAuthorEx.
     * @example
     * // Delete one BookExOnAuthorEx
     * const BookExOnAuthorEx = await prisma.bookExOnAuthorEx.delete({
     *   where: {
     *     // ... filter to delete one BookExOnAuthorEx
     *   }
     * })
     * 
    **/
    delete<T extends BookExOnAuthorExDeleteArgs>(
      args: SelectSubset<T, BookExOnAuthorExDeleteArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Update one BookExOnAuthorEx.
     * @param {BookExOnAuthorExUpdateArgs} args - Arguments to update one BookExOnAuthorEx.
     * @example
     * // Update one BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookExOnAuthorExUpdateArgs>(
      args: SelectSubset<T, BookExOnAuthorExUpdateArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Delete zero or more BookExOnAuthorExes.
     * @param {BookExOnAuthorExDeleteManyArgs} args - Arguments to filter BookExOnAuthorExes to delete.
     * @example
     * // Delete a few BookExOnAuthorExes
     * const { count } = await prisma.bookExOnAuthorEx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookExOnAuthorExDeleteManyArgs>(
      args?: SelectSubset<T, BookExOnAuthorExDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookExOnAuthorExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookExOnAuthorExes
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookExOnAuthorExUpdateManyArgs>(
      args: SelectSubset<T, BookExOnAuthorExUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookExOnAuthorEx.
     * @param {BookExOnAuthorExUpsertArgs} args - Arguments to update or create a BookExOnAuthorEx.
     * @example
     * // Update or create a BookExOnAuthorEx
     * const bookExOnAuthorEx = await prisma.bookExOnAuthorEx.upsert({
     *   create: {
     *     // ... data to create a BookExOnAuthorEx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookExOnAuthorEx we want to update
     *   }
     * })
    **/
    upsert<T extends BookExOnAuthorExUpsertArgs>(
      args: SelectSubset<T, BookExOnAuthorExUpsertArgs>
    ): Prisma__BookExOnAuthorExClient<BookExOnAuthorExGetPayload<T>>

    /**
     * Count the number of BookExOnAuthorExes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExCountArgs} args - Arguments to filter BookExOnAuthorExes to count.
     * @example
     * // Count the number of BookExOnAuthorExes
     * const count = await prisma.bookExOnAuthorEx.count({
     *   where: {
     *     // ... the filter for the BookExOnAuthorExes we want to count
     *   }
     * })
    **/
    count<T extends BookExOnAuthorExCountArgs>(
      args?: Subset<T, BookExOnAuthorExCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookExOnAuthorExCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookExOnAuthorEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookExOnAuthorExAggregateArgs>(args: Subset<T, BookExOnAuthorExAggregateArgs>): Prisma.PrismaPromise<GetBookExOnAuthorExAggregateType<T>>

    /**
     * Group by BookExOnAuthorEx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookExOnAuthorExGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookExOnAuthorExGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookExOnAuthorExGroupByArgs['orderBy'] }
        : { orderBy?: BookExOnAuthorExGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookExOnAuthorExGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookExOnAuthorExGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BookExOnAuthorEx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookExOnAuthorExClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookExample<T extends BookExArgs= {}>(args?: Subset<T, BookExArgs>): Prisma__BookExClient<BookExGetPayload<T> | Null>;

    authorExample<T extends AuthorExArgs= {}>(args?: Subset<T, AuthorExArgs>): Prisma__AuthorExClient<AuthorExGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BookExOnAuthorEx base type for findUnique actions
   */
  export type BookExOnAuthorExFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter, which BookExOnAuthorEx to fetch.
     */
    where: BookExOnAuthorExWhereUniqueInput
  }

  /**
   * BookExOnAuthorEx findUnique
   */
  export interface BookExOnAuthorExFindUniqueArgs extends BookExOnAuthorExFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookExOnAuthorEx findUniqueOrThrow
   */
  export type BookExOnAuthorExFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter, which BookExOnAuthorEx to fetch.
     */
    where: BookExOnAuthorExWhereUniqueInput
  }


  /**
   * BookExOnAuthorEx base type for findFirst actions
   */
  export type BookExOnAuthorExFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter, which BookExOnAuthorEx to fetch.
     */
    where?: BookExOnAuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExOnAuthorExes to fetch.
     */
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookExOnAuthorExes.
     */
    cursor?: BookExOnAuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExOnAuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExOnAuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookExOnAuthorExes.
     */
    distinct?: Enumerable<BookExOnAuthorExScalarFieldEnum>
  }

  /**
   * BookExOnAuthorEx findFirst
   */
  export interface BookExOnAuthorExFindFirstArgs extends BookExOnAuthorExFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BookExOnAuthorEx findFirstOrThrow
   */
  export type BookExOnAuthorExFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter, which BookExOnAuthorEx to fetch.
     */
    where?: BookExOnAuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExOnAuthorExes to fetch.
     */
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookExOnAuthorExes.
     */
    cursor?: BookExOnAuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExOnAuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExOnAuthorExes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookExOnAuthorExes.
     */
    distinct?: Enumerable<BookExOnAuthorExScalarFieldEnum>
  }


  /**
   * BookExOnAuthorEx findMany
   */
  export type BookExOnAuthorExFindManyArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter, which BookExOnAuthorExes to fetch.
     */
    where?: BookExOnAuthorExWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookExOnAuthorExes to fetch.
     */
    orderBy?: Enumerable<BookExOnAuthorExOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookExOnAuthorExes.
     */
    cursor?: BookExOnAuthorExWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookExOnAuthorExes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookExOnAuthorExes.
     */
    skip?: number
    distinct?: Enumerable<BookExOnAuthorExScalarFieldEnum>
  }


  /**
   * BookExOnAuthorEx create
   */
  export type BookExOnAuthorExCreateArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * The data needed to create a BookExOnAuthorEx.
     */
    data: XOR<BookExOnAuthorExCreateInput, BookExOnAuthorExUncheckedCreateInput>
  }


  /**
   * BookExOnAuthorEx createMany
   */
  export type BookExOnAuthorExCreateManyArgs = {
    /**
     * The data used to create many BookExOnAuthorExes.
     */
    data: Enumerable<BookExOnAuthorExCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BookExOnAuthorEx update
   */
  export type BookExOnAuthorExUpdateArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * The data needed to update a BookExOnAuthorEx.
     */
    data: XOR<BookExOnAuthorExUpdateInput, BookExOnAuthorExUncheckedUpdateInput>
    /**
     * Choose, which BookExOnAuthorEx to update.
     */
    where: BookExOnAuthorExWhereUniqueInput
  }


  /**
   * BookExOnAuthorEx updateMany
   */
  export type BookExOnAuthorExUpdateManyArgs = {
    /**
     * The data used to update BookExOnAuthorExes.
     */
    data: XOR<BookExOnAuthorExUpdateManyMutationInput, BookExOnAuthorExUncheckedUpdateManyInput>
    /**
     * Filter which BookExOnAuthorExes to update
     */
    where?: BookExOnAuthorExWhereInput
  }


  /**
   * BookExOnAuthorEx upsert
   */
  export type BookExOnAuthorExUpsertArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * The filter to search for the BookExOnAuthorEx to update in case it exists.
     */
    where: BookExOnAuthorExWhereUniqueInput
    /**
     * In case the BookExOnAuthorEx found by the `where` argument doesn't exist, create a new BookExOnAuthorEx with this data.
     */
    create: XOR<BookExOnAuthorExCreateInput, BookExOnAuthorExUncheckedCreateInput>
    /**
     * In case the BookExOnAuthorEx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookExOnAuthorExUpdateInput, BookExOnAuthorExUncheckedUpdateInput>
  }


  /**
   * BookExOnAuthorEx delete
   */
  export type BookExOnAuthorExDeleteArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
    /**
     * Filter which BookExOnAuthorEx to delete.
     */
    where: BookExOnAuthorExWhereUniqueInput
  }


  /**
   * BookExOnAuthorEx deleteMany
   */
  export type BookExOnAuthorExDeleteManyArgs = {
    /**
     * Filter which BookExOnAuthorExes to delete
     */
    where?: BookExOnAuthorExWhereInput
  }


  /**
   * BookExOnAuthorEx without action
   */
  export type BookExOnAuthorExArgs = {
    /**
     * Select specific fields to fetch from the BookExOnAuthorEx
     */
    select?: BookExOnAuthorExSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookExOnAuthorExInclude | null
  }



  /**
   * Model SeriesTv
   */


  export type AggregateSeriesTv = {
    _count: SeriesTvCountAggregateOutputType | null
    _avg: SeriesTvAvgAggregateOutputType | null
    _sum: SeriesTvSumAggregateOutputType | null
    _min: SeriesTvMinAggregateOutputType | null
    _max: SeriesTvMaxAggregateOutputType | null
  }

  export type SeriesTvAvgAggregateOutputType = {
    id: number | null
  }

  export type SeriesTvSumAggregateOutputType = {
    id: number | null
  }

  export type SeriesTvMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type SeriesTvMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type SeriesTvCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SeriesTvAvgAggregateInputType = {
    id?: true
  }

  export type SeriesTvSumAggregateInputType = {
    id?: true
  }

  export type SeriesTvMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SeriesTvMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SeriesTvCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SeriesTvAggregateArgs = {
    /**
     * Filter which SeriesTv to aggregate.
     */
    where?: SeriesTvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTvs to fetch.
     */
    orderBy?: Enumerable<SeriesTvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesTvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeriesTvs
    **/
    _count?: true | SeriesTvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesTvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesTvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesTvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesTvMaxAggregateInputType
  }

  export type GetSeriesTvAggregateType<T extends SeriesTvAggregateArgs> = {
        [P in keyof T & keyof AggregateSeriesTv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeriesTv[P]>
      : GetScalarType<T[P], AggregateSeriesTv[P]>
  }




  export type SeriesTvGroupByArgs = {
    where?: SeriesTvWhereInput
    orderBy?: Enumerable<SeriesTvOrderByWithAggregationInput>
    by: SeriesTvScalarFieldEnum[]
    having?: SeriesTvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesTvCountAggregateInputType | true
    _avg?: SeriesTvAvgAggregateInputType
    _sum?: SeriesTvSumAggregateInputType
    _min?: SeriesTvMinAggregateInputType
    _max?: SeriesTvMaxAggregateInputType
  }


  export type SeriesTvGroupByOutputType = {
    id: number
    name: string
    _count: SeriesTvCountAggregateOutputType | null
    _avg: SeriesTvAvgAggregateOutputType | null
    _sum: SeriesTvSumAggregateOutputType | null
    _min: SeriesTvMinAggregateOutputType | null
    _max: SeriesTvMaxAggregateOutputType | null
  }

  type GetSeriesTvGroupByPayload<T extends SeriesTvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SeriesTvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesTvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesTvGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesTvGroupByOutputType[P]>
        }
      >
    >


  export type SeriesTvSelect = {
    id?: boolean
    name?: boolean
    actors?: boolean | SeriesTv$actorsArgs
    _count?: boolean | SeriesTvCountOutputTypeArgs
  }


  export type SeriesTvInclude = {
    actors?: boolean | SeriesTv$actorsArgs
    _count?: boolean | SeriesTvCountOutputTypeArgs
  }

  export type SeriesTvGetPayload<S extends boolean | null | undefined | SeriesTvArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SeriesTv :
    S extends undefined ? never :
    S extends { include: any } & (SeriesTvArgs | SeriesTvFindManyArgs)
    ? SeriesTv  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'actors' ? Array < ActorsGetPayload<S['include'][P]>>  :
        P extends '_count' ? SeriesTvCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SeriesTvArgs | SeriesTvFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'actors' ? Array < ActorsGetPayload<S['select'][P]>>  :
        P extends '_count' ? SeriesTvCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SeriesTv ? SeriesTv[P] : never
  } 
      : SeriesTv


  type SeriesTvCountArgs = 
    Omit<SeriesTvFindManyArgs, 'select' | 'include'> & {
      select?: SeriesTvCountAggregateInputType | true
    }

  export interface SeriesTvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SeriesTv that matches the filter.
     * @param {SeriesTvFindUniqueArgs} args - Arguments to find a SeriesTv
     * @example
     * // Get one SeriesTv
     * const seriesTv = await prisma.seriesTv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SeriesTvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SeriesTvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SeriesTv'> extends True ? Prisma__SeriesTvClient<SeriesTvGetPayload<T>> : Prisma__SeriesTvClient<SeriesTvGetPayload<T> | null, null>

    /**
     * Find one SeriesTv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SeriesTvFindUniqueOrThrowArgs} args - Arguments to find a SeriesTv
     * @example
     * // Get one SeriesTv
     * const seriesTv = await prisma.seriesTv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SeriesTvFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SeriesTvFindUniqueOrThrowArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Find the first SeriesTv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvFindFirstArgs} args - Arguments to find a SeriesTv
     * @example
     * // Get one SeriesTv
     * const seriesTv = await prisma.seriesTv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SeriesTvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SeriesTvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SeriesTv'> extends True ? Prisma__SeriesTvClient<SeriesTvGetPayload<T>> : Prisma__SeriesTvClient<SeriesTvGetPayload<T> | null, null>

    /**
     * Find the first SeriesTv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvFindFirstOrThrowArgs} args - Arguments to find a SeriesTv
     * @example
     * // Get one SeriesTv
     * const seriesTv = await prisma.seriesTv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SeriesTvFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SeriesTvFindFirstOrThrowArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Find zero or more SeriesTvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeriesTvs
     * const seriesTvs = await prisma.seriesTv.findMany()
     * 
     * // Get first 10 SeriesTvs
     * const seriesTvs = await prisma.seriesTv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesTvWithIdOnly = await prisma.seriesTv.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SeriesTvFindManyArgs>(
      args?: SelectSubset<T, SeriesTvFindManyArgs>
    ): Prisma.PrismaPromise<Array<SeriesTvGetPayload<T>>>

    /**
     * Create a SeriesTv.
     * @param {SeriesTvCreateArgs} args - Arguments to create a SeriesTv.
     * @example
     * // Create one SeriesTv
     * const SeriesTv = await prisma.seriesTv.create({
     *   data: {
     *     // ... data to create a SeriesTv
     *   }
     * })
     * 
    **/
    create<T extends SeriesTvCreateArgs>(
      args: SelectSubset<T, SeriesTvCreateArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Create many SeriesTvs.
     *     @param {SeriesTvCreateManyArgs} args - Arguments to create many SeriesTvs.
     *     @example
     *     // Create many SeriesTvs
     *     const seriesTv = await prisma.seriesTv.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SeriesTvCreateManyArgs>(
      args?: SelectSubset<T, SeriesTvCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeriesTv.
     * @param {SeriesTvDeleteArgs} args - Arguments to delete one SeriesTv.
     * @example
     * // Delete one SeriesTv
     * const SeriesTv = await prisma.seriesTv.delete({
     *   where: {
     *     // ... filter to delete one SeriesTv
     *   }
     * })
     * 
    **/
    delete<T extends SeriesTvDeleteArgs>(
      args: SelectSubset<T, SeriesTvDeleteArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Update one SeriesTv.
     * @param {SeriesTvUpdateArgs} args - Arguments to update one SeriesTv.
     * @example
     * // Update one SeriesTv
     * const seriesTv = await prisma.seriesTv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SeriesTvUpdateArgs>(
      args: SelectSubset<T, SeriesTvUpdateArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Delete zero or more SeriesTvs.
     * @param {SeriesTvDeleteManyArgs} args - Arguments to filter SeriesTvs to delete.
     * @example
     * // Delete a few SeriesTvs
     * const { count } = await prisma.seriesTv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SeriesTvDeleteManyArgs>(
      args?: SelectSubset<T, SeriesTvDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeriesTvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeriesTvs
     * const seriesTv = await prisma.seriesTv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SeriesTvUpdateManyArgs>(
      args: SelectSubset<T, SeriesTvUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeriesTv.
     * @param {SeriesTvUpsertArgs} args - Arguments to update or create a SeriesTv.
     * @example
     * // Update or create a SeriesTv
     * const seriesTv = await prisma.seriesTv.upsert({
     *   create: {
     *     // ... data to create a SeriesTv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeriesTv we want to update
     *   }
     * })
    **/
    upsert<T extends SeriesTvUpsertArgs>(
      args: SelectSubset<T, SeriesTvUpsertArgs>
    ): Prisma__SeriesTvClient<SeriesTvGetPayload<T>>

    /**
     * Count the number of SeriesTvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvCountArgs} args - Arguments to filter SeriesTvs to count.
     * @example
     * // Count the number of SeriesTvs
     * const count = await prisma.seriesTv.count({
     *   where: {
     *     // ... the filter for the SeriesTvs we want to count
     *   }
     * })
    **/
    count<T extends SeriesTvCountArgs>(
      args?: Subset<T, SeriesTvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesTvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeriesTv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesTvAggregateArgs>(args: Subset<T, SeriesTvAggregateArgs>): Prisma.PrismaPromise<GetSeriesTvAggregateType<T>>

    /**
     * Group by SeriesTv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesTvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesTvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesTvGroupByArgs['orderBy'] }
        : { orderBy?: SeriesTvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesTvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesTvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SeriesTv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SeriesTvClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    actors<T extends SeriesTv$actorsArgs= {}>(args?: Subset<T, SeriesTv$actorsArgs>): Prisma.PrismaPromise<Array<ActorsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SeriesTv base type for findUnique actions
   */
  export type SeriesTvFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter, which SeriesTv to fetch.
     */
    where: SeriesTvWhereUniqueInput
  }

  /**
   * SeriesTv findUnique
   */
  export interface SeriesTvFindUniqueArgs extends SeriesTvFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeriesTv findUniqueOrThrow
   */
  export type SeriesTvFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter, which SeriesTv to fetch.
     */
    where: SeriesTvWhereUniqueInput
  }


  /**
   * SeriesTv base type for findFirst actions
   */
  export type SeriesTvFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter, which SeriesTv to fetch.
     */
    where?: SeriesTvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTvs to fetch.
     */
    orderBy?: Enumerable<SeriesTvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesTvs.
     */
    cursor?: SeriesTvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesTvs.
     */
    distinct?: Enumerable<SeriesTvScalarFieldEnum>
  }

  /**
   * SeriesTv findFirst
   */
  export interface SeriesTvFindFirstArgs extends SeriesTvFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeriesTv findFirstOrThrow
   */
  export type SeriesTvFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter, which SeriesTv to fetch.
     */
    where?: SeriesTvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTvs to fetch.
     */
    orderBy?: Enumerable<SeriesTvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeriesTvs.
     */
    cursor?: SeriesTvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeriesTvs.
     */
    distinct?: Enumerable<SeriesTvScalarFieldEnum>
  }


  /**
   * SeriesTv findMany
   */
  export type SeriesTvFindManyArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter, which SeriesTvs to fetch.
     */
    where?: SeriesTvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeriesTvs to fetch.
     */
    orderBy?: Enumerable<SeriesTvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeriesTvs.
     */
    cursor?: SeriesTvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeriesTvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeriesTvs.
     */
    skip?: number
    distinct?: Enumerable<SeriesTvScalarFieldEnum>
  }


  /**
   * SeriesTv create
   */
  export type SeriesTvCreateArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * The data needed to create a SeriesTv.
     */
    data: XOR<SeriesTvCreateInput, SeriesTvUncheckedCreateInput>
  }


  /**
   * SeriesTv createMany
   */
  export type SeriesTvCreateManyArgs = {
    /**
     * The data used to create many SeriesTvs.
     */
    data: Enumerable<SeriesTvCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SeriesTv update
   */
  export type SeriesTvUpdateArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * The data needed to update a SeriesTv.
     */
    data: XOR<SeriesTvUpdateInput, SeriesTvUncheckedUpdateInput>
    /**
     * Choose, which SeriesTv to update.
     */
    where: SeriesTvWhereUniqueInput
  }


  /**
   * SeriesTv updateMany
   */
  export type SeriesTvUpdateManyArgs = {
    /**
     * The data used to update SeriesTvs.
     */
    data: XOR<SeriesTvUpdateManyMutationInput, SeriesTvUncheckedUpdateManyInput>
    /**
     * Filter which SeriesTvs to update
     */
    where?: SeriesTvWhereInput
  }


  /**
   * SeriesTv upsert
   */
  export type SeriesTvUpsertArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * The filter to search for the SeriesTv to update in case it exists.
     */
    where: SeriesTvWhereUniqueInput
    /**
     * In case the SeriesTv found by the `where` argument doesn't exist, create a new SeriesTv with this data.
     */
    create: XOR<SeriesTvCreateInput, SeriesTvUncheckedCreateInput>
    /**
     * In case the SeriesTv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesTvUpdateInput, SeriesTvUncheckedUpdateInput>
  }


  /**
   * SeriesTv delete
   */
  export type SeriesTvDeleteArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    /**
     * Filter which SeriesTv to delete.
     */
    where: SeriesTvWhereUniqueInput
  }


  /**
   * SeriesTv deleteMany
   */
  export type SeriesTvDeleteManyArgs = {
    /**
     * Filter which SeriesTvs to delete
     */
    where?: SeriesTvWhereInput
  }


  /**
   * SeriesTv.actors
   */
  export type SeriesTv$actorsArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    where?: ActorsWhereInput
    orderBy?: Enumerable<ActorsOrderByWithRelationInput>
    cursor?: ActorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ActorsScalarFieldEnum>
  }


  /**
   * SeriesTv without action
   */
  export type SeriesTvArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
  }



  /**
   * Model Actors
   */


  export type AggregateActors = {
    _count: ActorsCountAggregateOutputType | null
    _avg: ActorsAvgAggregateOutputType | null
    _sum: ActorsSumAggregateOutputType | null
    _min: ActorsMinAggregateOutputType | null
    _max: ActorsMaxAggregateOutputType | null
  }

  export type ActorsAvgAggregateOutputType = {
    id: number | null
  }

  export type ActorsSumAggregateOutputType = {
    id: number | null
  }

  export type ActorsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ActorsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ActorsAvgAggregateInputType = {
    id?: true
  }

  export type ActorsSumAggregateInputType = {
    id?: true
  }

  export type ActorsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActorsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ActorsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ActorsAggregateArgs = {
    /**
     * Filter which Actors to aggregate.
     */
    where?: ActorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: Enumerable<ActorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actors
    **/
    _count?: true | ActorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActorsMaxAggregateInputType
  }

  export type GetActorsAggregateType<T extends ActorsAggregateArgs> = {
        [P in keyof T & keyof AggregateActors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActors[P]>
      : GetScalarType<T[P], AggregateActors[P]>
  }




  export type ActorsGroupByArgs = {
    where?: ActorsWhereInput
    orderBy?: Enumerable<ActorsOrderByWithAggregationInput>
    by: ActorsScalarFieldEnum[]
    having?: ActorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActorsCountAggregateInputType | true
    _avg?: ActorsAvgAggregateInputType
    _sum?: ActorsSumAggregateInputType
    _min?: ActorsMinAggregateInputType
    _max?: ActorsMaxAggregateInputType
  }


  export type ActorsGroupByOutputType = {
    id: number
    name: string
    _count: ActorsCountAggregateOutputType | null
    _avg: ActorsAvgAggregateOutputType | null
    _sum: ActorsSumAggregateOutputType | null
    _min: ActorsMinAggregateOutputType | null
    _max: ActorsMaxAggregateOutputType | null
  }

  type GetActorsGroupByPayload<T extends ActorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ActorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActorsGroupByOutputType[P]>
            : GetScalarType<T[P], ActorsGroupByOutputType[P]>
        }
      >
    >


  export type ActorsSelect = {
    id?: boolean
    name?: boolean
    seriesTv?: boolean | Actors$seriesTvArgs
    _count?: boolean | ActorsCountOutputTypeArgs
  }


  export type ActorsInclude = {
    seriesTv?: boolean | Actors$seriesTvArgs
    _count?: boolean | ActorsCountOutputTypeArgs
  }

  export type ActorsGetPayload<S extends boolean | null | undefined | ActorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Actors :
    S extends undefined ? never :
    S extends { include: any } & (ActorsArgs | ActorsFindManyArgs)
    ? Actors  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'seriesTv' ? Array < SeriesTvGetPayload<S['include'][P]>>  :
        P extends '_count' ? ActorsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ActorsArgs | ActorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'seriesTv' ? Array < SeriesTvGetPayload<S['select'][P]>>  :
        P extends '_count' ? ActorsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Actors ? Actors[P] : never
  } 
      : Actors


  type ActorsCountArgs = 
    Omit<ActorsFindManyArgs, 'select' | 'include'> & {
      select?: ActorsCountAggregateInputType | true
    }

  export interface ActorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Actors that matches the filter.
     * @param {ActorsFindUniqueArgs} args - Arguments to find a Actors
     * @example
     * // Get one Actors
     * const actors = await prisma.actors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Actors'> extends True ? Prisma__ActorsClient<ActorsGetPayload<T>> : Prisma__ActorsClient<ActorsGetPayload<T> | null, null>

    /**
     * Find one Actors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActorsFindUniqueOrThrowArgs} args - Arguments to find a Actors
     * @example
     * // Get one Actors
     * const actors = await prisma.actors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ActorsFindUniqueOrThrowArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Find the first Actors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsFindFirstArgs} args - Arguments to find a Actors
     * @example
     * // Get one Actors
     * const actors = await prisma.actors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Actors'> extends True ? Prisma__ActorsClient<ActorsGetPayload<T>> : Prisma__ActorsClient<ActorsGetPayload<T> | null, null>

    /**
     * Find the first Actors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsFindFirstOrThrowArgs} args - Arguments to find a Actors
     * @example
     * // Get one Actors
     * const actors = await prisma.actors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ActorsFindFirstOrThrowArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Find zero or more Actors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actors
     * const actors = await prisma.actors.findMany()
     * 
     * // Get first 10 Actors
     * const actors = await prisma.actors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actorsWithIdOnly = await prisma.actors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActorsFindManyArgs>(
      args?: SelectSubset<T, ActorsFindManyArgs>
    ): Prisma.PrismaPromise<Array<ActorsGetPayload<T>>>

    /**
     * Create a Actors.
     * @param {ActorsCreateArgs} args - Arguments to create a Actors.
     * @example
     * // Create one Actors
     * const Actors = await prisma.actors.create({
     *   data: {
     *     // ... data to create a Actors
     *   }
     * })
     * 
    **/
    create<T extends ActorsCreateArgs>(
      args: SelectSubset<T, ActorsCreateArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Create many Actors.
     *     @param {ActorsCreateManyArgs} args - Arguments to create many Actors.
     *     @example
     *     // Create many Actors
     *     const actors = await prisma.actors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActorsCreateManyArgs>(
      args?: SelectSubset<T, ActorsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actors.
     * @param {ActorsDeleteArgs} args - Arguments to delete one Actors.
     * @example
     * // Delete one Actors
     * const Actors = await prisma.actors.delete({
     *   where: {
     *     // ... filter to delete one Actors
     *   }
     * })
     * 
    **/
    delete<T extends ActorsDeleteArgs>(
      args: SelectSubset<T, ActorsDeleteArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Update one Actors.
     * @param {ActorsUpdateArgs} args - Arguments to update one Actors.
     * @example
     * // Update one Actors
     * const actors = await prisma.actors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActorsUpdateArgs>(
      args: SelectSubset<T, ActorsUpdateArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Delete zero or more Actors.
     * @param {ActorsDeleteManyArgs} args - Arguments to filter Actors to delete.
     * @example
     * // Delete a few Actors
     * const { count } = await prisma.actors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActorsDeleteManyArgs>(
      args?: SelectSubset<T, ActorsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actors
     * const actors = await prisma.actors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActorsUpdateManyArgs>(
      args: SelectSubset<T, ActorsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actors.
     * @param {ActorsUpsertArgs} args - Arguments to update or create a Actors.
     * @example
     * // Update or create a Actors
     * const actors = await prisma.actors.upsert({
     *   create: {
     *     // ... data to create a Actors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actors we want to update
     *   }
     * })
    **/
    upsert<T extends ActorsUpsertArgs>(
      args: SelectSubset<T, ActorsUpsertArgs>
    ): Prisma__ActorsClient<ActorsGetPayload<T>>

    /**
     * Count the number of Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsCountArgs} args - Arguments to filter Actors to count.
     * @example
     * // Count the number of Actors
     * const count = await prisma.actors.count({
     *   where: {
     *     // ... the filter for the Actors we want to count
     *   }
     * })
    **/
    count<T extends ActorsCountArgs>(
      args?: Subset<T, ActorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActorsAggregateArgs>(args: Subset<T, ActorsAggregateArgs>): Prisma.PrismaPromise<GetActorsAggregateType<T>>

    /**
     * Group by Actors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActorsGroupByArgs['orderBy'] }
        : { orderBy?: ActorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Actors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActorsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    seriesTv<T extends Actors$seriesTvArgs= {}>(args?: Subset<T, Actors$seriesTvArgs>): Prisma.PrismaPromise<Array<SeriesTvGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Actors base type for findUnique actions
   */
  export type ActorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter, which Actors to fetch.
     */
    where: ActorsWhereUniqueInput
  }

  /**
   * Actors findUnique
   */
  export interface ActorsFindUniqueArgs extends ActorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Actors findUniqueOrThrow
   */
  export type ActorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter, which Actors to fetch.
     */
    where: ActorsWhereUniqueInput
  }


  /**
   * Actors base type for findFirst actions
   */
  export type ActorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter, which Actors to fetch.
     */
    where?: ActorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: Enumerable<ActorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: Enumerable<ActorsScalarFieldEnum>
  }

  /**
   * Actors findFirst
   */
  export interface ActorsFindFirstArgs extends ActorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Actors findFirstOrThrow
   */
  export type ActorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter, which Actors to fetch.
     */
    where?: ActorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: Enumerable<ActorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actors.
     */
    cursor?: ActorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actors.
     */
    distinct?: Enumerable<ActorsScalarFieldEnum>
  }


  /**
   * Actors findMany
   */
  export type ActorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter, which Actors to fetch.
     */
    where?: ActorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actors to fetch.
     */
    orderBy?: Enumerable<ActorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actors.
     */
    cursor?: ActorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actors.
     */
    skip?: number
    distinct?: Enumerable<ActorsScalarFieldEnum>
  }


  /**
   * Actors create
   */
  export type ActorsCreateArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * The data needed to create a Actors.
     */
    data: XOR<ActorsCreateInput, ActorsUncheckedCreateInput>
  }


  /**
   * Actors createMany
   */
  export type ActorsCreateManyArgs = {
    /**
     * The data used to create many Actors.
     */
    data: Enumerable<ActorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Actors update
   */
  export type ActorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * The data needed to update a Actors.
     */
    data: XOR<ActorsUpdateInput, ActorsUncheckedUpdateInput>
    /**
     * Choose, which Actors to update.
     */
    where: ActorsWhereUniqueInput
  }


  /**
   * Actors updateMany
   */
  export type ActorsUpdateManyArgs = {
    /**
     * The data used to update Actors.
     */
    data: XOR<ActorsUpdateManyMutationInput, ActorsUncheckedUpdateManyInput>
    /**
     * Filter which Actors to update
     */
    where?: ActorsWhereInput
  }


  /**
   * Actors upsert
   */
  export type ActorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * The filter to search for the Actors to update in case it exists.
     */
    where: ActorsWhereUniqueInput
    /**
     * In case the Actors found by the `where` argument doesn't exist, create a new Actors with this data.
     */
    create: XOR<ActorsCreateInput, ActorsUncheckedCreateInput>
    /**
     * In case the Actors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActorsUpdateInput, ActorsUncheckedUpdateInput>
  }


  /**
   * Actors delete
   */
  export type ActorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
    /**
     * Filter which Actors to delete.
     */
    where: ActorsWhereUniqueInput
  }


  /**
   * Actors deleteMany
   */
  export type ActorsDeleteManyArgs = {
    /**
     * Filter which Actors to delete
     */
    where?: ActorsWhereInput
  }


  /**
   * Actors.seriesTv
   */
  export type Actors$seriesTvArgs = {
    /**
     * Select specific fields to fetch from the SeriesTv
     */
    select?: SeriesTvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeriesTvInclude | null
    where?: SeriesTvWhereInput
    orderBy?: Enumerable<SeriesTvOrderByWithRelationInput>
    cursor?: SeriesTvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeriesTvScalarFieldEnum>
  }


  /**
   * Actors without action
   */
  export type ActorsArgs = {
    /**
     * Select specific fields to fetch from the Actors
     */
    select?: ActorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActorsInclude | null
  }



  /**
   * Model Dew
   */


  export type AggregateDew = {
    _count: DewCountAggregateOutputType | null
    _avg: DewAvgAggregateOutputType | null
    _sum: DewSumAggregateOutputType | null
    _min: DewMinAggregateOutputType | null
    _max: DewMaxAggregateOutputType | null
  }

  export type DewAvgAggregateOutputType = {
    id: number | null
    kadId: number | null
  }

  export type DewSumAggregateOutputType = {
    id: number | null
    kadId: number | null
  }

  export type DewMinAggregateOutputType = {
    id: number | null
    name: string | null
    kadId: number | null
  }

  export type DewMaxAggregateOutputType = {
    id: number | null
    name: string | null
    kadId: number | null
  }

  export type DewCountAggregateOutputType = {
    id: number
    name: number
    kadId: number
    _all: number
  }


  export type DewAvgAggregateInputType = {
    id?: true
    kadId?: true
  }

  export type DewSumAggregateInputType = {
    id?: true
    kadId?: true
  }

  export type DewMinAggregateInputType = {
    id?: true
    name?: true
    kadId?: true
  }

  export type DewMaxAggregateInputType = {
    id?: true
    name?: true
    kadId?: true
  }

  export type DewCountAggregateInputType = {
    id?: true
    name?: true
    kadId?: true
    _all?: true
  }

  export type DewAggregateArgs = {
    /**
     * Filter which Dew to aggregate.
     */
    where?: DewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dews to fetch.
     */
    orderBy?: Enumerable<DewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dews
    **/
    _count?: true | DewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DewMaxAggregateInputType
  }

  export type GetDewAggregateType<T extends DewAggregateArgs> = {
        [P in keyof T & keyof AggregateDew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDew[P]>
      : GetScalarType<T[P], AggregateDew[P]>
  }




  export type DewGroupByArgs = {
    where?: DewWhereInput
    orderBy?: Enumerable<DewOrderByWithAggregationInput>
    by: DewScalarFieldEnum[]
    having?: DewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DewCountAggregateInputType | true
    _avg?: DewAvgAggregateInputType
    _sum?: DewSumAggregateInputType
    _min?: DewMinAggregateInputType
    _max?: DewMaxAggregateInputType
  }


  export type DewGroupByOutputType = {
    id: number
    name: string
    kadId: number
    _count: DewCountAggregateOutputType | null
    _avg: DewAvgAggregateOutputType | null
    _sum: DewSumAggregateOutputType | null
    _min: DewMinAggregateOutputType | null
    _max: DewMaxAggregateOutputType | null
  }

  type GetDewGroupByPayload<T extends DewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DewGroupByOutputType[P]>
            : GetScalarType<T[P], DewGroupByOutputType[P]>
        }
      >
    >


  export type DewSelect = {
    id?: boolean
    name?: boolean
    kad?: boolean | KadArgs
    kadId?: boolean
  }


  export type DewInclude = {
    kad?: boolean | KadArgs
  }

  export type DewGetPayload<S extends boolean | null | undefined | DewArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Dew :
    S extends undefined ? never :
    S extends { include: any } & (DewArgs | DewFindManyArgs)
    ? Dew  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'kad' ? KadGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DewArgs | DewFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'kad' ? KadGetPayload<S['select'][P]> :  P extends keyof Dew ? Dew[P] : never
  } 
      : Dew


  type DewCountArgs = 
    Omit<DewFindManyArgs, 'select' | 'include'> & {
      select?: DewCountAggregateInputType | true
    }

  export interface DewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Dew that matches the filter.
     * @param {DewFindUniqueArgs} args - Arguments to find a Dew
     * @example
     * // Get one Dew
     * const dew = await prisma.dew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dew'> extends True ? Prisma__DewClient<DewGetPayload<T>> : Prisma__DewClient<DewGetPayload<T> | null, null>

    /**
     * Find one Dew that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DewFindUniqueOrThrowArgs} args - Arguments to find a Dew
     * @example
     * // Get one Dew
     * const dew = await prisma.dew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DewFindUniqueOrThrowArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Find the first Dew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewFindFirstArgs} args - Arguments to find a Dew
     * @example
     * // Get one Dew
     * const dew = await prisma.dew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dew'> extends True ? Prisma__DewClient<DewGetPayload<T>> : Prisma__DewClient<DewGetPayload<T> | null, null>

    /**
     * Find the first Dew that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewFindFirstOrThrowArgs} args - Arguments to find a Dew
     * @example
     * // Get one Dew
     * const dew = await prisma.dew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DewFindFirstOrThrowArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Find zero or more Dews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dews
     * const dews = await prisma.dew.findMany()
     * 
     * // Get first 10 Dews
     * const dews = await prisma.dew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dewWithIdOnly = await prisma.dew.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DewFindManyArgs>(
      args?: SelectSubset<T, DewFindManyArgs>
    ): Prisma.PrismaPromise<Array<DewGetPayload<T>>>

    /**
     * Create a Dew.
     * @param {DewCreateArgs} args - Arguments to create a Dew.
     * @example
     * // Create one Dew
     * const Dew = await prisma.dew.create({
     *   data: {
     *     // ... data to create a Dew
     *   }
     * })
     * 
    **/
    create<T extends DewCreateArgs>(
      args: SelectSubset<T, DewCreateArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Create many Dews.
     *     @param {DewCreateManyArgs} args - Arguments to create many Dews.
     *     @example
     *     // Create many Dews
     *     const dew = await prisma.dew.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DewCreateManyArgs>(
      args?: SelectSubset<T, DewCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dew.
     * @param {DewDeleteArgs} args - Arguments to delete one Dew.
     * @example
     * // Delete one Dew
     * const Dew = await prisma.dew.delete({
     *   where: {
     *     // ... filter to delete one Dew
     *   }
     * })
     * 
    **/
    delete<T extends DewDeleteArgs>(
      args: SelectSubset<T, DewDeleteArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Update one Dew.
     * @param {DewUpdateArgs} args - Arguments to update one Dew.
     * @example
     * // Update one Dew
     * const dew = await prisma.dew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DewUpdateArgs>(
      args: SelectSubset<T, DewUpdateArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Delete zero or more Dews.
     * @param {DewDeleteManyArgs} args - Arguments to filter Dews to delete.
     * @example
     * // Delete a few Dews
     * const { count } = await prisma.dew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DewDeleteManyArgs>(
      args?: SelectSubset<T, DewDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dews
     * const dew = await prisma.dew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DewUpdateManyArgs>(
      args: SelectSubset<T, DewUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dew.
     * @param {DewUpsertArgs} args - Arguments to update or create a Dew.
     * @example
     * // Update or create a Dew
     * const dew = await prisma.dew.upsert({
     *   create: {
     *     // ... data to create a Dew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dew we want to update
     *   }
     * })
    **/
    upsert<T extends DewUpsertArgs>(
      args: SelectSubset<T, DewUpsertArgs>
    ): Prisma__DewClient<DewGetPayload<T>>

    /**
     * Count the number of Dews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewCountArgs} args - Arguments to filter Dews to count.
     * @example
     * // Count the number of Dews
     * const count = await prisma.dew.count({
     *   where: {
     *     // ... the filter for the Dews we want to count
     *   }
     * })
    **/
    count<T extends DewCountArgs>(
      args?: Subset<T, DewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DewAggregateArgs>(args: Subset<T, DewAggregateArgs>): Prisma.PrismaPromise<GetDewAggregateType<T>>

    /**
     * Group by Dew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DewGroupByArgs['orderBy'] }
        : { orderBy?: DewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DewClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kad<T extends KadArgs= {}>(args?: Subset<T, KadArgs>): Prisma__KadClient<KadGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dew base type for findUnique actions
   */
  export type DewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter, which Dew to fetch.
     */
    where: DewWhereUniqueInput
  }

  /**
   * Dew findUnique
   */
  export interface DewFindUniqueArgs extends DewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dew findUniqueOrThrow
   */
  export type DewFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter, which Dew to fetch.
     */
    where: DewWhereUniqueInput
  }


  /**
   * Dew base type for findFirst actions
   */
  export type DewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter, which Dew to fetch.
     */
    where?: DewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dews to fetch.
     */
    orderBy?: Enumerable<DewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dews.
     */
    cursor?: DewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dews.
     */
    distinct?: Enumerable<DewScalarFieldEnum>
  }

  /**
   * Dew findFirst
   */
  export interface DewFindFirstArgs extends DewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dew findFirstOrThrow
   */
  export type DewFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter, which Dew to fetch.
     */
    where?: DewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dews to fetch.
     */
    orderBy?: Enumerable<DewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dews.
     */
    cursor?: DewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dews.
     */
    distinct?: Enumerable<DewScalarFieldEnum>
  }


  /**
   * Dew findMany
   */
  export type DewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter, which Dews to fetch.
     */
    where?: DewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dews to fetch.
     */
    orderBy?: Enumerable<DewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dews.
     */
    cursor?: DewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dews.
     */
    skip?: number
    distinct?: Enumerable<DewScalarFieldEnum>
  }


  /**
   * Dew create
   */
  export type DewCreateArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * The data needed to create a Dew.
     */
    data: XOR<DewCreateInput, DewUncheckedCreateInput>
  }


  /**
   * Dew createMany
   */
  export type DewCreateManyArgs = {
    /**
     * The data used to create many Dews.
     */
    data: Enumerable<DewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Dew update
   */
  export type DewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * The data needed to update a Dew.
     */
    data: XOR<DewUpdateInput, DewUncheckedUpdateInput>
    /**
     * Choose, which Dew to update.
     */
    where: DewWhereUniqueInput
  }


  /**
   * Dew updateMany
   */
  export type DewUpdateManyArgs = {
    /**
     * The data used to update Dews.
     */
    data: XOR<DewUpdateManyMutationInput, DewUncheckedUpdateManyInput>
    /**
     * Filter which Dews to update
     */
    where?: DewWhereInput
  }


  /**
   * Dew upsert
   */
  export type DewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * The filter to search for the Dew to update in case it exists.
     */
    where: DewWhereUniqueInput
    /**
     * In case the Dew found by the `where` argument doesn't exist, create a new Dew with this data.
     */
    create: XOR<DewCreateInput, DewUncheckedCreateInput>
    /**
     * In case the Dew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DewUpdateInput, DewUncheckedUpdateInput>
  }


  /**
   * Dew delete
   */
  export type DewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
    /**
     * Filter which Dew to delete.
     */
    where: DewWhereUniqueInput
  }


  /**
   * Dew deleteMany
   */
  export type DewDeleteManyArgs = {
    /**
     * Filter which Dews to delete
     */
    where?: DewWhereInput
  }


  /**
   * Dew without action
   */
  export type DewArgs = {
    /**
     * Select specific fields to fetch from the Dew
     */
    select?: DewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DewInclude | null
  }



  /**
   * Model Kad
   */


  export type AggregateKad = {
    _count: KadCountAggregateOutputType | null
    _avg: KadAvgAggregateOutputType | null
    _sum: KadSumAggregateOutputType | null
    _min: KadMinAggregateOutputType | null
    _max: KadMaxAggregateOutputType | null
  }

  export type KadAvgAggregateOutputType = {
    id: number | null
  }

  export type KadSumAggregateOutputType = {
    id: number | null
  }

  export type KadMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type KadMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type KadCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type KadAvgAggregateInputType = {
    id?: true
  }

  export type KadSumAggregateInputType = {
    id?: true
  }

  export type KadMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type KadMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type KadCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type KadAggregateArgs = {
    /**
     * Filter which Kad to aggregate.
     */
    where?: KadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kads to fetch.
     */
    orderBy?: Enumerable<KadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kads
    **/
    _count?: true | KadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KadMaxAggregateInputType
  }

  export type GetKadAggregateType<T extends KadAggregateArgs> = {
        [P in keyof T & keyof AggregateKad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKad[P]>
      : GetScalarType<T[P], AggregateKad[P]>
  }




  export type KadGroupByArgs = {
    where?: KadWhereInput
    orderBy?: Enumerable<KadOrderByWithAggregationInput>
    by: KadScalarFieldEnum[]
    having?: KadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KadCountAggregateInputType | true
    _avg?: KadAvgAggregateInputType
    _sum?: KadSumAggregateInputType
    _min?: KadMinAggregateInputType
    _max?: KadMaxAggregateInputType
  }


  export type KadGroupByOutputType = {
    id: number
    name: string
    _count: KadCountAggregateOutputType | null
    _avg: KadAvgAggregateOutputType | null
    _sum: KadSumAggregateOutputType | null
    _min: KadMinAggregateOutputType | null
    _max: KadMaxAggregateOutputType | null
  }

  type GetKadGroupByPayload<T extends KadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KadGroupByOutputType[P]>
            : GetScalarType<T[P], KadGroupByOutputType[P]>
        }
      >
    >


  export type KadSelect = {
    id?: boolean
    name?: boolean
    Dew?: boolean | DewArgs
  }


  export type KadInclude = {
    Dew?: boolean | DewArgs
  }

  export type KadGetPayload<S extends boolean | null | undefined | KadArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Kad :
    S extends undefined ? never :
    S extends { include: any } & (KadArgs | KadFindManyArgs)
    ? Kad  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Dew' ? DewGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (KadArgs | KadFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Dew' ? DewGetPayload<S['select'][P]> | null :  P extends keyof Kad ? Kad[P] : never
  } 
      : Kad


  type KadCountArgs = 
    Omit<KadFindManyArgs, 'select' | 'include'> & {
      select?: KadCountAggregateInputType | true
    }

  export interface KadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Kad that matches the filter.
     * @param {KadFindUniqueArgs} args - Arguments to find a Kad
     * @example
     * // Get one Kad
     * const kad = await prisma.kad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Kad'> extends True ? Prisma__KadClient<KadGetPayload<T>> : Prisma__KadClient<KadGetPayload<T> | null, null>

    /**
     * Find one Kad that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KadFindUniqueOrThrowArgs} args - Arguments to find a Kad
     * @example
     * // Get one Kad
     * const kad = await prisma.kad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KadFindUniqueOrThrowArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Find the first Kad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadFindFirstArgs} args - Arguments to find a Kad
     * @example
     * // Get one Kad
     * const kad = await prisma.kad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Kad'> extends True ? Prisma__KadClient<KadGetPayload<T>> : Prisma__KadClient<KadGetPayload<T> | null, null>

    /**
     * Find the first Kad that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadFindFirstOrThrowArgs} args - Arguments to find a Kad
     * @example
     * // Get one Kad
     * const kad = await prisma.kad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KadFindFirstOrThrowArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Find zero or more Kads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kads
     * const kads = await prisma.kad.findMany()
     * 
     * // Get first 10 Kads
     * const kads = await prisma.kad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kadWithIdOnly = await prisma.kad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KadFindManyArgs>(
      args?: SelectSubset<T, KadFindManyArgs>
    ): Prisma.PrismaPromise<Array<KadGetPayload<T>>>

    /**
     * Create a Kad.
     * @param {KadCreateArgs} args - Arguments to create a Kad.
     * @example
     * // Create one Kad
     * const Kad = await prisma.kad.create({
     *   data: {
     *     // ... data to create a Kad
     *   }
     * })
     * 
    **/
    create<T extends KadCreateArgs>(
      args: SelectSubset<T, KadCreateArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Create many Kads.
     *     @param {KadCreateManyArgs} args - Arguments to create many Kads.
     *     @example
     *     // Create many Kads
     *     const kad = await prisma.kad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KadCreateManyArgs>(
      args?: SelectSubset<T, KadCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kad.
     * @param {KadDeleteArgs} args - Arguments to delete one Kad.
     * @example
     * // Delete one Kad
     * const Kad = await prisma.kad.delete({
     *   where: {
     *     // ... filter to delete one Kad
     *   }
     * })
     * 
    **/
    delete<T extends KadDeleteArgs>(
      args: SelectSubset<T, KadDeleteArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Update one Kad.
     * @param {KadUpdateArgs} args - Arguments to update one Kad.
     * @example
     * // Update one Kad
     * const kad = await prisma.kad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KadUpdateArgs>(
      args: SelectSubset<T, KadUpdateArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Delete zero or more Kads.
     * @param {KadDeleteManyArgs} args - Arguments to filter Kads to delete.
     * @example
     * // Delete a few Kads
     * const { count } = await prisma.kad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KadDeleteManyArgs>(
      args?: SelectSubset<T, KadDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kads
     * const kad = await prisma.kad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KadUpdateManyArgs>(
      args: SelectSubset<T, KadUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kad.
     * @param {KadUpsertArgs} args - Arguments to update or create a Kad.
     * @example
     * // Update or create a Kad
     * const kad = await prisma.kad.upsert({
     *   create: {
     *     // ... data to create a Kad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kad we want to update
     *   }
     * })
    **/
    upsert<T extends KadUpsertArgs>(
      args: SelectSubset<T, KadUpsertArgs>
    ): Prisma__KadClient<KadGetPayload<T>>

    /**
     * Count the number of Kads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadCountArgs} args - Arguments to filter Kads to count.
     * @example
     * // Count the number of Kads
     * const count = await prisma.kad.count({
     *   where: {
     *     // ... the filter for the Kads we want to count
     *   }
     * })
    **/
    count<T extends KadCountArgs>(
      args?: Subset<T, KadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KadAggregateArgs>(args: Subset<T, KadAggregateArgs>): Prisma.PrismaPromise<GetKadAggregateType<T>>

    /**
     * Group by Kad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KadGroupByArgs['orderBy'] }
        : { orderBy?: KadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Kad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KadClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Dew<T extends DewArgs= {}>(args?: Subset<T, DewArgs>): Prisma__DewClient<DewGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Kad base type for findUnique actions
   */
  export type KadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter, which Kad to fetch.
     */
    where: KadWhereUniqueInput
  }

  /**
   * Kad findUnique
   */
  export interface KadFindUniqueArgs extends KadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Kad findUniqueOrThrow
   */
  export type KadFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter, which Kad to fetch.
     */
    where: KadWhereUniqueInput
  }


  /**
   * Kad base type for findFirst actions
   */
  export type KadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter, which Kad to fetch.
     */
    where?: KadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kads to fetch.
     */
    orderBy?: Enumerable<KadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kads.
     */
    cursor?: KadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kads.
     */
    distinct?: Enumerable<KadScalarFieldEnum>
  }

  /**
   * Kad findFirst
   */
  export interface KadFindFirstArgs extends KadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Kad findFirstOrThrow
   */
  export type KadFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter, which Kad to fetch.
     */
    where?: KadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kads to fetch.
     */
    orderBy?: Enumerable<KadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kads.
     */
    cursor?: KadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kads.
     */
    distinct?: Enumerable<KadScalarFieldEnum>
  }


  /**
   * Kad findMany
   */
  export type KadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter, which Kads to fetch.
     */
    where?: KadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kads to fetch.
     */
    orderBy?: Enumerable<KadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kads.
     */
    cursor?: KadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kads.
     */
    skip?: number
    distinct?: Enumerable<KadScalarFieldEnum>
  }


  /**
   * Kad create
   */
  export type KadCreateArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * The data needed to create a Kad.
     */
    data: XOR<KadCreateInput, KadUncheckedCreateInput>
  }


  /**
   * Kad createMany
   */
  export type KadCreateManyArgs = {
    /**
     * The data used to create many Kads.
     */
    data: Enumerable<KadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Kad update
   */
  export type KadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * The data needed to update a Kad.
     */
    data: XOR<KadUpdateInput, KadUncheckedUpdateInput>
    /**
     * Choose, which Kad to update.
     */
    where: KadWhereUniqueInput
  }


  /**
   * Kad updateMany
   */
  export type KadUpdateManyArgs = {
    /**
     * The data used to update Kads.
     */
    data: XOR<KadUpdateManyMutationInput, KadUncheckedUpdateManyInput>
    /**
     * Filter which Kads to update
     */
    where?: KadWhereInput
  }


  /**
   * Kad upsert
   */
  export type KadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * The filter to search for the Kad to update in case it exists.
     */
    where: KadWhereUniqueInput
    /**
     * In case the Kad found by the `where` argument doesn't exist, create a new Kad with this data.
     */
    create: XOR<KadCreateInput, KadUncheckedCreateInput>
    /**
     * In case the Kad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KadUpdateInput, KadUncheckedUpdateInput>
  }


  /**
   * Kad delete
   */
  export type KadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
    /**
     * Filter which Kad to delete.
     */
    where: KadWhereUniqueInput
  }


  /**
   * Kad deleteMany
   */
  export type KadDeleteManyArgs = {
    /**
     * Filter which Kads to delete
     */
    where?: KadWhereInput
  }


  /**
   * Kad without action
   */
  export type KadArgs = {
    /**
     * Select specific fields to fetch from the Kad
     */
    select?: KadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KadInclude | null
  }



  /**
   * Model QuizeTable
   */


  export type AggregateQuizeTable = {
    _count: QuizeTableCountAggregateOutputType | null
    _avg: QuizeTableAvgAggregateOutputType | null
    _sum: QuizeTableSumAggregateOutputType | null
    _min: QuizeTableMinAggregateOutputType | null
    _max: QuizeTableMaxAggregateOutputType | null
  }

  export type QuizeTableAvgAggregateOutputType = {
    id: number | null
    idQuestion: number | null
  }

  export type QuizeTableSumAggregateOutputType = {
    id: number | null
    idQuestion: number | null
  }

  export type QuizeTableMinAggregateOutputType = {
    id: number | null
    idQuestion: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeTableMaxAggregateOutputType = {
    id: number | null
    idQuestion: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeTableCountAggregateOutputType = {
    id: number
    idQuestion: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuizeTableAvgAggregateInputType = {
    id?: true
    idQuestion?: true
  }

  export type QuizeTableSumAggregateInputType = {
    id?: true
    idQuestion?: true
  }

  export type QuizeTableMinAggregateInputType = {
    id?: true
    idQuestion?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeTableMaxAggregateInputType = {
    id?: true
    idQuestion?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeTableCountAggregateInputType = {
    id?: true
    idQuestion?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuizeTableAggregateArgs = {
    /**
     * Filter which QuizeTable to aggregate.
     */
    where?: QuizeTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeTables to fetch.
     */
    orderBy?: Enumerable<QuizeTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeTables
    **/
    _count?: true | QuizeTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeTableMaxAggregateInputType
  }

  export type GetQuizeTableAggregateType<T extends QuizeTableAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeTable[P]>
      : GetScalarType<T[P], AggregateQuizeTable[P]>
  }




  export type QuizeTableGroupByArgs = {
    where?: QuizeTableWhereInput
    orderBy?: Enumerable<QuizeTableOrderByWithAggregationInput>
    by: QuizeTableScalarFieldEnum[]
    having?: QuizeTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeTableCountAggregateInputType | true
    _avg?: QuizeTableAvgAggregateInputType
    _sum?: QuizeTableSumAggregateInputType
    _min?: QuizeTableMinAggregateInputType
    _max?: QuizeTableMaxAggregateInputType
  }


  export type QuizeTableGroupByOutputType = {
    id: number
    idQuestion: number
    createAt: Date
    updateAt: Date
    _count: QuizeTableCountAggregateOutputType | null
    _avg: QuizeTableAvgAggregateOutputType | null
    _sum: QuizeTableSumAggregateOutputType | null
    _min: QuizeTableMinAggregateOutputType | null
    _max: QuizeTableMaxAggregateOutputType | null
  }

  type GetQuizeTableGroupByPayload<T extends QuizeTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeTableGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeTableGroupByOutputType[P]>
        }
      >
    >


  export type QuizeTableSelect = {
    id?: boolean
    idQuestion?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type QuizeTableGetPayload<S extends boolean | null | undefined | QuizeTableArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeTable :
    S extends undefined ? never :
    S extends { include: any } & (QuizeTableArgs | QuizeTableFindManyArgs)
    ? QuizeTable 
    : S extends { select: any } & (QuizeTableArgs | QuizeTableFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizeTable ? QuizeTable[P] : never
  } 
      : QuizeTable


  type QuizeTableCountArgs = 
    Omit<QuizeTableFindManyArgs, 'select' | 'include'> & {
      select?: QuizeTableCountAggregateInputType | true
    }

  export interface QuizeTableDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeTable that matches the filter.
     * @param {QuizeTableFindUniqueArgs} args - Arguments to find a QuizeTable
     * @example
     * // Get one QuizeTable
     * const quizeTable = await prisma.quizeTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeTableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeTableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeTable'> extends True ? Prisma__QuizeTableClient<QuizeTableGetPayload<T>> : Prisma__QuizeTableClient<QuizeTableGetPayload<T> | null, null>

    /**
     * Find one QuizeTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeTableFindUniqueOrThrowArgs} args - Arguments to find a QuizeTable
     * @example
     * // Get one QuizeTable
     * const quizeTable = await prisma.quizeTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeTableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeTableFindUniqueOrThrowArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Find the first QuizeTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableFindFirstArgs} args - Arguments to find a QuizeTable
     * @example
     * // Get one QuizeTable
     * const quizeTable = await prisma.quizeTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeTableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeTableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeTable'> extends True ? Prisma__QuizeTableClient<QuizeTableGetPayload<T>> : Prisma__QuizeTableClient<QuizeTableGetPayload<T> | null, null>

    /**
     * Find the first QuizeTable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableFindFirstOrThrowArgs} args - Arguments to find a QuizeTable
     * @example
     * // Get one QuizeTable
     * const quizeTable = await prisma.quizeTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeTableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeTableFindFirstOrThrowArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Find zero or more QuizeTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeTables
     * const quizeTables = await prisma.quizeTable.findMany()
     * 
     * // Get first 10 QuizeTables
     * const quizeTables = await prisma.quizeTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeTableWithIdOnly = await prisma.quizeTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeTableFindManyArgs>(
      args?: SelectSubset<T, QuizeTableFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeTableGetPayload<T>>>

    /**
     * Create a QuizeTable.
     * @param {QuizeTableCreateArgs} args - Arguments to create a QuizeTable.
     * @example
     * // Create one QuizeTable
     * const QuizeTable = await prisma.quizeTable.create({
     *   data: {
     *     // ... data to create a QuizeTable
     *   }
     * })
     * 
    **/
    create<T extends QuizeTableCreateArgs>(
      args: SelectSubset<T, QuizeTableCreateArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Create many QuizeTables.
     *     @param {QuizeTableCreateManyArgs} args - Arguments to create many QuizeTables.
     *     @example
     *     // Create many QuizeTables
     *     const quizeTable = await prisma.quizeTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeTableCreateManyArgs>(
      args?: SelectSubset<T, QuizeTableCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeTable.
     * @param {QuizeTableDeleteArgs} args - Arguments to delete one QuizeTable.
     * @example
     * // Delete one QuizeTable
     * const QuizeTable = await prisma.quizeTable.delete({
     *   where: {
     *     // ... filter to delete one QuizeTable
     *   }
     * })
     * 
    **/
    delete<T extends QuizeTableDeleteArgs>(
      args: SelectSubset<T, QuizeTableDeleteArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Update one QuizeTable.
     * @param {QuizeTableUpdateArgs} args - Arguments to update one QuizeTable.
     * @example
     * // Update one QuizeTable
     * const quizeTable = await prisma.quizeTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeTableUpdateArgs>(
      args: SelectSubset<T, QuizeTableUpdateArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Delete zero or more QuizeTables.
     * @param {QuizeTableDeleteManyArgs} args - Arguments to filter QuizeTables to delete.
     * @example
     * // Delete a few QuizeTables
     * const { count } = await prisma.quizeTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeTableDeleteManyArgs>(
      args?: SelectSubset<T, QuizeTableDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeTables
     * const quizeTable = await prisma.quizeTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeTableUpdateManyArgs>(
      args: SelectSubset<T, QuizeTableUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeTable.
     * @param {QuizeTableUpsertArgs} args - Arguments to update or create a QuizeTable.
     * @example
     * // Update or create a QuizeTable
     * const quizeTable = await prisma.quizeTable.upsert({
     *   create: {
     *     // ... data to create a QuizeTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeTable we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeTableUpsertArgs>(
      args: SelectSubset<T, QuizeTableUpsertArgs>
    ): Prisma__QuizeTableClient<QuizeTableGetPayload<T>>

    /**
     * Count the number of QuizeTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableCountArgs} args - Arguments to filter QuizeTables to count.
     * @example
     * // Count the number of QuizeTables
     * const count = await prisma.quizeTable.count({
     *   where: {
     *     // ... the filter for the QuizeTables we want to count
     *   }
     * })
    **/
    count<T extends QuizeTableCountArgs>(
      args?: Subset<T, QuizeTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeTableAggregateArgs>(args: Subset<T, QuizeTableAggregateArgs>): Prisma.PrismaPromise<GetQuizeTableAggregateType<T>>

    /**
     * Group by QuizeTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeTableGroupByArgs['orderBy'] }
        : { orderBy?: QuizeTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeTableClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeTable base type for findUnique actions
   */
  export type QuizeTableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter, which QuizeTable to fetch.
     */
    where: QuizeTableWhereUniqueInput
  }

  /**
   * QuizeTable findUnique
   */
  export interface QuizeTableFindUniqueArgs extends QuizeTableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeTable findUniqueOrThrow
   */
  export type QuizeTableFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter, which QuizeTable to fetch.
     */
    where: QuizeTableWhereUniqueInput
  }


  /**
   * QuizeTable base type for findFirst actions
   */
  export type QuizeTableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter, which QuizeTable to fetch.
     */
    where?: QuizeTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeTables to fetch.
     */
    orderBy?: Enumerable<QuizeTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeTables.
     */
    cursor?: QuizeTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeTables.
     */
    distinct?: Enumerable<QuizeTableScalarFieldEnum>
  }

  /**
   * QuizeTable findFirst
   */
  export interface QuizeTableFindFirstArgs extends QuizeTableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeTable findFirstOrThrow
   */
  export type QuizeTableFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter, which QuizeTable to fetch.
     */
    where?: QuizeTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeTables to fetch.
     */
    orderBy?: Enumerable<QuizeTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeTables.
     */
    cursor?: QuizeTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeTables.
     */
    distinct?: Enumerable<QuizeTableScalarFieldEnum>
  }


  /**
   * QuizeTable findMany
   */
  export type QuizeTableFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter, which QuizeTables to fetch.
     */
    where?: QuizeTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeTables to fetch.
     */
    orderBy?: Enumerable<QuizeTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeTables.
     */
    cursor?: QuizeTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeTables.
     */
    skip?: number
    distinct?: Enumerable<QuizeTableScalarFieldEnum>
  }


  /**
   * QuizeTable create
   */
  export type QuizeTableCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * The data needed to create a QuizeTable.
     */
    data: XOR<QuizeTableCreateInput, QuizeTableUncheckedCreateInput>
  }


  /**
   * QuizeTable createMany
   */
  export type QuizeTableCreateManyArgs = {
    /**
     * The data used to create many QuizeTables.
     */
    data: Enumerable<QuizeTableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeTable update
   */
  export type QuizeTableUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * The data needed to update a QuizeTable.
     */
    data: XOR<QuizeTableUpdateInput, QuizeTableUncheckedUpdateInput>
    /**
     * Choose, which QuizeTable to update.
     */
    where: QuizeTableWhereUniqueInput
  }


  /**
   * QuizeTable updateMany
   */
  export type QuizeTableUpdateManyArgs = {
    /**
     * The data used to update QuizeTables.
     */
    data: XOR<QuizeTableUpdateManyMutationInput, QuizeTableUncheckedUpdateManyInput>
    /**
     * Filter which QuizeTables to update
     */
    where?: QuizeTableWhereInput
  }


  /**
   * QuizeTable upsert
   */
  export type QuizeTableUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * The filter to search for the QuizeTable to update in case it exists.
     */
    where: QuizeTableWhereUniqueInput
    /**
     * In case the QuizeTable found by the `where` argument doesn't exist, create a new QuizeTable with this data.
     */
    create: XOR<QuizeTableCreateInput, QuizeTableUncheckedCreateInput>
    /**
     * In case the QuizeTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeTableUpdateInput, QuizeTableUncheckedUpdateInput>
  }


  /**
   * QuizeTable delete
   */
  export type QuizeTableDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
    /**
     * Filter which QuizeTable to delete.
     */
    where: QuizeTableWhereUniqueInput
  }


  /**
   * QuizeTable deleteMany
   */
  export type QuizeTableDeleteManyArgs = {
    /**
     * Filter which QuizeTables to delete
     */
    where?: QuizeTableWhereInput
  }


  /**
   * QuizeTable without action
   */
  export type QuizeTableArgs = {
    /**
     * Select specific fields to fetch from the QuizeTable
     */
    select?: QuizeTableSelect | null
  }



  /**
   * Model Question
   */


  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    idCategory: number | null
    idAnswer: number | null
    idQuize: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    idCategory: number | null
    idAnswer: number | null
    idQuize: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    idCategory: number | null
    idAnswer: number | null
    idQuize: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    question: string | null
    answer: string | null
    idCategory: number | null
    idAnswer: number | null
    idQuize: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    idCategory: number
    idAnswer: number
    idQuize: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    idCategory?: true
    idAnswer?: true
    idQuize?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    idCategory?: true
    idAnswer?: true
    idQuize?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    idCategory?: true
    idAnswer?: true
    idQuize?: true
    createAt?: true
    updateAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    idCategory?: true
    idAnswer?: true
    idQuize?: true
    createAt?: true
    updateAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    idCategory?: true
    idAnswer?: true
    idQuize?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs = {
    where?: QuestionWhereInput
    orderBy?: Enumerable<QuestionOrderByWithAggregationInput>
    by: QuestionScalarFieldEnum[]
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }


  export type QuestionGroupByOutputType = {
    id: number
    question: string
    answer: string
    idCategory: number
    idAnswer: number
    idQuize: number
    createAt: Date
    updateAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect = {
    id?: boolean
    question?: boolean
    answer?: boolean
    idCategory?: boolean
    idAnswer?: boolean
    idQuize?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type QuestionGetPayload<S extends boolean | null | undefined | QuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Question :
    S extends undefined ? never :
    S extends { include: any } & (QuestionArgs | QuestionFindManyArgs)
    ? Question 
    : S extends { select: any } & (QuestionArgs | QuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Question ? Question[P] : never
  } 
      : Question


  type QuestionCountArgs = 
    Omit<QuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Question'> extends True ? Prisma__QuestionClient<QuestionGetPayload<T>> : Prisma__QuestionClient<QuestionGetPayload<T> | null, null>

    /**
     * Find one Question that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionFindUniqueOrThrowArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Question'> extends True ? Prisma__QuestionClient<QuestionGetPayload<T>> : Prisma__QuestionClient<QuestionGetPayload<T> | null, null>

    /**
     * Find the first Question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionFindFirstOrThrowArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionFindManyArgs>(
      args?: SelectSubset<T, QuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuestionGetPayload<T>>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
    **/
    create<T extends QuestionCreateArgs>(
      args: SelectSubset<T, QuestionCreateArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Create many Questions.
     *     @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     *     @example
     *     // Create many Questions
     *     const question = await prisma.question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionCreateManyArgs>(
      args?: SelectSubset<T, QuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
    **/
    delete<T extends QuestionDeleteArgs>(
      args: SelectSubset<T, QuestionDeleteArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionUpdateArgs>(
      args: SelectSubset<T, QuestionUpdateArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionUpdateManyArgs>(
      args: SelectSubset<T, QuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionUpsertArgs>(
      args: SelectSubset<T, QuestionUpsertArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Question base type for findUnique actions
   */
  export type QuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUnique
   */
  export interface QuestionFindUniqueArgs extends QuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }


  /**
   * Question base type for findFirst actions
   */
  export type QuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }

  /**
   * Question findFirst
   */
  export interface QuestionFindFirstArgs extends QuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question findMany
   */
  export type QuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question create
   */
  export type QuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }


  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs = {
    /**
     * The data used to create many Questions.
     */
    data: Enumerable<QuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Question update
   */
  export type QuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }


  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }


  /**
   * Question upsert
   */
  export type QuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }


  /**
   * Question delete
   */
  export type QuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }


  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }


  /**
   * Question without action
   */
  export type QuestionArgs = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    name: string
    createAt: Date
    updateAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    name?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
  }



  /**
   * Model roundTable
   */


  export type AggregateRoundTable = {
    _count: RoundTableCountAggregateOutputType | null
    _avg: RoundTableAvgAggregateOutputType | null
    _sum: RoundTableSumAggregateOutputType | null
    _min: RoundTableMinAggregateOutputType | null
    _max: RoundTableMaxAggregateOutputType | null
  }

  export type RoundTableAvgAggregateOutputType = {
    id: number | null
    score: number | null
    categoryId: number | null
  }

  export type RoundTableSumAggregateOutputType = {
    id: number | null
    score: number | null
    categoryId: number | null
  }

  export type RoundTableMinAggregateOutputType = {
    id: number | null
    score: number | null
    categoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RoundTableMaxAggregateOutputType = {
    id: number | null
    score: number | null
    categoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RoundTableCountAggregateOutputType = {
    id: number
    score: number
    categoryId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type RoundTableAvgAggregateInputType = {
    id?: true
    score?: true
    categoryId?: true
  }

  export type RoundTableSumAggregateInputType = {
    id?: true
    score?: true
    categoryId?: true
  }

  export type RoundTableMinAggregateInputType = {
    id?: true
    score?: true
    categoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type RoundTableMaxAggregateInputType = {
    id?: true
    score?: true
    categoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type RoundTableCountAggregateInputType = {
    id?: true
    score?: true
    categoryId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type RoundTableAggregateArgs = {
    /**
     * Filter which roundTable to aggregate.
     */
    where?: roundTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundTables to fetch.
     */
    orderBy?: Enumerable<roundTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roundTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roundTables
    **/
    _count?: true | RoundTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundTableMaxAggregateInputType
  }

  export type GetRoundTableAggregateType<T extends RoundTableAggregateArgs> = {
        [P in keyof T & keyof AggregateRoundTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoundTable[P]>
      : GetScalarType<T[P], AggregateRoundTable[P]>
  }




  export type RoundTableGroupByArgs = {
    where?: roundTableWhereInput
    orderBy?: Enumerable<roundTableOrderByWithAggregationInput>
    by: RoundTableScalarFieldEnum[]
    having?: roundTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundTableCountAggregateInputType | true
    _avg?: RoundTableAvgAggregateInputType
    _sum?: RoundTableSumAggregateInputType
    _min?: RoundTableMinAggregateInputType
    _max?: RoundTableMaxAggregateInputType
  }


  export type RoundTableGroupByOutputType = {
    id: number
    score: number
    categoryId: number
    createAt: Date
    updateAt: Date
    _count: RoundTableCountAggregateOutputType | null
    _avg: RoundTableAvgAggregateOutputType | null
    _sum: RoundTableSumAggregateOutputType | null
    _min: RoundTableMinAggregateOutputType | null
    _max: RoundTableMaxAggregateOutputType | null
  }

  type GetRoundTableGroupByPayload<T extends RoundTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoundTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundTableGroupByOutputType[P]>
            : GetScalarType<T[P], RoundTableGroupByOutputType[P]>
        }
      >
    >


  export type roundTableSelect = {
    id?: boolean
    score?: boolean
    categoryId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type roundTableGetPayload<S extends boolean | null | undefined | roundTableArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? roundTable :
    S extends undefined ? never :
    S extends { include: any } & (roundTableArgs | roundTableFindManyArgs)
    ? roundTable 
    : S extends { select: any } & (roundTableArgs | roundTableFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof roundTable ? roundTable[P] : never
  } 
      : roundTable


  type roundTableCountArgs = 
    Omit<roundTableFindManyArgs, 'select' | 'include'> & {
      select?: RoundTableCountAggregateInputType | true
    }

  export interface roundTableDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RoundTable that matches the filter.
     * @param {roundTableFindUniqueArgs} args - Arguments to find a RoundTable
     * @example
     * // Get one RoundTable
     * const roundTable = await prisma.roundTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roundTableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, roundTableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'roundTable'> extends True ? Prisma__roundTableClient<roundTableGetPayload<T>> : Prisma__roundTableClient<roundTableGetPayload<T> | null, null>

    /**
     * Find one RoundTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {roundTableFindUniqueOrThrowArgs} args - Arguments to find a RoundTable
     * @example
     * // Get one RoundTable
     * const roundTable = await prisma.roundTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roundTableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, roundTableFindUniqueOrThrowArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Find the first RoundTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundTableFindFirstArgs} args - Arguments to find a RoundTable
     * @example
     * // Get one RoundTable
     * const roundTable = await prisma.roundTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roundTableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, roundTableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'roundTable'> extends True ? Prisma__roundTableClient<roundTableGetPayload<T>> : Prisma__roundTableClient<roundTableGetPayload<T> | null, null>

    /**
     * Find the first RoundTable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundTableFindFirstOrThrowArgs} args - Arguments to find a RoundTable
     * @example
     * // Get one RoundTable
     * const roundTable = await prisma.roundTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roundTableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, roundTableFindFirstOrThrowArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Find zero or more RoundTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoundTables
     * const roundTables = await prisma.roundTable.findMany()
     * 
     * // Get first 10 RoundTables
     * const roundTables = await prisma.roundTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundTableWithIdOnly = await prisma.roundTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends roundTableFindManyArgs>(
      args?: SelectSubset<T, roundTableFindManyArgs>
    ): Prisma.PrismaPromise<Array<roundTableGetPayload<T>>>

    /**
     * Create a RoundTable.
     * @param {roundTableCreateArgs} args - Arguments to create a RoundTable.
     * @example
     * // Create one RoundTable
     * const RoundTable = await prisma.roundTable.create({
     *   data: {
     *     // ... data to create a RoundTable
     *   }
     * })
     * 
    **/
    create<T extends roundTableCreateArgs>(
      args: SelectSubset<T, roundTableCreateArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Create many RoundTables.
     *     @param {roundTableCreateManyArgs} args - Arguments to create many RoundTables.
     *     @example
     *     // Create many RoundTables
     *     const roundTable = await prisma.roundTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends roundTableCreateManyArgs>(
      args?: SelectSubset<T, roundTableCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoundTable.
     * @param {roundTableDeleteArgs} args - Arguments to delete one RoundTable.
     * @example
     * // Delete one RoundTable
     * const RoundTable = await prisma.roundTable.delete({
     *   where: {
     *     // ... filter to delete one RoundTable
     *   }
     * })
     * 
    **/
    delete<T extends roundTableDeleteArgs>(
      args: SelectSubset<T, roundTableDeleteArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Update one RoundTable.
     * @param {roundTableUpdateArgs} args - Arguments to update one RoundTable.
     * @example
     * // Update one RoundTable
     * const roundTable = await prisma.roundTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roundTableUpdateArgs>(
      args: SelectSubset<T, roundTableUpdateArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Delete zero or more RoundTables.
     * @param {roundTableDeleteManyArgs} args - Arguments to filter RoundTables to delete.
     * @example
     * // Delete a few RoundTables
     * const { count } = await prisma.roundTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roundTableDeleteManyArgs>(
      args?: SelectSubset<T, roundTableDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoundTables
     * const roundTable = await prisma.roundTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roundTableUpdateManyArgs>(
      args: SelectSubset<T, roundTableUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoundTable.
     * @param {roundTableUpsertArgs} args - Arguments to update or create a RoundTable.
     * @example
     * // Update or create a RoundTable
     * const roundTable = await prisma.roundTable.upsert({
     *   create: {
     *     // ... data to create a RoundTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoundTable we want to update
     *   }
     * })
    **/
    upsert<T extends roundTableUpsertArgs>(
      args: SelectSubset<T, roundTableUpsertArgs>
    ): Prisma__roundTableClient<roundTableGetPayload<T>>

    /**
     * Count the number of RoundTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundTableCountArgs} args - Arguments to filter RoundTables to count.
     * @example
     * // Count the number of RoundTables
     * const count = await prisma.roundTable.count({
     *   where: {
     *     // ... the filter for the RoundTables we want to count
     *   }
     * })
    **/
    count<T extends roundTableCountArgs>(
      args?: Subset<T, roundTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoundTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundTableAggregateArgs>(args: Subset<T, RoundTableAggregateArgs>): Prisma.PrismaPromise<GetRoundTableAggregateType<T>>

    /**
     * Group by RoundTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundTableGroupByArgs['orderBy'] }
        : { orderBy?: RoundTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for roundTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__roundTableClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * roundTable base type for findUnique actions
   */
  export type roundTableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter, which roundTable to fetch.
     */
    where: roundTableWhereUniqueInput
  }

  /**
   * roundTable findUnique
   */
  export interface roundTableFindUniqueArgs extends roundTableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roundTable findUniqueOrThrow
   */
  export type roundTableFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter, which roundTable to fetch.
     */
    where: roundTableWhereUniqueInput
  }


  /**
   * roundTable base type for findFirst actions
   */
  export type roundTableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter, which roundTable to fetch.
     */
    where?: roundTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundTables to fetch.
     */
    orderBy?: Enumerable<roundTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roundTables.
     */
    cursor?: roundTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roundTables.
     */
    distinct?: Enumerable<RoundTableScalarFieldEnum>
  }

  /**
   * roundTable findFirst
   */
  export interface roundTableFindFirstArgs extends roundTableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roundTable findFirstOrThrow
   */
  export type roundTableFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter, which roundTable to fetch.
     */
    where?: roundTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundTables to fetch.
     */
    orderBy?: Enumerable<roundTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roundTables.
     */
    cursor?: roundTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roundTables.
     */
    distinct?: Enumerable<RoundTableScalarFieldEnum>
  }


  /**
   * roundTable findMany
   */
  export type roundTableFindManyArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter, which roundTables to fetch.
     */
    where?: roundTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundTables to fetch.
     */
    orderBy?: Enumerable<roundTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roundTables.
     */
    cursor?: roundTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundTables.
     */
    skip?: number
    distinct?: Enumerable<RoundTableScalarFieldEnum>
  }


  /**
   * roundTable create
   */
  export type roundTableCreateArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * The data needed to create a roundTable.
     */
    data: XOR<roundTableCreateInput, roundTableUncheckedCreateInput>
  }


  /**
   * roundTable createMany
   */
  export type roundTableCreateManyArgs = {
    /**
     * The data used to create many roundTables.
     */
    data: Enumerable<roundTableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * roundTable update
   */
  export type roundTableUpdateArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * The data needed to update a roundTable.
     */
    data: XOR<roundTableUpdateInput, roundTableUncheckedUpdateInput>
    /**
     * Choose, which roundTable to update.
     */
    where: roundTableWhereUniqueInput
  }


  /**
   * roundTable updateMany
   */
  export type roundTableUpdateManyArgs = {
    /**
     * The data used to update roundTables.
     */
    data: XOR<roundTableUpdateManyMutationInput, roundTableUncheckedUpdateManyInput>
    /**
     * Filter which roundTables to update
     */
    where?: roundTableWhereInput
  }


  /**
   * roundTable upsert
   */
  export type roundTableUpsertArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * The filter to search for the roundTable to update in case it exists.
     */
    where: roundTableWhereUniqueInput
    /**
     * In case the roundTable found by the `where` argument doesn't exist, create a new roundTable with this data.
     */
    create: XOR<roundTableCreateInput, roundTableUncheckedCreateInput>
    /**
     * In case the roundTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roundTableUpdateInput, roundTableUncheckedUpdateInput>
  }


  /**
   * roundTable delete
   */
  export type roundTableDeleteArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
    /**
     * Filter which roundTable to delete.
     */
    where: roundTableWhereUniqueInput
  }


  /**
   * roundTable deleteMany
   */
  export type roundTableDeleteManyArgs = {
    /**
     * Filter which roundTables to delete
     */
    where?: roundTableWhereInput
  }


  /**
   * roundTable without action
   */
  export type roundTableArgs = {
    /**
     * Select specific fields to fetch from the roundTable
     */
    select?: roundTableSelect | null
  }



  /**
   * Model roundQuestionTable
   */


  export type AggregateRoundQuestionTable = {
    _count: RoundQuestionTableCountAggregateOutputType | null
    _avg: RoundQuestionTableAvgAggregateOutputType | null
    _sum: RoundQuestionTableSumAggregateOutputType | null
    _min: RoundQuestionTableMinAggregateOutputType | null
    _max: RoundQuestionTableMaxAggregateOutputType | null
  }

  export type RoundQuestionTableAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    userAnswerId: number | null
    quizId: number | null
  }

  export type RoundQuestionTableSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    userAnswerId: number | null
    quizId: number | null
  }

  export type RoundQuestionTableMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    userAnswerId: number | null
    quizId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RoundQuestionTableMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    userAnswerId: number | null
    quizId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RoundQuestionTableCountAggregateOutputType = {
    id: number
    roundId: number
    userAnswerId: number
    quizId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type RoundQuestionTableAvgAggregateInputType = {
    id?: true
    roundId?: true
    userAnswerId?: true
    quizId?: true
  }

  export type RoundQuestionTableSumAggregateInputType = {
    id?: true
    roundId?: true
    userAnswerId?: true
    quizId?: true
  }

  export type RoundQuestionTableMinAggregateInputType = {
    id?: true
    roundId?: true
    userAnswerId?: true
    quizId?: true
    createAt?: true
    updateAt?: true
  }

  export type RoundQuestionTableMaxAggregateInputType = {
    id?: true
    roundId?: true
    userAnswerId?: true
    quizId?: true
    createAt?: true
    updateAt?: true
  }

  export type RoundQuestionTableCountAggregateInputType = {
    id?: true
    roundId?: true
    userAnswerId?: true
    quizId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type RoundQuestionTableAggregateArgs = {
    /**
     * Filter which roundQuestionTable to aggregate.
     */
    where?: roundQuestionTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundQuestionTables to fetch.
     */
    orderBy?: Enumerable<roundQuestionTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roundQuestionTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundQuestionTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundQuestionTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roundQuestionTables
    **/
    _count?: true | RoundQuestionTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundQuestionTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundQuestionTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundQuestionTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundQuestionTableMaxAggregateInputType
  }

  export type GetRoundQuestionTableAggregateType<T extends RoundQuestionTableAggregateArgs> = {
        [P in keyof T & keyof AggregateRoundQuestionTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoundQuestionTable[P]>
      : GetScalarType<T[P], AggregateRoundQuestionTable[P]>
  }




  export type RoundQuestionTableGroupByArgs = {
    where?: roundQuestionTableWhereInput
    orderBy?: Enumerable<roundQuestionTableOrderByWithAggregationInput>
    by: RoundQuestionTableScalarFieldEnum[]
    having?: roundQuestionTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundQuestionTableCountAggregateInputType | true
    _avg?: RoundQuestionTableAvgAggregateInputType
    _sum?: RoundQuestionTableSumAggregateInputType
    _min?: RoundQuestionTableMinAggregateInputType
    _max?: RoundQuestionTableMaxAggregateInputType
  }


  export type RoundQuestionTableGroupByOutputType = {
    id: number
    roundId: number
    userAnswerId: number
    quizId: number
    createAt: Date
    updateAt: Date
    _count: RoundQuestionTableCountAggregateOutputType | null
    _avg: RoundQuestionTableAvgAggregateOutputType | null
    _sum: RoundQuestionTableSumAggregateOutputType | null
    _min: RoundQuestionTableMinAggregateOutputType | null
    _max: RoundQuestionTableMaxAggregateOutputType | null
  }

  type GetRoundQuestionTableGroupByPayload<T extends RoundQuestionTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoundQuestionTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundQuestionTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundQuestionTableGroupByOutputType[P]>
            : GetScalarType<T[P], RoundQuestionTableGroupByOutputType[P]>
        }
      >
    >


  export type roundQuestionTableSelect = {
    id?: boolean
    roundId?: boolean
    userAnswerId?: boolean
    quizId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type roundQuestionTableGetPayload<S extends boolean | null | undefined | roundQuestionTableArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? roundQuestionTable :
    S extends undefined ? never :
    S extends { include: any } & (roundQuestionTableArgs | roundQuestionTableFindManyArgs)
    ? roundQuestionTable 
    : S extends { select: any } & (roundQuestionTableArgs | roundQuestionTableFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof roundQuestionTable ? roundQuestionTable[P] : never
  } 
      : roundQuestionTable


  type roundQuestionTableCountArgs = 
    Omit<roundQuestionTableFindManyArgs, 'select' | 'include'> & {
      select?: RoundQuestionTableCountAggregateInputType | true
    }

  export interface roundQuestionTableDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RoundQuestionTable that matches the filter.
     * @param {roundQuestionTableFindUniqueArgs} args - Arguments to find a RoundQuestionTable
     * @example
     * // Get one RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends roundQuestionTableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, roundQuestionTableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'roundQuestionTable'> extends True ? Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>> : Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T> | null, null>

    /**
     * Find one RoundQuestionTable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {roundQuestionTableFindUniqueOrThrowArgs} args - Arguments to find a RoundQuestionTable
     * @example
     * // Get one RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends roundQuestionTableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, roundQuestionTableFindUniqueOrThrowArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Find the first RoundQuestionTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundQuestionTableFindFirstArgs} args - Arguments to find a RoundQuestionTable
     * @example
     * // Get one RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends roundQuestionTableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, roundQuestionTableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'roundQuestionTable'> extends True ? Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>> : Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T> | null, null>

    /**
     * Find the first RoundQuestionTable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundQuestionTableFindFirstOrThrowArgs} args - Arguments to find a RoundQuestionTable
     * @example
     * // Get one RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends roundQuestionTableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, roundQuestionTableFindFirstOrThrowArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Find zero or more RoundQuestionTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundQuestionTableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoundQuestionTables
     * const roundQuestionTables = await prisma.roundQuestionTable.findMany()
     * 
     * // Get first 10 RoundQuestionTables
     * const roundQuestionTables = await prisma.roundQuestionTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundQuestionTableWithIdOnly = await prisma.roundQuestionTable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends roundQuestionTableFindManyArgs>(
      args?: SelectSubset<T, roundQuestionTableFindManyArgs>
    ): Prisma.PrismaPromise<Array<roundQuestionTableGetPayload<T>>>

    /**
     * Create a RoundQuestionTable.
     * @param {roundQuestionTableCreateArgs} args - Arguments to create a RoundQuestionTable.
     * @example
     * // Create one RoundQuestionTable
     * const RoundQuestionTable = await prisma.roundQuestionTable.create({
     *   data: {
     *     // ... data to create a RoundQuestionTable
     *   }
     * })
     * 
    **/
    create<T extends roundQuestionTableCreateArgs>(
      args: SelectSubset<T, roundQuestionTableCreateArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Create many RoundQuestionTables.
     *     @param {roundQuestionTableCreateManyArgs} args - Arguments to create many RoundQuestionTables.
     *     @example
     *     // Create many RoundQuestionTables
     *     const roundQuestionTable = await prisma.roundQuestionTable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends roundQuestionTableCreateManyArgs>(
      args?: SelectSubset<T, roundQuestionTableCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoundQuestionTable.
     * @param {roundQuestionTableDeleteArgs} args - Arguments to delete one RoundQuestionTable.
     * @example
     * // Delete one RoundQuestionTable
     * const RoundQuestionTable = await prisma.roundQuestionTable.delete({
     *   where: {
     *     // ... filter to delete one RoundQuestionTable
     *   }
     * })
     * 
    **/
    delete<T extends roundQuestionTableDeleteArgs>(
      args: SelectSubset<T, roundQuestionTableDeleteArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Update one RoundQuestionTable.
     * @param {roundQuestionTableUpdateArgs} args - Arguments to update one RoundQuestionTable.
     * @example
     * // Update one RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roundQuestionTableUpdateArgs>(
      args: SelectSubset<T, roundQuestionTableUpdateArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Delete zero or more RoundQuestionTables.
     * @param {roundQuestionTableDeleteManyArgs} args - Arguments to filter RoundQuestionTables to delete.
     * @example
     * // Delete a few RoundQuestionTables
     * const { count } = await prisma.roundQuestionTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roundQuestionTableDeleteManyArgs>(
      args?: SelectSubset<T, roundQuestionTableDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundQuestionTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundQuestionTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoundQuestionTables
     * const roundQuestionTable = await prisma.roundQuestionTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roundQuestionTableUpdateManyArgs>(
      args: SelectSubset<T, roundQuestionTableUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoundQuestionTable.
     * @param {roundQuestionTableUpsertArgs} args - Arguments to update or create a RoundQuestionTable.
     * @example
     * // Update or create a RoundQuestionTable
     * const roundQuestionTable = await prisma.roundQuestionTable.upsert({
     *   create: {
     *     // ... data to create a RoundQuestionTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoundQuestionTable we want to update
     *   }
     * })
    **/
    upsert<T extends roundQuestionTableUpsertArgs>(
      args: SelectSubset<T, roundQuestionTableUpsertArgs>
    ): Prisma__roundQuestionTableClient<roundQuestionTableGetPayload<T>>

    /**
     * Count the number of RoundQuestionTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roundQuestionTableCountArgs} args - Arguments to filter RoundQuestionTables to count.
     * @example
     * // Count the number of RoundQuestionTables
     * const count = await prisma.roundQuestionTable.count({
     *   where: {
     *     // ... the filter for the RoundQuestionTables we want to count
     *   }
     * })
    **/
    count<T extends roundQuestionTableCountArgs>(
      args?: Subset<T, roundQuestionTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundQuestionTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoundQuestionTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundQuestionTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundQuestionTableAggregateArgs>(args: Subset<T, RoundQuestionTableAggregateArgs>): Prisma.PrismaPromise<GetRoundQuestionTableAggregateType<T>>

    /**
     * Group by RoundQuestionTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundQuestionTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundQuestionTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundQuestionTableGroupByArgs['orderBy'] }
        : { orderBy?: RoundQuestionTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundQuestionTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundQuestionTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for roundQuestionTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__roundQuestionTableClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * roundQuestionTable base type for findUnique actions
   */
  export type roundQuestionTableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter, which roundQuestionTable to fetch.
     */
    where: roundQuestionTableWhereUniqueInput
  }

  /**
   * roundQuestionTable findUnique
   */
  export interface roundQuestionTableFindUniqueArgs extends roundQuestionTableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roundQuestionTable findUniqueOrThrow
   */
  export type roundQuestionTableFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter, which roundQuestionTable to fetch.
     */
    where: roundQuestionTableWhereUniqueInput
  }


  /**
   * roundQuestionTable base type for findFirst actions
   */
  export type roundQuestionTableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter, which roundQuestionTable to fetch.
     */
    where?: roundQuestionTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundQuestionTables to fetch.
     */
    orderBy?: Enumerable<roundQuestionTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roundQuestionTables.
     */
    cursor?: roundQuestionTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundQuestionTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundQuestionTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roundQuestionTables.
     */
    distinct?: Enumerable<RoundQuestionTableScalarFieldEnum>
  }

  /**
   * roundQuestionTable findFirst
   */
  export interface roundQuestionTableFindFirstArgs extends roundQuestionTableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * roundQuestionTable findFirstOrThrow
   */
  export type roundQuestionTableFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter, which roundQuestionTable to fetch.
     */
    where?: roundQuestionTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundQuestionTables to fetch.
     */
    orderBy?: Enumerable<roundQuestionTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roundQuestionTables.
     */
    cursor?: roundQuestionTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundQuestionTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundQuestionTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roundQuestionTables.
     */
    distinct?: Enumerable<RoundQuestionTableScalarFieldEnum>
  }


  /**
   * roundQuestionTable findMany
   */
  export type roundQuestionTableFindManyArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter, which roundQuestionTables to fetch.
     */
    where?: roundQuestionTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roundQuestionTables to fetch.
     */
    orderBy?: Enumerable<roundQuestionTableOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roundQuestionTables.
     */
    cursor?: roundQuestionTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roundQuestionTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roundQuestionTables.
     */
    skip?: number
    distinct?: Enumerable<RoundQuestionTableScalarFieldEnum>
  }


  /**
   * roundQuestionTable create
   */
  export type roundQuestionTableCreateArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * The data needed to create a roundQuestionTable.
     */
    data: XOR<roundQuestionTableCreateInput, roundQuestionTableUncheckedCreateInput>
  }


  /**
   * roundQuestionTable createMany
   */
  export type roundQuestionTableCreateManyArgs = {
    /**
     * The data used to create many roundQuestionTables.
     */
    data: Enumerable<roundQuestionTableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * roundQuestionTable update
   */
  export type roundQuestionTableUpdateArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * The data needed to update a roundQuestionTable.
     */
    data: XOR<roundQuestionTableUpdateInput, roundQuestionTableUncheckedUpdateInput>
    /**
     * Choose, which roundQuestionTable to update.
     */
    where: roundQuestionTableWhereUniqueInput
  }


  /**
   * roundQuestionTable updateMany
   */
  export type roundQuestionTableUpdateManyArgs = {
    /**
     * The data used to update roundQuestionTables.
     */
    data: XOR<roundQuestionTableUpdateManyMutationInput, roundQuestionTableUncheckedUpdateManyInput>
    /**
     * Filter which roundQuestionTables to update
     */
    where?: roundQuestionTableWhereInput
  }


  /**
   * roundQuestionTable upsert
   */
  export type roundQuestionTableUpsertArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * The filter to search for the roundQuestionTable to update in case it exists.
     */
    where: roundQuestionTableWhereUniqueInput
    /**
     * In case the roundQuestionTable found by the `where` argument doesn't exist, create a new roundQuestionTable with this data.
     */
    create: XOR<roundQuestionTableCreateInput, roundQuestionTableUncheckedCreateInput>
    /**
     * In case the roundQuestionTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roundQuestionTableUpdateInput, roundQuestionTableUncheckedUpdateInput>
  }


  /**
   * roundQuestionTable delete
   */
  export type roundQuestionTableDeleteArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
    /**
     * Filter which roundQuestionTable to delete.
     */
    where: roundQuestionTableWhereUniqueInput
  }


  /**
   * roundQuestionTable deleteMany
   */
  export type roundQuestionTableDeleteManyArgs = {
    /**
     * Filter which roundQuestionTables to delete
     */
    where?: roundQuestionTableWhereInput
  }


  /**
   * roundQuestionTable without action
   */
  export type roundQuestionTableArgs = {
    /**
     * Select specific fields to fetch from the roundQuestionTable
     */
    select?: roundQuestionTableSelect | null
  }



  /**
   * Model QuizeCategory
   */


  export type AggregateQuizeCategory = {
    _count: QuizeCategoryCountAggregateOutputType | null
    _avg: QuizeCategoryAvgAggregateOutputType | null
    _sum: QuizeCategorySumAggregateOutputType | null
    _min: QuizeCategoryMinAggregateOutputType | null
    _max: QuizeCategoryMaxAggregateOutputType | null
  }

  export type QuizeCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuizeCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuizeCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeCategoryCountAggregateOutputType = {
    id: number
    name: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuizeCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuizeCategorySumAggregateInputType = {
    id?: true
  }

  export type QuizeCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuizeCategoryAggregateArgs = {
    /**
     * Filter which QuizeCategory to aggregate.
     */
    where?: QuizeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeCategories to fetch.
     */
    orderBy?: Enumerable<QuizeCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeCategories
    **/
    _count?: true | QuizeCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeCategoryMaxAggregateInputType
  }

  export type GetQuizeCategoryAggregateType<T extends QuizeCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeCategory[P]>
      : GetScalarType<T[P], AggregateQuizeCategory[P]>
  }




  export type QuizeCategoryGroupByArgs = {
    where?: QuizeCategoryWhereInput
    orderBy?: Enumerable<QuizeCategoryOrderByWithAggregationInput>
    by: QuizeCategoryScalarFieldEnum[]
    having?: QuizeCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeCategoryCountAggregateInputType | true
    _avg?: QuizeCategoryAvgAggregateInputType
    _sum?: QuizeCategorySumAggregateInputType
    _min?: QuizeCategoryMinAggregateInputType
    _max?: QuizeCategoryMaxAggregateInputType
  }


  export type QuizeCategoryGroupByOutputType = {
    id: number
    name: string
    createAt: Date
    updateAt: Date
    _count: QuizeCategoryCountAggregateOutputType | null
    _avg: QuizeCategoryAvgAggregateOutputType | null
    _sum: QuizeCategorySumAggregateOutputType | null
    _min: QuizeCategoryMinAggregateOutputType | null
    _max: QuizeCategoryMaxAggregateOutputType | null
  }

  type GetQuizeCategoryGroupByPayload<T extends QuizeCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuizeCategorySelect = {
    id?: boolean
    name?: boolean
    questions?: boolean | QuizeCategory$questionsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | QuizeCategoryCountOutputTypeArgs
  }


  export type QuizeCategoryInclude = {
    questions?: boolean | QuizeCategory$questionsArgs
    _count?: boolean | QuizeCategoryCountOutputTypeArgs
  }

  export type QuizeCategoryGetPayload<S extends boolean | null | undefined | QuizeCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeCategory :
    S extends undefined ? never :
    S extends { include: any } & (QuizeCategoryArgs | QuizeCategoryFindManyArgs)
    ? QuizeCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questions' ? Array < QuizeQuestionGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizeCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizeCategoryArgs | QuizeCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questions' ? Array < QuizeQuestionGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizeCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizeCategory ? QuizeCategory[P] : never
  } 
      : QuizeCategory


  type QuizeCategoryCountArgs = 
    Omit<QuizeCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuizeCategoryCountAggregateInputType | true
    }

  export interface QuizeCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeCategory that matches the filter.
     * @param {QuizeCategoryFindUniqueArgs} args - Arguments to find a QuizeCategory
     * @example
     * // Get one QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeCategory'> extends True ? Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>> : Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T> | null, null>

    /**
     * Find one QuizeCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuizeCategory
     * @example
     * // Get one QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeCategoryFindUniqueOrThrowArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Find the first QuizeCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryFindFirstArgs} args - Arguments to find a QuizeCategory
     * @example
     * // Get one QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeCategory'> extends True ? Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>> : Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T> | null, null>

    /**
     * Find the first QuizeCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryFindFirstOrThrowArgs} args - Arguments to find a QuizeCategory
     * @example
     * // Get one QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeCategoryFindFirstOrThrowArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Find zero or more QuizeCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeCategories
     * const quizeCategories = await prisma.quizeCategory.findMany()
     * 
     * // Get first 10 QuizeCategories
     * const quizeCategories = await prisma.quizeCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeCategoryWithIdOnly = await prisma.quizeCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeCategoryFindManyArgs>(
      args?: SelectSubset<T, QuizeCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeCategoryGetPayload<T>>>

    /**
     * Create a QuizeCategory.
     * @param {QuizeCategoryCreateArgs} args - Arguments to create a QuizeCategory.
     * @example
     * // Create one QuizeCategory
     * const QuizeCategory = await prisma.quizeCategory.create({
     *   data: {
     *     // ... data to create a QuizeCategory
     *   }
     * })
     * 
    **/
    create<T extends QuizeCategoryCreateArgs>(
      args: SelectSubset<T, QuizeCategoryCreateArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Create many QuizeCategories.
     *     @param {QuizeCategoryCreateManyArgs} args - Arguments to create many QuizeCategories.
     *     @example
     *     // Create many QuizeCategories
     *     const quizeCategory = await prisma.quizeCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuizeCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeCategory.
     * @param {QuizeCategoryDeleteArgs} args - Arguments to delete one QuizeCategory.
     * @example
     * // Delete one QuizeCategory
     * const QuizeCategory = await prisma.quizeCategory.delete({
     *   where: {
     *     // ... filter to delete one QuizeCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuizeCategoryDeleteArgs>(
      args: SelectSubset<T, QuizeCategoryDeleteArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Update one QuizeCategory.
     * @param {QuizeCategoryUpdateArgs} args - Arguments to update one QuizeCategory.
     * @example
     * // Update one QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeCategoryUpdateArgs>(
      args: SelectSubset<T, QuizeCategoryUpdateArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Delete zero or more QuizeCategories.
     * @param {QuizeCategoryDeleteManyArgs} args - Arguments to filter QuizeCategories to delete.
     * @example
     * // Delete a few QuizeCategories
     * const { count } = await prisma.quizeCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuizeCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeCategories
     * const quizeCategory = await prisma.quizeCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuizeCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeCategory.
     * @param {QuizeCategoryUpsertArgs} args - Arguments to update or create a QuizeCategory.
     * @example
     * // Update or create a QuizeCategory
     * const quizeCategory = await prisma.quizeCategory.upsert({
     *   create: {
     *     // ... data to create a QuizeCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeCategoryUpsertArgs>(
      args: SelectSubset<T, QuizeCategoryUpsertArgs>
    ): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T>>

    /**
     * Count the number of QuizeCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryCountArgs} args - Arguments to filter QuizeCategories to count.
     * @example
     * // Count the number of QuizeCategories
     * const count = await prisma.quizeCategory.count({
     *   where: {
     *     // ... the filter for the QuizeCategories we want to count
     *   }
     * })
    **/
    count<T extends QuizeCategoryCountArgs>(
      args?: Subset<T, QuizeCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeCategoryAggregateArgs>(args: Subset<T, QuizeCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuizeCategoryAggregateType<T>>

    /**
     * Group by QuizeCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuizeCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    questions<T extends QuizeCategory$questionsArgs= {}>(args?: Subset<T, QuizeCategory$questionsArgs>): Prisma.PrismaPromise<Array<QuizeQuestionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeCategory base type for findUnique actions
   */
  export type QuizeCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter, which QuizeCategory to fetch.
     */
    where: QuizeCategoryWhereUniqueInput
  }

  /**
   * QuizeCategory findUnique
   */
  export interface QuizeCategoryFindUniqueArgs extends QuizeCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeCategory findUniqueOrThrow
   */
  export type QuizeCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter, which QuizeCategory to fetch.
     */
    where: QuizeCategoryWhereUniqueInput
  }


  /**
   * QuizeCategory base type for findFirst actions
   */
  export type QuizeCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter, which QuizeCategory to fetch.
     */
    where?: QuizeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeCategories to fetch.
     */
    orderBy?: Enumerable<QuizeCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeCategories.
     */
    cursor?: QuizeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeCategories.
     */
    distinct?: Enumerable<QuizeCategoryScalarFieldEnum>
  }

  /**
   * QuizeCategory findFirst
   */
  export interface QuizeCategoryFindFirstArgs extends QuizeCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeCategory findFirstOrThrow
   */
  export type QuizeCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter, which QuizeCategory to fetch.
     */
    where?: QuizeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeCategories to fetch.
     */
    orderBy?: Enumerable<QuizeCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeCategories.
     */
    cursor?: QuizeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeCategories.
     */
    distinct?: Enumerable<QuizeCategoryScalarFieldEnum>
  }


  /**
   * QuizeCategory findMany
   */
  export type QuizeCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter, which QuizeCategories to fetch.
     */
    where?: QuizeCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeCategories to fetch.
     */
    orderBy?: Enumerable<QuizeCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeCategories.
     */
    cursor?: QuizeCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeCategories.
     */
    skip?: number
    distinct?: Enumerable<QuizeCategoryScalarFieldEnum>
  }


  /**
   * QuizeCategory create
   */
  export type QuizeCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * The data needed to create a QuizeCategory.
     */
    data: XOR<QuizeCategoryCreateInput, QuizeCategoryUncheckedCreateInput>
  }


  /**
   * QuizeCategory createMany
   */
  export type QuizeCategoryCreateManyArgs = {
    /**
     * The data used to create many QuizeCategories.
     */
    data: Enumerable<QuizeCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeCategory update
   */
  export type QuizeCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * The data needed to update a QuizeCategory.
     */
    data: XOR<QuizeCategoryUpdateInput, QuizeCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuizeCategory to update.
     */
    where: QuizeCategoryWhereUniqueInput
  }


  /**
   * QuizeCategory updateMany
   */
  export type QuizeCategoryUpdateManyArgs = {
    /**
     * The data used to update QuizeCategories.
     */
    data: XOR<QuizeCategoryUpdateManyMutationInput, QuizeCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuizeCategories to update
     */
    where?: QuizeCategoryWhereInput
  }


  /**
   * QuizeCategory upsert
   */
  export type QuizeCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * The filter to search for the QuizeCategory to update in case it exists.
     */
    where: QuizeCategoryWhereUniqueInput
    /**
     * In case the QuizeCategory found by the `where` argument doesn't exist, create a new QuizeCategory with this data.
     */
    create: XOR<QuizeCategoryCreateInput, QuizeCategoryUncheckedCreateInput>
    /**
     * In case the QuizeCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeCategoryUpdateInput, QuizeCategoryUncheckedUpdateInput>
  }


  /**
   * QuizeCategory delete
   */
  export type QuizeCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
    /**
     * Filter which QuizeCategory to delete.
     */
    where: QuizeCategoryWhereUniqueInput
  }


  /**
   * QuizeCategory deleteMany
   */
  export type QuizeCategoryDeleteManyArgs = {
    /**
     * Filter which QuizeCategories to delete
     */
    where?: QuizeCategoryWhereInput
  }


  /**
   * QuizeCategory.questions
   */
  export type QuizeCategory$questionsArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    where?: QuizeQuestionWhereInput
    orderBy?: Enumerable<QuizeQuestionOrderByWithRelationInput>
    cursor?: QuizeQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizeQuestionScalarFieldEnum>
  }


  /**
   * QuizeCategory without action
   */
  export type QuizeCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuizeCategory
     */
    select?: QuizeCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeCategoryInclude | null
  }



  /**
   * Model QuizeQuestion
   */


  export type AggregateQuizeQuestion = {
    _count: QuizeQuestionCountAggregateOutputType | null
    _avg: QuizeQuestionAvgAggregateOutputType | null
    _sum: QuizeQuestionSumAggregateOutputType | null
    _min: QuizeQuestionMinAggregateOutputType | null
    _max: QuizeQuestionMaxAggregateOutputType | null
  }

  export type QuizeQuestionAvgAggregateOutputType = {
    id: number | null
    quizeCategoryId: number | null
    quizeAnswerId: number | null
  }

  export type QuizeQuestionSumAggregateOutputType = {
    id: number | null
    quizeCategoryId: number | null
    quizeAnswerId: number | null
  }

  export type QuizeQuestionMinAggregateOutputType = {
    id: number | null
    question: string | null
    quizeCategoryId: number | null
    quizeAnswerId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeQuestionMaxAggregateOutputType = {
    id: number | null
    question: string | null
    quizeCategoryId: number | null
    quizeAnswerId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeQuestionCountAggregateOutputType = {
    id: number
    question: number
    quizeCategoryId: number
    quizeAnswerId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuizeQuestionAvgAggregateInputType = {
    id?: true
    quizeCategoryId?: true
    quizeAnswerId?: true
  }

  export type QuizeQuestionSumAggregateInputType = {
    id?: true
    quizeCategoryId?: true
    quizeAnswerId?: true
  }

  export type QuizeQuestionMinAggregateInputType = {
    id?: true
    question?: true
    quizeCategoryId?: true
    quizeAnswerId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeQuestionMaxAggregateInputType = {
    id?: true
    question?: true
    quizeCategoryId?: true
    quizeAnswerId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeQuestionCountAggregateInputType = {
    id?: true
    question?: true
    quizeCategoryId?: true
    quizeAnswerId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuizeQuestionAggregateArgs = {
    /**
     * Filter which QuizeQuestion to aggregate.
     */
    where?: QuizeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeQuestions to fetch.
     */
    orderBy?: Enumerable<QuizeQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeQuestions
    **/
    _count?: true | QuizeQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeQuestionMaxAggregateInputType
  }

  export type GetQuizeQuestionAggregateType<T extends QuizeQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeQuestion[P]>
      : GetScalarType<T[P], AggregateQuizeQuestion[P]>
  }




  export type QuizeQuestionGroupByArgs = {
    where?: QuizeQuestionWhereInput
    orderBy?: Enumerable<QuizeQuestionOrderByWithAggregationInput>
    by: QuizeQuestionScalarFieldEnum[]
    having?: QuizeQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeQuestionCountAggregateInputType | true
    _avg?: QuizeQuestionAvgAggregateInputType
    _sum?: QuizeQuestionSumAggregateInputType
    _min?: QuizeQuestionMinAggregateInputType
    _max?: QuizeQuestionMaxAggregateInputType
  }


  export type QuizeQuestionGroupByOutputType = {
    id: number
    question: string
    quizeCategoryId: number | null
    quizeAnswerId: number | null
    createAt: Date
    updateAt: Date
    _count: QuizeQuestionCountAggregateOutputType | null
    _avg: QuizeQuestionAvgAggregateOutputType | null
    _sum: QuizeQuestionSumAggregateOutputType | null
    _min: QuizeQuestionMinAggregateOutputType | null
    _max: QuizeQuestionMaxAggregateOutputType | null
  }

  type GetQuizeQuestionGroupByPayload<T extends QuizeQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizeQuestionSelect = {
    id?: boolean
    question?: boolean
    quizeCategory?: boolean | QuizeCategoryArgs
    quizeCategoryId?: boolean
    choices?: boolean | QuizeQuestion$choicesArgs
    answer?: boolean | QuizeAnswerArgs
    quizeAnswerId?: boolean
    createAt?: boolean
    updateAt?: boolean
    round?: boolean | QuizeGameRoundArgs
    _count?: boolean | QuizeQuestionCountOutputTypeArgs
  }


  export type QuizeQuestionInclude = {
    quizeCategory?: boolean | QuizeCategoryArgs
    choices?: boolean | QuizeQuestion$choicesArgs
    answer?: boolean | QuizeAnswerArgs
    round?: boolean | QuizeGameRoundArgs
    _count?: boolean | QuizeQuestionCountOutputTypeArgs
  }

  export type QuizeQuestionGetPayload<S extends boolean | null | undefined | QuizeQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeQuestion :
    S extends undefined ? never :
    S extends { include: any } & (QuizeQuestionArgs | QuizeQuestionFindManyArgs)
    ? QuizeQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizeCategory' ? QuizeCategoryGetPayload<S['include'][P]> | null :
        P extends 'choices' ? Array < QuizeChoiceGetPayload<S['include'][P]>>  :
        P extends 'answer' ? QuizeAnswerGetPayload<S['include'][P]> | null :
        P extends 'round' ? QuizeGameRoundGetPayload<S['include'][P]> | null :
        P extends '_count' ? QuizeQuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizeQuestionArgs | QuizeQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizeCategory' ? QuizeCategoryGetPayload<S['select'][P]> | null :
        P extends 'choices' ? Array < QuizeChoiceGetPayload<S['select'][P]>>  :
        P extends 'answer' ? QuizeAnswerGetPayload<S['select'][P]> | null :
        P extends 'round' ? QuizeGameRoundGetPayload<S['select'][P]> | null :
        P extends '_count' ? QuizeQuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizeQuestion ? QuizeQuestion[P] : never
  } 
      : QuizeQuestion


  type QuizeQuestionCountArgs = 
    Omit<QuizeQuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuizeQuestionCountAggregateInputType | true
    }

  export interface QuizeQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeQuestion that matches the filter.
     * @param {QuizeQuestionFindUniqueArgs} args - Arguments to find a QuizeQuestion
     * @example
     * // Get one QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeQuestion'> extends True ? Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>> : Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T> | null, null>

    /**
     * Find one QuizeQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizeQuestion
     * @example
     * // Get one QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeQuestionFindUniqueOrThrowArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Find the first QuizeQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionFindFirstArgs} args - Arguments to find a QuizeQuestion
     * @example
     * // Get one QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeQuestion'> extends True ? Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>> : Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T> | null, null>

    /**
     * Find the first QuizeQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizeQuestion
     * @example
     * // Get one QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeQuestionFindFirstOrThrowArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Find zero or more QuizeQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeQuestions
     * const quizeQuestions = await prisma.quizeQuestion.findMany()
     * 
     * // Get first 10 QuizeQuestions
     * const quizeQuestions = await prisma.quizeQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeQuestionWithIdOnly = await prisma.quizeQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeQuestionFindManyArgs>(
      args?: SelectSubset<T, QuizeQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeQuestionGetPayload<T>>>

    /**
     * Create a QuizeQuestion.
     * @param {QuizeQuestionCreateArgs} args - Arguments to create a QuizeQuestion.
     * @example
     * // Create one QuizeQuestion
     * const QuizeQuestion = await prisma.quizeQuestion.create({
     *   data: {
     *     // ... data to create a QuizeQuestion
     *   }
     * })
     * 
    **/
    create<T extends QuizeQuestionCreateArgs>(
      args: SelectSubset<T, QuizeQuestionCreateArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Create many QuizeQuestions.
     *     @param {QuizeQuestionCreateManyArgs} args - Arguments to create many QuizeQuestions.
     *     @example
     *     // Create many QuizeQuestions
     *     const quizeQuestion = await prisma.quizeQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeQuestionCreateManyArgs>(
      args?: SelectSubset<T, QuizeQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeQuestion.
     * @param {QuizeQuestionDeleteArgs} args - Arguments to delete one QuizeQuestion.
     * @example
     * // Delete one QuizeQuestion
     * const QuizeQuestion = await prisma.quizeQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizeQuestion
     *   }
     * })
     * 
    **/
    delete<T extends QuizeQuestionDeleteArgs>(
      args: SelectSubset<T, QuizeQuestionDeleteArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Update one QuizeQuestion.
     * @param {QuizeQuestionUpdateArgs} args - Arguments to update one QuizeQuestion.
     * @example
     * // Update one QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeQuestionUpdateArgs>(
      args: SelectSubset<T, QuizeQuestionUpdateArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Delete zero or more QuizeQuestions.
     * @param {QuizeQuestionDeleteManyArgs} args - Arguments to filter QuizeQuestions to delete.
     * @example
     * // Delete a few QuizeQuestions
     * const { count } = await prisma.quizeQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeQuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuizeQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeQuestions
     * const quizeQuestion = await prisma.quizeQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeQuestionUpdateManyArgs>(
      args: SelectSubset<T, QuizeQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeQuestion.
     * @param {QuizeQuestionUpsertArgs} args - Arguments to update or create a QuizeQuestion.
     * @example
     * // Update or create a QuizeQuestion
     * const quizeQuestion = await prisma.quizeQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizeQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeQuestionUpsertArgs>(
      args: SelectSubset<T, QuizeQuestionUpsertArgs>
    ): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T>>

    /**
     * Count the number of QuizeQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionCountArgs} args - Arguments to filter QuizeQuestions to count.
     * @example
     * // Count the number of QuizeQuestions
     * const count = await prisma.quizeQuestion.count({
     *   where: {
     *     // ... the filter for the QuizeQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizeQuestionCountArgs>(
      args?: Subset<T, QuizeQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeQuestionAggregateArgs>(args: Subset<T, QuizeQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizeQuestionAggregateType<T>>

    /**
     * Group by QuizeQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizeQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizeCategory<T extends QuizeCategoryArgs= {}>(args?: Subset<T, QuizeCategoryArgs>): Prisma__QuizeCategoryClient<QuizeCategoryGetPayload<T> | Null>;

    choices<T extends QuizeQuestion$choicesArgs= {}>(args?: Subset<T, QuizeQuestion$choicesArgs>): Prisma.PrismaPromise<Array<QuizeChoiceGetPayload<T>>| Null>;

    answer<T extends QuizeAnswerArgs= {}>(args?: Subset<T, QuizeAnswerArgs>): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T> | Null>;

    round<T extends QuizeGameRoundArgs= {}>(args?: Subset<T, QuizeGameRoundArgs>): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeQuestion base type for findUnique actions
   */
  export type QuizeQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter, which QuizeQuestion to fetch.
     */
    where: QuizeQuestionWhereUniqueInput
  }

  /**
   * QuizeQuestion findUnique
   */
  export interface QuizeQuestionFindUniqueArgs extends QuizeQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeQuestion findUniqueOrThrow
   */
  export type QuizeQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter, which QuizeQuestion to fetch.
     */
    where: QuizeQuestionWhereUniqueInput
  }


  /**
   * QuizeQuestion base type for findFirst actions
   */
  export type QuizeQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter, which QuizeQuestion to fetch.
     */
    where?: QuizeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeQuestions to fetch.
     */
    orderBy?: Enumerable<QuizeQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeQuestions.
     */
    cursor?: QuizeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeQuestions.
     */
    distinct?: Enumerable<QuizeQuestionScalarFieldEnum>
  }

  /**
   * QuizeQuestion findFirst
   */
  export interface QuizeQuestionFindFirstArgs extends QuizeQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeQuestion findFirstOrThrow
   */
  export type QuizeQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter, which QuizeQuestion to fetch.
     */
    where?: QuizeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeQuestions to fetch.
     */
    orderBy?: Enumerable<QuizeQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeQuestions.
     */
    cursor?: QuizeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeQuestions.
     */
    distinct?: Enumerable<QuizeQuestionScalarFieldEnum>
  }


  /**
   * QuizeQuestion findMany
   */
  export type QuizeQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter, which QuizeQuestions to fetch.
     */
    where?: QuizeQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeQuestions to fetch.
     */
    orderBy?: Enumerable<QuizeQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeQuestions.
     */
    cursor?: QuizeQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeQuestions.
     */
    skip?: number
    distinct?: Enumerable<QuizeQuestionScalarFieldEnum>
  }


  /**
   * QuizeQuestion create
   */
  export type QuizeQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * The data needed to create a QuizeQuestion.
     */
    data: XOR<QuizeQuestionCreateInput, QuizeQuestionUncheckedCreateInput>
  }


  /**
   * QuizeQuestion createMany
   */
  export type QuizeQuestionCreateManyArgs = {
    /**
     * The data used to create many QuizeQuestions.
     */
    data: Enumerable<QuizeQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeQuestion update
   */
  export type QuizeQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * The data needed to update a QuizeQuestion.
     */
    data: XOR<QuizeQuestionUpdateInput, QuizeQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizeQuestion to update.
     */
    where: QuizeQuestionWhereUniqueInput
  }


  /**
   * QuizeQuestion updateMany
   */
  export type QuizeQuestionUpdateManyArgs = {
    /**
     * The data used to update QuizeQuestions.
     */
    data: XOR<QuizeQuestionUpdateManyMutationInput, QuizeQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizeQuestions to update
     */
    where?: QuizeQuestionWhereInput
  }


  /**
   * QuizeQuestion upsert
   */
  export type QuizeQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * The filter to search for the QuizeQuestion to update in case it exists.
     */
    where: QuizeQuestionWhereUniqueInput
    /**
     * In case the QuizeQuestion found by the `where` argument doesn't exist, create a new QuizeQuestion with this data.
     */
    create: XOR<QuizeQuestionCreateInput, QuizeQuestionUncheckedCreateInput>
    /**
     * In case the QuizeQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeQuestionUpdateInput, QuizeQuestionUncheckedUpdateInput>
  }


  /**
   * QuizeQuestion delete
   */
  export type QuizeQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
    /**
     * Filter which QuizeQuestion to delete.
     */
    where: QuizeQuestionWhereUniqueInput
  }


  /**
   * QuizeQuestion deleteMany
   */
  export type QuizeQuestionDeleteManyArgs = {
    /**
     * Filter which QuizeQuestions to delete
     */
    where?: QuizeQuestionWhereInput
  }


  /**
   * QuizeQuestion.choices
   */
  export type QuizeQuestion$choicesArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    where?: QuizeChoiceWhereInput
    orderBy?: Enumerable<QuizeChoiceOrderByWithRelationInput>
    cursor?: QuizeChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizeChoiceScalarFieldEnum>
  }


  /**
   * QuizeQuestion without action
   */
  export type QuizeQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuizeQuestion
     */
    select?: QuizeQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeQuestionInclude | null
  }



  /**
   * Model QuizeChoice
   */


  export type AggregateQuizeChoice = {
    _count: QuizeChoiceCountAggregateOutputType | null
    _avg: QuizeChoiceAvgAggregateOutputType | null
    _sum: QuizeChoiceSumAggregateOutputType | null
    _min: QuizeChoiceMinAggregateOutputType | null
    _max: QuizeChoiceMaxAggregateOutputType | null
  }

  export type QuizeChoiceAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizeChoiceSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizeChoiceMinAggregateOutputType = {
    id: number | null
    choice: string | null
    questionId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeChoiceMaxAggregateOutputType = {
    id: number | null
    choice: string | null
    questionId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeChoiceCountAggregateOutputType = {
    id: number
    choice: number
    questionId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuizeChoiceAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizeChoiceSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizeChoiceMinAggregateInputType = {
    id?: true
    choice?: true
    questionId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeChoiceMaxAggregateInputType = {
    id?: true
    choice?: true
    questionId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeChoiceCountAggregateInputType = {
    id?: true
    choice?: true
    questionId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuizeChoiceAggregateArgs = {
    /**
     * Filter which QuizeChoice to aggregate.
     */
    where?: QuizeChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeChoices to fetch.
     */
    orderBy?: Enumerable<QuizeChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeChoices
    **/
    _count?: true | QuizeChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeChoiceMaxAggregateInputType
  }

  export type GetQuizeChoiceAggregateType<T extends QuizeChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeChoice[P]>
      : GetScalarType<T[P], AggregateQuizeChoice[P]>
  }




  export type QuizeChoiceGroupByArgs = {
    where?: QuizeChoiceWhereInput
    orderBy?: Enumerable<QuizeChoiceOrderByWithAggregationInput>
    by: QuizeChoiceScalarFieldEnum[]
    having?: QuizeChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeChoiceCountAggregateInputType | true
    _avg?: QuizeChoiceAvgAggregateInputType
    _sum?: QuizeChoiceSumAggregateInputType
    _min?: QuizeChoiceMinAggregateInputType
    _max?: QuizeChoiceMaxAggregateInputType
  }


  export type QuizeChoiceGroupByOutputType = {
    id: number
    choice: string
    questionId: number | null
    createAt: Date
    updateAt: Date
    _count: QuizeChoiceCountAggregateOutputType | null
    _avg: QuizeChoiceAvgAggregateOutputType | null
    _sum: QuizeChoiceSumAggregateOutputType | null
    _min: QuizeChoiceMinAggregateOutputType | null
    _max: QuizeChoiceMaxAggregateOutputType | null
  }

  type GetQuizeChoiceGroupByPayload<T extends QuizeChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeChoiceGroupByOutputType[P]>
        }
      >
    >


  export type QuizeChoiceSelect = {
    id?: boolean
    choice?: boolean
    quizeQuestion?: boolean | QuizeQuestionArgs
    questionId?: boolean
    quizeAnswer?: boolean | QuizeAnswerArgs
    createAt?: boolean
    updateAt?: boolean
    round?: boolean | QuizeGameRoundArgs
  }


  export type QuizeChoiceInclude = {
    quizeQuestion?: boolean | QuizeQuestionArgs
    quizeAnswer?: boolean | QuizeAnswerArgs
    round?: boolean | QuizeGameRoundArgs
  }

  export type QuizeChoiceGetPayload<S extends boolean | null | undefined | QuizeChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeChoice :
    S extends undefined ? never :
    S extends { include: any } & (QuizeChoiceArgs | QuizeChoiceFindManyArgs)
    ? QuizeChoice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizeQuestion' ? QuizeQuestionGetPayload<S['include'][P]> | null :
        P extends 'quizeAnswer' ? QuizeAnswerGetPayload<S['include'][P]> | null :
        P extends 'round' ? QuizeGameRoundGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuizeChoiceArgs | QuizeChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizeQuestion' ? QuizeQuestionGetPayload<S['select'][P]> | null :
        P extends 'quizeAnswer' ? QuizeAnswerGetPayload<S['select'][P]> | null :
        P extends 'round' ? QuizeGameRoundGetPayload<S['select'][P]> | null :  P extends keyof QuizeChoice ? QuizeChoice[P] : never
  } 
      : QuizeChoice


  type QuizeChoiceCountArgs = 
    Omit<QuizeChoiceFindManyArgs, 'select' | 'include'> & {
      select?: QuizeChoiceCountAggregateInputType | true
    }

  export interface QuizeChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeChoice that matches the filter.
     * @param {QuizeChoiceFindUniqueArgs} args - Arguments to find a QuizeChoice
     * @example
     * // Get one QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeChoice'> extends True ? Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>> : Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T> | null, null>

    /**
     * Find one QuizeChoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeChoiceFindUniqueOrThrowArgs} args - Arguments to find a QuizeChoice
     * @example
     * // Get one QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeChoiceFindUniqueOrThrowArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Find the first QuizeChoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceFindFirstArgs} args - Arguments to find a QuizeChoice
     * @example
     * // Get one QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeChoice'> extends True ? Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>> : Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T> | null, null>

    /**
     * Find the first QuizeChoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceFindFirstOrThrowArgs} args - Arguments to find a QuizeChoice
     * @example
     * // Get one QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeChoiceFindFirstOrThrowArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Find zero or more QuizeChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeChoices
     * const quizeChoices = await prisma.quizeChoice.findMany()
     * 
     * // Get first 10 QuizeChoices
     * const quizeChoices = await prisma.quizeChoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeChoiceWithIdOnly = await prisma.quizeChoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeChoiceFindManyArgs>(
      args?: SelectSubset<T, QuizeChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeChoiceGetPayload<T>>>

    /**
     * Create a QuizeChoice.
     * @param {QuizeChoiceCreateArgs} args - Arguments to create a QuizeChoice.
     * @example
     * // Create one QuizeChoice
     * const QuizeChoice = await prisma.quizeChoice.create({
     *   data: {
     *     // ... data to create a QuizeChoice
     *   }
     * })
     * 
    **/
    create<T extends QuizeChoiceCreateArgs>(
      args: SelectSubset<T, QuizeChoiceCreateArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Create many QuizeChoices.
     *     @param {QuizeChoiceCreateManyArgs} args - Arguments to create many QuizeChoices.
     *     @example
     *     // Create many QuizeChoices
     *     const quizeChoice = await prisma.quizeChoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeChoiceCreateManyArgs>(
      args?: SelectSubset<T, QuizeChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeChoice.
     * @param {QuizeChoiceDeleteArgs} args - Arguments to delete one QuizeChoice.
     * @example
     * // Delete one QuizeChoice
     * const QuizeChoice = await prisma.quizeChoice.delete({
     *   where: {
     *     // ... filter to delete one QuizeChoice
     *   }
     * })
     * 
    **/
    delete<T extends QuizeChoiceDeleteArgs>(
      args: SelectSubset<T, QuizeChoiceDeleteArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Update one QuizeChoice.
     * @param {QuizeChoiceUpdateArgs} args - Arguments to update one QuizeChoice.
     * @example
     * // Update one QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeChoiceUpdateArgs>(
      args: SelectSubset<T, QuizeChoiceUpdateArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Delete zero or more QuizeChoices.
     * @param {QuizeChoiceDeleteManyArgs} args - Arguments to filter QuizeChoices to delete.
     * @example
     * // Delete a few QuizeChoices
     * const { count } = await prisma.quizeChoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeChoiceDeleteManyArgs>(
      args?: SelectSubset<T, QuizeChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeChoices
     * const quizeChoice = await prisma.quizeChoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeChoiceUpdateManyArgs>(
      args: SelectSubset<T, QuizeChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeChoice.
     * @param {QuizeChoiceUpsertArgs} args - Arguments to update or create a QuizeChoice.
     * @example
     * // Update or create a QuizeChoice
     * const quizeChoice = await prisma.quizeChoice.upsert({
     *   create: {
     *     // ... data to create a QuizeChoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeChoice we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeChoiceUpsertArgs>(
      args: SelectSubset<T, QuizeChoiceUpsertArgs>
    ): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T>>

    /**
     * Count the number of QuizeChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceCountArgs} args - Arguments to filter QuizeChoices to count.
     * @example
     * // Count the number of QuizeChoices
     * const count = await prisma.quizeChoice.count({
     *   where: {
     *     // ... the filter for the QuizeChoices we want to count
     *   }
     * })
    **/
    count<T extends QuizeChoiceCountArgs>(
      args?: Subset<T, QuizeChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeChoiceAggregateArgs>(args: Subset<T, QuizeChoiceAggregateArgs>): Prisma.PrismaPromise<GetQuizeChoiceAggregateType<T>>

    /**
     * Group by QuizeChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeChoiceGroupByArgs['orderBy'] }
        : { orderBy?: QuizeChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeChoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizeQuestion<T extends QuizeQuestionArgs= {}>(args?: Subset<T, QuizeQuestionArgs>): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T> | Null>;

    quizeAnswer<T extends QuizeAnswerArgs= {}>(args?: Subset<T, QuizeAnswerArgs>): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T> | Null>;

    round<T extends QuizeGameRoundArgs= {}>(args?: Subset<T, QuizeGameRoundArgs>): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeChoice base type for findUnique actions
   */
  export type QuizeChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter, which QuizeChoice to fetch.
     */
    where: QuizeChoiceWhereUniqueInput
  }

  /**
   * QuizeChoice findUnique
   */
  export interface QuizeChoiceFindUniqueArgs extends QuizeChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeChoice findUniqueOrThrow
   */
  export type QuizeChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter, which QuizeChoice to fetch.
     */
    where: QuizeChoiceWhereUniqueInput
  }


  /**
   * QuizeChoice base type for findFirst actions
   */
  export type QuizeChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter, which QuizeChoice to fetch.
     */
    where?: QuizeChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeChoices to fetch.
     */
    orderBy?: Enumerable<QuizeChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeChoices.
     */
    cursor?: QuizeChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeChoices.
     */
    distinct?: Enumerable<QuizeChoiceScalarFieldEnum>
  }

  /**
   * QuizeChoice findFirst
   */
  export interface QuizeChoiceFindFirstArgs extends QuizeChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeChoice findFirstOrThrow
   */
  export type QuizeChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter, which QuizeChoice to fetch.
     */
    where?: QuizeChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeChoices to fetch.
     */
    orderBy?: Enumerable<QuizeChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeChoices.
     */
    cursor?: QuizeChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeChoices.
     */
    distinct?: Enumerable<QuizeChoiceScalarFieldEnum>
  }


  /**
   * QuizeChoice findMany
   */
  export type QuizeChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter, which QuizeChoices to fetch.
     */
    where?: QuizeChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeChoices to fetch.
     */
    orderBy?: Enumerable<QuizeChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeChoices.
     */
    cursor?: QuizeChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeChoices.
     */
    skip?: number
    distinct?: Enumerable<QuizeChoiceScalarFieldEnum>
  }


  /**
   * QuizeChoice create
   */
  export type QuizeChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * The data needed to create a QuizeChoice.
     */
    data: XOR<QuizeChoiceCreateInput, QuizeChoiceUncheckedCreateInput>
  }


  /**
   * QuizeChoice createMany
   */
  export type QuizeChoiceCreateManyArgs = {
    /**
     * The data used to create many QuizeChoices.
     */
    data: Enumerable<QuizeChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeChoice update
   */
  export type QuizeChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * The data needed to update a QuizeChoice.
     */
    data: XOR<QuizeChoiceUpdateInput, QuizeChoiceUncheckedUpdateInput>
    /**
     * Choose, which QuizeChoice to update.
     */
    where: QuizeChoiceWhereUniqueInput
  }


  /**
   * QuizeChoice updateMany
   */
  export type QuizeChoiceUpdateManyArgs = {
    /**
     * The data used to update QuizeChoices.
     */
    data: XOR<QuizeChoiceUpdateManyMutationInput, QuizeChoiceUncheckedUpdateManyInput>
    /**
     * Filter which QuizeChoices to update
     */
    where?: QuizeChoiceWhereInput
  }


  /**
   * QuizeChoice upsert
   */
  export type QuizeChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * The filter to search for the QuizeChoice to update in case it exists.
     */
    where: QuizeChoiceWhereUniqueInput
    /**
     * In case the QuizeChoice found by the `where` argument doesn't exist, create a new QuizeChoice with this data.
     */
    create: XOR<QuizeChoiceCreateInput, QuizeChoiceUncheckedCreateInput>
    /**
     * In case the QuizeChoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeChoiceUpdateInput, QuizeChoiceUncheckedUpdateInput>
  }


  /**
   * QuizeChoice delete
   */
  export type QuizeChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
    /**
     * Filter which QuizeChoice to delete.
     */
    where: QuizeChoiceWhereUniqueInput
  }


  /**
   * QuizeChoice deleteMany
   */
  export type QuizeChoiceDeleteManyArgs = {
    /**
     * Filter which QuizeChoices to delete
     */
    where?: QuizeChoiceWhereInput
  }


  /**
   * QuizeChoice without action
   */
  export type QuizeChoiceArgs = {
    /**
     * Select specific fields to fetch from the QuizeChoice
     */
    select?: QuizeChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeChoiceInclude | null
  }



  /**
   * Model QuizeAnswer
   */


  export type AggregateQuizeAnswer = {
    _count: QuizeAnswerCountAggregateOutputType | null
    _avg: QuizeAnswerAvgAggregateOutputType | null
    _sum: QuizeAnswerSumAggregateOutputType | null
    _min: QuizeAnswerMinAggregateOutputType | null
    _max: QuizeAnswerMaxAggregateOutputType | null
  }

  export type QuizeAnswerAvgAggregateOutputType = {
    id: number | null
    choiceId: number | null
  }

  export type QuizeAnswerSumAggregateOutputType = {
    id: number | null
    choiceId: number | null
  }

  export type QuizeAnswerMinAggregateOutputType = {
    id: number | null
    answer: string | null
    choiceId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeAnswerMaxAggregateOutputType = {
    id: number | null
    answer: string | null
    choiceId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type QuizeAnswerCountAggregateOutputType = {
    id: number
    answer: number
    choiceId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type QuizeAnswerAvgAggregateInputType = {
    id?: true
    choiceId?: true
  }

  export type QuizeAnswerSumAggregateInputType = {
    id?: true
    choiceId?: true
  }

  export type QuizeAnswerMinAggregateInputType = {
    id?: true
    answer?: true
    choiceId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeAnswerMaxAggregateInputType = {
    id?: true
    answer?: true
    choiceId?: true
    createAt?: true
    updateAt?: true
  }

  export type QuizeAnswerCountAggregateInputType = {
    id?: true
    answer?: true
    choiceId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type QuizeAnswerAggregateArgs = {
    /**
     * Filter which QuizeAnswer to aggregate.
     */
    where?: QuizeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeAnswers to fetch.
     */
    orderBy?: Enumerable<QuizeAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeAnswers
    **/
    _count?: true | QuizeAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeAnswerMaxAggregateInputType
  }

  export type GetQuizeAnswerAggregateType<T extends QuizeAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeAnswer[P]>
      : GetScalarType<T[P], AggregateQuizeAnswer[P]>
  }




  export type QuizeAnswerGroupByArgs = {
    where?: QuizeAnswerWhereInput
    orderBy?: Enumerable<QuizeAnswerOrderByWithAggregationInput>
    by: QuizeAnswerScalarFieldEnum[]
    having?: QuizeAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeAnswerCountAggregateInputType | true
    _avg?: QuizeAnswerAvgAggregateInputType
    _sum?: QuizeAnswerSumAggregateInputType
    _min?: QuizeAnswerMinAggregateInputType
    _max?: QuizeAnswerMaxAggregateInputType
  }


  export type QuizeAnswerGroupByOutputType = {
    id: number
    answer: string
    choiceId: number
    createAt: Date
    updateAt: Date
    _count: QuizeAnswerCountAggregateOutputType | null
    _avg: QuizeAnswerAvgAggregateOutputType | null
    _sum: QuizeAnswerSumAggregateOutputType | null
    _min: QuizeAnswerMinAggregateOutputType | null
    _max: QuizeAnswerMaxAggregateOutputType | null
  }

  type GetQuizeAnswerGroupByPayload<T extends QuizeAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuizeAnswerSelect = {
    id?: boolean
    answer?: boolean
    quizeQuestion?: boolean | QuizeQuestionArgs
    choice?: boolean | QuizeChoiceArgs
    choiceId?: boolean
    createAt?: boolean
    updateAt?: boolean
    round?: boolean | QuizeGameRoundArgs
  }


  export type QuizeAnswerInclude = {
    quizeQuestion?: boolean | QuizeQuestionArgs
    choice?: boolean | QuizeChoiceArgs
    round?: boolean | QuizeGameRoundArgs
  }

  export type QuizeAnswerGetPayload<S extends boolean | null | undefined | QuizeAnswerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeAnswer :
    S extends undefined ? never :
    S extends { include: any } & (QuizeAnswerArgs | QuizeAnswerFindManyArgs)
    ? QuizeAnswer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quizeQuestion' ? QuizeQuestionGetPayload<S['include'][P]> | null :
        P extends 'choice' ? QuizeChoiceGetPayload<S['include'][P]> :
        P extends 'round' ? QuizeGameRoundGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuizeAnswerArgs | QuizeAnswerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quizeQuestion' ? QuizeQuestionGetPayload<S['select'][P]> | null :
        P extends 'choice' ? QuizeChoiceGetPayload<S['select'][P]> :
        P extends 'round' ? QuizeGameRoundGetPayload<S['select'][P]> | null :  P extends keyof QuizeAnswer ? QuizeAnswer[P] : never
  } 
      : QuizeAnswer


  type QuizeAnswerCountArgs = 
    Omit<QuizeAnswerFindManyArgs, 'select' | 'include'> & {
      select?: QuizeAnswerCountAggregateInputType | true
    }

  export interface QuizeAnswerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeAnswer that matches the filter.
     * @param {QuizeAnswerFindUniqueArgs} args - Arguments to find a QuizeAnswer
     * @example
     * // Get one QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeAnswer'> extends True ? Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>> : Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T> | null, null>

    /**
     * Find one QuizeAnswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuizeAnswer
     * @example
     * // Get one QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeAnswerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeAnswerFindUniqueOrThrowArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Find the first QuizeAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerFindFirstArgs} args - Arguments to find a QuizeAnswer
     * @example
     * // Get one QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeAnswer'> extends True ? Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>> : Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T> | null, null>

    /**
     * Find the first QuizeAnswer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerFindFirstOrThrowArgs} args - Arguments to find a QuizeAnswer
     * @example
     * // Get one QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeAnswerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeAnswerFindFirstOrThrowArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Find zero or more QuizeAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeAnswers
     * const quizeAnswers = await prisma.quizeAnswer.findMany()
     * 
     * // Get first 10 QuizeAnswers
     * const quizeAnswers = await prisma.quizeAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeAnswerWithIdOnly = await prisma.quizeAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeAnswerFindManyArgs>(
      args?: SelectSubset<T, QuizeAnswerFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeAnswerGetPayload<T>>>

    /**
     * Create a QuizeAnswer.
     * @param {QuizeAnswerCreateArgs} args - Arguments to create a QuizeAnswer.
     * @example
     * // Create one QuizeAnswer
     * const QuizeAnswer = await prisma.quizeAnswer.create({
     *   data: {
     *     // ... data to create a QuizeAnswer
     *   }
     * })
     * 
    **/
    create<T extends QuizeAnswerCreateArgs>(
      args: SelectSubset<T, QuizeAnswerCreateArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Create many QuizeAnswers.
     *     @param {QuizeAnswerCreateManyArgs} args - Arguments to create many QuizeAnswers.
     *     @example
     *     // Create many QuizeAnswers
     *     const quizeAnswer = await prisma.quizeAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeAnswerCreateManyArgs>(
      args?: SelectSubset<T, QuizeAnswerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeAnswer.
     * @param {QuizeAnswerDeleteArgs} args - Arguments to delete one QuizeAnswer.
     * @example
     * // Delete one QuizeAnswer
     * const QuizeAnswer = await prisma.quizeAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuizeAnswer
     *   }
     * })
     * 
    **/
    delete<T extends QuizeAnswerDeleteArgs>(
      args: SelectSubset<T, QuizeAnswerDeleteArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Update one QuizeAnswer.
     * @param {QuizeAnswerUpdateArgs} args - Arguments to update one QuizeAnswer.
     * @example
     * // Update one QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeAnswerUpdateArgs>(
      args: SelectSubset<T, QuizeAnswerUpdateArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Delete zero or more QuizeAnswers.
     * @param {QuizeAnswerDeleteManyArgs} args - Arguments to filter QuizeAnswers to delete.
     * @example
     * // Delete a few QuizeAnswers
     * const { count } = await prisma.quizeAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeAnswerDeleteManyArgs>(
      args?: SelectSubset<T, QuizeAnswerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeAnswers
     * const quizeAnswer = await prisma.quizeAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeAnswerUpdateManyArgs>(
      args: SelectSubset<T, QuizeAnswerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeAnswer.
     * @param {QuizeAnswerUpsertArgs} args - Arguments to update or create a QuizeAnswer.
     * @example
     * // Update or create a QuizeAnswer
     * const quizeAnswer = await prisma.quizeAnswer.upsert({
     *   create: {
     *     // ... data to create a QuizeAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeAnswerUpsertArgs>(
      args: SelectSubset<T, QuizeAnswerUpsertArgs>
    ): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T>>

    /**
     * Count the number of QuizeAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerCountArgs} args - Arguments to filter QuizeAnswers to count.
     * @example
     * // Count the number of QuizeAnswers
     * const count = await prisma.quizeAnswer.count({
     *   where: {
     *     // ... the filter for the QuizeAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuizeAnswerCountArgs>(
      args?: Subset<T, QuizeAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeAnswerAggregateArgs>(args: Subset<T, QuizeAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuizeAnswerAggregateType<T>>

    /**
     * Group by QuizeAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuizeAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeAnswerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    quizeQuestion<T extends QuizeQuestionArgs= {}>(args?: Subset<T, QuizeQuestionArgs>): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T> | Null>;

    choice<T extends QuizeChoiceArgs= {}>(args?: Subset<T, QuizeChoiceArgs>): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T> | Null>;

    round<T extends QuizeGameRoundArgs= {}>(args?: Subset<T, QuizeGameRoundArgs>): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeAnswer base type for findUnique actions
   */
  export type QuizeAnswerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter, which QuizeAnswer to fetch.
     */
    where: QuizeAnswerWhereUniqueInput
  }

  /**
   * QuizeAnswer findUnique
   */
  export interface QuizeAnswerFindUniqueArgs extends QuizeAnswerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeAnswer findUniqueOrThrow
   */
  export type QuizeAnswerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter, which QuizeAnswer to fetch.
     */
    where: QuizeAnswerWhereUniqueInput
  }


  /**
   * QuizeAnswer base type for findFirst actions
   */
  export type QuizeAnswerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter, which QuizeAnswer to fetch.
     */
    where?: QuizeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeAnswers to fetch.
     */
    orderBy?: Enumerable<QuizeAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeAnswers.
     */
    cursor?: QuizeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeAnswers.
     */
    distinct?: Enumerable<QuizeAnswerScalarFieldEnum>
  }

  /**
   * QuizeAnswer findFirst
   */
  export interface QuizeAnswerFindFirstArgs extends QuizeAnswerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeAnswer findFirstOrThrow
   */
  export type QuizeAnswerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter, which QuizeAnswer to fetch.
     */
    where?: QuizeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeAnswers to fetch.
     */
    orderBy?: Enumerable<QuizeAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeAnswers.
     */
    cursor?: QuizeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeAnswers.
     */
    distinct?: Enumerable<QuizeAnswerScalarFieldEnum>
  }


  /**
   * QuizeAnswer findMany
   */
  export type QuizeAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter, which QuizeAnswers to fetch.
     */
    where?: QuizeAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeAnswers to fetch.
     */
    orderBy?: Enumerable<QuizeAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeAnswers.
     */
    cursor?: QuizeAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeAnswers.
     */
    skip?: number
    distinct?: Enumerable<QuizeAnswerScalarFieldEnum>
  }


  /**
   * QuizeAnswer create
   */
  export type QuizeAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * The data needed to create a QuizeAnswer.
     */
    data: XOR<QuizeAnswerCreateInput, QuizeAnswerUncheckedCreateInput>
  }


  /**
   * QuizeAnswer createMany
   */
  export type QuizeAnswerCreateManyArgs = {
    /**
     * The data used to create many QuizeAnswers.
     */
    data: Enumerable<QuizeAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeAnswer update
   */
  export type QuizeAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * The data needed to update a QuizeAnswer.
     */
    data: XOR<QuizeAnswerUpdateInput, QuizeAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuizeAnswer to update.
     */
    where: QuizeAnswerWhereUniqueInput
  }


  /**
   * QuizeAnswer updateMany
   */
  export type QuizeAnswerUpdateManyArgs = {
    /**
     * The data used to update QuizeAnswers.
     */
    data: XOR<QuizeAnswerUpdateManyMutationInput, QuizeAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizeAnswers to update
     */
    where?: QuizeAnswerWhereInput
  }


  /**
   * QuizeAnswer upsert
   */
  export type QuizeAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * The filter to search for the QuizeAnswer to update in case it exists.
     */
    where: QuizeAnswerWhereUniqueInput
    /**
     * In case the QuizeAnswer found by the `where` argument doesn't exist, create a new QuizeAnswer with this data.
     */
    create: XOR<QuizeAnswerCreateInput, QuizeAnswerUncheckedCreateInput>
    /**
     * In case the QuizeAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeAnswerUpdateInput, QuizeAnswerUncheckedUpdateInput>
  }


  /**
   * QuizeAnswer delete
   */
  export type QuizeAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
    /**
     * Filter which QuizeAnswer to delete.
     */
    where: QuizeAnswerWhereUniqueInput
  }


  /**
   * QuizeAnswer deleteMany
   */
  export type QuizeAnswerDeleteManyArgs = {
    /**
     * Filter which QuizeAnswers to delete
     */
    where?: QuizeAnswerWhereInput
  }


  /**
   * QuizeAnswer without action
   */
  export type QuizeAnswerArgs = {
    /**
     * Select specific fields to fetch from the QuizeAnswer
     */
    select?: QuizeAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeAnswerInclude | null
  }



  /**
   * Model QuizeGameRound
   */


  export type AggregateQuizeGameRound = {
    _count: QuizeGameRoundCountAggregateOutputType | null
    _avg: QuizeGameRoundAvgAggregateOutputType | null
    _sum: QuizeGameRoundSumAggregateOutputType | null
    _min: QuizeGameRoundMinAggregateOutputType | null
    _max: QuizeGameRoundMaxAggregateOutputType | null
  }

  export type QuizeGameRoundAvgAggregateOutputType = {
    id: number | null
    score: number | null
    answerId: number | null
    questionId: number | null
    choiceId: number | null
  }

  export type QuizeGameRoundSumAggregateOutputType = {
    id: number | null
    score: number | null
    answerId: number | null
    questionId: number | null
    choiceId: number | null
  }

  export type QuizeGameRoundMinAggregateOutputType = {
    id: number | null
    user: string | null
    score: number | null
    answerId: number | null
    questionId: number | null
    choiceId: number | null
  }

  export type QuizeGameRoundMaxAggregateOutputType = {
    id: number | null
    user: string | null
    score: number | null
    answerId: number | null
    questionId: number | null
    choiceId: number | null
  }

  export type QuizeGameRoundCountAggregateOutputType = {
    id: number
    user: number
    score: number
    answerId: number
    questionId: number
    choiceId: number
    _all: number
  }


  export type QuizeGameRoundAvgAggregateInputType = {
    id?: true
    score?: true
    answerId?: true
    questionId?: true
    choiceId?: true
  }

  export type QuizeGameRoundSumAggregateInputType = {
    id?: true
    score?: true
    answerId?: true
    questionId?: true
    choiceId?: true
  }

  export type QuizeGameRoundMinAggregateInputType = {
    id?: true
    user?: true
    score?: true
    answerId?: true
    questionId?: true
    choiceId?: true
  }

  export type QuizeGameRoundMaxAggregateInputType = {
    id?: true
    user?: true
    score?: true
    answerId?: true
    questionId?: true
    choiceId?: true
  }

  export type QuizeGameRoundCountAggregateInputType = {
    id?: true
    user?: true
    score?: true
    answerId?: true
    questionId?: true
    choiceId?: true
    _all?: true
  }

  export type QuizeGameRoundAggregateArgs = {
    /**
     * Filter which QuizeGameRound to aggregate.
     */
    where?: QuizeGameRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeGameRounds to fetch.
     */
    orderBy?: Enumerable<QuizeGameRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizeGameRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeGameRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeGameRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizeGameRounds
    **/
    _count?: true | QuizeGameRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizeGameRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizeGameRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizeGameRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizeGameRoundMaxAggregateInputType
  }

  export type GetQuizeGameRoundAggregateType<T extends QuizeGameRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizeGameRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizeGameRound[P]>
      : GetScalarType<T[P], AggregateQuizeGameRound[P]>
  }




  export type QuizeGameRoundGroupByArgs = {
    where?: QuizeGameRoundWhereInput
    orderBy?: Enumerable<QuizeGameRoundOrderByWithAggregationInput>
    by: QuizeGameRoundScalarFieldEnum[]
    having?: QuizeGameRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizeGameRoundCountAggregateInputType | true
    _avg?: QuizeGameRoundAvgAggregateInputType
    _sum?: QuizeGameRoundSumAggregateInputType
    _min?: QuizeGameRoundMinAggregateInputType
    _max?: QuizeGameRoundMaxAggregateInputType
  }


  export type QuizeGameRoundGroupByOutputType = {
    id: number
    user: string
    score: number
    answerId: number
    questionId: number
    choiceId: number
    _count: QuizeGameRoundCountAggregateOutputType | null
    _avg: QuizeGameRoundAvgAggregateOutputType | null
    _sum: QuizeGameRoundSumAggregateOutputType | null
    _min: QuizeGameRoundMinAggregateOutputType | null
    _max: QuizeGameRoundMaxAggregateOutputType | null
  }

  type GetQuizeGameRoundGroupByPayload<T extends QuizeGameRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizeGameRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizeGameRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizeGameRoundGroupByOutputType[P]>
            : GetScalarType<T[P], QuizeGameRoundGroupByOutputType[P]>
        }
      >
    >


  export type QuizeGameRoundSelect = {
    id?: boolean
    user?: boolean
    score?: boolean
    answer?: boolean | QuizeAnswerArgs
    answerId?: boolean
    question?: boolean | QuizeQuestionArgs
    questionId?: boolean
    choice?: boolean | QuizeChoiceArgs
    choiceId?: boolean
  }


  export type QuizeGameRoundInclude = {
    answer?: boolean | QuizeAnswerArgs
    question?: boolean | QuizeQuestionArgs
    choice?: boolean | QuizeChoiceArgs
  }

  export type QuizeGameRoundGetPayload<S extends boolean | null | undefined | QuizeGameRoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizeGameRound :
    S extends undefined ? never :
    S extends { include: any } & (QuizeGameRoundArgs | QuizeGameRoundFindManyArgs)
    ? QuizeGameRound  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'answer' ? QuizeAnswerGetPayload<S['include'][P]> :
        P extends 'question' ? QuizeQuestionGetPayload<S['include'][P]> :
        P extends 'choice' ? QuizeChoiceGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizeGameRoundArgs | QuizeGameRoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'answer' ? QuizeAnswerGetPayload<S['select'][P]> :
        P extends 'question' ? QuizeQuestionGetPayload<S['select'][P]> :
        P extends 'choice' ? QuizeChoiceGetPayload<S['select'][P]> :  P extends keyof QuizeGameRound ? QuizeGameRound[P] : never
  } 
      : QuizeGameRound


  type QuizeGameRoundCountArgs = 
    Omit<QuizeGameRoundFindManyArgs, 'select' | 'include'> & {
      select?: QuizeGameRoundCountAggregateInputType | true
    }

  export interface QuizeGameRoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizeGameRound that matches the filter.
     * @param {QuizeGameRoundFindUniqueArgs} args - Arguments to find a QuizeGameRound
     * @example
     * // Get one QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizeGameRoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizeGameRoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizeGameRound'> extends True ? Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>> : Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T> | null, null>

    /**
     * Find one QuizeGameRound that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizeGameRoundFindUniqueOrThrowArgs} args - Arguments to find a QuizeGameRound
     * @example
     * // Get one QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizeGameRoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizeGameRoundFindUniqueOrThrowArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Find the first QuizeGameRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundFindFirstArgs} args - Arguments to find a QuizeGameRound
     * @example
     * // Get one QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizeGameRoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizeGameRoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizeGameRound'> extends True ? Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>> : Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T> | null, null>

    /**
     * Find the first QuizeGameRound that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundFindFirstOrThrowArgs} args - Arguments to find a QuizeGameRound
     * @example
     * // Get one QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizeGameRoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizeGameRoundFindFirstOrThrowArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Find zero or more QuizeGameRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizeGameRounds
     * const quizeGameRounds = await prisma.quizeGameRound.findMany()
     * 
     * // Get first 10 QuizeGameRounds
     * const quizeGameRounds = await prisma.quizeGameRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizeGameRoundWithIdOnly = await prisma.quizeGameRound.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizeGameRoundFindManyArgs>(
      args?: SelectSubset<T, QuizeGameRoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizeGameRoundGetPayload<T>>>

    /**
     * Create a QuizeGameRound.
     * @param {QuizeGameRoundCreateArgs} args - Arguments to create a QuizeGameRound.
     * @example
     * // Create one QuizeGameRound
     * const QuizeGameRound = await prisma.quizeGameRound.create({
     *   data: {
     *     // ... data to create a QuizeGameRound
     *   }
     * })
     * 
    **/
    create<T extends QuizeGameRoundCreateArgs>(
      args: SelectSubset<T, QuizeGameRoundCreateArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Create many QuizeGameRounds.
     *     @param {QuizeGameRoundCreateManyArgs} args - Arguments to create many QuizeGameRounds.
     *     @example
     *     // Create many QuizeGameRounds
     *     const quizeGameRound = await prisma.quizeGameRound.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizeGameRoundCreateManyArgs>(
      args?: SelectSubset<T, QuizeGameRoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizeGameRound.
     * @param {QuizeGameRoundDeleteArgs} args - Arguments to delete one QuizeGameRound.
     * @example
     * // Delete one QuizeGameRound
     * const QuizeGameRound = await prisma.quizeGameRound.delete({
     *   where: {
     *     // ... filter to delete one QuizeGameRound
     *   }
     * })
     * 
    **/
    delete<T extends QuizeGameRoundDeleteArgs>(
      args: SelectSubset<T, QuizeGameRoundDeleteArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Update one QuizeGameRound.
     * @param {QuizeGameRoundUpdateArgs} args - Arguments to update one QuizeGameRound.
     * @example
     * // Update one QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizeGameRoundUpdateArgs>(
      args: SelectSubset<T, QuizeGameRoundUpdateArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Delete zero or more QuizeGameRounds.
     * @param {QuizeGameRoundDeleteManyArgs} args - Arguments to filter QuizeGameRounds to delete.
     * @example
     * // Delete a few QuizeGameRounds
     * const { count } = await prisma.quizeGameRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizeGameRoundDeleteManyArgs>(
      args?: SelectSubset<T, QuizeGameRoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizeGameRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizeGameRounds
     * const quizeGameRound = await prisma.quizeGameRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizeGameRoundUpdateManyArgs>(
      args: SelectSubset<T, QuizeGameRoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizeGameRound.
     * @param {QuizeGameRoundUpsertArgs} args - Arguments to update or create a QuizeGameRound.
     * @example
     * // Update or create a QuizeGameRound
     * const quizeGameRound = await prisma.quizeGameRound.upsert({
     *   create: {
     *     // ... data to create a QuizeGameRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizeGameRound we want to update
     *   }
     * })
    **/
    upsert<T extends QuizeGameRoundUpsertArgs>(
      args: SelectSubset<T, QuizeGameRoundUpsertArgs>
    ): Prisma__QuizeGameRoundClient<QuizeGameRoundGetPayload<T>>

    /**
     * Count the number of QuizeGameRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundCountArgs} args - Arguments to filter QuizeGameRounds to count.
     * @example
     * // Count the number of QuizeGameRounds
     * const count = await prisma.quizeGameRound.count({
     *   where: {
     *     // ... the filter for the QuizeGameRounds we want to count
     *   }
     * })
    **/
    count<T extends QuizeGameRoundCountArgs>(
      args?: Subset<T, QuizeGameRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizeGameRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizeGameRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizeGameRoundAggregateArgs>(args: Subset<T, QuizeGameRoundAggregateArgs>): Prisma.PrismaPromise<GetQuizeGameRoundAggregateType<T>>

    /**
     * Group by QuizeGameRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizeGameRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizeGameRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizeGameRoundGroupByArgs['orderBy'] }
        : { orderBy?: QuizeGameRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizeGameRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizeGameRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizeGameRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizeGameRoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    answer<T extends QuizeAnswerArgs= {}>(args?: Subset<T, QuizeAnswerArgs>): Prisma__QuizeAnswerClient<QuizeAnswerGetPayload<T> | Null>;

    question<T extends QuizeQuestionArgs= {}>(args?: Subset<T, QuizeQuestionArgs>): Prisma__QuizeQuestionClient<QuizeQuestionGetPayload<T> | Null>;

    choice<T extends QuizeChoiceArgs= {}>(args?: Subset<T, QuizeChoiceArgs>): Prisma__QuizeChoiceClient<QuizeChoiceGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizeGameRound base type for findUnique actions
   */
  export type QuizeGameRoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter, which QuizeGameRound to fetch.
     */
    where: QuizeGameRoundWhereUniqueInput
  }

  /**
   * QuizeGameRound findUnique
   */
  export interface QuizeGameRoundFindUniqueArgs extends QuizeGameRoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeGameRound findUniqueOrThrow
   */
  export type QuizeGameRoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter, which QuizeGameRound to fetch.
     */
    where: QuizeGameRoundWhereUniqueInput
  }


  /**
   * QuizeGameRound base type for findFirst actions
   */
  export type QuizeGameRoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter, which QuizeGameRound to fetch.
     */
    where?: QuizeGameRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeGameRounds to fetch.
     */
    orderBy?: Enumerable<QuizeGameRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeGameRounds.
     */
    cursor?: QuizeGameRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeGameRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeGameRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeGameRounds.
     */
    distinct?: Enumerable<QuizeGameRoundScalarFieldEnum>
  }

  /**
   * QuizeGameRound findFirst
   */
  export interface QuizeGameRoundFindFirstArgs extends QuizeGameRoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizeGameRound findFirstOrThrow
   */
  export type QuizeGameRoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter, which QuizeGameRound to fetch.
     */
    where?: QuizeGameRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeGameRounds to fetch.
     */
    orderBy?: Enumerable<QuizeGameRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizeGameRounds.
     */
    cursor?: QuizeGameRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeGameRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeGameRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizeGameRounds.
     */
    distinct?: Enumerable<QuizeGameRoundScalarFieldEnum>
  }


  /**
   * QuizeGameRound findMany
   */
  export type QuizeGameRoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter, which QuizeGameRounds to fetch.
     */
    where?: QuizeGameRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizeGameRounds to fetch.
     */
    orderBy?: Enumerable<QuizeGameRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizeGameRounds.
     */
    cursor?: QuizeGameRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizeGameRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizeGameRounds.
     */
    skip?: number
    distinct?: Enumerable<QuizeGameRoundScalarFieldEnum>
  }


  /**
   * QuizeGameRound create
   */
  export type QuizeGameRoundCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * The data needed to create a QuizeGameRound.
     */
    data: XOR<QuizeGameRoundCreateInput, QuizeGameRoundUncheckedCreateInput>
  }


  /**
   * QuizeGameRound createMany
   */
  export type QuizeGameRoundCreateManyArgs = {
    /**
     * The data used to create many QuizeGameRounds.
     */
    data: Enumerable<QuizeGameRoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizeGameRound update
   */
  export type QuizeGameRoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * The data needed to update a QuizeGameRound.
     */
    data: XOR<QuizeGameRoundUpdateInput, QuizeGameRoundUncheckedUpdateInput>
    /**
     * Choose, which QuizeGameRound to update.
     */
    where: QuizeGameRoundWhereUniqueInput
  }


  /**
   * QuizeGameRound updateMany
   */
  export type QuizeGameRoundUpdateManyArgs = {
    /**
     * The data used to update QuizeGameRounds.
     */
    data: XOR<QuizeGameRoundUpdateManyMutationInput, QuizeGameRoundUncheckedUpdateManyInput>
    /**
     * Filter which QuizeGameRounds to update
     */
    where?: QuizeGameRoundWhereInput
  }


  /**
   * QuizeGameRound upsert
   */
  export type QuizeGameRoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * The filter to search for the QuizeGameRound to update in case it exists.
     */
    where: QuizeGameRoundWhereUniqueInput
    /**
     * In case the QuizeGameRound found by the `where` argument doesn't exist, create a new QuizeGameRound with this data.
     */
    create: XOR<QuizeGameRoundCreateInput, QuizeGameRoundUncheckedCreateInput>
    /**
     * In case the QuizeGameRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizeGameRoundUpdateInput, QuizeGameRoundUncheckedUpdateInput>
  }


  /**
   * QuizeGameRound delete
   */
  export type QuizeGameRoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
    /**
     * Filter which QuizeGameRound to delete.
     */
    where: QuizeGameRoundWhereUniqueInput
  }


  /**
   * QuizeGameRound deleteMany
   */
  export type QuizeGameRoundDeleteManyArgs = {
    /**
     * Filter which QuizeGameRounds to delete
     */
    where?: QuizeGameRoundWhereInput
  }


  /**
   * QuizeGameRound without action
   */
  export type QuizeGameRoundArgs = {
    /**
     * Select specific fields to fetch from the QuizeGameRound
     */
    select?: QuizeGameRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizeGameRoundInclude | null
  }



  /**
   * Model MainCompany
   */


  export type AggregateMainCompany = {
    _count: MainCompanyCountAggregateOutputType | null
    _avg: MainCompanyAvgAggregateOutputType | null
    _sum: MainCompanySumAggregateOutputType | null
    _min: MainCompanyMinAggregateOutputType | null
    _max: MainCompanyMaxAggregateOutputType | null
  }

  export type MainCompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type MainCompanySumAggregateOutputType = {
    id: number | null
  }

  export type MainCompanyMinAggregateOutputType = {
    id: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MainCompanyMaxAggregateOutputType = {
    id: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MainCompanyCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type MainCompanyAvgAggregateInputType = {
    id?: true
  }

  export type MainCompanySumAggregateInputType = {
    id?: true
  }

  export type MainCompanyMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
  }

  export type MainCompanyMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
  }

  export type MainCompanyCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type MainCompanyAggregateArgs = {
    /**
     * Filter which MainCompany to aggregate.
     */
    where?: MainCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCompanies to fetch.
     */
    orderBy?: Enumerable<MainCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MainCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MainCompanies
    **/
    _count?: true | MainCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MainCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MainCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MainCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MainCompanyMaxAggregateInputType
  }

  export type GetMainCompanyAggregateType<T extends MainCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateMainCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMainCompany[P]>
      : GetScalarType<T[P], AggregateMainCompany[P]>
  }




  export type MainCompanyGroupByArgs = {
    where?: MainCompanyWhereInput
    orderBy?: Enumerable<MainCompanyOrderByWithAggregationInput>
    by: MainCompanyScalarFieldEnum[]
    having?: MainCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MainCompanyCountAggregateInputType | true
    _avg?: MainCompanyAvgAggregateInputType
    _sum?: MainCompanySumAggregateInputType
    _min?: MainCompanyMinAggregateInputType
    _max?: MainCompanyMaxAggregateInputType
  }


  export type MainCompanyGroupByOutputType = {
    id: number
    createAt: Date
    updateAt: Date
    _count: MainCompanyCountAggregateOutputType | null
    _avg: MainCompanyAvgAggregateOutputType | null
    _sum: MainCompanySumAggregateOutputType | null
    _min: MainCompanyMinAggregateOutputType | null
    _max: MainCompanyMaxAggregateOutputType | null
  }

  type GetMainCompanyGroupByPayload<T extends MainCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MainCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MainCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MainCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], MainCompanyGroupByOutputType[P]>
        }
      >
    >


  export type MainCompanySelect = {
    id?: boolean
    branchIds?: boolean | MainCompany$branchIdsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | MainCompanyCountOutputTypeArgs
  }


  export type MainCompanyInclude = {
    branchIds?: boolean | MainCompany$branchIdsArgs
    _count?: boolean | MainCompanyCountOutputTypeArgs
  }

  export type MainCompanyGetPayload<S extends boolean | null | undefined | MainCompanyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MainCompany :
    S extends undefined ? never :
    S extends { include: any } & (MainCompanyArgs | MainCompanyFindManyArgs)
    ? MainCompany  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'branchIds' ? Array < BranchGetPayload<S['include'][P]>>  :
        P extends '_count' ? MainCompanyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MainCompanyArgs | MainCompanyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'branchIds' ? Array < BranchGetPayload<S['select'][P]>>  :
        P extends '_count' ? MainCompanyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MainCompany ? MainCompany[P] : never
  } 
      : MainCompany


  type MainCompanyCountArgs = 
    Omit<MainCompanyFindManyArgs, 'select' | 'include'> & {
      select?: MainCompanyCountAggregateInputType | true
    }

  export interface MainCompanyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MainCompany that matches the filter.
     * @param {MainCompanyFindUniqueArgs} args - Arguments to find a MainCompany
     * @example
     * // Get one MainCompany
     * const mainCompany = await prisma.mainCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MainCompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MainCompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MainCompany'> extends True ? Prisma__MainCompanyClient<MainCompanyGetPayload<T>> : Prisma__MainCompanyClient<MainCompanyGetPayload<T> | null, null>

    /**
     * Find one MainCompany that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MainCompanyFindUniqueOrThrowArgs} args - Arguments to find a MainCompany
     * @example
     * // Get one MainCompany
     * const mainCompany = await prisma.mainCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MainCompanyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MainCompanyFindUniqueOrThrowArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Find the first MainCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyFindFirstArgs} args - Arguments to find a MainCompany
     * @example
     * // Get one MainCompany
     * const mainCompany = await prisma.mainCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MainCompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MainCompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MainCompany'> extends True ? Prisma__MainCompanyClient<MainCompanyGetPayload<T>> : Prisma__MainCompanyClient<MainCompanyGetPayload<T> | null, null>

    /**
     * Find the first MainCompany that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyFindFirstOrThrowArgs} args - Arguments to find a MainCompany
     * @example
     * // Get one MainCompany
     * const mainCompany = await prisma.mainCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MainCompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MainCompanyFindFirstOrThrowArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Find zero or more MainCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MainCompanies
     * const mainCompanies = await prisma.mainCompany.findMany()
     * 
     * // Get first 10 MainCompanies
     * const mainCompanies = await prisma.mainCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mainCompanyWithIdOnly = await prisma.mainCompany.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MainCompanyFindManyArgs>(
      args?: SelectSubset<T, MainCompanyFindManyArgs>
    ): Prisma.PrismaPromise<Array<MainCompanyGetPayload<T>>>

    /**
     * Create a MainCompany.
     * @param {MainCompanyCreateArgs} args - Arguments to create a MainCompany.
     * @example
     * // Create one MainCompany
     * const MainCompany = await prisma.mainCompany.create({
     *   data: {
     *     // ... data to create a MainCompany
     *   }
     * })
     * 
    **/
    create<T extends MainCompanyCreateArgs>(
      args: SelectSubset<T, MainCompanyCreateArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Create many MainCompanies.
     *     @param {MainCompanyCreateManyArgs} args - Arguments to create many MainCompanies.
     *     @example
     *     // Create many MainCompanies
     *     const mainCompany = await prisma.mainCompany.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MainCompanyCreateManyArgs>(
      args?: SelectSubset<T, MainCompanyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MainCompany.
     * @param {MainCompanyDeleteArgs} args - Arguments to delete one MainCompany.
     * @example
     * // Delete one MainCompany
     * const MainCompany = await prisma.mainCompany.delete({
     *   where: {
     *     // ... filter to delete one MainCompany
     *   }
     * })
     * 
    **/
    delete<T extends MainCompanyDeleteArgs>(
      args: SelectSubset<T, MainCompanyDeleteArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Update one MainCompany.
     * @param {MainCompanyUpdateArgs} args - Arguments to update one MainCompany.
     * @example
     * // Update one MainCompany
     * const mainCompany = await prisma.mainCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MainCompanyUpdateArgs>(
      args: SelectSubset<T, MainCompanyUpdateArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Delete zero or more MainCompanies.
     * @param {MainCompanyDeleteManyArgs} args - Arguments to filter MainCompanies to delete.
     * @example
     * // Delete a few MainCompanies
     * const { count } = await prisma.mainCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MainCompanyDeleteManyArgs>(
      args?: SelectSubset<T, MainCompanyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MainCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MainCompanies
     * const mainCompany = await prisma.mainCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MainCompanyUpdateManyArgs>(
      args: SelectSubset<T, MainCompanyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MainCompany.
     * @param {MainCompanyUpsertArgs} args - Arguments to update or create a MainCompany.
     * @example
     * // Update or create a MainCompany
     * const mainCompany = await prisma.mainCompany.upsert({
     *   create: {
     *     // ... data to create a MainCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MainCompany we want to update
     *   }
     * })
    **/
    upsert<T extends MainCompanyUpsertArgs>(
      args: SelectSubset<T, MainCompanyUpsertArgs>
    ): Prisma__MainCompanyClient<MainCompanyGetPayload<T>>

    /**
     * Count the number of MainCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyCountArgs} args - Arguments to filter MainCompanies to count.
     * @example
     * // Count the number of MainCompanies
     * const count = await prisma.mainCompany.count({
     *   where: {
     *     // ... the filter for the MainCompanies we want to count
     *   }
     * })
    **/
    count<T extends MainCompanyCountArgs>(
      args?: Subset<T, MainCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MainCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MainCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MainCompanyAggregateArgs>(args: Subset<T, MainCompanyAggregateArgs>): Prisma.PrismaPromise<GetMainCompanyAggregateType<T>>

    /**
     * Group by MainCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MainCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MainCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MainCompanyGroupByArgs['orderBy'] }
        : { orderBy?: MainCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MainCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMainCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MainCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MainCompanyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    branchIds<T extends MainCompany$branchIdsArgs= {}>(args?: Subset<T, MainCompany$branchIdsArgs>): Prisma.PrismaPromise<Array<BranchGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MainCompany base type for findUnique actions
   */
  export type MainCompanyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter, which MainCompany to fetch.
     */
    where: MainCompanyWhereUniqueInput
  }

  /**
   * MainCompany findUnique
   */
  export interface MainCompanyFindUniqueArgs extends MainCompanyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MainCompany findUniqueOrThrow
   */
  export type MainCompanyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter, which MainCompany to fetch.
     */
    where: MainCompanyWhereUniqueInput
  }


  /**
   * MainCompany base type for findFirst actions
   */
  export type MainCompanyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter, which MainCompany to fetch.
     */
    where?: MainCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCompanies to fetch.
     */
    orderBy?: Enumerable<MainCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainCompanies.
     */
    cursor?: MainCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainCompanies.
     */
    distinct?: Enumerable<MainCompanyScalarFieldEnum>
  }

  /**
   * MainCompany findFirst
   */
  export interface MainCompanyFindFirstArgs extends MainCompanyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MainCompany findFirstOrThrow
   */
  export type MainCompanyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter, which MainCompany to fetch.
     */
    where?: MainCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCompanies to fetch.
     */
    orderBy?: Enumerable<MainCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MainCompanies.
     */
    cursor?: MainCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MainCompanies.
     */
    distinct?: Enumerable<MainCompanyScalarFieldEnum>
  }


  /**
   * MainCompany findMany
   */
  export type MainCompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter, which MainCompanies to fetch.
     */
    where?: MainCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MainCompanies to fetch.
     */
    orderBy?: Enumerable<MainCompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MainCompanies.
     */
    cursor?: MainCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MainCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MainCompanies.
     */
    skip?: number
    distinct?: Enumerable<MainCompanyScalarFieldEnum>
  }


  /**
   * MainCompany create
   */
  export type MainCompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * The data needed to create a MainCompany.
     */
    data: XOR<MainCompanyCreateInput, MainCompanyUncheckedCreateInput>
  }


  /**
   * MainCompany createMany
   */
  export type MainCompanyCreateManyArgs = {
    /**
     * The data used to create many MainCompanies.
     */
    data: Enumerable<MainCompanyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MainCompany update
   */
  export type MainCompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * The data needed to update a MainCompany.
     */
    data: XOR<MainCompanyUpdateInput, MainCompanyUncheckedUpdateInput>
    /**
     * Choose, which MainCompany to update.
     */
    where: MainCompanyWhereUniqueInput
  }


  /**
   * MainCompany updateMany
   */
  export type MainCompanyUpdateManyArgs = {
    /**
     * The data used to update MainCompanies.
     */
    data: XOR<MainCompanyUpdateManyMutationInput, MainCompanyUncheckedUpdateManyInput>
    /**
     * Filter which MainCompanies to update
     */
    where?: MainCompanyWhereInput
  }


  /**
   * MainCompany upsert
   */
  export type MainCompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * The filter to search for the MainCompany to update in case it exists.
     */
    where: MainCompanyWhereUniqueInput
    /**
     * In case the MainCompany found by the `where` argument doesn't exist, create a new MainCompany with this data.
     */
    create: XOR<MainCompanyCreateInput, MainCompanyUncheckedCreateInput>
    /**
     * In case the MainCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MainCompanyUpdateInput, MainCompanyUncheckedUpdateInput>
  }


  /**
   * MainCompany delete
   */
  export type MainCompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
    /**
     * Filter which MainCompany to delete.
     */
    where: MainCompanyWhereUniqueInput
  }


  /**
   * MainCompany deleteMany
   */
  export type MainCompanyDeleteManyArgs = {
    /**
     * Filter which MainCompanies to delete
     */
    where?: MainCompanyWhereInput
  }


  /**
   * MainCompany.branchIds
   */
  export type MainCompany$branchIdsArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    where?: BranchWhereInput
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * MainCompany without action
   */
  export type MainCompanyArgs = {
    /**
     * Select specific fields to fetch from the MainCompany
     */
    select?: MainCompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MainCompanyInclude | null
  }



  /**
   * Model Branch
   */


  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
    tel: number | null
    area: number | null
    totolMachine: number | null
    mainCompanyId: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
    tel: number | null
    area: number | null
    totolMachine: number | null
    mainCompanyId: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    ownerName: string | null
    tel: number | null
    address: string | null
    area: number | null
    totolMachine: number | null
    mainCompanyId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    ownerName: string | null
    tel: number | null
    address: string | null
    area: number | null
    totolMachine: number | null
    mainCompanyId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    ownerName: number
    tel: number
    address: number
    area: number
    totolMachine: number
    mainCompanyId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
    tel?: true
    area?: true
    totolMachine?: true
    mainCompanyId?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
    tel?: true
    area?: true
    totolMachine?: true
    mainCompanyId?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    ownerName?: true
    tel?: true
    address?: true
    area?: true
    totolMachine?: true
    mainCompanyId?: true
    createAt?: true
    updateAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    ownerName?: true
    tel?: true
    address?: true
    area?: true
    totolMachine?: true
    mainCompanyId?: true
    createAt?: true
    updateAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    ownerName?: true
    tel?: true
    address?: true
    area?: true
    totolMachine?: true
    mainCompanyId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type BranchAggregateArgs = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs = {
    where?: BranchWhereInput
    orderBy?: Enumerable<BranchOrderByWithAggregationInput>
    by: BranchScalarFieldEnum[]
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }


  export type BranchGroupByOutputType = {
    id: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    mainCompanyId: number | null
    createAt: Date
    updateAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect = {
    id?: boolean
    ownerName?: boolean
    tel?: boolean
    address?: boolean
    area?: boolean
    totolMachine?: boolean
    machines?: boolean | Branch$machinesArgs
    mainCompany?: boolean | MainCompanyArgs
    mainCompanyId?: boolean
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | BranchCountOutputTypeArgs
  }


  export type BranchInclude = {
    machines?: boolean | Branch$machinesArgs
    mainCompany?: boolean | MainCompanyArgs
    _count?: boolean | BranchCountOutputTypeArgs
  }

  export type BranchGetPayload<S extends boolean | null | undefined | BranchArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Branch :
    S extends undefined ? never :
    S extends { include: any } & (BranchArgs | BranchFindManyArgs)
    ? Branch  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machines' ? Array < MachineGetPayload<S['include'][P]>>  :
        P extends 'mainCompany' ? MainCompanyGetPayload<S['include'][P]> | null :
        P extends '_count' ? BranchCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BranchArgs | BranchFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machines' ? Array < MachineGetPayload<S['select'][P]>>  :
        P extends 'mainCompany' ? MainCompanyGetPayload<S['select'][P]> | null :
        P extends '_count' ? BranchCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Branch ? Branch[P] : never
  } 
      : Branch


  type BranchCountArgs = 
    Omit<BranchFindManyArgs, 'select' | 'include'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BranchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BranchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Branch'> extends True ? Prisma__BranchClient<BranchGetPayload<T>> : Prisma__BranchClient<BranchGetPayload<T> | null, null>

    /**
     * Find one Branch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BranchFindUniqueOrThrowArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BranchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BranchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Branch'> extends True ? Prisma__BranchClient<BranchGetPayload<T>> : Prisma__BranchClient<BranchGetPayload<T> | null, null>

    /**
     * Find the first Branch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BranchFindFirstOrThrowArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BranchFindManyArgs>(
      args?: SelectSubset<T, BranchFindManyArgs>
    ): Prisma.PrismaPromise<Array<BranchGetPayload<T>>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
    **/
    create<T extends BranchCreateArgs>(
      args: SelectSubset<T, BranchCreateArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Create many Branches.
     *     @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     *     @example
     *     // Create many Branches
     *     const branch = await prisma.branch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BranchCreateManyArgs>(
      args?: SelectSubset<T, BranchCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
    **/
    delete<T extends BranchDeleteArgs>(
      args: SelectSubset<T, BranchDeleteArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BranchUpdateArgs>(
      args: SelectSubset<T, BranchUpdateArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BranchDeleteManyArgs>(
      args?: SelectSubset<T, BranchDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BranchUpdateManyArgs>(
      args: SelectSubset<T, BranchUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
    **/
    upsert<T extends BranchUpsertArgs>(
      args: SelectSubset<T, BranchUpsertArgs>
    ): Prisma__BranchClient<BranchGetPayload<T>>

    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BranchClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machines<T extends Branch$machinesArgs= {}>(args?: Subset<T, Branch$machinesArgs>): Prisma.PrismaPromise<Array<MachineGetPayload<T>>| Null>;

    mainCompany<T extends MainCompanyArgs= {}>(args?: Subset<T, MainCompanyArgs>): Prisma__MainCompanyClient<MainCompanyGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Branch base type for findUnique actions
   */
  export type BranchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUnique
   */
  export interface BranchFindUniqueArgs extends BranchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch base type for findFirst actions
   */
  export type BranchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: Enumerable<BranchScalarFieldEnum>
  }

  /**
   * Branch findFirst
   */
  export interface BranchFindFirstArgs extends BranchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * Branch findMany
   */
  export type BranchFindManyArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: Enumerable<BranchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: Enumerable<BranchScalarFieldEnum>
  }


  /**
   * Branch create
   */
  export type BranchCreateArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }


  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs = {
    /**
     * The data used to create many Branches.
     */
    data: Enumerable<BranchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Branch update
   */
  export type BranchUpdateArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }


  /**
   * Branch upsert
   */
  export type BranchUpsertArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }


  /**
   * Branch delete
   */
  export type BranchDeleteArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }


  /**
   * Branch.machines
   */
  export type Branch$machinesArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    where?: MachineWhereInput
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Branch without action
   */
  export type BranchArgs = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude | null
  }



  /**
   * Model Machine
   */


  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    washHistoryId: number | null
  }

  export type MachineSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    washHistoryId: number | null
  }

  export type MachineMinAggregateOutputType = {
    id: number | null
    brand: string | null
    size: string | null
    category: string | null
    model: string | null
    mfg: string | null
    insurance: string | null
    branchId: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MachineMaxAggregateOutputType = {
    id: number | null
    brand: string | null
    size: string | null
    category: string | null
    model: string | null
    mfg: string | null
    insurance: string | null
    branchId: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    brand: number
    size: number
    category: number
    model: number
    mfg: number
    insurance: number
    branchId: number
    washHistoryId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type MachineAvgAggregateInputType = {
    id?: true
    branchId?: true
    washHistoryId?: true
  }

  export type MachineSumAggregateInputType = {
    id?: true
    branchId?: true
    washHistoryId?: true
  }

  export type MachineMinAggregateInputType = {
    id?: true
    brand?: true
    size?: true
    category?: true
    model?: true
    mfg?: true
    insurance?: true
    branchId?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    brand?: true
    size?: true
    category?: true
    model?: true
    mfg?: true
    insurance?: true
    branchId?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    brand?: true
    size?: true
    category?: true
    model?: true
    mfg?: true
    insurance?: true
    branchId?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type MachineAggregateArgs = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs = {
    where?: MachineWhereInput
    orderBy?: Enumerable<MachineOrderByWithAggregationInput>
    by: MachineScalarFieldEnum[]
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _avg?: MachineAvgAggregateInputType
    _sum?: MachineSumAggregateInputType
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }


  export type MachineGroupByOutputType = {
    id: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId: number | null
    washHistoryId: number | null
    createAt: Date
    updateAt: Date
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect = {
    id?: boolean
    brand?: boolean
    size?: boolean
    category?: boolean
    model?: boolean
    mfg?: boolean
    insurance?: boolean
    branch?: boolean | BranchArgs
    branchId?: boolean
    repairHistories?: boolean | Machine$repairHistoriesArgs
    washHistory?: boolean | WashHistoryArgs
    washHistoryId?: boolean
    machineOnPrograms?: boolean | Machine$machineOnProgramsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | MachineCountOutputTypeArgs
  }


  export type MachineInclude = {
    branch?: boolean | BranchArgs
    repairHistories?: boolean | Machine$repairHistoriesArgs
    washHistory?: boolean | WashHistoryArgs
    machineOnPrograms?: boolean | Machine$machineOnProgramsArgs
    _count?: boolean | MachineCountOutputTypeArgs
  }

  export type MachineGetPayload<S extends boolean | null | undefined | MachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Machine :
    S extends undefined ? never :
    S extends { include: any } & (MachineArgs | MachineFindManyArgs)
    ? Machine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'branch' ? BranchGetPayload<S['include'][P]> | null :
        P extends 'repairHistories' ? Array < RepairHistoryGetPayload<S['include'][P]>>  :
        P extends 'washHistory' ? WashHistoryGetPayload<S['include'][P]> | null :
        P extends 'machineOnPrograms' ? Array < MachineOnProgramGetPayload<S['include'][P]>>  :
        P extends '_count' ? MachineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MachineArgs | MachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'branch' ? BranchGetPayload<S['select'][P]> | null :
        P extends 'repairHistories' ? Array < RepairHistoryGetPayload<S['select'][P]>>  :
        P extends 'washHistory' ? WashHistoryGetPayload<S['select'][P]> | null :
        P extends 'machineOnPrograms' ? Array < MachineOnProgramGetPayload<S['select'][P]>>  :
        P extends '_count' ? MachineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Machine ? Machine[P] : never
  } 
      : Machine


  type MachineCountArgs = 
    Omit<MachineFindManyArgs, 'select' | 'include'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Machine'> extends True ? Prisma__MachineClient<MachineGetPayload<T>> : Prisma__MachineClient<MachineGetPayload<T> | null, null>

    /**
     * Find one Machine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MachineFindUniqueOrThrowArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Machine'> extends True ? Prisma__MachineClient<MachineGetPayload<T>> : Prisma__MachineClient<MachineGetPayload<T> | null, null>

    /**
     * Find the first Machine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MachineFindFirstOrThrowArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MachineFindManyArgs>(
      args?: SelectSubset<T, MachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<MachineGetPayload<T>>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
    **/
    create<T extends MachineCreateArgs>(
      args: SelectSubset<T, MachineCreateArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Create many Machines.
     *     @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     *     @example
     *     // Create many Machines
     *     const machine = await prisma.machine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MachineCreateManyArgs>(
      args?: SelectSubset<T, MachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
    **/
    delete<T extends MachineDeleteArgs>(
      args: SelectSubset<T, MachineDeleteArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MachineUpdateArgs>(
      args: SelectSubset<T, MachineUpdateArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MachineDeleteManyArgs>(
      args?: SelectSubset<T, MachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MachineUpdateManyArgs>(
      args: SelectSubset<T, MachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
    **/
    upsert<T extends MachineUpsertArgs>(
      args: SelectSubset<T, MachineUpsertArgs>
    ): Prisma__MachineClient<MachineGetPayload<T>>

    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    branch<T extends BranchArgs= {}>(args?: Subset<T, BranchArgs>): Prisma__BranchClient<BranchGetPayload<T> | Null>;

    repairHistories<T extends Machine$repairHistoriesArgs= {}>(args?: Subset<T, Machine$repairHistoriesArgs>): Prisma.PrismaPromise<Array<RepairHistoryGetPayload<T>>| Null>;

    washHistory<T extends WashHistoryArgs= {}>(args?: Subset<T, WashHistoryArgs>): Prisma__WashHistoryClient<WashHistoryGetPayload<T> | Null>;

    machineOnPrograms<T extends Machine$machineOnProgramsArgs= {}>(args?: Subset<T, Machine$machineOnProgramsArgs>): Prisma.PrismaPromise<Array<MachineOnProgramGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Machine base type for findUnique actions
   */
  export type MachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUnique
   */
  export interface MachineFindUniqueArgs extends MachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine base type for findFirst actions
   */
  export type MachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: Enumerable<MachineScalarFieldEnum>
  }

  /**
   * Machine findFirst
   */
  export interface MachineFindFirstArgs extends MachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Machine findMany
   */
  export type MachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * Machine create
   */
  export type MachineCreateArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }


  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs = {
    /**
     * The data used to create many Machines.
     */
    data: Enumerable<MachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Machine update
   */
  export type MachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
  }


  /**
   * Machine upsert
   */
  export type MachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }


  /**
   * Machine delete
   */
  export type MachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }


  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
  }


  /**
   * Machine.repairHistories
   */
  export type Machine$repairHistoriesArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    where?: RepairHistoryWhereInput
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    cursor?: RepairHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RepairHistoryScalarFieldEnum>
  }


  /**
   * Machine.machineOnPrograms
   */
  export type Machine$machineOnProgramsArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    where?: MachineOnProgramWhereInput
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    cursor?: MachineOnProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineOnProgramScalarFieldEnum>
  }


  /**
   * Machine without action
   */
  export type MachineArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
  }



  /**
   * Model Program
   */


  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    washHistoryId: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    washHistoryId: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    duration: number | null
    price: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    duration: number
    price: number
    washHistoryId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    washHistoryId?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    washHistoryId?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    duration?: true
    price?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: Enumerable<ProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs = {
    where?: ProgramWhereInput
    orderBy?: Enumerable<ProgramOrderByWithAggregationInput>
    by: ProgramScalarFieldEnum[]
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }


  export type ProgramGroupByOutputType = {
    id: number
    duration: number
    price: number
    washHistoryId: number | null
    createAt: Date
    updateAt: Date
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect = {
    id?: boolean
    duration?: boolean
    price?: boolean
    processes?: boolean | Program$processesArgs
    washHistory?: boolean | WashHistoryArgs
    washHistoryId?: boolean
    machineOnPrograms?: boolean | Program$machineOnProgramsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | ProgramCountOutputTypeArgs
  }


  export type ProgramInclude = {
    processes?: boolean | Program$processesArgs
    washHistory?: boolean | WashHistoryArgs
    machineOnPrograms?: boolean | Program$machineOnProgramsArgs
    _count?: boolean | ProgramCountOutputTypeArgs
  }

  export type ProgramGetPayload<S extends boolean | null | undefined | ProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Program :
    S extends undefined ? never :
    S extends { include: any } & (ProgramArgs | ProgramFindManyArgs)
    ? Program  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'processes' ? Array < ProcessTypeGetPayload<S['include'][P]>>  :
        P extends 'washHistory' ? WashHistoryGetPayload<S['include'][P]> | null :
        P extends 'machineOnPrograms' ? Array < MachineOnProgramGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProgramCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProgramArgs | ProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'processes' ? Array < ProcessTypeGetPayload<S['select'][P]>>  :
        P extends 'washHistory' ? WashHistoryGetPayload<S['select'][P]> | null :
        P extends 'machineOnPrograms' ? Array < MachineOnProgramGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProgramCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Program ? Program[P] : never
  } 
      : Program


  type ProgramCountArgs = 
    Omit<ProgramFindManyArgs, 'select' | 'include'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Program'> extends True ? Prisma__ProgramClient<ProgramGetPayload<T>> : Prisma__ProgramClient<ProgramGetPayload<T> | null, null>

    /**
     * Find one Program that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProgramFindUniqueOrThrowArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Program'> extends True ? Prisma__ProgramClient<ProgramGetPayload<T>> : Prisma__ProgramClient<ProgramGetPayload<T> | null, null>

    /**
     * Find the first Program that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProgramFindFirstOrThrowArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgramFindManyArgs>(
      args?: SelectSubset<T, ProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProgramGetPayload<T>>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
    **/
    create<T extends ProgramCreateArgs>(
      args: SelectSubset<T, ProgramCreateArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Create many Programs.
     *     @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     *     @example
     *     // Create many Programs
     *     const program = await prisma.program.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgramCreateManyArgs>(
      args?: SelectSubset<T, ProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
    **/
    delete<T extends ProgramDeleteArgs>(
      args: SelectSubset<T, ProgramDeleteArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgramUpdateArgs>(
      args: SelectSubset<T, ProgramUpdateArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgramDeleteManyArgs>(
      args?: SelectSubset<T, ProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgramUpdateManyArgs>(
      args: SelectSubset<T, ProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
    **/
    upsert<T extends ProgramUpsertArgs>(
      args: SelectSubset<T, ProgramUpsertArgs>
    ): Prisma__ProgramClient<ProgramGetPayload<T>>

    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    processes<T extends Program$processesArgs= {}>(args?: Subset<T, Program$processesArgs>): Prisma.PrismaPromise<Array<ProcessTypeGetPayload<T>>| Null>;

    washHistory<T extends WashHistoryArgs= {}>(args?: Subset<T, WashHistoryArgs>): Prisma__WashHistoryClient<WashHistoryGetPayload<T> | Null>;

    machineOnPrograms<T extends Program$machineOnProgramsArgs= {}>(args?: Subset<T, Program$machineOnProgramsArgs>): Prisma.PrismaPromise<Array<MachineOnProgramGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Program base type for findUnique actions
   */
  export type ProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUnique
   */
  export interface ProgramFindUniqueArgs extends ProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program base type for findFirst actions
   */
  export type ProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: Enumerable<ProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: Enumerable<ProgramScalarFieldEnum>
  }

  /**
   * Program findFirst
   */
  export interface ProgramFindFirstArgs extends ProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: Enumerable<ProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: Enumerable<ProgramScalarFieldEnum>
  }


  /**
   * Program findMany
   */
  export type ProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: Enumerable<ProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: Enumerable<ProgramScalarFieldEnum>
  }


  /**
   * Program create
   */
  export type ProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }


  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs = {
    /**
     * The data used to create many Programs.
     */
    data: Enumerable<ProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Program update
   */
  export type ProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }


  /**
   * Program upsert
   */
  export type ProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }


  /**
   * Program delete
   */
  export type ProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }


  /**
   * Program.processes
   */
  export type Program$processesArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    where?: ProcessTypeWhereInput
    orderBy?: Enumerable<ProcessTypeOrderByWithRelationInput>
    cursor?: ProcessTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProcessTypeScalarFieldEnum>
  }


  /**
   * Program.machineOnPrograms
   */
  export type Program$machineOnProgramsArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    where?: MachineOnProgramWhereInput
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    cursor?: MachineOnProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineOnProgramScalarFieldEnum>
  }


  /**
   * Program without action
   */
  export type ProgramArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
  }



  /**
   * Model MachineOnProgram
   */


  export type AggregateMachineOnProgram = {
    _count: MachineOnProgramCountAggregateOutputType | null
    _avg: MachineOnProgramAvgAggregateOutputType | null
    _sum: MachineOnProgramSumAggregateOutputType | null
    _min: MachineOnProgramMinAggregateOutputType | null
    _max: MachineOnProgramMaxAggregateOutputType | null
  }

  export type MachineOnProgramAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type MachineOnProgramSumAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type MachineOnProgramMinAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MachineOnProgramMaxAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MachineOnProgramCountAggregateOutputType = {
    id: number
    machineId: number
    programId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type MachineOnProgramAvgAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type MachineOnProgramSumAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type MachineOnProgramMinAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createAt?: true
    updateAt?: true
  }

  export type MachineOnProgramMaxAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createAt?: true
    updateAt?: true
  }

  export type MachineOnProgramCountAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type MachineOnProgramAggregateArgs = {
    /**
     * Filter which MachineOnProgram to aggregate.
     */
    where?: MachineOnProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineOnPrograms to fetch.
     */
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineOnProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineOnPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineOnPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineOnPrograms
    **/
    _count?: true | MachineOnProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineOnProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineOnProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineOnProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineOnProgramMaxAggregateInputType
  }

  export type GetMachineOnProgramAggregateType<T extends MachineOnProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineOnProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineOnProgram[P]>
      : GetScalarType<T[P], AggregateMachineOnProgram[P]>
  }




  export type MachineOnProgramGroupByArgs = {
    where?: MachineOnProgramWhereInput
    orderBy?: Enumerable<MachineOnProgramOrderByWithAggregationInput>
    by: MachineOnProgramScalarFieldEnum[]
    having?: MachineOnProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineOnProgramCountAggregateInputType | true
    _avg?: MachineOnProgramAvgAggregateInputType
    _sum?: MachineOnProgramSumAggregateInputType
    _min?: MachineOnProgramMinAggregateInputType
    _max?: MachineOnProgramMaxAggregateInputType
  }


  export type MachineOnProgramGroupByOutputType = {
    id: number
    machineId: number
    programId: number
    createAt: Date
    updateAt: Date
    _count: MachineOnProgramCountAggregateOutputType | null
    _avg: MachineOnProgramAvgAggregateOutputType | null
    _sum: MachineOnProgramSumAggregateOutputType | null
    _min: MachineOnProgramMinAggregateOutputType | null
    _max: MachineOnProgramMaxAggregateOutputType | null
  }

  type GetMachineOnProgramGroupByPayload<T extends MachineOnProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MachineOnProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineOnProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineOnProgramGroupByOutputType[P]>
            : GetScalarType<T[P], MachineOnProgramGroupByOutputType[P]>
        }
      >
    >


  export type MachineOnProgramSelect = {
    id?: boolean
    machine?: boolean | MachineArgs
    program?: boolean | ProgramArgs
    machineId?: boolean
    programId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type MachineOnProgramInclude = {
    machine?: boolean | MachineArgs
    program?: boolean | ProgramArgs
  }

  export type MachineOnProgramGetPayload<S extends boolean | null | undefined | MachineOnProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MachineOnProgram :
    S extends undefined ? never :
    S extends { include: any } & (MachineOnProgramArgs | MachineOnProgramFindManyArgs)
    ? MachineOnProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? MachineGetPayload<S['include'][P]> :
        P extends 'program' ? ProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MachineOnProgramArgs | MachineOnProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? MachineGetPayload<S['select'][P]> :
        P extends 'program' ? ProgramGetPayload<S['select'][P]> :  P extends keyof MachineOnProgram ? MachineOnProgram[P] : never
  } 
      : MachineOnProgram


  type MachineOnProgramCountArgs = 
    Omit<MachineOnProgramFindManyArgs, 'select' | 'include'> & {
      select?: MachineOnProgramCountAggregateInputType | true
    }

  export interface MachineOnProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MachineOnProgram that matches the filter.
     * @param {MachineOnProgramFindUniqueArgs} args - Arguments to find a MachineOnProgram
     * @example
     * // Get one MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MachineOnProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MachineOnProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MachineOnProgram'> extends True ? Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>> : Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T> | null, null>

    /**
     * Find one MachineOnProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MachineOnProgramFindUniqueOrThrowArgs} args - Arguments to find a MachineOnProgram
     * @example
     * // Get one MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MachineOnProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MachineOnProgramFindUniqueOrThrowArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Find the first MachineOnProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramFindFirstArgs} args - Arguments to find a MachineOnProgram
     * @example
     * // Get one MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MachineOnProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MachineOnProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MachineOnProgram'> extends True ? Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>> : Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T> | null, null>

    /**
     * Find the first MachineOnProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramFindFirstOrThrowArgs} args - Arguments to find a MachineOnProgram
     * @example
     * // Get one MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MachineOnProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MachineOnProgramFindFirstOrThrowArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Find zero or more MachineOnPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineOnPrograms
     * const machineOnPrograms = await prisma.machineOnProgram.findMany()
     * 
     * // Get first 10 MachineOnPrograms
     * const machineOnPrograms = await prisma.machineOnProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineOnProgramWithIdOnly = await prisma.machineOnProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MachineOnProgramFindManyArgs>(
      args?: SelectSubset<T, MachineOnProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<MachineOnProgramGetPayload<T>>>

    /**
     * Create a MachineOnProgram.
     * @param {MachineOnProgramCreateArgs} args - Arguments to create a MachineOnProgram.
     * @example
     * // Create one MachineOnProgram
     * const MachineOnProgram = await prisma.machineOnProgram.create({
     *   data: {
     *     // ... data to create a MachineOnProgram
     *   }
     * })
     * 
    **/
    create<T extends MachineOnProgramCreateArgs>(
      args: SelectSubset<T, MachineOnProgramCreateArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Create many MachineOnPrograms.
     *     @param {MachineOnProgramCreateManyArgs} args - Arguments to create many MachineOnPrograms.
     *     @example
     *     // Create many MachineOnPrograms
     *     const machineOnProgram = await prisma.machineOnProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MachineOnProgramCreateManyArgs>(
      args?: SelectSubset<T, MachineOnProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MachineOnProgram.
     * @param {MachineOnProgramDeleteArgs} args - Arguments to delete one MachineOnProgram.
     * @example
     * // Delete one MachineOnProgram
     * const MachineOnProgram = await prisma.machineOnProgram.delete({
     *   where: {
     *     // ... filter to delete one MachineOnProgram
     *   }
     * })
     * 
    **/
    delete<T extends MachineOnProgramDeleteArgs>(
      args: SelectSubset<T, MachineOnProgramDeleteArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Update one MachineOnProgram.
     * @param {MachineOnProgramUpdateArgs} args - Arguments to update one MachineOnProgram.
     * @example
     * // Update one MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MachineOnProgramUpdateArgs>(
      args: SelectSubset<T, MachineOnProgramUpdateArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Delete zero or more MachineOnPrograms.
     * @param {MachineOnProgramDeleteManyArgs} args - Arguments to filter MachineOnPrograms to delete.
     * @example
     * // Delete a few MachineOnPrograms
     * const { count } = await prisma.machineOnProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MachineOnProgramDeleteManyArgs>(
      args?: SelectSubset<T, MachineOnProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineOnPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineOnPrograms
     * const machineOnProgram = await prisma.machineOnProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MachineOnProgramUpdateManyArgs>(
      args: SelectSubset<T, MachineOnProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MachineOnProgram.
     * @param {MachineOnProgramUpsertArgs} args - Arguments to update or create a MachineOnProgram.
     * @example
     * // Update or create a MachineOnProgram
     * const machineOnProgram = await prisma.machineOnProgram.upsert({
     *   create: {
     *     // ... data to create a MachineOnProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineOnProgram we want to update
     *   }
     * })
    **/
    upsert<T extends MachineOnProgramUpsertArgs>(
      args: SelectSubset<T, MachineOnProgramUpsertArgs>
    ): Prisma__MachineOnProgramClient<MachineOnProgramGetPayload<T>>

    /**
     * Count the number of MachineOnPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramCountArgs} args - Arguments to filter MachineOnPrograms to count.
     * @example
     * // Count the number of MachineOnPrograms
     * const count = await prisma.machineOnProgram.count({
     *   where: {
     *     // ... the filter for the MachineOnPrograms we want to count
     *   }
     * })
    **/
    count<T extends MachineOnProgramCountArgs>(
      args?: Subset<T, MachineOnProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineOnProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineOnProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineOnProgramAggregateArgs>(args: Subset<T, MachineOnProgramAggregateArgs>): Prisma.PrismaPromise<GetMachineOnProgramAggregateType<T>>

    /**
     * Group by MachineOnProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineOnProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineOnProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineOnProgramGroupByArgs['orderBy'] }
        : { orderBy?: MachineOnProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineOnProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineOnProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineOnProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MachineOnProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends MachineArgs= {}>(args?: Subset<T, MachineArgs>): Prisma__MachineClient<MachineGetPayload<T> | Null>;

    program<T extends ProgramArgs= {}>(args?: Subset<T, ProgramArgs>): Prisma__ProgramClient<ProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MachineOnProgram base type for findUnique actions
   */
  export type MachineOnProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter, which MachineOnProgram to fetch.
     */
    where: MachineOnProgramWhereUniqueInput
  }

  /**
   * MachineOnProgram findUnique
   */
  export interface MachineOnProgramFindUniqueArgs extends MachineOnProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MachineOnProgram findUniqueOrThrow
   */
  export type MachineOnProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter, which MachineOnProgram to fetch.
     */
    where: MachineOnProgramWhereUniqueInput
  }


  /**
   * MachineOnProgram base type for findFirst actions
   */
  export type MachineOnProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter, which MachineOnProgram to fetch.
     */
    where?: MachineOnProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineOnPrograms to fetch.
     */
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineOnPrograms.
     */
    cursor?: MachineOnProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineOnPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineOnPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineOnPrograms.
     */
    distinct?: Enumerable<MachineOnProgramScalarFieldEnum>
  }

  /**
   * MachineOnProgram findFirst
   */
  export interface MachineOnProgramFindFirstArgs extends MachineOnProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MachineOnProgram findFirstOrThrow
   */
  export type MachineOnProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter, which MachineOnProgram to fetch.
     */
    where?: MachineOnProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineOnPrograms to fetch.
     */
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineOnPrograms.
     */
    cursor?: MachineOnProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineOnPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineOnPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineOnPrograms.
     */
    distinct?: Enumerable<MachineOnProgramScalarFieldEnum>
  }


  /**
   * MachineOnProgram findMany
   */
  export type MachineOnProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter, which MachineOnPrograms to fetch.
     */
    where?: MachineOnProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineOnPrograms to fetch.
     */
    orderBy?: Enumerable<MachineOnProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineOnPrograms.
     */
    cursor?: MachineOnProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineOnPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineOnPrograms.
     */
    skip?: number
    distinct?: Enumerable<MachineOnProgramScalarFieldEnum>
  }


  /**
   * MachineOnProgram create
   */
  export type MachineOnProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * The data needed to create a MachineOnProgram.
     */
    data: XOR<MachineOnProgramCreateInput, MachineOnProgramUncheckedCreateInput>
  }


  /**
   * MachineOnProgram createMany
   */
  export type MachineOnProgramCreateManyArgs = {
    /**
     * The data used to create many MachineOnPrograms.
     */
    data: Enumerable<MachineOnProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MachineOnProgram update
   */
  export type MachineOnProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * The data needed to update a MachineOnProgram.
     */
    data: XOR<MachineOnProgramUpdateInput, MachineOnProgramUncheckedUpdateInput>
    /**
     * Choose, which MachineOnProgram to update.
     */
    where: MachineOnProgramWhereUniqueInput
  }


  /**
   * MachineOnProgram updateMany
   */
  export type MachineOnProgramUpdateManyArgs = {
    /**
     * The data used to update MachineOnPrograms.
     */
    data: XOR<MachineOnProgramUpdateManyMutationInput, MachineOnProgramUncheckedUpdateManyInput>
    /**
     * Filter which MachineOnPrograms to update
     */
    where?: MachineOnProgramWhereInput
  }


  /**
   * MachineOnProgram upsert
   */
  export type MachineOnProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * The filter to search for the MachineOnProgram to update in case it exists.
     */
    where: MachineOnProgramWhereUniqueInput
    /**
     * In case the MachineOnProgram found by the `where` argument doesn't exist, create a new MachineOnProgram with this data.
     */
    create: XOR<MachineOnProgramCreateInput, MachineOnProgramUncheckedCreateInput>
    /**
     * In case the MachineOnProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineOnProgramUpdateInput, MachineOnProgramUncheckedUpdateInput>
  }


  /**
   * MachineOnProgram delete
   */
  export type MachineOnProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
    /**
     * Filter which MachineOnProgram to delete.
     */
    where: MachineOnProgramWhereUniqueInput
  }


  /**
   * MachineOnProgram deleteMany
   */
  export type MachineOnProgramDeleteManyArgs = {
    /**
     * Filter which MachineOnPrograms to delete
     */
    where?: MachineOnProgramWhereInput
  }


  /**
   * MachineOnProgram without action
   */
  export type MachineOnProgramArgs = {
    /**
     * Select specific fields to fetch from the MachineOnProgram
     */
    select?: MachineOnProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineOnProgramInclude | null
  }



  /**
   * Model ProcessType
   */


  export type AggregateProcessType = {
    _count: ProcessTypeCountAggregateOutputType | null
    _avg: ProcessTypeAvgAggregateOutputType | null
    _sum: ProcessTypeSumAggregateOutputType | null
    _min: ProcessTypeMinAggregateOutputType | null
    _max: ProcessTypeMaxAggregateOutputType | null
  }

  export type ProcessTypeAvgAggregateOutputType = {
    id: number | null
    programId: number | null
  }

  export type ProcessTypeSumAggregateOutputType = {
    id: number | null
    programId: number | null
  }

  export type ProcessTypeMinAggregateOutputType = {
    id: number | null
    description: string | null
    programId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProcessTypeMaxAggregateOutputType = {
    id: number | null
    description: string | null
    programId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProcessTypeCountAggregateOutputType = {
    id: number
    description: number
    programId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type ProcessTypeAvgAggregateInputType = {
    id?: true
    programId?: true
  }

  export type ProcessTypeSumAggregateInputType = {
    id?: true
    programId?: true
  }

  export type ProcessTypeMinAggregateInputType = {
    id?: true
    description?: true
    programId?: true
    createAt?: true
    updateAt?: true
  }

  export type ProcessTypeMaxAggregateInputType = {
    id?: true
    description?: true
    programId?: true
    createAt?: true
    updateAt?: true
  }

  export type ProcessTypeCountAggregateInputType = {
    id?: true
    description?: true
    programId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type ProcessTypeAggregateArgs = {
    /**
     * Filter which ProcessType to aggregate.
     */
    where?: ProcessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessTypes to fetch.
     */
    orderBy?: Enumerable<ProcessTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessTypes
    **/
    _count?: true | ProcessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessTypeMaxAggregateInputType
  }

  export type GetProcessTypeAggregateType<T extends ProcessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessType[P]>
      : GetScalarType<T[P], AggregateProcessType[P]>
  }




  export type ProcessTypeGroupByArgs = {
    where?: ProcessTypeWhereInput
    orderBy?: Enumerable<ProcessTypeOrderByWithAggregationInput>
    by: ProcessTypeScalarFieldEnum[]
    having?: ProcessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessTypeCountAggregateInputType | true
    _avg?: ProcessTypeAvgAggregateInputType
    _sum?: ProcessTypeSumAggregateInputType
    _min?: ProcessTypeMinAggregateInputType
    _max?: ProcessTypeMaxAggregateInputType
  }


  export type ProcessTypeGroupByOutputType = {
    id: number
    description: string
    programId: number | null
    createAt: Date
    updateAt: Date
    _count: ProcessTypeCountAggregateOutputType | null
    _avg: ProcessTypeAvgAggregateOutputType | null
    _sum: ProcessTypeSumAggregateOutputType | null
    _min: ProcessTypeMinAggregateOutputType | null
    _max: ProcessTypeMaxAggregateOutputType | null
  }

  type GetProcessTypeGroupByPayload<T extends ProcessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProcessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProcessTypeSelect = {
    id?: boolean
    description?: boolean
    program?: boolean | ProgramArgs
    programId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type ProcessTypeInclude = {
    program?: boolean | ProgramArgs
  }

  export type ProcessTypeGetPayload<S extends boolean | null | undefined | ProcessTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProcessType :
    S extends undefined ? never :
    S extends { include: any } & (ProcessTypeArgs | ProcessTypeFindManyArgs)
    ? ProcessType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? ProgramGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ProcessTypeArgs | ProcessTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? ProgramGetPayload<S['select'][P]> | null :  P extends keyof ProcessType ? ProcessType[P] : never
  } 
      : ProcessType


  type ProcessTypeCountArgs = 
    Omit<ProcessTypeFindManyArgs, 'select' | 'include'> & {
      select?: ProcessTypeCountAggregateInputType | true
    }

  export interface ProcessTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProcessType that matches the filter.
     * @param {ProcessTypeFindUniqueArgs} args - Arguments to find a ProcessType
     * @example
     * // Get one ProcessType
     * const processType = await prisma.processType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProcessTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProcessTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProcessType'> extends True ? Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>> : Prisma__ProcessTypeClient<ProcessTypeGetPayload<T> | null, null>

    /**
     * Find one ProcessType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProcessTypeFindUniqueOrThrowArgs} args - Arguments to find a ProcessType
     * @example
     * // Get one ProcessType
     * const processType = await prisma.processType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProcessTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProcessTypeFindUniqueOrThrowArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Find the first ProcessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeFindFirstArgs} args - Arguments to find a ProcessType
     * @example
     * // Get one ProcessType
     * const processType = await prisma.processType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProcessTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProcessTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProcessType'> extends True ? Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>> : Prisma__ProcessTypeClient<ProcessTypeGetPayload<T> | null, null>

    /**
     * Find the first ProcessType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeFindFirstOrThrowArgs} args - Arguments to find a ProcessType
     * @example
     * // Get one ProcessType
     * const processType = await prisma.processType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProcessTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProcessTypeFindFirstOrThrowArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Find zero or more ProcessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessTypes
     * const processTypes = await prisma.processType.findMany()
     * 
     * // Get first 10 ProcessTypes
     * const processTypes = await prisma.processType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processTypeWithIdOnly = await prisma.processType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProcessTypeFindManyArgs>(
      args?: SelectSubset<T, ProcessTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProcessTypeGetPayload<T>>>

    /**
     * Create a ProcessType.
     * @param {ProcessTypeCreateArgs} args - Arguments to create a ProcessType.
     * @example
     * // Create one ProcessType
     * const ProcessType = await prisma.processType.create({
     *   data: {
     *     // ... data to create a ProcessType
     *   }
     * })
     * 
    **/
    create<T extends ProcessTypeCreateArgs>(
      args: SelectSubset<T, ProcessTypeCreateArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Create many ProcessTypes.
     *     @param {ProcessTypeCreateManyArgs} args - Arguments to create many ProcessTypes.
     *     @example
     *     // Create many ProcessTypes
     *     const processType = await prisma.processType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProcessTypeCreateManyArgs>(
      args?: SelectSubset<T, ProcessTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProcessType.
     * @param {ProcessTypeDeleteArgs} args - Arguments to delete one ProcessType.
     * @example
     * // Delete one ProcessType
     * const ProcessType = await prisma.processType.delete({
     *   where: {
     *     // ... filter to delete one ProcessType
     *   }
     * })
     * 
    **/
    delete<T extends ProcessTypeDeleteArgs>(
      args: SelectSubset<T, ProcessTypeDeleteArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Update one ProcessType.
     * @param {ProcessTypeUpdateArgs} args - Arguments to update one ProcessType.
     * @example
     * // Update one ProcessType
     * const processType = await prisma.processType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProcessTypeUpdateArgs>(
      args: SelectSubset<T, ProcessTypeUpdateArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Delete zero or more ProcessTypes.
     * @param {ProcessTypeDeleteManyArgs} args - Arguments to filter ProcessTypes to delete.
     * @example
     * // Delete a few ProcessTypes
     * const { count } = await prisma.processType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProcessTypeDeleteManyArgs>(
      args?: SelectSubset<T, ProcessTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessTypes
     * const processType = await prisma.processType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProcessTypeUpdateManyArgs>(
      args: SelectSubset<T, ProcessTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcessType.
     * @param {ProcessTypeUpsertArgs} args - Arguments to update or create a ProcessType.
     * @example
     * // Update or create a ProcessType
     * const processType = await prisma.processType.upsert({
     *   create: {
     *     // ... data to create a ProcessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessType we want to update
     *   }
     * })
    **/
    upsert<T extends ProcessTypeUpsertArgs>(
      args: SelectSubset<T, ProcessTypeUpsertArgs>
    ): Prisma__ProcessTypeClient<ProcessTypeGetPayload<T>>

    /**
     * Count the number of ProcessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeCountArgs} args - Arguments to filter ProcessTypes to count.
     * @example
     * // Count the number of ProcessTypes
     * const count = await prisma.processType.count({
     *   where: {
     *     // ... the filter for the ProcessTypes we want to count
     *   }
     * })
    **/
    count<T extends ProcessTypeCountArgs>(
      args?: Subset<T, ProcessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessTypeAggregateArgs>(args: Subset<T, ProcessTypeAggregateArgs>): Prisma.PrismaPromise<GetProcessTypeAggregateType<T>>

    /**
     * Group by ProcessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProcessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProcessTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends ProgramArgs= {}>(args?: Subset<T, ProgramArgs>): Prisma__ProgramClient<ProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProcessType base type for findUnique actions
   */
  export type ProcessTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter, which ProcessType to fetch.
     */
    where: ProcessTypeWhereUniqueInput
  }

  /**
   * ProcessType findUnique
   */
  export interface ProcessTypeFindUniqueArgs extends ProcessTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProcessType findUniqueOrThrow
   */
  export type ProcessTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter, which ProcessType to fetch.
     */
    where: ProcessTypeWhereUniqueInput
  }


  /**
   * ProcessType base type for findFirst actions
   */
  export type ProcessTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter, which ProcessType to fetch.
     */
    where?: ProcessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessTypes to fetch.
     */
    orderBy?: Enumerable<ProcessTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessTypes.
     */
    cursor?: ProcessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessTypes.
     */
    distinct?: Enumerable<ProcessTypeScalarFieldEnum>
  }

  /**
   * ProcessType findFirst
   */
  export interface ProcessTypeFindFirstArgs extends ProcessTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProcessType findFirstOrThrow
   */
  export type ProcessTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter, which ProcessType to fetch.
     */
    where?: ProcessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessTypes to fetch.
     */
    orderBy?: Enumerable<ProcessTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessTypes.
     */
    cursor?: ProcessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessTypes.
     */
    distinct?: Enumerable<ProcessTypeScalarFieldEnum>
  }


  /**
   * ProcessType findMany
   */
  export type ProcessTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter, which ProcessTypes to fetch.
     */
    where?: ProcessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessTypes to fetch.
     */
    orderBy?: Enumerable<ProcessTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessTypes.
     */
    cursor?: ProcessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessTypes.
     */
    skip?: number
    distinct?: Enumerable<ProcessTypeScalarFieldEnum>
  }


  /**
   * ProcessType create
   */
  export type ProcessTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * The data needed to create a ProcessType.
     */
    data: XOR<ProcessTypeCreateInput, ProcessTypeUncheckedCreateInput>
  }


  /**
   * ProcessType createMany
   */
  export type ProcessTypeCreateManyArgs = {
    /**
     * The data used to create many ProcessTypes.
     */
    data: Enumerable<ProcessTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProcessType update
   */
  export type ProcessTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * The data needed to update a ProcessType.
     */
    data: XOR<ProcessTypeUpdateInput, ProcessTypeUncheckedUpdateInput>
    /**
     * Choose, which ProcessType to update.
     */
    where: ProcessTypeWhereUniqueInput
  }


  /**
   * ProcessType updateMany
   */
  export type ProcessTypeUpdateManyArgs = {
    /**
     * The data used to update ProcessTypes.
     */
    data: XOR<ProcessTypeUpdateManyMutationInput, ProcessTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProcessTypes to update
     */
    where?: ProcessTypeWhereInput
  }


  /**
   * ProcessType upsert
   */
  export type ProcessTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * The filter to search for the ProcessType to update in case it exists.
     */
    where: ProcessTypeWhereUniqueInput
    /**
     * In case the ProcessType found by the `where` argument doesn't exist, create a new ProcessType with this data.
     */
    create: XOR<ProcessTypeCreateInput, ProcessTypeUncheckedCreateInput>
    /**
     * In case the ProcessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessTypeUpdateInput, ProcessTypeUncheckedUpdateInput>
  }


  /**
   * ProcessType delete
   */
  export type ProcessTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
    /**
     * Filter which ProcessType to delete.
     */
    where: ProcessTypeWhereUniqueInput
  }


  /**
   * ProcessType deleteMany
   */
  export type ProcessTypeDeleteManyArgs = {
    /**
     * Filter which ProcessTypes to delete
     */
    where?: ProcessTypeWhereInput
  }


  /**
   * ProcessType without action
   */
  export type ProcessTypeArgs = {
    /**
     * Select specific fields to fetch from the ProcessType
     */
    select?: ProcessTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProcessTypeInclude | null
  }



  /**
   * Model RepairHistory
   */


  export type AggregateRepairHistory = {
    _count: RepairHistoryCountAggregateOutputType | null
    _avg: RepairHistoryAvgAggregateOutputType | null
    _sum: RepairHistorySumAggregateOutputType | null
    _min: RepairHistoryMinAggregateOutputType | null
    _max: RepairHistoryMaxAggregateOutputType | null
  }

  export type RepairHistoryAvgAggregateOutputType = {
    id: number | null
    time: number | null
    machineId: number | null
    repairDetailId: number | null
  }

  export type RepairHistorySumAggregateOutputType = {
    id: number | null
    time: number | null
    machineId: number | null
    repairDetailId: number | null
  }

  export type RepairHistoryMinAggregateOutputType = {
    id: number | null
    time: number | null
    machineId: number | null
    repairDetailId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RepairHistoryMaxAggregateOutputType = {
    id: number | null
    time: number | null
    machineId: number | null
    repairDetailId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RepairHistoryCountAggregateOutputType = {
    id: number
    time: number
    machineId: number
    repairDetailId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type RepairHistoryAvgAggregateInputType = {
    id?: true
    time?: true
    machineId?: true
    repairDetailId?: true
  }

  export type RepairHistorySumAggregateInputType = {
    id?: true
    time?: true
    machineId?: true
    repairDetailId?: true
  }

  export type RepairHistoryMinAggregateInputType = {
    id?: true
    time?: true
    machineId?: true
    repairDetailId?: true
    createAt?: true
    updateAt?: true
  }

  export type RepairHistoryMaxAggregateInputType = {
    id?: true
    time?: true
    machineId?: true
    repairDetailId?: true
    createAt?: true
    updateAt?: true
  }

  export type RepairHistoryCountAggregateInputType = {
    id?: true
    time?: true
    machineId?: true
    repairDetailId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type RepairHistoryAggregateArgs = {
    /**
     * Filter which RepairHistory to aggregate.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairHistories
    **/
    _count?: true | RepairHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairHistoryMaxAggregateInputType
  }

  export type GetRepairHistoryAggregateType<T extends RepairHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairHistory[P]>
      : GetScalarType<T[P], AggregateRepairHistory[P]>
  }




  export type RepairHistoryGroupByArgs = {
    where?: RepairHistoryWhereInput
    orderBy?: Enumerable<RepairHistoryOrderByWithAggregationInput>
    by: RepairHistoryScalarFieldEnum[]
    having?: RepairHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairHistoryCountAggregateInputType | true
    _avg?: RepairHistoryAvgAggregateInputType
    _sum?: RepairHistorySumAggregateInputType
    _min?: RepairHistoryMinAggregateInputType
    _max?: RepairHistoryMaxAggregateInputType
  }


  export type RepairHistoryGroupByOutputType = {
    id: number
    time: number
    machineId: number | null
    repairDetailId: number
    createAt: Date
    updateAt: Date
    _count: RepairHistoryCountAggregateOutputType | null
    _avg: RepairHistoryAvgAggregateOutputType | null
    _sum: RepairHistorySumAggregateOutputType | null
    _min: RepairHistoryMinAggregateOutputType | null
    _max: RepairHistoryMaxAggregateOutputType | null
  }

  type GetRepairHistoryGroupByPayload<T extends RepairHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RepairHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RepairHistorySelect = {
    id?: boolean
    time?: boolean
    machine?: boolean | MachineArgs
    machineId?: boolean
    detail?: boolean | RepairDetailArgs
    repairDetailId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type RepairHistoryInclude = {
    machine?: boolean | MachineArgs
    detail?: boolean | RepairDetailArgs
  }

  export type RepairHistoryGetPayload<S extends boolean | null | undefined | RepairHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairHistory :
    S extends undefined ? never :
    S extends { include: any } & (RepairHistoryArgs | RepairHistoryFindManyArgs)
    ? RepairHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? MachineGetPayload<S['include'][P]> | null :
        P extends 'detail' ? RepairDetailGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairHistoryArgs | RepairHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? MachineGetPayload<S['select'][P]> | null :
        P extends 'detail' ? RepairDetailGetPayload<S['select'][P]> :  P extends keyof RepairHistory ? RepairHistory[P] : never
  } 
      : RepairHistory


  type RepairHistoryCountArgs = 
    Omit<RepairHistoryFindManyArgs, 'select' | 'include'> & {
      select?: RepairHistoryCountAggregateInputType | true
    }

  export interface RepairHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairHistory that matches the filter.
     * @param {RepairHistoryFindUniqueArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairHistory'> extends True ? Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>> : Prisma__RepairHistoryClient<RepairHistoryGetPayload<T> | null, null>

    /**
     * Find one RepairHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairHistoryFindUniqueOrThrowArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairHistoryFindUniqueOrThrowArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Find the first RepairHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindFirstArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairHistory'> extends True ? Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>> : Prisma__RepairHistoryClient<RepairHistoryGetPayload<T> | null, null>

    /**
     * Find the first RepairHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindFirstOrThrowArgs} args - Arguments to find a RepairHistory
     * @example
     * // Get one RepairHistory
     * const repairHistory = await prisma.repairHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairHistoryFindFirstOrThrowArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Find zero or more RepairHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairHistories
     * const repairHistories = await prisma.repairHistory.findMany()
     * 
     * // Get first 10 RepairHistories
     * const repairHistories = await prisma.repairHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairHistoryWithIdOnly = await prisma.repairHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairHistoryFindManyArgs>(
      args?: SelectSubset<T, RepairHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairHistoryGetPayload<T>>>

    /**
     * Create a RepairHistory.
     * @param {RepairHistoryCreateArgs} args - Arguments to create a RepairHistory.
     * @example
     * // Create one RepairHistory
     * const RepairHistory = await prisma.repairHistory.create({
     *   data: {
     *     // ... data to create a RepairHistory
     *   }
     * })
     * 
    **/
    create<T extends RepairHistoryCreateArgs>(
      args: SelectSubset<T, RepairHistoryCreateArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Create many RepairHistories.
     *     @param {RepairHistoryCreateManyArgs} args - Arguments to create many RepairHistories.
     *     @example
     *     // Create many RepairHistories
     *     const repairHistory = await prisma.repairHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairHistoryCreateManyArgs>(
      args?: SelectSubset<T, RepairHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairHistory.
     * @param {RepairHistoryDeleteArgs} args - Arguments to delete one RepairHistory.
     * @example
     * // Delete one RepairHistory
     * const RepairHistory = await prisma.repairHistory.delete({
     *   where: {
     *     // ... filter to delete one RepairHistory
     *   }
     * })
     * 
    **/
    delete<T extends RepairHistoryDeleteArgs>(
      args: SelectSubset<T, RepairHistoryDeleteArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Update one RepairHistory.
     * @param {RepairHistoryUpdateArgs} args - Arguments to update one RepairHistory.
     * @example
     * // Update one RepairHistory
     * const repairHistory = await prisma.repairHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairHistoryUpdateArgs>(
      args: SelectSubset<T, RepairHistoryUpdateArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Delete zero or more RepairHistories.
     * @param {RepairHistoryDeleteManyArgs} args - Arguments to filter RepairHistories to delete.
     * @example
     * // Delete a few RepairHistories
     * const { count } = await prisma.repairHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairHistoryDeleteManyArgs>(
      args?: SelectSubset<T, RepairHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairHistories
     * const repairHistory = await prisma.repairHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairHistoryUpdateManyArgs>(
      args: SelectSubset<T, RepairHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairHistory.
     * @param {RepairHistoryUpsertArgs} args - Arguments to update or create a RepairHistory.
     * @example
     * // Update or create a RepairHistory
     * const repairHistory = await prisma.repairHistory.upsert({
     *   create: {
     *     // ... data to create a RepairHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairHistory we want to update
     *   }
     * })
    **/
    upsert<T extends RepairHistoryUpsertArgs>(
      args: SelectSubset<T, RepairHistoryUpsertArgs>
    ): Prisma__RepairHistoryClient<RepairHistoryGetPayload<T>>

    /**
     * Count the number of RepairHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryCountArgs} args - Arguments to filter RepairHistories to count.
     * @example
     * // Count the number of RepairHistories
     * const count = await prisma.repairHistory.count({
     *   where: {
     *     // ... the filter for the RepairHistories we want to count
     *   }
     * })
    **/
    count<T extends RepairHistoryCountArgs>(
      args?: Subset<T, RepairHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairHistoryAggregateArgs>(args: Subset<T, RepairHistoryAggregateArgs>): Prisma.PrismaPromise<GetRepairHistoryAggregateType<T>>

    /**
     * Group by RepairHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RepairHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends MachineArgs= {}>(args?: Subset<T, MachineArgs>): Prisma__MachineClient<MachineGetPayload<T> | Null>;

    detail<T extends RepairDetailArgs= {}>(args?: Subset<T, RepairDetailArgs>): Prisma__RepairDetailClient<RepairDetailGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairHistory base type for findUnique actions
   */
  export type RepairHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where: RepairHistoryWhereUniqueInput
  }

  /**
   * RepairHistory findUnique
   */
  export interface RepairHistoryFindUniqueArgs extends RepairHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairHistory findUniqueOrThrow
   */
  export type RepairHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory base type for findFirst actions
   */
  export type RepairHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairHistories.
     */
    distinct?: Enumerable<RepairHistoryScalarFieldEnum>
  }

  /**
   * RepairHistory findFirst
   */
  export interface RepairHistoryFindFirstArgs extends RepairHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairHistory findFirstOrThrow
   */
  export type RepairHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter, which RepairHistory to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairHistories.
     */
    distinct?: Enumerable<RepairHistoryScalarFieldEnum>
  }


  /**
   * RepairHistory findMany
   */
  export type RepairHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter, which RepairHistories to fetch.
     */
    where?: RepairHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairHistories to fetch.
     */
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairHistories.
     */
    cursor?: RepairHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairHistories.
     */
    skip?: number
    distinct?: Enumerable<RepairHistoryScalarFieldEnum>
  }


  /**
   * RepairHistory create
   */
  export type RepairHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * The data needed to create a RepairHistory.
     */
    data: XOR<RepairHistoryCreateInput, RepairHistoryUncheckedCreateInput>
  }


  /**
   * RepairHistory createMany
   */
  export type RepairHistoryCreateManyArgs = {
    /**
     * The data used to create many RepairHistories.
     */
    data: Enumerable<RepairHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairHistory update
   */
  export type RepairHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * The data needed to update a RepairHistory.
     */
    data: XOR<RepairHistoryUpdateInput, RepairHistoryUncheckedUpdateInput>
    /**
     * Choose, which RepairHistory to update.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory updateMany
   */
  export type RepairHistoryUpdateManyArgs = {
    /**
     * The data used to update RepairHistories.
     */
    data: XOR<RepairHistoryUpdateManyMutationInput, RepairHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RepairHistories to update
     */
    where?: RepairHistoryWhereInput
  }


  /**
   * RepairHistory upsert
   */
  export type RepairHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * The filter to search for the RepairHistory to update in case it exists.
     */
    where: RepairHistoryWhereUniqueInput
    /**
     * In case the RepairHistory found by the `where` argument doesn't exist, create a new RepairHistory with this data.
     */
    create: XOR<RepairHistoryCreateInput, RepairHistoryUncheckedCreateInput>
    /**
     * In case the RepairHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairHistoryUpdateInput, RepairHistoryUncheckedUpdateInput>
  }


  /**
   * RepairHistory delete
   */
  export type RepairHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    /**
     * Filter which RepairHistory to delete.
     */
    where: RepairHistoryWhereUniqueInput
  }


  /**
   * RepairHistory deleteMany
   */
  export type RepairHistoryDeleteManyArgs = {
    /**
     * Filter which RepairHistories to delete
     */
    where?: RepairHistoryWhereInput
  }


  /**
   * RepairHistory without action
   */
  export type RepairHistoryArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
  }



  /**
   * Model RepairDetail
   */


  export type AggregateRepairDetail = {
    _count: RepairDetailCountAggregateOutputType | null
    _avg: RepairDetailAvgAggregateOutputType | null
    _sum: RepairDetailSumAggregateOutputType | null
    _min: RepairDetailMinAggregateOutputType | null
    _max: RepairDetailMaxAggregateOutputType | null
  }

  export type RepairDetailAvgAggregateOutputType = {
    id: number | null
    repairHistoryId: number | null
  }

  export type RepairDetailSumAggregateOutputType = {
    id: number | null
    repairHistoryId: number | null
  }

  export type RepairDetailMinAggregateOutputType = {
    id: number | null
    date: string | null
    damage: string | null
    cause: string | null
    machanics: string | null
    createAt: Date | null
    updateAt: Date | null
    repairHistoryId: number | null
  }

  export type RepairDetailMaxAggregateOutputType = {
    id: number | null
    date: string | null
    damage: string | null
    cause: string | null
    machanics: string | null
    createAt: Date | null
    updateAt: Date | null
    repairHistoryId: number | null
  }

  export type RepairDetailCountAggregateOutputType = {
    id: number
    date: number
    damage: number
    cause: number
    machanics: number
    createAt: number
    updateAt: number
    repairHistoryId: number
    _all: number
  }


  export type RepairDetailAvgAggregateInputType = {
    id?: true
    repairHistoryId?: true
  }

  export type RepairDetailSumAggregateInputType = {
    id?: true
    repairHistoryId?: true
  }

  export type RepairDetailMinAggregateInputType = {
    id?: true
    date?: true
    damage?: true
    cause?: true
    machanics?: true
    createAt?: true
    updateAt?: true
    repairHistoryId?: true
  }

  export type RepairDetailMaxAggregateInputType = {
    id?: true
    date?: true
    damage?: true
    cause?: true
    machanics?: true
    createAt?: true
    updateAt?: true
    repairHistoryId?: true
  }

  export type RepairDetailCountAggregateInputType = {
    id?: true
    date?: true
    damage?: true
    cause?: true
    machanics?: true
    createAt?: true
    updateAt?: true
    repairHistoryId?: true
    _all?: true
  }

  export type RepairDetailAggregateArgs = {
    /**
     * Filter which RepairDetail to aggregate.
     */
    where?: RepairDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairDetails to fetch.
     */
    orderBy?: Enumerable<RepairDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepairDetails
    **/
    _count?: true | RepairDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairDetailMaxAggregateInputType
  }

  export type GetRepairDetailAggregateType<T extends RepairDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateRepairDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepairDetail[P]>
      : GetScalarType<T[P], AggregateRepairDetail[P]>
  }




  export type RepairDetailGroupByArgs = {
    where?: RepairDetailWhereInput
    orderBy?: Enumerable<RepairDetailOrderByWithAggregationInput>
    by: RepairDetailScalarFieldEnum[]
    having?: RepairDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairDetailCountAggregateInputType | true
    _avg?: RepairDetailAvgAggregateInputType
    _sum?: RepairDetailSumAggregateInputType
    _min?: RepairDetailMinAggregateInputType
    _max?: RepairDetailMaxAggregateInputType
  }


  export type RepairDetailGroupByOutputType = {
    id: number
    date: string
    damage: string
    cause: string
    machanics: string
    createAt: Date
    updateAt: Date
    repairHistoryId: number
    _count: RepairDetailCountAggregateOutputType | null
    _avg: RepairDetailAvgAggregateOutputType | null
    _sum: RepairDetailSumAggregateOutputType | null
    _min: RepairDetailMinAggregateOutputType | null
    _max: RepairDetailMaxAggregateOutputType | null
  }

  type GetRepairDetailGroupByPayload<T extends RepairDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RepairDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairDetailGroupByOutputType[P]>
            : GetScalarType<T[P], RepairDetailGroupByOutputType[P]>
        }
      >
    >


  export type RepairDetailSelect = {
    id?: boolean
    date?: boolean
    damage?: boolean
    cause?: boolean
    machanics?: boolean
    createAt?: boolean
    updateAt?: boolean
    repairHistoryId?: boolean
    RepairHistory?: boolean | RepairDetail$RepairHistoryArgs
    _count?: boolean | RepairDetailCountOutputTypeArgs
  }


  export type RepairDetailInclude = {
    RepairHistory?: boolean | RepairDetail$RepairHistoryArgs
    _count?: boolean | RepairDetailCountOutputTypeArgs
  }

  export type RepairDetailGetPayload<S extends boolean | null | undefined | RepairDetailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RepairDetail :
    S extends undefined ? never :
    S extends { include: any } & (RepairDetailArgs | RepairDetailFindManyArgs)
    ? RepairDetail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'RepairHistory' ? Array < RepairHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? RepairDetailCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RepairDetailArgs | RepairDetailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'RepairHistory' ? Array < RepairHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? RepairDetailCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RepairDetail ? RepairDetail[P] : never
  } 
      : RepairDetail


  type RepairDetailCountArgs = 
    Omit<RepairDetailFindManyArgs, 'select' | 'include'> & {
      select?: RepairDetailCountAggregateInputType | true
    }

  export interface RepairDetailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RepairDetail that matches the filter.
     * @param {RepairDetailFindUniqueArgs} args - Arguments to find a RepairDetail
     * @example
     * // Get one RepairDetail
     * const repairDetail = await prisma.repairDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RepairDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RepairDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RepairDetail'> extends True ? Prisma__RepairDetailClient<RepairDetailGetPayload<T>> : Prisma__RepairDetailClient<RepairDetailGetPayload<T> | null, null>

    /**
     * Find one RepairDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RepairDetailFindUniqueOrThrowArgs} args - Arguments to find a RepairDetail
     * @example
     * // Get one RepairDetail
     * const repairDetail = await prisma.repairDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RepairDetailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RepairDetailFindUniqueOrThrowArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Find the first RepairDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailFindFirstArgs} args - Arguments to find a RepairDetail
     * @example
     * // Get one RepairDetail
     * const repairDetail = await prisma.repairDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RepairDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RepairDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RepairDetail'> extends True ? Prisma__RepairDetailClient<RepairDetailGetPayload<T>> : Prisma__RepairDetailClient<RepairDetailGetPayload<T> | null, null>

    /**
     * Find the first RepairDetail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailFindFirstOrThrowArgs} args - Arguments to find a RepairDetail
     * @example
     * // Get one RepairDetail
     * const repairDetail = await prisma.repairDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RepairDetailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RepairDetailFindFirstOrThrowArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Find zero or more RepairDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepairDetails
     * const repairDetails = await prisma.repairDetail.findMany()
     * 
     * // Get first 10 RepairDetails
     * const repairDetails = await prisma.repairDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairDetailWithIdOnly = await prisma.repairDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RepairDetailFindManyArgs>(
      args?: SelectSubset<T, RepairDetailFindManyArgs>
    ): Prisma.PrismaPromise<Array<RepairDetailGetPayload<T>>>

    /**
     * Create a RepairDetail.
     * @param {RepairDetailCreateArgs} args - Arguments to create a RepairDetail.
     * @example
     * // Create one RepairDetail
     * const RepairDetail = await prisma.repairDetail.create({
     *   data: {
     *     // ... data to create a RepairDetail
     *   }
     * })
     * 
    **/
    create<T extends RepairDetailCreateArgs>(
      args: SelectSubset<T, RepairDetailCreateArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Create many RepairDetails.
     *     @param {RepairDetailCreateManyArgs} args - Arguments to create many RepairDetails.
     *     @example
     *     // Create many RepairDetails
     *     const repairDetail = await prisma.repairDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RepairDetailCreateManyArgs>(
      args?: SelectSubset<T, RepairDetailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RepairDetail.
     * @param {RepairDetailDeleteArgs} args - Arguments to delete one RepairDetail.
     * @example
     * // Delete one RepairDetail
     * const RepairDetail = await prisma.repairDetail.delete({
     *   where: {
     *     // ... filter to delete one RepairDetail
     *   }
     * })
     * 
    **/
    delete<T extends RepairDetailDeleteArgs>(
      args: SelectSubset<T, RepairDetailDeleteArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Update one RepairDetail.
     * @param {RepairDetailUpdateArgs} args - Arguments to update one RepairDetail.
     * @example
     * // Update one RepairDetail
     * const repairDetail = await prisma.repairDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RepairDetailUpdateArgs>(
      args: SelectSubset<T, RepairDetailUpdateArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Delete zero or more RepairDetails.
     * @param {RepairDetailDeleteManyArgs} args - Arguments to filter RepairDetails to delete.
     * @example
     * // Delete a few RepairDetails
     * const { count } = await prisma.repairDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RepairDetailDeleteManyArgs>(
      args?: SelectSubset<T, RepairDetailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepairDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepairDetails
     * const repairDetail = await prisma.repairDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RepairDetailUpdateManyArgs>(
      args: SelectSubset<T, RepairDetailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RepairDetail.
     * @param {RepairDetailUpsertArgs} args - Arguments to update or create a RepairDetail.
     * @example
     * // Update or create a RepairDetail
     * const repairDetail = await prisma.repairDetail.upsert({
     *   create: {
     *     // ... data to create a RepairDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepairDetail we want to update
     *   }
     * })
    **/
    upsert<T extends RepairDetailUpsertArgs>(
      args: SelectSubset<T, RepairDetailUpsertArgs>
    ): Prisma__RepairDetailClient<RepairDetailGetPayload<T>>

    /**
     * Count the number of RepairDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailCountArgs} args - Arguments to filter RepairDetails to count.
     * @example
     * // Count the number of RepairDetails
     * const count = await prisma.repairDetail.count({
     *   where: {
     *     // ... the filter for the RepairDetails we want to count
     *   }
     * })
    **/
    count<T extends RepairDetailCountArgs>(
      args?: Subset<T, RepairDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepairDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairDetailAggregateArgs>(args: Subset<T, RepairDetailAggregateArgs>): Prisma.PrismaPromise<GetRepairDetailAggregateType<T>>

    /**
     * Group by RepairDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairDetailGroupByArgs['orderBy'] }
        : { orderBy?: RepairDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RepairDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RepairDetailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    RepairHistory<T extends RepairDetail$RepairHistoryArgs= {}>(args?: Subset<T, RepairDetail$RepairHistoryArgs>): Prisma.PrismaPromise<Array<RepairHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RepairDetail base type for findUnique actions
   */
  export type RepairDetailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter, which RepairDetail to fetch.
     */
    where: RepairDetailWhereUniqueInput
  }

  /**
   * RepairDetail findUnique
   */
  export interface RepairDetailFindUniqueArgs extends RepairDetailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairDetail findUniqueOrThrow
   */
  export type RepairDetailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter, which RepairDetail to fetch.
     */
    where: RepairDetailWhereUniqueInput
  }


  /**
   * RepairDetail base type for findFirst actions
   */
  export type RepairDetailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter, which RepairDetail to fetch.
     */
    where?: RepairDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairDetails to fetch.
     */
    orderBy?: Enumerable<RepairDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairDetails.
     */
    cursor?: RepairDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairDetails.
     */
    distinct?: Enumerable<RepairDetailScalarFieldEnum>
  }

  /**
   * RepairDetail findFirst
   */
  export interface RepairDetailFindFirstArgs extends RepairDetailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RepairDetail findFirstOrThrow
   */
  export type RepairDetailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter, which RepairDetail to fetch.
     */
    where?: RepairDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairDetails to fetch.
     */
    orderBy?: Enumerable<RepairDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepairDetails.
     */
    cursor?: RepairDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepairDetails.
     */
    distinct?: Enumerable<RepairDetailScalarFieldEnum>
  }


  /**
   * RepairDetail findMany
   */
  export type RepairDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter, which RepairDetails to fetch.
     */
    where?: RepairDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepairDetails to fetch.
     */
    orderBy?: Enumerable<RepairDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepairDetails.
     */
    cursor?: RepairDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepairDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepairDetails.
     */
    skip?: number
    distinct?: Enumerable<RepairDetailScalarFieldEnum>
  }


  /**
   * RepairDetail create
   */
  export type RepairDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * The data needed to create a RepairDetail.
     */
    data: XOR<RepairDetailCreateInput, RepairDetailUncheckedCreateInput>
  }


  /**
   * RepairDetail createMany
   */
  export type RepairDetailCreateManyArgs = {
    /**
     * The data used to create many RepairDetails.
     */
    data: Enumerable<RepairDetailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RepairDetail update
   */
  export type RepairDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * The data needed to update a RepairDetail.
     */
    data: XOR<RepairDetailUpdateInput, RepairDetailUncheckedUpdateInput>
    /**
     * Choose, which RepairDetail to update.
     */
    where: RepairDetailWhereUniqueInput
  }


  /**
   * RepairDetail updateMany
   */
  export type RepairDetailUpdateManyArgs = {
    /**
     * The data used to update RepairDetails.
     */
    data: XOR<RepairDetailUpdateManyMutationInput, RepairDetailUncheckedUpdateManyInput>
    /**
     * Filter which RepairDetails to update
     */
    where?: RepairDetailWhereInput
  }


  /**
   * RepairDetail upsert
   */
  export type RepairDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * The filter to search for the RepairDetail to update in case it exists.
     */
    where: RepairDetailWhereUniqueInput
    /**
     * In case the RepairDetail found by the `where` argument doesn't exist, create a new RepairDetail with this data.
     */
    create: XOR<RepairDetailCreateInput, RepairDetailUncheckedCreateInput>
    /**
     * In case the RepairDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairDetailUpdateInput, RepairDetailUncheckedUpdateInput>
  }


  /**
   * RepairDetail delete
   */
  export type RepairDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
    /**
     * Filter which RepairDetail to delete.
     */
    where: RepairDetailWhereUniqueInput
  }


  /**
   * RepairDetail deleteMany
   */
  export type RepairDetailDeleteManyArgs = {
    /**
     * Filter which RepairDetails to delete
     */
    where?: RepairDetailWhereInput
  }


  /**
   * RepairDetail.RepairHistory
   */
  export type RepairDetail$RepairHistoryArgs = {
    /**
     * Select specific fields to fetch from the RepairHistory
     */
    select?: RepairHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairHistoryInclude | null
    where?: RepairHistoryWhereInput
    orderBy?: Enumerable<RepairHistoryOrderByWithRelationInput>
    cursor?: RepairHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RepairHistoryScalarFieldEnum>
  }


  /**
   * RepairDetail without action
   */
  export type RepairDetailArgs = {
    /**
     * Select specific fields to fetch from the RepairDetail
     */
    select?: RepairDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RepairDetailInclude | null
  }



  /**
   * Model washUser
   */


  export type AggregateWashUser = {
    _count: WashUserCountAggregateOutputType | null
    _avg: WashUserAvgAggregateOutputType | null
    _sum: WashUserSumAggregateOutputType | null
    _min: WashUserMinAggregateOutputType | null
    _max: WashUserMaxAggregateOutputType | null
  }

  export type WashUserAvgAggregateOutputType = {
    id: number | null
    tel: number | null
    balance: number | null
    washHistoryId: number | null
  }

  export type WashUserSumAggregateOutputType = {
    id: number | null
    tel: number | null
    balance: number | null
    washHistoryId: number | null
  }

  export type WashUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    balance: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type WashUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    tel: number | null
    balance: number | null
    washHistoryId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type WashUserCountAggregateOutputType = {
    id: number
    name: number
    tel: number
    balance: number
    washHistoryId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type WashUserAvgAggregateInputType = {
    id?: true
    tel?: true
    balance?: true
    washHistoryId?: true
  }

  export type WashUserSumAggregateInputType = {
    id?: true
    tel?: true
    balance?: true
    washHistoryId?: true
  }

  export type WashUserMinAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type WashUserMaxAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
  }

  export type WashUserCountAggregateInputType = {
    id?: true
    name?: true
    tel?: true
    balance?: true
    washHistoryId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type WashUserAggregateArgs = {
    /**
     * Filter which washUser to aggregate.
     */
    where?: washUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of washUsers to fetch.
     */
    orderBy?: Enumerable<washUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: washUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` washUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` washUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned washUsers
    **/
    _count?: true | WashUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashUserMaxAggregateInputType
  }

  export type GetWashUserAggregateType<T extends WashUserAggregateArgs> = {
        [P in keyof T & keyof AggregateWashUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashUser[P]>
      : GetScalarType<T[P], AggregateWashUser[P]>
  }




  export type WashUserGroupByArgs = {
    where?: washUserWhereInput
    orderBy?: Enumerable<washUserOrderByWithAggregationInput>
    by: WashUserScalarFieldEnum[]
    having?: washUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashUserCountAggregateInputType | true
    _avg?: WashUserAvgAggregateInputType
    _sum?: WashUserSumAggregateInputType
    _min?: WashUserMinAggregateInputType
    _max?: WashUserMaxAggregateInputType
  }


  export type WashUserGroupByOutputType = {
    id: number
    name: string
    tel: number
    balance: number
    washHistoryId: number | null
    createAt: Date
    updateAt: Date
    _count: WashUserCountAggregateOutputType | null
    _avg: WashUserAvgAggregateOutputType | null
    _sum: WashUserSumAggregateOutputType | null
    _min: WashUserMinAggregateOutputType | null
    _max: WashUserMaxAggregateOutputType | null
  }

  type GetWashUserGroupByPayload<T extends WashUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WashUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashUserGroupByOutputType[P]>
            : GetScalarType<T[P], WashUserGroupByOutputType[P]>
        }
      >
    >


  export type washUserSelect = {
    id?: boolean
    name?: boolean
    tel?: boolean
    balance?: boolean
    washHistory?: boolean | WashHistoryArgs
    washHistoryId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type washUserInclude = {
    washHistory?: boolean | WashHistoryArgs
  }

  export type washUserGetPayload<S extends boolean | null | undefined | washUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? washUser :
    S extends undefined ? never :
    S extends { include: any } & (washUserArgs | washUserFindManyArgs)
    ? washUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'washHistory' ? WashHistoryGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (washUserArgs | washUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'washHistory' ? WashHistoryGetPayload<S['select'][P]> | null :  P extends keyof washUser ? washUser[P] : never
  } 
      : washUser


  type washUserCountArgs = 
    Omit<washUserFindManyArgs, 'select' | 'include'> & {
      select?: WashUserCountAggregateInputType | true
    }

  export interface washUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WashUser that matches the filter.
     * @param {washUserFindUniqueArgs} args - Arguments to find a WashUser
     * @example
     * // Get one WashUser
     * const washUser = await prisma.washUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends washUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, washUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'washUser'> extends True ? Prisma__washUserClient<washUserGetPayload<T>> : Prisma__washUserClient<washUserGetPayload<T> | null, null>

    /**
     * Find one WashUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {washUserFindUniqueOrThrowArgs} args - Arguments to find a WashUser
     * @example
     * // Get one WashUser
     * const washUser = await prisma.washUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends washUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, washUserFindUniqueOrThrowArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Find the first WashUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {washUserFindFirstArgs} args - Arguments to find a WashUser
     * @example
     * // Get one WashUser
     * const washUser = await prisma.washUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends washUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, washUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'washUser'> extends True ? Prisma__washUserClient<washUserGetPayload<T>> : Prisma__washUserClient<washUserGetPayload<T> | null, null>

    /**
     * Find the first WashUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {washUserFindFirstOrThrowArgs} args - Arguments to find a WashUser
     * @example
     * // Get one WashUser
     * const washUser = await prisma.washUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends washUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, washUserFindFirstOrThrowArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Find zero or more WashUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {washUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashUsers
     * const washUsers = await prisma.washUser.findMany()
     * 
     * // Get first 10 WashUsers
     * const washUsers = await prisma.washUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washUserWithIdOnly = await prisma.washUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends washUserFindManyArgs>(
      args?: SelectSubset<T, washUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<washUserGetPayload<T>>>

    /**
     * Create a WashUser.
     * @param {washUserCreateArgs} args - Arguments to create a WashUser.
     * @example
     * // Create one WashUser
     * const WashUser = await prisma.washUser.create({
     *   data: {
     *     // ... data to create a WashUser
     *   }
     * })
     * 
    **/
    create<T extends washUserCreateArgs>(
      args: SelectSubset<T, washUserCreateArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Create many WashUsers.
     *     @param {washUserCreateManyArgs} args - Arguments to create many WashUsers.
     *     @example
     *     // Create many WashUsers
     *     const washUser = await prisma.washUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends washUserCreateManyArgs>(
      args?: SelectSubset<T, washUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WashUser.
     * @param {washUserDeleteArgs} args - Arguments to delete one WashUser.
     * @example
     * // Delete one WashUser
     * const WashUser = await prisma.washUser.delete({
     *   where: {
     *     // ... filter to delete one WashUser
     *   }
     * })
     * 
    **/
    delete<T extends washUserDeleteArgs>(
      args: SelectSubset<T, washUserDeleteArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Update one WashUser.
     * @param {washUserUpdateArgs} args - Arguments to update one WashUser.
     * @example
     * // Update one WashUser
     * const washUser = await prisma.washUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends washUserUpdateArgs>(
      args: SelectSubset<T, washUserUpdateArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Delete zero or more WashUsers.
     * @param {washUserDeleteManyArgs} args - Arguments to filter WashUsers to delete.
     * @example
     * // Delete a few WashUsers
     * const { count } = await prisma.washUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends washUserDeleteManyArgs>(
      args?: SelectSubset<T, washUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {washUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashUsers
     * const washUser = await prisma.washUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends washUserUpdateManyArgs>(
      args: SelectSubset<T, washUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WashUser.
     * @param {washUserUpsertArgs} args - Arguments to update or create a WashUser.
     * @example
     * // Update or create a WashUser
     * const washUser = await prisma.washUser.upsert({
     *   create: {
     *     // ... data to create a WashUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashUser we want to update
     *   }
     * })
    **/
    upsert<T extends washUserUpsertArgs>(
      args: SelectSubset<T, washUserUpsertArgs>
    ): Prisma__washUserClient<washUserGetPayload<T>>

    /**
     * Count the number of WashUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {washUserCountArgs} args - Arguments to filter WashUsers to count.
     * @example
     * // Count the number of WashUsers
     * const count = await prisma.washUser.count({
     *   where: {
     *     // ... the filter for the WashUsers we want to count
     *   }
     * })
    **/
    count<T extends washUserCountArgs>(
      args?: Subset<T, washUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashUserAggregateArgs>(args: Subset<T, WashUserAggregateArgs>): Prisma.PrismaPromise<GetWashUserAggregateType<T>>

    /**
     * Group by WashUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashUserGroupByArgs['orderBy'] }
        : { orderBy?: WashUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for washUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__washUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    washHistory<T extends WashHistoryArgs= {}>(args?: Subset<T, WashHistoryArgs>): Prisma__WashHistoryClient<WashHistoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * washUser base type for findUnique actions
   */
  export type washUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter, which washUser to fetch.
     */
    where: washUserWhereUniqueInput
  }

  /**
   * washUser findUnique
   */
  export interface washUserFindUniqueArgs extends washUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * washUser findUniqueOrThrow
   */
  export type washUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter, which washUser to fetch.
     */
    where: washUserWhereUniqueInput
  }


  /**
   * washUser base type for findFirst actions
   */
  export type washUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter, which washUser to fetch.
     */
    where?: washUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of washUsers to fetch.
     */
    orderBy?: Enumerable<washUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for washUsers.
     */
    cursor?: washUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` washUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` washUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of washUsers.
     */
    distinct?: Enumerable<WashUserScalarFieldEnum>
  }

  /**
   * washUser findFirst
   */
  export interface washUserFindFirstArgs extends washUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * washUser findFirstOrThrow
   */
  export type washUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter, which washUser to fetch.
     */
    where?: washUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of washUsers to fetch.
     */
    orderBy?: Enumerable<washUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for washUsers.
     */
    cursor?: washUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` washUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` washUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of washUsers.
     */
    distinct?: Enumerable<WashUserScalarFieldEnum>
  }


  /**
   * washUser findMany
   */
  export type washUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter, which washUsers to fetch.
     */
    where?: washUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of washUsers to fetch.
     */
    orderBy?: Enumerable<washUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing washUsers.
     */
    cursor?: washUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` washUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` washUsers.
     */
    skip?: number
    distinct?: Enumerable<WashUserScalarFieldEnum>
  }


  /**
   * washUser create
   */
  export type washUserCreateArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * The data needed to create a washUser.
     */
    data: XOR<washUserCreateInput, washUserUncheckedCreateInput>
  }


  /**
   * washUser createMany
   */
  export type washUserCreateManyArgs = {
    /**
     * The data used to create many washUsers.
     */
    data: Enumerable<washUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * washUser update
   */
  export type washUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * The data needed to update a washUser.
     */
    data: XOR<washUserUpdateInput, washUserUncheckedUpdateInput>
    /**
     * Choose, which washUser to update.
     */
    where: washUserWhereUniqueInput
  }


  /**
   * washUser updateMany
   */
  export type washUserUpdateManyArgs = {
    /**
     * The data used to update washUsers.
     */
    data: XOR<washUserUpdateManyMutationInput, washUserUncheckedUpdateManyInput>
    /**
     * Filter which washUsers to update
     */
    where?: washUserWhereInput
  }


  /**
   * washUser upsert
   */
  export type washUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * The filter to search for the washUser to update in case it exists.
     */
    where: washUserWhereUniqueInput
    /**
     * In case the washUser found by the `where` argument doesn't exist, create a new washUser with this data.
     */
    create: XOR<washUserCreateInput, washUserUncheckedCreateInput>
    /**
     * In case the washUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<washUserUpdateInput, washUserUncheckedUpdateInput>
  }


  /**
   * washUser delete
   */
  export type washUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    /**
     * Filter which washUser to delete.
     */
    where: washUserWhereUniqueInput
  }


  /**
   * washUser deleteMany
   */
  export type washUserDeleteManyArgs = {
    /**
     * Filter which washUsers to delete
     */
    where?: washUserWhereInput
  }


  /**
   * washUser without action
   */
  export type washUserArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
  }



  /**
   * Model WashHistory
   */


  export type AggregateWashHistory = {
    _count: WashHistoryCountAggregateOutputType | null
    _avg: WashHistoryAvgAggregateOutputType | null
    _sum: WashHistorySumAggregateOutputType | null
    _min: WashHistoryMinAggregateOutputType | null
    _max: WashHistoryMaxAggregateOutputType | null
  }

  export type WashHistoryAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type WashHistorySumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type WashHistoryMinAggregateOutputType = {
    id: number | null
    date: string | null
    price: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type WashHistoryMaxAggregateOutputType = {
    id: number | null
    date: string | null
    price: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type WashHistoryCountAggregateOutputType = {
    id: number
    date: number
    price: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type WashHistoryAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type WashHistorySumAggregateInputType = {
    id?: true
    price?: true
  }

  export type WashHistoryMinAggregateInputType = {
    id?: true
    date?: true
    price?: true
    createAt?: true
    updateAt?: true
  }

  export type WashHistoryMaxAggregateInputType = {
    id?: true
    date?: true
    price?: true
    createAt?: true
    updateAt?: true
  }

  export type WashHistoryCountAggregateInputType = {
    id?: true
    date?: true
    price?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type WashHistoryAggregateArgs = {
    /**
     * Filter which WashHistory to aggregate.
     */
    where?: WashHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashHistories to fetch.
     */
    orderBy?: Enumerable<WashHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WashHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WashHistories
    **/
    _count?: true | WashHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashHistoryMaxAggregateInputType
  }

  export type GetWashHistoryAggregateType<T extends WashHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateWashHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashHistory[P]>
      : GetScalarType<T[P], AggregateWashHistory[P]>
  }




  export type WashHistoryGroupByArgs = {
    where?: WashHistoryWhereInput
    orderBy?: Enumerable<WashHistoryOrderByWithAggregationInput>
    by: WashHistoryScalarFieldEnum[]
    having?: WashHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashHistoryCountAggregateInputType | true
    _avg?: WashHistoryAvgAggregateInputType
    _sum?: WashHistorySumAggregateInputType
    _min?: WashHistoryMinAggregateInputType
    _max?: WashHistoryMaxAggregateInputType
  }


  export type WashHistoryGroupByOutputType = {
    id: number
    date: string
    price: number
    createAt: Date
    updateAt: Date
    _count: WashHistoryCountAggregateOutputType | null
    _avg: WashHistoryAvgAggregateOutputType | null
    _sum: WashHistorySumAggregateOutputType | null
    _min: WashHistoryMinAggregateOutputType | null
    _max: WashHistoryMaxAggregateOutputType | null
  }

  type GetWashHistoryGroupByPayload<T extends WashHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WashHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], WashHistoryGroupByOutputType[P]>
        }
      >
    >


  export type WashHistorySelect = {
    id?: boolean
    date?: boolean
    price?: boolean
    programs?: boolean | WashHistory$programsArgs
    machines?: boolean | WashHistory$machinesArgs
    users?: boolean | WashHistory$usersArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | WashHistoryCountOutputTypeArgs
  }


  export type WashHistoryInclude = {
    programs?: boolean | WashHistory$programsArgs
    machines?: boolean | WashHistory$machinesArgs
    users?: boolean | WashHistory$usersArgs
    _count?: boolean | WashHistoryCountOutputTypeArgs
  }

  export type WashHistoryGetPayload<S extends boolean | null | undefined | WashHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WashHistory :
    S extends undefined ? never :
    S extends { include: any } & (WashHistoryArgs | WashHistoryFindManyArgs)
    ? WashHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'programs' ? Array < ProgramGetPayload<S['include'][P]>>  :
        P extends 'machines' ? Array < MachineGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < washUserGetPayload<S['include'][P]>>  :
        P extends '_count' ? WashHistoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WashHistoryArgs | WashHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'programs' ? Array < ProgramGetPayload<S['select'][P]>>  :
        P extends 'machines' ? Array < MachineGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < washUserGetPayload<S['select'][P]>>  :
        P extends '_count' ? WashHistoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WashHistory ? WashHistory[P] : never
  } 
      : WashHistory


  type WashHistoryCountArgs = 
    Omit<WashHistoryFindManyArgs, 'select' | 'include'> & {
      select?: WashHistoryCountAggregateInputType | true
    }

  export interface WashHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WashHistory that matches the filter.
     * @param {WashHistoryFindUniqueArgs} args - Arguments to find a WashHistory
     * @example
     * // Get one WashHistory
     * const washHistory = await prisma.washHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WashHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WashHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WashHistory'> extends True ? Prisma__WashHistoryClient<WashHistoryGetPayload<T>> : Prisma__WashHistoryClient<WashHistoryGetPayload<T> | null, null>

    /**
     * Find one WashHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WashHistoryFindUniqueOrThrowArgs} args - Arguments to find a WashHistory
     * @example
     * // Get one WashHistory
     * const washHistory = await prisma.washHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WashHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WashHistoryFindUniqueOrThrowArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Find the first WashHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryFindFirstArgs} args - Arguments to find a WashHistory
     * @example
     * // Get one WashHistory
     * const washHistory = await prisma.washHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WashHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WashHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WashHistory'> extends True ? Prisma__WashHistoryClient<WashHistoryGetPayload<T>> : Prisma__WashHistoryClient<WashHistoryGetPayload<T> | null, null>

    /**
     * Find the first WashHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryFindFirstOrThrowArgs} args - Arguments to find a WashHistory
     * @example
     * // Get one WashHistory
     * const washHistory = await prisma.washHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WashHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WashHistoryFindFirstOrThrowArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Find zero or more WashHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashHistories
     * const washHistories = await prisma.washHistory.findMany()
     * 
     * // Get first 10 WashHistories
     * const washHistories = await prisma.washHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washHistoryWithIdOnly = await prisma.washHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WashHistoryFindManyArgs>(
      args?: SelectSubset<T, WashHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<WashHistoryGetPayload<T>>>

    /**
     * Create a WashHistory.
     * @param {WashHistoryCreateArgs} args - Arguments to create a WashHistory.
     * @example
     * // Create one WashHistory
     * const WashHistory = await prisma.washHistory.create({
     *   data: {
     *     // ... data to create a WashHistory
     *   }
     * })
     * 
    **/
    create<T extends WashHistoryCreateArgs>(
      args: SelectSubset<T, WashHistoryCreateArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Create many WashHistories.
     *     @param {WashHistoryCreateManyArgs} args - Arguments to create many WashHistories.
     *     @example
     *     // Create many WashHistories
     *     const washHistory = await prisma.washHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WashHistoryCreateManyArgs>(
      args?: SelectSubset<T, WashHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WashHistory.
     * @param {WashHistoryDeleteArgs} args - Arguments to delete one WashHistory.
     * @example
     * // Delete one WashHistory
     * const WashHistory = await prisma.washHistory.delete({
     *   where: {
     *     // ... filter to delete one WashHistory
     *   }
     * })
     * 
    **/
    delete<T extends WashHistoryDeleteArgs>(
      args: SelectSubset<T, WashHistoryDeleteArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Update one WashHistory.
     * @param {WashHistoryUpdateArgs} args - Arguments to update one WashHistory.
     * @example
     * // Update one WashHistory
     * const washHistory = await prisma.washHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WashHistoryUpdateArgs>(
      args: SelectSubset<T, WashHistoryUpdateArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Delete zero or more WashHistories.
     * @param {WashHistoryDeleteManyArgs} args - Arguments to filter WashHistories to delete.
     * @example
     * // Delete a few WashHistories
     * const { count } = await prisma.washHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WashHistoryDeleteManyArgs>(
      args?: SelectSubset<T, WashHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashHistories
     * const washHistory = await prisma.washHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WashHistoryUpdateManyArgs>(
      args: SelectSubset<T, WashHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WashHistory.
     * @param {WashHistoryUpsertArgs} args - Arguments to update or create a WashHistory.
     * @example
     * // Update or create a WashHistory
     * const washHistory = await prisma.washHistory.upsert({
     *   create: {
     *     // ... data to create a WashHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashHistory we want to update
     *   }
     * })
    **/
    upsert<T extends WashHistoryUpsertArgs>(
      args: SelectSubset<T, WashHistoryUpsertArgs>
    ): Prisma__WashHistoryClient<WashHistoryGetPayload<T>>

    /**
     * Count the number of WashHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryCountArgs} args - Arguments to filter WashHistories to count.
     * @example
     * // Count the number of WashHistories
     * const count = await prisma.washHistory.count({
     *   where: {
     *     // ... the filter for the WashHistories we want to count
     *   }
     * })
    **/
    count<T extends WashHistoryCountArgs>(
      args?: Subset<T, WashHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashHistoryAggregateArgs>(args: Subset<T, WashHistoryAggregateArgs>): Prisma.PrismaPromise<GetWashHistoryAggregateType<T>>

    /**
     * Group by WashHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashHistoryGroupByArgs['orderBy'] }
        : { orderBy?: WashHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WashHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WashHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    programs<T extends WashHistory$programsArgs= {}>(args?: Subset<T, WashHistory$programsArgs>): Prisma.PrismaPromise<Array<ProgramGetPayload<T>>| Null>;

    machines<T extends WashHistory$machinesArgs= {}>(args?: Subset<T, WashHistory$machinesArgs>): Prisma.PrismaPromise<Array<MachineGetPayload<T>>| Null>;

    users<T extends WashHistory$usersArgs= {}>(args?: Subset<T, WashHistory$usersArgs>): Prisma.PrismaPromise<Array<washUserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WashHistory base type for findUnique actions
   */
  export type WashHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter, which WashHistory to fetch.
     */
    where: WashHistoryWhereUniqueInput
  }

  /**
   * WashHistory findUnique
   */
  export interface WashHistoryFindUniqueArgs extends WashHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WashHistory findUniqueOrThrow
   */
  export type WashHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter, which WashHistory to fetch.
     */
    where: WashHistoryWhereUniqueInput
  }


  /**
   * WashHistory base type for findFirst actions
   */
  export type WashHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter, which WashHistory to fetch.
     */
    where?: WashHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashHistories to fetch.
     */
    orderBy?: Enumerable<WashHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashHistories.
     */
    cursor?: WashHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashHistories.
     */
    distinct?: Enumerable<WashHistoryScalarFieldEnum>
  }

  /**
   * WashHistory findFirst
   */
  export interface WashHistoryFindFirstArgs extends WashHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WashHistory findFirstOrThrow
   */
  export type WashHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter, which WashHistory to fetch.
     */
    where?: WashHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashHistories to fetch.
     */
    orderBy?: Enumerable<WashHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashHistories.
     */
    cursor?: WashHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashHistories.
     */
    distinct?: Enumerable<WashHistoryScalarFieldEnum>
  }


  /**
   * WashHistory findMany
   */
  export type WashHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter, which WashHistories to fetch.
     */
    where?: WashHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashHistories to fetch.
     */
    orderBy?: Enumerable<WashHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WashHistories.
     */
    cursor?: WashHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashHistories.
     */
    skip?: number
    distinct?: Enumerable<WashHistoryScalarFieldEnum>
  }


  /**
   * WashHistory create
   */
  export type WashHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * The data needed to create a WashHistory.
     */
    data: XOR<WashHistoryCreateInput, WashHistoryUncheckedCreateInput>
  }


  /**
   * WashHistory createMany
   */
  export type WashHistoryCreateManyArgs = {
    /**
     * The data used to create many WashHistories.
     */
    data: Enumerable<WashHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WashHistory update
   */
  export type WashHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * The data needed to update a WashHistory.
     */
    data: XOR<WashHistoryUpdateInput, WashHistoryUncheckedUpdateInput>
    /**
     * Choose, which WashHistory to update.
     */
    where: WashHistoryWhereUniqueInput
  }


  /**
   * WashHistory updateMany
   */
  export type WashHistoryUpdateManyArgs = {
    /**
     * The data used to update WashHistories.
     */
    data: XOR<WashHistoryUpdateManyMutationInput, WashHistoryUncheckedUpdateManyInput>
    /**
     * Filter which WashHistories to update
     */
    where?: WashHistoryWhereInput
  }


  /**
   * WashHistory upsert
   */
  export type WashHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * The filter to search for the WashHistory to update in case it exists.
     */
    where: WashHistoryWhereUniqueInput
    /**
     * In case the WashHistory found by the `where` argument doesn't exist, create a new WashHistory with this data.
     */
    create: XOR<WashHistoryCreateInput, WashHistoryUncheckedCreateInput>
    /**
     * In case the WashHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WashHistoryUpdateInput, WashHistoryUncheckedUpdateInput>
  }


  /**
   * WashHistory delete
   */
  export type WashHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
    /**
     * Filter which WashHistory to delete.
     */
    where: WashHistoryWhereUniqueInput
  }


  /**
   * WashHistory deleteMany
   */
  export type WashHistoryDeleteManyArgs = {
    /**
     * Filter which WashHistories to delete
     */
    where?: WashHistoryWhereInput
  }


  /**
   * WashHistory.programs
   */
  export type WashHistory$programsArgs = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude | null
    where?: ProgramWhereInput
    orderBy?: Enumerable<ProgramOrderByWithRelationInput>
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProgramScalarFieldEnum>
  }


  /**
   * WashHistory.machines
   */
  export type WashHistory$machinesArgs = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MachineInclude | null
    where?: MachineWhereInput
    orderBy?: Enumerable<MachineOrderByWithRelationInput>
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MachineScalarFieldEnum>
  }


  /**
   * WashHistory.users
   */
  export type WashHistory$usersArgs = {
    /**
     * Select specific fields to fetch from the washUser
     */
    select?: washUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: washUserInclude | null
    where?: washUserWhereInput
    orderBy?: Enumerable<washUserOrderByWithRelationInput>
    cursor?: washUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WashUserScalarFieldEnum>
  }


  /**
   * WashHistory without action
   */
  export type WashHistoryArgs = {
    /**
     * Select specific fields to fetch from the WashHistory
     */
    select?: WashHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WashHistoryInclude | null
  }



  /**
   * Model Todolist
   */


  export type AggregateTodolist = {
    _count: TodolistCountAggregateOutputType | null
    _avg: TodolistAvgAggregateOutputType | null
    _sum: TodolistSumAggregateOutputType | null
    _min: TodolistMinAggregateOutputType | null
    _max: TodolistMaxAggregateOutputType | null
  }

  export type TodolistAvgAggregateOutputType = {
    id: number | null
  }

  export type TodolistSumAggregateOutputType = {
    id: number | null
  }

  export type TodolistMinAggregateOutputType = {
    id: number | null
    task: string | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodolistMaxAggregateOutputType = {
    id: number | null
    task: string | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodolistCountAggregateOutputType = {
    id: number
    task: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodolistAvgAggregateInputType = {
    id?: true
  }

  export type TodolistSumAggregateInputType = {
    id?: true
  }

  export type TodolistMinAggregateInputType = {
    id?: true
    task?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodolistMaxAggregateInputType = {
    id?: true
    task?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodolistCountAggregateInputType = {
    id?: true
    task?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodolistAggregateArgs = {
    /**
     * Filter which Todolist to aggregate.
     */
    where?: TodolistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todolists to fetch.
     */
    orderBy?: Enumerable<TodolistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodolistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todolists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todolists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Todolists
    **/
    _count?: true | TodolistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodolistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodolistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodolistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodolistMaxAggregateInputType
  }

  export type GetTodolistAggregateType<T extends TodolistAggregateArgs> = {
        [P in keyof T & keyof AggregateTodolist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodolist[P]>
      : GetScalarType<T[P], AggregateTodolist[P]>
  }




  export type TodolistGroupByArgs = {
    where?: TodolistWhereInput
    orderBy?: Enumerable<TodolistOrderByWithAggregationInput>
    by: TodolistScalarFieldEnum[]
    having?: TodolistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodolistCountAggregateInputType | true
    _avg?: TodolistAvgAggregateInputType
    _sum?: TodolistSumAggregateInputType
    _min?: TodolistMinAggregateInputType
    _max?: TodolistMaxAggregateInputType
  }


  export type TodolistGroupByOutputType = {
    id: number
    task: string
    notes: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TodolistCountAggregateOutputType | null
    _avg: TodolistAvgAggregateOutputType | null
    _sum: TodolistSumAggregateOutputType | null
    _min: TodolistMinAggregateOutputType | null
    _max: TodolistMaxAggregateOutputType | null
  }

  type GetTodolistGroupByPayload<T extends TodolistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodolistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodolistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodolistGroupByOutputType[P]>
            : GetScalarType<T[P], TodolistGroupByOutputType[P]>
        }
      >
    >


  export type TodolistSelect = {
    id?: boolean
    task?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TodolistGetPayload<S extends boolean | null | undefined | TodolistArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Todolist :
    S extends undefined ? never :
    S extends { include: any } & (TodolistArgs | TodolistFindManyArgs)
    ? Todolist 
    : S extends { select: any } & (TodolistArgs | TodolistFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Todolist ? Todolist[P] : never
  } 
      : Todolist


  type TodolistCountArgs = 
    Omit<TodolistFindManyArgs, 'select' | 'include'> & {
      select?: TodolistCountAggregateInputType | true
    }

  export interface TodolistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Todolist that matches the filter.
     * @param {TodolistFindUniqueArgs} args - Arguments to find a Todolist
     * @example
     * // Get one Todolist
     * const todolist = await prisma.todolist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodolistFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodolistFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Todolist'> extends True ? Prisma__TodolistClient<TodolistGetPayload<T>> : Prisma__TodolistClient<TodolistGetPayload<T> | null, null>

    /**
     * Find one Todolist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodolistFindUniqueOrThrowArgs} args - Arguments to find a Todolist
     * @example
     * // Get one Todolist
     * const todolist = await prisma.todolist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodolistFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodolistFindUniqueOrThrowArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Find the first Todolist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistFindFirstArgs} args - Arguments to find a Todolist
     * @example
     * // Get one Todolist
     * const todolist = await prisma.todolist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodolistFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodolistFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Todolist'> extends True ? Prisma__TodolistClient<TodolistGetPayload<T>> : Prisma__TodolistClient<TodolistGetPayload<T> | null, null>

    /**
     * Find the first Todolist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistFindFirstOrThrowArgs} args - Arguments to find a Todolist
     * @example
     * // Get one Todolist
     * const todolist = await prisma.todolist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodolistFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodolistFindFirstOrThrowArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Find zero or more Todolists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Todolists
     * const todolists = await prisma.todolist.findMany()
     * 
     * // Get first 10 Todolists
     * const todolists = await prisma.todolist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todolistWithIdOnly = await prisma.todolist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodolistFindManyArgs>(
      args?: SelectSubset<T, TodolistFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodolistGetPayload<T>>>

    /**
     * Create a Todolist.
     * @param {TodolistCreateArgs} args - Arguments to create a Todolist.
     * @example
     * // Create one Todolist
     * const Todolist = await prisma.todolist.create({
     *   data: {
     *     // ... data to create a Todolist
     *   }
     * })
     * 
    **/
    create<T extends TodolistCreateArgs>(
      args: SelectSubset<T, TodolistCreateArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Create many Todolists.
     *     @param {TodolistCreateManyArgs} args - Arguments to create many Todolists.
     *     @example
     *     // Create many Todolists
     *     const todolist = await prisma.todolist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodolistCreateManyArgs>(
      args?: SelectSubset<T, TodolistCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Todolist.
     * @param {TodolistDeleteArgs} args - Arguments to delete one Todolist.
     * @example
     * // Delete one Todolist
     * const Todolist = await prisma.todolist.delete({
     *   where: {
     *     // ... filter to delete one Todolist
     *   }
     * })
     * 
    **/
    delete<T extends TodolistDeleteArgs>(
      args: SelectSubset<T, TodolistDeleteArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Update one Todolist.
     * @param {TodolistUpdateArgs} args - Arguments to update one Todolist.
     * @example
     * // Update one Todolist
     * const todolist = await prisma.todolist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodolistUpdateArgs>(
      args: SelectSubset<T, TodolistUpdateArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Delete zero or more Todolists.
     * @param {TodolistDeleteManyArgs} args - Arguments to filter Todolists to delete.
     * @example
     * // Delete a few Todolists
     * const { count } = await prisma.todolist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodolistDeleteManyArgs>(
      args?: SelectSubset<T, TodolistDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todolists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Todolists
     * const todolist = await prisma.todolist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodolistUpdateManyArgs>(
      args: SelectSubset<T, TodolistUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Todolist.
     * @param {TodolistUpsertArgs} args - Arguments to update or create a Todolist.
     * @example
     * // Update or create a Todolist
     * const todolist = await prisma.todolist.upsert({
     *   create: {
     *     // ... data to create a Todolist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Todolist we want to update
     *   }
     * })
    **/
    upsert<T extends TodolistUpsertArgs>(
      args: SelectSubset<T, TodolistUpsertArgs>
    ): Prisma__TodolistClient<TodolistGetPayload<T>>

    /**
     * Count the number of Todolists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistCountArgs} args - Arguments to filter Todolists to count.
     * @example
     * // Count the number of Todolists
     * const count = await prisma.todolist.count({
     *   where: {
     *     // ... the filter for the Todolists we want to count
     *   }
     * })
    **/
    count<T extends TodolistCountArgs>(
      args?: Subset<T, TodolistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodolistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Todolist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodolistAggregateArgs>(args: Subset<T, TodolistAggregateArgs>): Prisma.PrismaPromise<GetTodolistAggregateType<T>>

    /**
     * Group by Todolist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodolistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodolistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodolistGroupByArgs['orderBy'] }
        : { orderBy?: TodolistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodolistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodolistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Todolist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodolistClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Todolist base type for findUnique actions
   */
  export type TodolistFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter, which Todolist to fetch.
     */
    where: TodolistWhereUniqueInput
  }

  /**
   * Todolist findUnique
   */
  export interface TodolistFindUniqueArgs extends TodolistFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Todolist findUniqueOrThrow
   */
  export type TodolistFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter, which Todolist to fetch.
     */
    where: TodolistWhereUniqueInput
  }


  /**
   * Todolist base type for findFirst actions
   */
  export type TodolistFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter, which Todolist to fetch.
     */
    where?: TodolistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todolists to fetch.
     */
    orderBy?: Enumerable<TodolistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todolists.
     */
    cursor?: TodolistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todolists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todolists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todolists.
     */
    distinct?: Enumerable<TodolistScalarFieldEnum>
  }

  /**
   * Todolist findFirst
   */
  export interface TodolistFindFirstArgs extends TodolistFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Todolist findFirstOrThrow
   */
  export type TodolistFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter, which Todolist to fetch.
     */
    where?: TodolistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todolists to fetch.
     */
    orderBy?: Enumerable<TodolistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todolists.
     */
    cursor?: TodolistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todolists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todolists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todolists.
     */
    distinct?: Enumerable<TodolistScalarFieldEnum>
  }


  /**
   * Todolist findMany
   */
  export type TodolistFindManyArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter, which Todolists to fetch.
     */
    where?: TodolistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todolists to fetch.
     */
    orderBy?: Enumerable<TodolistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Todolists.
     */
    cursor?: TodolistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Todolists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todolists.
     */
    skip?: number
    distinct?: Enumerable<TodolistScalarFieldEnum>
  }


  /**
   * Todolist create
   */
  export type TodolistCreateArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * The data needed to create a Todolist.
     */
    data: XOR<TodolistCreateInput, TodolistUncheckedCreateInput>
  }


  /**
   * Todolist createMany
   */
  export type TodolistCreateManyArgs = {
    /**
     * The data used to create many Todolists.
     */
    data: Enumerable<TodolistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Todolist update
   */
  export type TodolistUpdateArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * The data needed to update a Todolist.
     */
    data: XOR<TodolistUpdateInput, TodolistUncheckedUpdateInput>
    /**
     * Choose, which Todolist to update.
     */
    where: TodolistWhereUniqueInput
  }


  /**
   * Todolist updateMany
   */
  export type TodolistUpdateManyArgs = {
    /**
     * The data used to update Todolists.
     */
    data: XOR<TodolistUpdateManyMutationInput, TodolistUncheckedUpdateManyInput>
    /**
     * Filter which Todolists to update
     */
    where?: TodolistWhereInput
  }


  /**
   * Todolist upsert
   */
  export type TodolistUpsertArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * The filter to search for the Todolist to update in case it exists.
     */
    where: TodolistWhereUniqueInput
    /**
     * In case the Todolist found by the `where` argument doesn't exist, create a new Todolist with this data.
     */
    create: XOR<TodolistCreateInput, TodolistUncheckedCreateInput>
    /**
     * In case the Todolist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodolistUpdateInput, TodolistUncheckedUpdateInput>
  }


  /**
   * Todolist delete
   */
  export type TodolistDeleteArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
    /**
     * Filter which Todolist to delete.
     */
    where: TodolistWhereUniqueInput
  }


  /**
   * Todolist deleteMany
   */
  export type TodolistDeleteManyArgs = {
    /**
     * Filter which Todolists to delete
     */
    where?: TodolistWhereInput
  }


  /**
   * Todolist without action
   */
  export type TodolistArgs = {
    /**
     * Select specific fields to fetch from the Todolist
     */
    select?: TodolistSelect | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    image: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    name: string
    image: string
    createAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    createAt?: boolean
    updateAt?: boolean
    directMessage?: boolean | User$directMessageArgs
    fromUserRelation?: boolean | User$fromUserRelationArgs
    toUserRelation?: boolean | User$toUserRelationArgs
    posts?: boolean | User$postsArgs
    replies?: boolean | User$repliesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    directMessage?: boolean | User$directMessageArgs
    fromUserRelation?: boolean | User$fromUserRelationArgs
    toUserRelation?: boolean | User$toUserRelationArgs
    posts?: boolean | User$postsArgs
    replies?: boolean | User$repliesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'directMessage' ? Array < DirectMessageGetPayload<S['include'][P]>>  :
        P extends 'fromUserRelation' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'toUserRelation' ? Array < UserRelationGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'replies' ? Array < ReplyGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'directMessage' ? Array < DirectMessageGetPayload<S['select'][P]>>  :
        P extends 'fromUserRelation' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'toUserRelation' ? Array < UserRelationGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'replies' ? Array < ReplyGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    directMessage<T extends User$directMessageArgs= {}>(args?: Subset<T, User$directMessageArgs>): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>| Null>;

    fromUserRelation<T extends User$fromUserRelationArgs= {}>(args?: Subset<T, User$fromUserRelationArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    toUserRelation<T extends User$toUserRelationArgs= {}>(args?: Subset<T, User$toUserRelationArgs>): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>| Null>;

    posts<T extends User$postsArgs= {}>(args?: Subset<T, User$postsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    replies<T extends User$repliesArgs= {}>(args?: Subset<T, User$repliesArgs>): Prisma.PrismaPromise<Array<ReplyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.directMessage
   */
  export type User$directMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * User.fromUserRelation
   */
  export type User$fromUserRelationArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.toUserRelation
   */
  export type User$toUserRelationArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    cursor?: UserRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * User.posts
   */
  export type User$postsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * User.replies
   */
  export type User$repliesArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    where?: ReplyWhereInput
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReplyScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model DirectMessage
   */


  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DirectMessageSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type DirectMessageAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DirectMessageSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DirectMessageMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createAt?: true
    updateAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createAt?: true
    updateAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs = {
    where?: DirectMessageWhereInput
    orderBy?: Enumerable<DirectMessageOrderByWithAggregationInput>
    by: DirectMessageScalarFieldEnum[]
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _avg?: DirectMessageAvgAggregateInputType
    _sum?: DirectMessageSumAggregateInputType
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }


  export type DirectMessageGroupByOutputType = {
    id: number
    userId: number
    message: string
    createAt: Date
    updateAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _avg: DirectMessageAvgAggregateOutputType | null
    _sum: DirectMessageSumAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    message?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type DirectMessageInclude = {
    user?: boolean | UserArgs
  }

  export type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
    ? DirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DirectMessageArgs | DirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof DirectMessage ? DirectMessage[P] : never
  } 
      : DirectMessage


  type DirectMessageCountArgs = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find one DirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DirectMessage'> extends True ? Prisma__DirectMessageClient<DirectMessageGetPayload<T>> : Prisma__DirectMessageClient<DirectMessageGetPayload<T> | null, null>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DirectMessageFindManyArgs>(
      args?: SelectSubset<T, DirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<DirectMessageGetPayload<T>>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
    **/
    create<T extends DirectMessageCreateArgs>(
      args: SelectSubset<T, DirectMessageCreateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Create many DirectMessages.
     *     @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     *     @example
     *     // Create many DirectMessages
     *     const directMessage = await prisma.directMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DirectMessageCreateManyArgs>(
      args?: SelectSubset<T, DirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends DirectMessageDeleteArgs>(
      args: SelectSubset<T, DirectMessageDeleteArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DirectMessageUpdateArgs>(
      args: SelectSubset<T, DirectMessageUpdateArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, DirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DirectMessageUpdateManyArgs>(
      args: SelectSubset<T, DirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends DirectMessageUpsertArgs>(
      args: SelectSubset<T, DirectMessageUpsertArgs>
    ): Prisma__DirectMessageClient<DirectMessageGetPayload<T>>

    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DirectMessage base type for findUnique actions
   */
  export type DirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUnique
   */
  export interface DirectMessageFindUniqueArgs extends DirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage base type for findFirst actions
   */
  export type DirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }

  /**
   * DirectMessage findFirst
   */
  export interface DirectMessageFindFirstArgs extends DirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: Enumerable<DirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: Enumerable<DirectMessageScalarFieldEnum>
  }


  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }


  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs = {
    /**
     * The data used to create many DirectMessages.
     */
    data: Enumerable<DirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }


  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }


  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }


  /**
   * DirectMessage without action
   */
  export type DirectMessageArgs = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DirectMessageInclude | null
  }



  /**
   * Model UserRelation
   */


  export type AggregateUserRelation = {
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  export type UserRelationAvgAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type UserRelationSumAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type UserRelationMinAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type UserRelationMaxAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type UserRelationCountAggregateOutputType = {
    id: number
    fromId: number
    toId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type UserRelationAvgAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type UserRelationSumAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type UserRelationMinAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    createAt?: true
    updateAt?: true
  }

  export type UserRelationMaxAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    createAt?: true
    updateAt?: true
  }

  export type UserRelationCountAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserRelationAggregateArgs = {
    /**
     * Filter which UserRelation to aggregate.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRelations
    **/
    _count?: true | UserRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRelationMaxAggregateInputType
  }

  export type GetUserRelationAggregateType<T extends UserRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRelation[P]>
      : GetScalarType<T[P], AggregateUserRelation[P]>
  }




  export type UserRelationGroupByArgs = {
    where?: UserRelationWhereInput
    orderBy?: Enumerable<UserRelationOrderByWithAggregationInput>
    by: UserRelationScalarFieldEnum[]
    having?: UserRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRelationCountAggregateInputType | true
    _avg?: UserRelationAvgAggregateInputType
    _sum?: UserRelationSumAggregateInputType
    _min?: UserRelationMinAggregateInputType
    _max?: UserRelationMaxAggregateInputType
  }


  export type UserRelationGroupByOutputType = {
    id: number
    fromId: number
    toId: number
    createAt: Date
    updateAt: Date
    _count: UserRelationCountAggregateOutputType | null
    _avg: UserRelationAvgAggregateOutputType | null
    _sum: UserRelationSumAggregateOutputType | null
    _min: UserRelationMinAggregateOutputType | null
    _max: UserRelationMaxAggregateOutputType | null
  }

  type GetUserRelationGroupByPayload<T extends UserRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
            : GetScalarType<T[P], UserRelationGroupByOutputType[P]>
        }
      >
    >


  export type UserRelationSelect = {
    id?: boolean
    from?: boolean | UserArgs
    fromId?: boolean
    to?: boolean | UserArgs
    toId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type UserRelationInclude = {
    from?: boolean | UserArgs
    to?: boolean | UserArgs
  }

  export type UserRelationGetPayload<S extends boolean | null | undefined | UserRelationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserRelation :
    S extends undefined ? never :
    S extends { include: any } & (UserRelationArgs | UserRelationFindManyArgs)
    ? UserRelation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? UserGetPayload<S['include'][P]> :
        P extends 'to' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserRelationArgs | UserRelationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? UserGetPayload<S['select'][P]> :
        P extends 'to' ? UserGetPayload<S['select'][P]> :  P extends keyof UserRelation ? UserRelation[P] : never
  } 
      : UserRelation


  type UserRelationCountArgs = 
    Omit<UserRelationFindManyArgs, 'select' | 'include'> & {
      select?: UserRelationCountAggregateInputType | true
    }

  export interface UserRelationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserRelation that matches the filter.
     * @param {UserRelationFindUniqueArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRelationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRelationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find one UserRelation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserRelationFindUniqueOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserRelationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindUniqueOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find the first UserRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRelationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRelationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRelation'> extends True ? Prisma__UserRelationClient<UserRelationGetPayload<T>> : Prisma__UserRelationClient<UserRelationGetPayload<T> | null, null>

    /**
     * Find the first UserRelation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindFirstOrThrowArgs} args - Arguments to find a UserRelation
     * @example
     * // Get one UserRelation
     * const userRelation = await prisma.userRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRelationFindFirstOrThrowArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Find zero or more UserRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRelations
     * const userRelations = await prisma.userRelation.findMany()
     * 
     * // Get first 10 UserRelations
     * const userRelations = await prisma.userRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRelationWithIdOnly = await prisma.userRelation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserRelationFindManyArgs>(
      args?: SelectSubset<T, UserRelationFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserRelationGetPayload<T>>>

    /**
     * Create a UserRelation.
     * @param {UserRelationCreateArgs} args - Arguments to create a UserRelation.
     * @example
     * // Create one UserRelation
     * const UserRelation = await prisma.userRelation.create({
     *   data: {
     *     // ... data to create a UserRelation
     *   }
     * })
     * 
    **/
    create<T extends UserRelationCreateArgs>(
      args: SelectSubset<T, UserRelationCreateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Create many UserRelations.
     *     @param {UserRelationCreateManyArgs} args - Arguments to create many UserRelations.
     *     @example
     *     // Create many UserRelations
     *     const userRelation = await prisma.userRelation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRelationCreateManyArgs>(
      args?: SelectSubset<T, UserRelationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRelation.
     * @param {UserRelationDeleteArgs} args - Arguments to delete one UserRelation.
     * @example
     * // Delete one UserRelation
     * const UserRelation = await prisma.userRelation.delete({
     *   where: {
     *     // ... filter to delete one UserRelation
     *   }
     * })
     * 
    **/
    delete<T extends UserRelationDeleteArgs>(
      args: SelectSubset<T, UserRelationDeleteArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Update one UserRelation.
     * @param {UserRelationUpdateArgs} args - Arguments to update one UserRelation.
     * @example
     * // Update one UserRelation
     * const userRelation = await prisma.userRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRelationUpdateArgs>(
      args: SelectSubset<T, UserRelationUpdateArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Delete zero or more UserRelations.
     * @param {UserRelationDeleteManyArgs} args - Arguments to filter UserRelations to delete.
     * @example
     * // Delete a few UserRelations
     * const { count } = await prisma.userRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRelationDeleteManyArgs>(
      args?: SelectSubset<T, UserRelationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRelations
     * const userRelation = await prisma.userRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRelationUpdateManyArgs>(
      args: SelectSubset<T, UserRelationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRelation.
     * @param {UserRelationUpsertArgs} args - Arguments to update or create a UserRelation.
     * @example
     * // Update or create a UserRelation
     * const userRelation = await prisma.userRelation.upsert({
     *   create: {
     *     // ... data to create a UserRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRelation we want to update
     *   }
     * })
    **/
    upsert<T extends UserRelationUpsertArgs>(
      args: SelectSubset<T, UserRelationUpsertArgs>
    ): Prisma__UserRelationClient<UserRelationGetPayload<T>>

    /**
     * Count the number of UserRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationCountArgs} args - Arguments to filter UserRelations to count.
     * @example
     * // Count the number of UserRelations
     * const count = await prisma.userRelation.count({
     *   where: {
     *     // ... the filter for the UserRelations we want to count
     *   }
     * })
    **/
    count<T extends UserRelationCountArgs>(
      args?: Subset<T, UserRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRelationAggregateArgs>(args: Subset<T, UserRelationAggregateArgs>): Prisma.PrismaPromise<GetUserRelationAggregateType<T>>

    /**
     * Group by UserRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRelationGroupByArgs['orderBy'] }
        : { orderBy?: UserRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRelationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    to<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserRelation base type for findUnique actions
   */
  export type UserRelationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }

  /**
   * UserRelation findUnique
   */
  export interface UserRelationFindUniqueArgs extends UserRelationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findUniqueOrThrow
   */
  export type UserRelationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation base type for findFirst actions
   */
  export type UserRelationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }

  /**
   * UserRelation findFirst
   */
  export interface UserRelationFindFirstArgs extends UserRelationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserRelation findFirstOrThrow
   */
  export type UserRelationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelation to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRelations.
     */
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation findMany
   */
  export type UserRelationFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter, which UserRelations to fetch.
     */
    where?: UserRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRelations to fetch.
     */
    orderBy?: Enumerable<UserRelationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRelations.
     */
    cursor?: UserRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRelations.
     */
    skip?: number
    distinct?: Enumerable<UserRelationScalarFieldEnum>
  }


  /**
   * UserRelation create
   */
  export type UserRelationCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to create a UserRelation.
     */
    data: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
  }


  /**
   * UserRelation createMany
   */
  export type UserRelationCreateManyArgs = {
    /**
     * The data used to create many UserRelations.
     */
    data: Enumerable<UserRelationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRelation update
   */
  export type UserRelationUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The data needed to update a UserRelation.
     */
    data: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
    /**
     * Choose, which UserRelation to update.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation updateMany
   */
  export type UserRelationUpdateManyArgs = {
    /**
     * The data used to update UserRelations.
     */
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyInput>
    /**
     * Filter which UserRelations to update
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation upsert
   */
  export type UserRelationUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * The filter to search for the UserRelation to update in case it exists.
     */
    where: UserRelationWhereUniqueInput
    /**
     * In case the UserRelation found by the `where` argument doesn't exist, create a new UserRelation with this data.
     */
    create: XOR<UserRelationCreateInput, UserRelationUncheckedCreateInput>
    /**
     * In case the UserRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRelationUpdateInput, UserRelationUncheckedUpdateInput>
  }


  /**
   * UserRelation delete
   */
  export type UserRelationDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
    /**
     * Filter which UserRelation to delete.
     */
    where: UserRelationWhereUniqueInput
  }


  /**
   * UserRelation deleteMany
   */
  export type UserRelationDeleteManyArgs = {
    /**
     * Filter which UserRelations to delete
     */
    where?: UserRelationWhereInput
  }


  /**
   * UserRelation without action
   */
  export type UserRelationArgs = {
    /**
     * Select specific fields to fetch from the UserRelation
     */
    select?: UserRelationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserRelationInclude | null
  }



  /**
   * Model HashTag
   */


  export type AggregateHashTag = {
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  export type HashTagAvgAggregateOutputType = {
    id: number | null
    postOnHashTagId: number | null
  }

  export type HashTagSumAggregateOutputType = {
    id: number | null
    postOnHashTagId: number | null
  }

  export type HashTagMinAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
    postOnHashTagId: number | null
  }

  export type HashTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
    postOnHashTagId: number | null
  }

  export type HashTagCountAggregateOutputType = {
    id: number
    name: number
    createAt: number
    updateAt: number
    postOnHashTagId: number
    _all: number
  }


  export type HashTagAvgAggregateInputType = {
    id?: true
    postOnHashTagId?: true
  }

  export type HashTagSumAggregateInputType = {
    id?: true
    postOnHashTagId?: true
  }

  export type HashTagMinAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    postOnHashTagId?: true
  }

  export type HashTagMaxAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    postOnHashTagId?: true
  }

  export type HashTagCountAggregateInputType = {
    id?: true
    name?: true
    createAt?: true
    updateAt?: true
    postOnHashTagId?: true
    _all?: true
  }

  export type HashTagAggregateArgs = {
    /**
     * Filter which HashTag to aggregate.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HashTags
    **/
    _count?: true | HashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashTagMaxAggregateInputType
  }

  export type GetHashTagAggregateType<T extends HashTagAggregateArgs> = {
        [P in keyof T & keyof AggregateHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashTag[P]>
      : GetScalarType<T[P], AggregateHashTag[P]>
  }




  export type HashTagGroupByArgs = {
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithAggregationInput>
    by: HashTagScalarFieldEnum[]
    having?: HashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashTagCountAggregateInputType | true
    _avg?: HashTagAvgAggregateInputType
    _sum?: HashTagSumAggregateInputType
    _min?: HashTagMinAggregateInputType
    _max?: HashTagMaxAggregateInputType
  }


  export type HashTagGroupByOutputType = {
    id: number
    name: string
    createAt: Date
    updateAt: Date
    postOnHashTagId: number | null
    _count: HashTagCountAggregateOutputType | null
    _avg: HashTagAvgAggregateOutputType | null
    _sum: HashTagSumAggregateOutputType | null
    _min: HashTagMinAggregateOutputType | null
    _max: HashTagMaxAggregateOutputType | null
  }

  type GetHashTagGroupByPayload<T extends HashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashTagGroupByOutputType[P]>
            : GetScalarType<T[P], HashTagGroupByOutputType[P]>
        }
      >
    >


  export type HashTagSelect = {
    id?: boolean
    name?: boolean
    createAt?: boolean
    updateAt?: boolean
    postOnHashTag?: boolean | PostOnHashTagArgs
    postOnHashTagId?: boolean
  }


  export type HashTagInclude = {
    postOnHashTag?: boolean | PostOnHashTagArgs
  }

  export type HashTagGetPayload<S extends boolean | null | undefined | HashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HashTag :
    S extends undefined ? never :
    S extends { include: any } & (HashTagArgs | HashTagFindManyArgs)
    ? HashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postOnHashTag' ? PostOnHashTagGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (HashTagArgs | HashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postOnHashTag' ? PostOnHashTagGetPayload<S['select'][P]> | null :  P extends keyof HashTag ? HashTag[P] : never
  } 
      : HashTag


  type HashTagCountArgs = 
    Omit<HashTagFindManyArgs, 'select' | 'include'> & {
      select?: HashTagCountAggregateInputType | true
    }

  export interface HashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HashTag that matches the filter.
     * @param {HashTagFindUniqueArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find one HashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HashTagFindUniqueOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindUniqueOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find the first HashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HashTag'> extends True ? Prisma__HashTagClient<HashTagGetPayload<T>> : Prisma__HashTagClient<HashTagGetPayload<T> | null, null>

    /**
     * Find the first HashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindFirstOrThrowArgs} args - Arguments to find a HashTag
     * @example
     * // Get one HashTag
     * const hashTag = await prisma.hashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HashTagFindFirstOrThrowArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Find zero or more HashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HashTags
     * const hashTags = await prisma.hashTag.findMany()
     * 
     * // Get first 10 HashTags
     * const hashTags = await prisma.hashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hashTagWithIdOnly = await prisma.hashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HashTagFindManyArgs>(
      args?: SelectSubset<T, HashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>>

    /**
     * Create a HashTag.
     * @param {HashTagCreateArgs} args - Arguments to create a HashTag.
     * @example
     * // Create one HashTag
     * const HashTag = await prisma.hashTag.create({
     *   data: {
     *     // ... data to create a HashTag
     *   }
     * })
     * 
    **/
    create<T extends HashTagCreateArgs>(
      args: SelectSubset<T, HashTagCreateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Create many HashTags.
     *     @param {HashTagCreateManyArgs} args - Arguments to create many HashTags.
     *     @example
     *     // Create many HashTags
     *     const hashTag = await prisma.hashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HashTagCreateManyArgs>(
      args?: SelectSubset<T, HashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HashTag.
     * @param {HashTagDeleteArgs} args - Arguments to delete one HashTag.
     * @example
     * // Delete one HashTag
     * const HashTag = await prisma.hashTag.delete({
     *   where: {
     *     // ... filter to delete one HashTag
     *   }
     * })
     * 
    **/
    delete<T extends HashTagDeleteArgs>(
      args: SelectSubset<T, HashTagDeleteArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Update one HashTag.
     * @param {HashTagUpdateArgs} args - Arguments to update one HashTag.
     * @example
     * // Update one HashTag
     * const hashTag = await prisma.hashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HashTagUpdateArgs>(
      args: SelectSubset<T, HashTagUpdateArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Delete zero or more HashTags.
     * @param {HashTagDeleteManyArgs} args - Arguments to filter HashTags to delete.
     * @example
     * // Delete a few HashTags
     * const { count } = await prisma.hashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HashTagDeleteManyArgs>(
      args?: SelectSubset<T, HashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HashTags
     * const hashTag = await prisma.hashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HashTagUpdateManyArgs>(
      args: SelectSubset<T, HashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HashTag.
     * @param {HashTagUpsertArgs} args - Arguments to update or create a HashTag.
     * @example
     * // Update or create a HashTag
     * const hashTag = await prisma.hashTag.upsert({
     *   create: {
     *     // ... data to create a HashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HashTag we want to update
     *   }
     * })
    **/
    upsert<T extends HashTagUpsertArgs>(
      args: SelectSubset<T, HashTagUpsertArgs>
    ): Prisma__HashTagClient<HashTagGetPayload<T>>

    /**
     * Count the number of HashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagCountArgs} args - Arguments to filter HashTags to count.
     * @example
     * // Count the number of HashTags
     * const count = await prisma.hashTag.count({
     *   where: {
     *     // ... the filter for the HashTags we want to count
     *   }
     * })
    **/
    count<T extends HashTagCountArgs>(
      args?: Subset<T, HashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashTagAggregateArgs>(args: Subset<T, HashTagAggregateArgs>): Prisma.PrismaPromise<GetHashTagAggregateType<T>>

    /**
     * Group by HashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashTagGroupByArgs['orderBy'] }
        : { orderBy?: HashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postOnHashTag<T extends PostOnHashTagArgs= {}>(args?: Subset<T, PostOnHashTagArgs>): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HashTag base type for findUnique actions
   */
  export type HashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }

  /**
   * HashTag findUnique
   */
  export interface HashTagFindUniqueArgs extends HashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findUniqueOrThrow
   */
  export type HashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag base type for findFirst actions
   */
  export type HashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }

  /**
   * HashTag findFirst
   */
  export interface HashTagFindFirstArgs extends HashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HashTag findFirstOrThrow
   */
  export type HashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTag to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HashTags.
     */
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag findMany
   */
  export type HashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter, which HashTags to fetch.
     */
    where?: HashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HashTags to fetch.
     */
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HashTags.
     */
    cursor?: HashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HashTags.
     */
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * HashTag create
   */
  export type HashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to create a HashTag.
     */
    data: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
  }


  /**
   * HashTag createMany
   */
  export type HashTagCreateManyArgs = {
    /**
     * The data used to create many HashTags.
     */
    data: Enumerable<HashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HashTag update
   */
  export type HashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The data needed to update a HashTag.
     */
    data: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
    /**
     * Choose, which HashTag to update.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag updateMany
   */
  export type HashTagUpdateManyArgs = {
    /**
     * The data used to update HashTags.
     */
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyInput>
    /**
     * Filter which HashTags to update
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag upsert
   */
  export type HashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * The filter to search for the HashTag to update in case it exists.
     */
    where: HashTagWhereUniqueInput
    /**
     * In case the HashTag found by the `where` argument doesn't exist, create a new HashTag with this data.
     */
    create: XOR<HashTagCreateInput, HashTagUncheckedCreateInput>
    /**
     * In case the HashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashTagUpdateInput, HashTagUncheckedUpdateInput>
  }


  /**
   * HashTag delete
   */
  export type HashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    /**
     * Filter which HashTag to delete.
     */
    where: HashTagWhereUniqueInput
  }


  /**
   * HashTag deleteMany
   */
  export type HashTagDeleteManyArgs = {
    /**
     * Filter which HashTags to delete
     */
    where?: HashTagWhereInput
  }


  /**
   * HashTag without action
   */
  export type HashTagArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    message: string | null
    userId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    message: string | null
    userId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    message: number
    userId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    message?: true
    userId?: true
    createAt?: true
    updateAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    message?: true
    userId?: true
    createAt?: true
    updateAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    message?: true
    userId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    message: string
    userId: number
    createAt: Date
    updateAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    message?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    postOnHashTags?: boolean | Post$postOnHashTagsArgs
    createAt?: boolean
    updateAt?: boolean
    replies?: boolean | Post$repliesArgs
    _count?: boolean | PostCountOutputTypeArgs
  }


  export type PostInclude = {
    user?: boolean | UserArgs
    postOnHashTags?: boolean | Post$postOnHashTagsArgs
    replies?: boolean | Post$repliesArgs
    _count?: boolean | PostCountOutputTypeArgs
  }

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'postOnHashTags' ? Array < PostOnHashTagGetPayload<S['include'][P]>>  :
        P extends 'replies' ? Array < ReplyGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'postOnHashTags' ? Array < PostOnHashTagGetPayload<S['select'][P]>>  :
        P extends 'replies' ? Array < ReplyGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    postOnHashTags<T extends Post$postOnHashTagsArgs= {}>(args?: Subset<T, Post$postOnHashTagsArgs>): Prisma.PrismaPromise<Array<PostOnHashTagGetPayload<T>>| Null>;

    replies<T extends Post$repliesArgs= {}>(args?: Subset<T, Post$repliesArgs>): Prisma.PrismaPromise<Array<ReplyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.postOnHashTags
   */
  export type Post$postOnHashTagsArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    where?: PostOnHashTagWhereInput
    orderBy?: Enumerable<PostOnHashTagOrderByWithRelationInput>
    cursor?: PostOnHashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostOnHashTagScalarFieldEnum>
  }


  /**
   * Post.replies
   */
  export type Post$repliesArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    where?: ReplyWhereInput
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReplyScalarFieldEnum>
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
  }



  /**
   * Model PostOnHashTag
   */


  export type AggregatePostOnHashTag = {
    _count: PostOnHashTagCountAggregateOutputType | null
    _avg: PostOnHashTagAvgAggregateOutputType | null
    _sum: PostOnHashTagSumAggregateOutputType | null
    _min: PostOnHashTagMinAggregateOutputType | null
    _max: PostOnHashTagMaxAggregateOutputType | null
  }

  export type PostOnHashTagAvgAggregateOutputType = {
    id: number | null
  }

  export type PostOnHashTagSumAggregateOutputType = {
    id: number | null
  }

  export type PostOnHashTagMinAggregateOutputType = {
    id: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type PostOnHashTagMaxAggregateOutputType = {
    id: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type PostOnHashTagCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type PostOnHashTagAvgAggregateInputType = {
    id?: true
  }

  export type PostOnHashTagSumAggregateInputType = {
    id?: true
  }

  export type PostOnHashTagMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
  }

  export type PostOnHashTagMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
  }

  export type PostOnHashTagCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type PostOnHashTagAggregateArgs = {
    /**
     * Filter which PostOnHashTag to aggregate.
     */
    where?: PostOnHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostOnHashTags to fetch.
     */
    orderBy?: Enumerable<PostOnHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostOnHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostOnHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostOnHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostOnHashTags
    **/
    _count?: true | PostOnHashTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostOnHashTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostOnHashTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostOnHashTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostOnHashTagMaxAggregateInputType
  }

  export type GetPostOnHashTagAggregateType<T extends PostOnHashTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostOnHashTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostOnHashTag[P]>
      : GetScalarType<T[P], AggregatePostOnHashTag[P]>
  }




  export type PostOnHashTagGroupByArgs = {
    where?: PostOnHashTagWhereInput
    orderBy?: Enumerable<PostOnHashTagOrderByWithAggregationInput>
    by: PostOnHashTagScalarFieldEnum[]
    having?: PostOnHashTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostOnHashTagCountAggregateInputType | true
    _avg?: PostOnHashTagAvgAggregateInputType
    _sum?: PostOnHashTagSumAggregateInputType
    _min?: PostOnHashTagMinAggregateInputType
    _max?: PostOnHashTagMaxAggregateInputType
  }


  export type PostOnHashTagGroupByOutputType = {
    id: number
    createAt: Date
    updateAt: Date
    _count: PostOnHashTagCountAggregateOutputType | null
    _avg: PostOnHashTagAvgAggregateOutputType | null
    _sum: PostOnHashTagSumAggregateOutputType | null
    _min: PostOnHashTagMinAggregateOutputType | null
    _max: PostOnHashTagMaxAggregateOutputType | null
  }

  type GetPostOnHashTagGroupByPayload<T extends PostOnHashTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostOnHashTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostOnHashTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostOnHashTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostOnHashTagGroupByOutputType[P]>
        }
      >
    >


  export type PostOnHashTagSelect = {
    id?: boolean
    posts?: boolean | PostOnHashTag$postsArgs
    hashTags?: boolean | PostOnHashTag$hashTagsArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | PostOnHashTagCountOutputTypeArgs
  }


  export type PostOnHashTagInclude = {
    posts?: boolean | PostOnHashTag$postsArgs
    hashTags?: boolean | PostOnHashTag$hashTagsArgs
    _count?: boolean | PostOnHashTagCountOutputTypeArgs
  }

  export type PostOnHashTagGetPayload<S extends boolean | null | undefined | PostOnHashTagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostOnHashTag :
    S extends undefined ? never :
    S extends { include: any } & (PostOnHashTagArgs | PostOnHashTagFindManyArgs)
    ? PostOnHashTag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostOnHashTagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostOnHashTagArgs | PostOnHashTagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'hashTags' ? Array < HashTagGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostOnHashTagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PostOnHashTag ? PostOnHashTag[P] : never
  } 
      : PostOnHashTag


  type PostOnHashTagCountArgs = 
    Omit<PostOnHashTagFindManyArgs, 'select' | 'include'> & {
      select?: PostOnHashTagCountAggregateInputType | true
    }

  export interface PostOnHashTagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PostOnHashTag that matches the filter.
     * @param {PostOnHashTagFindUniqueArgs} args - Arguments to find a PostOnHashTag
     * @example
     * // Get one PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostOnHashTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostOnHashTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostOnHashTag'> extends True ? Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>> : Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T> | null, null>

    /**
     * Find one PostOnHashTag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostOnHashTagFindUniqueOrThrowArgs} args - Arguments to find a PostOnHashTag
     * @example
     * // Get one PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostOnHashTagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostOnHashTagFindUniqueOrThrowArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Find the first PostOnHashTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagFindFirstArgs} args - Arguments to find a PostOnHashTag
     * @example
     * // Get one PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostOnHashTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostOnHashTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostOnHashTag'> extends True ? Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>> : Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T> | null, null>

    /**
     * Find the first PostOnHashTag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagFindFirstOrThrowArgs} args - Arguments to find a PostOnHashTag
     * @example
     * // Get one PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostOnHashTagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostOnHashTagFindFirstOrThrowArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Find zero or more PostOnHashTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostOnHashTags
     * const postOnHashTags = await prisma.postOnHashTag.findMany()
     * 
     * // Get first 10 PostOnHashTags
     * const postOnHashTags = await prisma.postOnHashTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postOnHashTagWithIdOnly = await prisma.postOnHashTag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostOnHashTagFindManyArgs>(
      args?: SelectSubset<T, PostOnHashTagFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostOnHashTagGetPayload<T>>>

    /**
     * Create a PostOnHashTag.
     * @param {PostOnHashTagCreateArgs} args - Arguments to create a PostOnHashTag.
     * @example
     * // Create one PostOnHashTag
     * const PostOnHashTag = await prisma.postOnHashTag.create({
     *   data: {
     *     // ... data to create a PostOnHashTag
     *   }
     * })
     * 
    **/
    create<T extends PostOnHashTagCreateArgs>(
      args: SelectSubset<T, PostOnHashTagCreateArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Create many PostOnHashTags.
     *     @param {PostOnHashTagCreateManyArgs} args - Arguments to create many PostOnHashTags.
     *     @example
     *     // Create many PostOnHashTags
     *     const postOnHashTag = await prisma.postOnHashTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostOnHashTagCreateManyArgs>(
      args?: SelectSubset<T, PostOnHashTagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostOnHashTag.
     * @param {PostOnHashTagDeleteArgs} args - Arguments to delete one PostOnHashTag.
     * @example
     * // Delete one PostOnHashTag
     * const PostOnHashTag = await prisma.postOnHashTag.delete({
     *   where: {
     *     // ... filter to delete one PostOnHashTag
     *   }
     * })
     * 
    **/
    delete<T extends PostOnHashTagDeleteArgs>(
      args: SelectSubset<T, PostOnHashTagDeleteArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Update one PostOnHashTag.
     * @param {PostOnHashTagUpdateArgs} args - Arguments to update one PostOnHashTag.
     * @example
     * // Update one PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostOnHashTagUpdateArgs>(
      args: SelectSubset<T, PostOnHashTagUpdateArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Delete zero or more PostOnHashTags.
     * @param {PostOnHashTagDeleteManyArgs} args - Arguments to filter PostOnHashTags to delete.
     * @example
     * // Delete a few PostOnHashTags
     * const { count } = await prisma.postOnHashTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostOnHashTagDeleteManyArgs>(
      args?: SelectSubset<T, PostOnHashTagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostOnHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostOnHashTags
     * const postOnHashTag = await prisma.postOnHashTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostOnHashTagUpdateManyArgs>(
      args: SelectSubset<T, PostOnHashTagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostOnHashTag.
     * @param {PostOnHashTagUpsertArgs} args - Arguments to update or create a PostOnHashTag.
     * @example
     * // Update or create a PostOnHashTag
     * const postOnHashTag = await prisma.postOnHashTag.upsert({
     *   create: {
     *     // ... data to create a PostOnHashTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostOnHashTag we want to update
     *   }
     * })
    **/
    upsert<T extends PostOnHashTagUpsertArgs>(
      args: SelectSubset<T, PostOnHashTagUpsertArgs>
    ): Prisma__PostOnHashTagClient<PostOnHashTagGetPayload<T>>

    /**
     * Count the number of PostOnHashTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagCountArgs} args - Arguments to filter PostOnHashTags to count.
     * @example
     * // Count the number of PostOnHashTags
     * const count = await prisma.postOnHashTag.count({
     *   where: {
     *     // ... the filter for the PostOnHashTags we want to count
     *   }
     * })
    **/
    count<T extends PostOnHashTagCountArgs>(
      args?: Subset<T, PostOnHashTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostOnHashTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostOnHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostOnHashTagAggregateArgs>(args: Subset<T, PostOnHashTagAggregateArgs>): Prisma.PrismaPromise<GetPostOnHashTagAggregateType<T>>

    /**
     * Group by PostOnHashTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostOnHashTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostOnHashTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostOnHashTagGroupByArgs['orderBy'] }
        : { orderBy?: PostOnHashTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostOnHashTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostOnHashTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostOnHashTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostOnHashTagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends PostOnHashTag$postsArgs= {}>(args?: Subset<T, PostOnHashTag$postsArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    hashTags<T extends PostOnHashTag$hashTagsArgs= {}>(args?: Subset<T, PostOnHashTag$hashTagsArgs>): Prisma.PrismaPromise<Array<HashTagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostOnHashTag base type for findUnique actions
   */
  export type PostOnHashTagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter, which PostOnHashTag to fetch.
     */
    where: PostOnHashTagWhereUniqueInput
  }

  /**
   * PostOnHashTag findUnique
   */
  export interface PostOnHashTagFindUniqueArgs extends PostOnHashTagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostOnHashTag findUniqueOrThrow
   */
  export type PostOnHashTagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter, which PostOnHashTag to fetch.
     */
    where: PostOnHashTagWhereUniqueInput
  }


  /**
   * PostOnHashTag base type for findFirst actions
   */
  export type PostOnHashTagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter, which PostOnHashTag to fetch.
     */
    where?: PostOnHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostOnHashTags to fetch.
     */
    orderBy?: Enumerable<PostOnHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostOnHashTags.
     */
    cursor?: PostOnHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostOnHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostOnHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostOnHashTags.
     */
    distinct?: Enumerable<PostOnHashTagScalarFieldEnum>
  }

  /**
   * PostOnHashTag findFirst
   */
  export interface PostOnHashTagFindFirstArgs extends PostOnHashTagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostOnHashTag findFirstOrThrow
   */
  export type PostOnHashTagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter, which PostOnHashTag to fetch.
     */
    where?: PostOnHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostOnHashTags to fetch.
     */
    orderBy?: Enumerable<PostOnHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostOnHashTags.
     */
    cursor?: PostOnHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostOnHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostOnHashTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostOnHashTags.
     */
    distinct?: Enumerable<PostOnHashTagScalarFieldEnum>
  }


  /**
   * PostOnHashTag findMany
   */
  export type PostOnHashTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter, which PostOnHashTags to fetch.
     */
    where?: PostOnHashTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostOnHashTags to fetch.
     */
    orderBy?: Enumerable<PostOnHashTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostOnHashTags.
     */
    cursor?: PostOnHashTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostOnHashTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostOnHashTags.
     */
    skip?: number
    distinct?: Enumerable<PostOnHashTagScalarFieldEnum>
  }


  /**
   * PostOnHashTag create
   */
  export type PostOnHashTagCreateArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * The data needed to create a PostOnHashTag.
     */
    data: XOR<PostOnHashTagCreateInput, PostOnHashTagUncheckedCreateInput>
  }


  /**
   * PostOnHashTag createMany
   */
  export type PostOnHashTagCreateManyArgs = {
    /**
     * The data used to create many PostOnHashTags.
     */
    data: Enumerable<PostOnHashTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostOnHashTag update
   */
  export type PostOnHashTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * The data needed to update a PostOnHashTag.
     */
    data: XOR<PostOnHashTagUpdateInput, PostOnHashTagUncheckedUpdateInput>
    /**
     * Choose, which PostOnHashTag to update.
     */
    where: PostOnHashTagWhereUniqueInput
  }


  /**
   * PostOnHashTag updateMany
   */
  export type PostOnHashTagUpdateManyArgs = {
    /**
     * The data used to update PostOnHashTags.
     */
    data: XOR<PostOnHashTagUpdateManyMutationInput, PostOnHashTagUncheckedUpdateManyInput>
    /**
     * Filter which PostOnHashTags to update
     */
    where?: PostOnHashTagWhereInput
  }


  /**
   * PostOnHashTag upsert
   */
  export type PostOnHashTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * The filter to search for the PostOnHashTag to update in case it exists.
     */
    where: PostOnHashTagWhereUniqueInput
    /**
     * In case the PostOnHashTag found by the `where` argument doesn't exist, create a new PostOnHashTag with this data.
     */
    create: XOR<PostOnHashTagCreateInput, PostOnHashTagUncheckedCreateInput>
    /**
     * In case the PostOnHashTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostOnHashTagUpdateInput, PostOnHashTagUncheckedUpdateInput>
  }


  /**
   * PostOnHashTag delete
   */
  export type PostOnHashTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
    /**
     * Filter which PostOnHashTag to delete.
     */
    where: PostOnHashTagWhereUniqueInput
  }


  /**
   * PostOnHashTag deleteMany
   */
  export type PostOnHashTagDeleteManyArgs = {
    /**
     * Filter which PostOnHashTags to delete
     */
    where?: PostOnHashTagWhereInput
  }


  /**
   * PostOnHashTag.posts
   */
  export type PostOnHashTag$postsArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * PostOnHashTag.hashTags
   */
  export type PostOnHashTag$hashTagsArgs = {
    /**
     * Select specific fields to fetch from the HashTag
     */
    select?: HashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HashTagInclude | null
    where?: HashTagWhereInput
    orderBy?: Enumerable<HashTagOrderByWithRelationInput>
    cursor?: HashTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HashTagScalarFieldEnum>
  }


  /**
   * PostOnHashTag without action
   */
  export type PostOnHashTagArgs = {
    /**
     * Select specific fields to fetch from the PostOnHashTag
     */
    select?: PostOnHashTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostOnHashTagInclude | null
  }



  /**
   * Model Reply
   */


  export type AggregateReply = {
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  export type ReplyAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReplySumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReplyMinAggregateOutputType = {
    id: number | null
    message: string | null
    postId: number | null
    createAt: Date | null
    updateAt: Date | null
    userId: number | null
  }

  export type ReplyMaxAggregateOutputType = {
    id: number | null
    message: string | null
    postId: number | null
    createAt: Date | null
    updateAt: Date | null
    userId: number | null
  }

  export type ReplyCountAggregateOutputType = {
    id: number
    message: number
    postId: number
    createAt: number
    updateAt: number
    userId: number
    _all: number
  }


  export type ReplyAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReplySumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReplyMinAggregateInputType = {
    id?: true
    message?: true
    postId?: true
    createAt?: true
    updateAt?: true
    userId?: true
  }

  export type ReplyMaxAggregateInputType = {
    id?: true
    message?: true
    postId?: true
    createAt?: true
    updateAt?: true
    userId?: true
  }

  export type ReplyCountAggregateInputType = {
    id?: true
    message?: true
    postId?: true
    createAt?: true
    updateAt?: true
    userId?: true
    _all?: true
  }

  export type ReplyAggregateArgs = {
    /**
     * Filter which Reply to aggregate.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Replies
    **/
    _count?: true | ReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReplyMaxAggregateInputType
  }

  export type GetReplyAggregateType<T extends ReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReply[P]>
      : GetScalarType<T[P], AggregateReply[P]>
  }




  export type ReplyGroupByArgs = {
    where?: ReplyWhereInput
    orderBy?: Enumerable<ReplyOrderByWithAggregationInput>
    by: ReplyScalarFieldEnum[]
    having?: ReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReplyCountAggregateInputType | true
    _avg?: ReplyAvgAggregateInputType
    _sum?: ReplySumAggregateInputType
    _min?: ReplyMinAggregateInputType
    _max?: ReplyMaxAggregateInputType
  }


  export type ReplyGroupByOutputType = {
    id: number
    message: string
    postId: number
    createAt: Date
    updateAt: Date
    userId: number
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  type GetReplyGroupByPayload<T extends ReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReplySelect = {
    id?: boolean
    message?: boolean
    user?: boolean | UserArgs
    post?: boolean | PostArgs
    postId?: boolean
    createAt?: boolean
    updateAt?: boolean
    userId?: boolean
  }


  export type ReplyInclude = {
    user?: boolean | UserArgs
    post?: boolean | PostArgs
  }

  export type ReplyGetPayload<S extends boolean | null | undefined | ReplyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Reply :
    S extends undefined ? never :
    S extends { include: any } & (ReplyArgs | ReplyFindManyArgs)
    ? Reply  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReplyArgs | ReplyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'post' ? PostGetPayload<S['select'][P]> :  P extends keyof Reply ? Reply[P] : never
  } 
      : Reply


  type ReplyCountArgs = 
    Omit<ReplyFindManyArgs, 'select' | 'include'> & {
      select?: ReplyCountAggregateInputType | true
    }

  export interface ReplyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reply that matches the filter.
     * @param {ReplyFindUniqueArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReplyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReplyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reply'> extends True ? Prisma__ReplyClient<ReplyGetPayload<T>> : Prisma__ReplyClient<ReplyGetPayload<T> | null, null>

    /**
     * Find one Reply that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReplyFindUniqueOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReplyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReplyFindUniqueOrThrowArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Find the first Reply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReplyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReplyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reply'> extends True ? Prisma__ReplyClient<ReplyGetPayload<T>> : Prisma__ReplyClient<ReplyGetPayload<T> | null, null>

    /**
     * Find the first Reply that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReplyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReplyFindFirstOrThrowArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Find zero or more Replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Replies
     * const replies = await prisma.reply.findMany()
     * 
     * // Get first 10 Replies
     * const replies = await prisma.reply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const replyWithIdOnly = await prisma.reply.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReplyFindManyArgs>(
      args?: SelectSubset<T, ReplyFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReplyGetPayload<T>>>

    /**
     * Create a Reply.
     * @param {ReplyCreateArgs} args - Arguments to create a Reply.
     * @example
     * // Create one Reply
     * const Reply = await prisma.reply.create({
     *   data: {
     *     // ... data to create a Reply
     *   }
     * })
     * 
    **/
    create<T extends ReplyCreateArgs>(
      args: SelectSubset<T, ReplyCreateArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Create many Replies.
     *     @param {ReplyCreateManyArgs} args - Arguments to create many Replies.
     *     @example
     *     // Create many Replies
     *     const reply = await prisma.reply.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReplyCreateManyArgs>(
      args?: SelectSubset<T, ReplyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reply.
     * @param {ReplyDeleteArgs} args - Arguments to delete one Reply.
     * @example
     * // Delete one Reply
     * const Reply = await prisma.reply.delete({
     *   where: {
     *     // ... filter to delete one Reply
     *   }
     * })
     * 
    **/
    delete<T extends ReplyDeleteArgs>(
      args: SelectSubset<T, ReplyDeleteArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Update one Reply.
     * @param {ReplyUpdateArgs} args - Arguments to update one Reply.
     * @example
     * // Update one Reply
     * const reply = await prisma.reply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReplyUpdateArgs>(
      args: SelectSubset<T, ReplyUpdateArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Delete zero or more Replies.
     * @param {ReplyDeleteManyArgs} args - Arguments to filter Replies to delete.
     * @example
     * // Delete a few Replies
     * const { count } = await prisma.reply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReplyDeleteManyArgs>(
      args?: SelectSubset<T, ReplyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Replies
     * const reply = await prisma.reply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReplyUpdateManyArgs>(
      args: SelectSubset<T, ReplyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reply.
     * @param {ReplyUpsertArgs} args - Arguments to update or create a Reply.
     * @example
     * // Update or create a Reply
     * const reply = await prisma.reply.upsert({
     *   create: {
     *     // ... data to create a Reply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reply we want to update
     *   }
     * })
    **/
    upsert<T extends ReplyUpsertArgs>(
      args: SelectSubset<T, ReplyUpsertArgs>
    ): Prisma__ReplyClient<ReplyGetPayload<T>>

    /**
     * Count the number of Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCountArgs} args - Arguments to filter Replies to count.
     * @example
     * // Count the number of Replies
     * const count = await prisma.reply.count({
     *   where: {
     *     // ... the filter for the Replies we want to count
     *   }
     * })
    **/
    count<T extends ReplyCountArgs>(
      args?: Subset<T, ReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReplyAggregateArgs>(args: Subset<T, ReplyAggregateArgs>): Prisma.PrismaPromise<GetReplyAggregateType<T>>

    /**
     * Group by Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReplyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reply base type for findUnique actions
   */
  export type ReplyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }

  /**
   * Reply findUnique
   */
  export interface ReplyFindUniqueArgs extends ReplyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reply findUniqueOrThrow
   */
  export type ReplyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply base type for findFirst actions
   */
  export type ReplyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: Enumerable<ReplyScalarFieldEnum>
  }

  /**
   * Reply findFirst
   */
  export interface ReplyFindFirstArgs extends ReplyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reply findFirstOrThrow
   */
  export type ReplyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: Enumerable<ReplyScalarFieldEnum>
  }


  /**
   * Reply findMany
   */
  export type ReplyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter, which Replies to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: Enumerable<ReplyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    distinct?: Enumerable<ReplyScalarFieldEnum>
  }


  /**
   * Reply create
   */
  export type ReplyCreateArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * The data needed to create a Reply.
     */
    data: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
  }


  /**
   * Reply createMany
   */
  export type ReplyCreateManyArgs = {
    /**
     * The data used to create many Replies.
     */
    data: Enumerable<ReplyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reply update
   */
  export type ReplyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * The data needed to update a Reply.
     */
    data: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
    /**
     * Choose, which Reply to update.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply updateMany
   */
  export type ReplyUpdateManyArgs = {
    /**
     * The data used to update Replies.
     */
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyInput>
    /**
     * Filter which Replies to update
     */
    where?: ReplyWhereInput
  }


  /**
   * Reply upsert
   */
  export type ReplyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * The filter to search for the Reply to update in case it exists.
     */
    where: ReplyWhereUniqueInput
    /**
     * In case the Reply found by the `where` argument doesn't exist, create a new Reply with this data.
     */
    create: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
    /**
     * In case the Reply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
  }


  /**
   * Reply delete
   */
  export type ReplyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
    /**
     * Filter which Reply to delete.
     */
    where: ReplyWhereUniqueInput
  }


  /**
   * Reply deleteMany
   */
  export type ReplyDeleteManyArgs = {
    /**
     * Filter which Replies to delete
     */
    where?: ReplyWhereInput
  }


  /**
   * Reply without action
   */
  export type ReplyArgs = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReplyInclude | null
  }



  /**
   * Model YoutubeUser
   */


  export type AggregateYoutubeUser = {
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  export type YoutubeUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeUserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    image: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeUserAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeUserSumAggregateInputType = {
    id?: true
  }

  export type YoutubeUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeUserAggregateArgs = {
    /**
     * Filter which YoutubeUser to aggregate.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUsers
    **/
    _count?: true | YoutubeUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserMaxAggregateInputType
  }

  export type GetYoutubeUserAggregateType<T extends YoutubeUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUser[P]>
      : GetScalarType<T[P], AggregateYoutubeUser[P]>
  }




  export type YoutubeUserGroupByArgs = {
    where?: YoutubeUserWhereInput
    orderBy?: Enumerable<YoutubeUserOrderByWithAggregationInput>
    by: YoutubeUserScalarFieldEnum[]
    having?: YoutubeUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserCountAggregateInputType | true
    _avg?: YoutubeUserAvgAggregateInputType
    _sum?: YoutubeUserSumAggregateInputType
    _min?: YoutubeUserMinAggregateInputType
    _max?: YoutubeUserMaxAggregateInputType
  }


  export type YoutubeUserGroupByOutputType = {
    id: number
    name: string
    email: string
    image: string
    createAt: Date
    updateAt: Date
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  type GetYoutubeUserGroupByPayload<T extends YoutubeUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    subtoChannels?: boolean | YoutubeUser$subtoChannelsArgs
    commentToVideoes?: boolean | YoutubeUser$commentToVideoesArgs
    UserToChannel?: boolean | YoutubeUser$UserToChannelArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }


  export type YoutubeUserInclude = {
    subtoChannels?: boolean | YoutubeUser$subtoChannelsArgs
    commentToVideoes?: boolean | YoutubeUser$commentToVideoesArgs
    UserToChannel?: boolean | YoutubeUser$UserToChannelArgs
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }

  export type YoutubeUserGetPayload<S extends boolean | null | undefined | YoutubeUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUser :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
    ? YoutubeUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subtoChannels' ? Array < YoutubeChannelGetPayload<S['include'][P]>>  :
        P extends 'commentToVideoes' ? Array < YoutubeCommentToVideoGetPayload<S['include'][P]>>  :
        P extends 'UserToChannel' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subtoChannels' ? Array < YoutubeChannelGetPayload<S['select'][P]>>  :
        P extends 'commentToVideoes' ? Array < YoutubeCommentToVideoGetPayload<S['select'][P]>>  :
        P extends 'UserToChannel' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeUser ? YoutubeUser[P] : never
  } 
      : YoutubeUser


  type YoutubeUserCountArgs = 
    Omit<YoutubeUserFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserCountAggregateInputType | true
    }

  export interface YoutubeUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUser that matches the filter.
     * @param {YoutubeUserFindUniqueArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find one YoutubeUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find the first YoutubeUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find zero or more YoutubeUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany()
     * 
     * // Get first 10 YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeUserWithIdOnly = await prisma.youtubeUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeUserFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserGetPayload<T>>>

    /**
     * Create a YoutubeUser.
     * @param {YoutubeUserCreateArgs} args - Arguments to create a YoutubeUser.
     * @example
     * // Create one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.create({
     *   data: {
     *     // ... data to create a YoutubeUser
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserCreateArgs>(
      args: SelectSubset<T, YoutubeUserCreateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Create many YoutubeUsers.
     *     @param {YoutubeUserCreateManyArgs} args - Arguments to create many YoutubeUsers.
     *     @example
     *     // Create many YoutubeUsers
     *     const youtubeUser = await prisma.youtubeUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUser.
     * @param {YoutubeUserDeleteArgs} args - Arguments to delete one YoutubeUser.
     * @example
     * // Delete one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUser
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserDeleteArgs>(
      args: SelectSubset<T, YoutubeUserDeleteArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Update one YoutubeUser.
     * @param {YoutubeUserUpdateArgs} args - Arguments to update one YoutubeUser.
     * @example
     * // Update one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserUpdateArgs>(
      args: SelectSubset<T, YoutubeUserUpdateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Delete zero or more YoutubeUsers.
     * @param {YoutubeUserDeleteManyArgs} args - Arguments to filter YoutubeUsers to delete.
     * @example
     * // Delete a few YoutubeUsers
     * const { count } = await prisma.youtubeUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUsers
     * const youtubeUser = await prisma.youtubeUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUser.
     * @param {YoutubeUserUpsertArgs} args - Arguments to update or create a YoutubeUser.
     * @example
     * // Update or create a YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.upsert({
     *   create: {
     *     // ... data to create a YoutubeUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUser we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserUpsertArgs>(
      args: SelectSubset<T, YoutubeUserUpsertArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Count the number of YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserCountArgs} args - Arguments to filter YoutubeUsers to count.
     * @example
     * // Count the number of YoutubeUsers
     * const count = await prisma.youtubeUser.count({
     *   where: {
     *     // ... the filter for the YoutubeUsers we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserCountArgs>(
      args?: Subset<T, YoutubeUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserAggregateArgs>(args: Subset<T, YoutubeUserAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserAggregateType<T>>

    /**
     * Group by YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    subtoChannels<T extends YoutubeUser$subtoChannelsArgs= {}>(args?: Subset<T, YoutubeUser$subtoChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeChannelGetPayload<T>>| Null>;

    commentToVideoes<T extends YoutubeUser$commentToVideoesArgs= {}>(args?: Subset<T, YoutubeUser$commentToVideoesArgs>): Prisma.PrismaPromise<Array<YoutubeCommentToVideoGetPayload<T>>| Null>;

    UserToChannel<T extends YoutubeUser$UserToChannelArgs= {}>(args?: Subset<T, YoutubeUser$UserToChannelArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUser base type for findUnique actions
   */
  export type YoutubeUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }

  /**
   * YoutubeUser findUnique
   */
  export interface YoutubeUserFindUniqueArgs extends YoutubeUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findUniqueOrThrow
   */
  export type YoutubeUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser base type for findFirst actions
   */
  export type YoutubeUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }

  /**
   * YoutubeUser findFirst
   */
  export interface YoutubeUserFindFirstArgs extends YoutubeUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findFirstOrThrow
   */
  export type YoutubeUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser findMany
   */
  export type YoutubeUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUsers to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser create
   */
  export type YoutubeUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to create a YoutubeUser.
     */
    data: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
  }


  /**
   * YoutubeUser createMany
   */
  export type YoutubeUserCreateManyArgs = {
    /**
     * The data used to create many YoutubeUsers.
     */
    data: Enumerable<YoutubeUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUser update
   */
  export type YoutubeUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to update a YoutubeUser.
     */
    data: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUser to update.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser updateMany
   */
  export type YoutubeUserUpdateManyArgs = {
    /**
     * The data used to update YoutubeUsers.
     */
    data: XOR<YoutubeUserUpdateManyMutationInput, YoutubeUserUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUsers to update
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser upsert
   */
  export type YoutubeUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The filter to search for the YoutubeUser to update in case it exists.
     */
    where: YoutubeUserWhereUniqueInput
    /**
     * In case the YoutubeUser found by the `where` argument doesn't exist, create a new YoutubeUser with this data.
     */
    create: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
    /**
     * In case the YoutubeUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
  }


  /**
   * YoutubeUser delete
   */
  export type YoutubeUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter which YoutubeUser to delete.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser deleteMany
   */
  export type YoutubeUserDeleteManyArgs = {
    /**
     * Filter which YoutubeUsers to delete
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser.subtoChannels
   */
  export type YoutubeUser$subtoChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    where?: YoutubeChannelWhereInput
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    cursor?: YoutubeChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeUser.commentToVideoes
   */
  export type YoutubeUser$commentToVideoesArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    where?: YoutubeCommentToVideoWhereInput
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentToVideoScalarFieldEnum>
  }


  /**
   * YoutubeUser.UserToChannel
   */
  export type YoutubeUser$UserToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUser without action
   */
  export type YoutubeUserArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
  }



  /**
   * Model YoutubeRole
   */


  export type AggregateYoutubeRole = {
    _count: YoutubeRoleCountAggregateOutputType | null
    _avg: YoutubeRoleAvgAggregateOutputType | null
    _sum: YoutubeRoleSumAggregateOutputType | null
    _min: YoutubeRoleMinAggregateOutputType | null
    _max: YoutubeRoleMaxAggregateOutputType | null
  }

  export type YoutubeRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeRoleSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeRoleMinAggregateOutputType = {
    id: number | null
    role: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeRoleMaxAggregateOutputType = {
    id: number | null
    role: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeRoleCountAggregateOutputType = {
    id: number
    role: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeRoleAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeRoleSumAggregateInputType = {
    id?: true
  }

  export type YoutubeRoleMinAggregateInputType = {
    id?: true
    role?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeRoleMaxAggregateInputType = {
    id?: true
    role?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeRoleCountAggregateInputType = {
    id?: true
    role?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeRoleAggregateArgs = {
    /**
     * Filter which YoutubeRole to aggregate.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeRoles
    **/
    _count?: true | YoutubeRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeRoleMaxAggregateInputType
  }

  export type GetYoutubeRoleAggregateType<T extends YoutubeRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeRole[P]>
      : GetScalarType<T[P], AggregateYoutubeRole[P]>
  }




  export type YoutubeRoleGroupByArgs = {
    where?: YoutubeRoleWhereInput
    orderBy?: Enumerable<YoutubeRoleOrderByWithAggregationInput>
    by: YoutubeRoleScalarFieldEnum[]
    having?: YoutubeRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeRoleCountAggregateInputType | true
    _avg?: YoutubeRoleAvgAggregateInputType
    _sum?: YoutubeRoleSumAggregateInputType
    _min?: YoutubeRoleMinAggregateInputType
    _max?: YoutubeRoleMaxAggregateInputType
  }


  export type YoutubeRoleGroupByOutputType = {
    id: number
    role: string
    createAt: Date
    updateAt: Date
    _count: YoutubeRoleCountAggregateOutputType | null
    _avg: YoutubeRoleAvgAggregateOutputType | null
    _sum: YoutubeRoleSumAggregateOutputType | null
    _min: YoutubeRoleMinAggregateOutputType | null
    _max: YoutubeRoleMaxAggregateOutputType | null
  }

  type GetYoutubeRoleGroupByPayload<T extends YoutubeRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeRoleGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeRoleGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeRoleSelect = {
    id?: boolean
    role?: boolean
    createAt?: boolean
    updateAt?: boolean
    userToChannel?: boolean | YoutubeRole$userToChannelArgs
    _count?: boolean | YoutubeRoleCountOutputTypeArgs
  }


  export type YoutubeRoleInclude = {
    userToChannel?: boolean | YoutubeRole$userToChannelArgs
    _count?: boolean | YoutubeRoleCountOutputTypeArgs
  }

  export type YoutubeRoleGetPayload<S extends boolean | null | undefined | YoutubeRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeRole :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeRoleArgs | YoutubeRoleFindManyArgs)
    ? YoutubeRole  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannel' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeRoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeRoleArgs | YoutubeRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannel' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeRoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeRole ? YoutubeRole[P] : never
  } 
      : YoutubeRole


  type YoutubeRoleCountArgs = 
    Omit<YoutubeRoleFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeRoleCountAggregateInputType | true
    }

  export interface YoutubeRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeRole that matches the filter.
     * @param {YoutubeRoleFindUniqueArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeRole'> extends True ? Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>> : Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | null, null>

    /**
     * Find one YoutubeRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeRoleFindUniqueOrThrowArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeRoleFindUniqueOrThrowArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Find the first YoutubeRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindFirstArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeRole'> extends True ? Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>> : Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | null, null>

    /**
     * Find the first YoutubeRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindFirstOrThrowArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeRoleFindFirstOrThrowArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Find zero or more YoutubeRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeRoles
     * const youtubeRoles = await prisma.youtubeRole.findMany()
     * 
     * // Get first 10 YoutubeRoles
     * const youtubeRoles = await prisma.youtubeRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeRoleWithIdOnly = await prisma.youtubeRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeRoleFindManyArgs>(
      args?: SelectSubset<T, YoutubeRoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeRoleGetPayload<T>>>

    /**
     * Create a YoutubeRole.
     * @param {YoutubeRoleCreateArgs} args - Arguments to create a YoutubeRole.
     * @example
     * // Create one YoutubeRole
     * const YoutubeRole = await prisma.youtubeRole.create({
     *   data: {
     *     // ... data to create a YoutubeRole
     *   }
     * })
     * 
    **/
    create<T extends YoutubeRoleCreateArgs>(
      args: SelectSubset<T, YoutubeRoleCreateArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Create many YoutubeRoles.
     *     @param {YoutubeRoleCreateManyArgs} args - Arguments to create many YoutubeRoles.
     *     @example
     *     // Create many YoutubeRoles
     *     const youtubeRole = await prisma.youtubeRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeRoleCreateManyArgs>(
      args?: SelectSubset<T, YoutubeRoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeRole.
     * @param {YoutubeRoleDeleteArgs} args - Arguments to delete one YoutubeRole.
     * @example
     * // Delete one YoutubeRole
     * const YoutubeRole = await prisma.youtubeRole.delete({
     *   where: {
     *     // ... filter to delete one YoutubeRole
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeRoleDeleteArgs>(
      args: SelectSubset<T, YoutubeRoleDeleteArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Update one YoutubeRole.
     * @param {YoutubeRoleUpdateArgs} args - Arguments to update one YoutubeRole.
     * @example
     * // Update one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeRoleUpdateArgs>(
      args: SelectSubset<T, YoutubeRoleUpdateArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Delete zero or more YoutubeRoles.
     * @param {YoutubeRoleDeleteManyArgs} args - Arguments to filter YoutubeRoles to delete.
     * @example
     * // Delete a few YoutubeRoles
     * const { count } = await prisma.youtubeRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeRoleDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeRoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeRoles
     * const youtubeRole = await prisma.youtubeRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeRoleUpdateManyArgs>(
      args: SelectSubset<T, YoutubeRoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeRole.
     * @param {YoutubeRoleUpsertArgs} args - Arguments to update or create a YoutubeRole.
     * @example
     * // Update or create a YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.upsert({
     *   create: {
     *     // ... data to create a YoutubeRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeRole we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeRoleUpsertArgs>(
      args: SelectSubset<T, YoutubeRoleUpsertArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Count the number of YoutubeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleCountArgs} args - Arguments to filter YoutubeRoles to count.
     * @example
     * // Count the number of YoutubeRoles
     * const count = await prisma.youtubeRole.count({
     *   where: {
     *     // ... the filter for the YoutubeRoles we want to count
     *   }
     * })
    **/
    count<T extends YoutubeRoleCountArgs>(
      args?: Subset<T, YoutubeRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeRoleAggregateArgs>(args: Subset<T, YoutubeRoleAggregateArgs>): Prisma.PrismaPromise<GetYoutubeRoleAggregateType<T>>

    /**
     * Group by YoutubeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeRoleGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeRoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannel<T extends YoutubeRole$userToChannelArgs= {}>(args?: Subset<T, YoutubeRole$userToChannelArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeRole base type for findUnique actions
   */
  export type YoutubeRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where: YoutubeRoleWhereUniqueInput
  }

  /**
   * YoutubeRole findUnique
   */
  export interface YoutubeRoleFindUniqueArgs extends YoutubeRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeRole findUniqueOrThrow
   */
  export type YoutubeRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole base type for findFirst actions
   */
  export type YoutubeRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeRoles.
     */
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }

  /**
   * YoutubeRole findFirst
   */
  export interface YoutubeRoleFindFirstArgs extends YoutubeRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeRole findFirstOrThrow
   */
  export type YoutubeRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeRoles.
     */
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }


  /**
   * YoutubeRole findMany
   */
  export type YoutubeRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRoles to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }


  /**
   * YoutubeRole create
   */
  export type YoutubeRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The data needed to create a YoutubeRole.
     */
    data: XOR<YoutubeRoleCreateInput, YoutubeRoleUncheckedCreateInput>
  }


  /**
   * YoutubeRole createMany
   */
  export type YoutubeRoleCreateManyArgs = {
    /**
     * The data used to create many YoutubeRoles.
     */
    data: Enumerable<YoutubeRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeRole update
   */
  export type YoutubeRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The data needed to update a YoutubeRole.
     */
    data: XOR<YoutubeRoleUpdateInput, YoutubeRoleUncheckedUpdateInput>
    /**
     * Choose, which YoutubeRole to update.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole updateMany
   */
  export type YoutubeRoleUpdateManyArgs = {
    /**
     * The data used to update YoutubeRoles.
     */
    data: XOR<YoutubeRoleUpdateManyMutationInput, YoutubeRoleUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeRoles to update
     */
    where?: YoutubeRoleWhereInput
  }


  /**
   * YoutubeRole upsert
   */
  export type YoutubeRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The filter to search for the YoutubeRole to update in case it exists.
     */
    where: YoutubeRoleWhereUniqueInput
    /**
     * In case the YoutubeRole found by the `where` argument doesn't exist, create a new YoutubeRole with this data.
     */
    create: XOR<YoutubeRoleCreateInput, YoutubeRoleUncheckedCreateInput>
    /**
     * In case the YoutubeRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeRoleUpdateInput, YoutubeRoleUncheckedUpdateInput>
  }


  /**
   * YoutubeRole delete
   */
  export type YoutubeRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter which YoutubeRole to delete.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole deleteMany
   */
  export type YoutubeRoleDeleteManyArgs = {
    /**
     * Filter which YoutubeRoles to delete
     */
    where?: YoutubeRoleWhereInput
  }


  /**
   * YoutubeRole.userToChannel
   */
  export type YoutubeRole$userToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeRole without action
   */
  export type YoutubeRoleArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
  }



  /**
   * Model YoutubeReaction
   */


  export type AggregateYoutubeReaction = {
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  export type YoutubeReactionAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeReactionSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeReactionMinAggregateOutputType = {
    id: number | null
    reaction: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeReactionMaxAggregateOutputType = {
    id: number | null
    reaction: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeReactionCountAggregateOutputType = {
    id: number
    reaction: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeReactionAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeReactionSumAggregateInputType = {
    id?: true
  }

  export type YoutubeReactionMinAggregateInputType = {
    id?: true
    reaction?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeReactionMaxAggregateInputType = {
    id?: true
    reaction?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeReactionCountAggregateInputType = {
    id?: true
    reaction?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeReactionAggregateArgs = {
    /**
     * Filter which YoutubeReaction to aggregate.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeReactions
    **/
    _count?: true | YoutubeReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeReactionMaxAggregateInputType
  }

  export type GetYoutubeReactionAggregateType<T extends YoutubeReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeReaction[P]>
      : GetScalarType<T[P], AggregateYoutubeReaction[P]>
  }




  export type YoutubeReactionGroupByArgs = {
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithAggregationInput>
    by: YoutubeReactionScalarFieldEnum[]
    having?: YoutubeReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeReactionCountAggregateInputType | true
    _avg?: YoutubeReactionAvgAggregateInputType
    _sum?: YoutubeReactionSumAggregateInputType
    _min?: YoutubeReactionMinAggregateInputType
    _max?: YoutubeReactionMaxAggregateInputType
  }


  export type YoutubeReactionGroupByOutputType = {
    id: number
    reaction: string
    createAt: Date
    updateAt: Date
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  type GetYoutubeReactionGroupByPayload<T extends YoutubeReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeReactionSelect = {
    id?: boolean
    reaction?: boolean
    createAt?: boolean
    updateAt?: boolean
    Video?: boolean | YoutubeReaction$VideoArgs
    _count?: boolean | YoutubeReactionCountOutputTypeArgs
  }


  export type YoutubeReactionInclude = {
    Video?: boolean | YoutubeReaction$VideoArgs
    _count?: boolean | YoutubeReactionCountOutputTypeArgs
  }

  export type YoutubeReactionGetPayload<S extends boolean | null | undefined | YoutubeReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeReaction :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
    ? YoutubeReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Video' ? Array < YoutubeVideoGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeReactionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Video' ? Array < YoutubeVideoGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeReactionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeReaction ? YoutubeReaction[P] : never
  } 
      : YoutubeReaction


  type YoutubeReactionCountArgs = 
    Omit<YoutubeReactionFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeReactionCountAggregateInputType | true
    }

  export interface YoutubeReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeReaction that matches the filter.
     * @param {YoutubeReactionFindUniqueArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find one YoutubeReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeReactionFindUniqueOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindUniqueOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find the first YoutubeReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find the first YoutubeReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindFirstOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find zero or more YoutubeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany()
     * 
     * // Get first 10 YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeReactionWithIdOnly = await prisma.youtubeReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeReactionFindManyArgs>(
      args?: SelectSubset<T, YoutubeReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>>

    /**
     * Create a YoutubeReaction.
     * @param {YoutubeReactionCreateArgs} args - Arguments to create a YoutubeReaction.
     * @example
     * // Create one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.create({
     *   data: {
     *     // ... data to create a YoutubeReaction
     *   }
     * })
     * 
    **/
    create<T extends YoutubeReactionCreateArgs>(
      args: SelectSubset<T, YoutubeReactionCreateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Create many YoutubeReactions.
     *     @param {YoutubeReactionCreateManyArgs} args - Arguments to create many YoutubeReactions.
     *     @example
     *     // Create many YoutubeReactions
     *     const youtubeReaction = await prisma.youtubeReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeReactionCreateManyArgs>(
      args?: SelectSubset<T, YoutubeReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeReaction.
     * @param {YoutubeReactionDeleteArgs} args - Arguments to delete one YoutubeReaction.
     * @example
     * // Delete one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.delete({
     *   where: {
     *     // ... filter to delete one YoutubeReaction
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeReactionDeleteArgs>(
      args: SelectSubset<T, YoutubeReactionDeleteArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Update one YoutubeReaction.
     * @param {YoutubeReactionUpdateArgs} args - Arguments to update one YoutubeReaction.
     * @example
     * // Update one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeReactionUpdateArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Delete zero or more YoutubeReactions.
     * @param {YoutubeReactionDeleteManyArgs} args - Arguments to filter YoutubeReactions to delete.
     * @example
     * // Delete a few YoutubeReactions
     * const { count } = await prisma.youtubeReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeReactionDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeReactions
     * const youtubeReaction = await prisma.youtubeReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeReactionUpdateManyArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeReaction.
     * @param {YoutubeReactionUpsertArgs} args - Arguments to update or create a YoutubeReaction.
     * @example
     * // Update or create a YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.upsert({
     *   create: {
     *     // ... data to create a YoutubeReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeReaction we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeReactionUpsertArgs>(
      args: SelectSubset<T, YoutubeReactionUpsertArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Count the number of YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionCountArgs} args - Arguments to filter YoutubeReactions to count.
     * @example
     * // Count the number of YoutubeReactions
     * const count = await prisma.youtubeReaction.count({
     *   where: {
     *     // ... the filter for the YoutubeReactions we want to count
     *   }
     * })
    **/
    count<T extends YoutubeReactionCountArgs>(
      args?: Subset<T, YoutubeReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeReactionAggregateArgs>(args: Subset<T, YoutubeReactionAggregateArgs>): Prisma.PrismaPromise<GetYoutubeReactionAggregateType<T>>

    /**
     * Group by YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeReactionGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Video<T extends YoutubeReaction$VideoArgs= {}>(args?: Subset<T, YoutubeReaction$VideoArgs>): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeReaction base type for findUnique actions
   */
  export type YoutubeReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }

  /**
   * YoutubeReaction findUnique
   */
  export interface YoutubeReactionFindUniqueArgs extends YoutubeReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findUniqueOrThrow
   */
  export type YoutubeReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction base type for findFirst actions
   */
  export type YoutubeReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }

  /**
   * YoutubeReaction findFirst
   */
  export interface YoutubeReactionFindFirstArgs extends YoutubeReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findFirstOrThrow
   */
  export type YoutubeReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction findMany
   */
  export type YoutubeReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReactions to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction create
   */
  export type YoutubeReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to create a YoutubeReaction.
     */
    data: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
  }


  /**
   * YoutubeReaction createMany
   */
  export type YoutubeReactionCreateManyArgs = {
    /**
     * The data used to create many YoutubeReactions.
     */
    data: Enumerable<YoutubeReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeReaction update
   */
  export type YoutubeReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to update a YoutubeReaction.
     */
    data: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
    /**
     * Choose, which YoutubeReaction to update.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction updateMany
   */
  export type YoutubeReactionUpdateManyArgs = {
    /**
     * The data used to update YoutubeReactions.
     */
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeReactions to update
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction upsert
   */
  export type YoutubeReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The filter to search for the YoutubeReaction to update in case it exists.
     */
    where: YoutubeReactionWhereUniqueInput
    /**
     * In case the YoutubeReaction found by the `where` argument doesn't exist, create a new YoutubeReaction with this data.
     */
    create: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
    /**
     * In case the YoutubeReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
  }


  /**
   * YoutubeReaction delete
   */
  export type YoutubeReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter which YoutubeReaction to delete.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction deleteMany
   */
  export type YoutubeReactionDeleteManyArgs = {
    /**
     * Filter which YoutubeReactions to delete
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction.Video
   */
  export type YoutubeReaction$VideoArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    cursor?: YoutubeVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeReaction without action
   */
  export type YoutubeReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
  }



  /**
   * Model YoutubeVideo
   */


  export type AggregateYoutubeVideo = {
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  export type YoutubeVideoAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
    youtubeReactionId: number | null
  }

  export type YoutubeVideoSumAggregateOutputType = {
    id: number | null
    channelId: number | null
    youtubeReactionId: number | null
  }

  export type YoutubeVideoMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    channelId: number | null
    createAt: Date | null
    updateAt: Date | null
    youtubeReactionId: number | null
  }

  export type YoutubeVideoMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    url: string | null
    channelId: number | null
    createAt: Date | null
    updateAt: Date | null
    youtubeReactionId: number | null
  }

  export type YoutubeVideoCountAggregateOutputType = {
    id: number
    name: number
    description: number
    url: number
    channelId: number
    createAt: number
    updateAt: number
    youtubeReactionId: number
    _all: number
  }


  export type YoutubeVideoAvgAggregateInputType = {
    id?: true
    channelId?: true
    youtubeReactionId?: true
  }

  export type YoutubeVideoSumAggregateInputType = {
    id?: true
    channelId?: true
    youtubeReactionId?: true
  }

  export type YoutubeVideoMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    channelId?: true
    createAt?: true
    updateAt?: true
    youtubeReactionId?: true
  }

  export type YoutubeVideoMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    channelId?: true
    createAt?: true
    updateAt?: true
    youtubeReactionId?: true
  }

  export type YoutubeVideoCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    url?: true
    channelId?: true
    createAt?: true
    updateAt?: true
    youtubeReactionId?: true
    _all?: true
  }

  export type YoutubeVideoAggregateArgs = {
    /**
     * Filter which YoutubeVideo to aggregate.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeVideos
    **/
    _count?: true | YoutubeVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeVideoMaxAggregateInputType
  }

  export type GetYoutubeVideoAggregateType<T extends YoutubeVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeVideo[P]>
      : GetScalarType<T[P], AggregateYoutubeVideo[P]>
  }




  export type YoutubeVideoGroupByArgs = {
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithAggregationInput>
    by: YoutubeVideoScalarFieldEnum[]
    having?: YoutubeVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeVideoCountAggregateInputType | true
    _avg?: YoutubeVideoAvgAggregateInputType
    _sum?: YoutubeVideoSumAggregateInputType
    _min?: YoutubeVideoMinAggregateInputType
    _max?: YoutubeVideoMaxAggregateInputType
  }


  export type YoutubeVideoGroupByOutputType = {
    id: number
    name: string
    description: string
    url: string
    channelId: number | null
    createAt: Date
    updateAt: Date
    youtubeReactionId: number
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  type GetYoutubeVideoGroupByPayload<T extends YoutubeVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeVideoSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    likeorDislike?: boolean | YoutubeReactionArgs
    channel?: boolean | YoutubeChannelArgs
    channelId?: boolean
    commentToVideoes?: boolean | YoutubeVideo$commentToVideoesArgs
    createAt?: boolean
    updateAt?: boolean
    youtubeReactionId?: boolean
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }


  export type YoutubeVideoInclude = {
    likeorDislike?: boolean | YoutubeReactionArgs
    channel?: boolean | YoutubeChannelArgs
    commentToVideoes?: boolean | YoutubeVideo$commentToVideoesArgs
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }

  export type YoutubeVideoGetPayload<S extends boolean | null | undefined | YoutubeVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideo :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
    ? YoutubeVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'likeorDislike' ? YoutubeReactionGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> | null :
        P extends 'commentToVideoes' ? Array < YoutubeCommentToVideoGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'likeorDislike' ? YoutubeReactionGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> | null :
        P extends 'commentToVideoes' ? Array < YoutubeCommentToVideoGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeVideo ? YoutubeVideo[P] : never
  } 
      : YoutubeVideo


  type YoutubeVideoCountArgs = 
    Omit<YoutubeVideoFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeVideoCountAggregateInputType | true
    }

  export interface YoutubeVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeVideo that matches the filter.
     * @param {YoutubeVideoFindUniqueArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find one YoutubeVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeVideoFindUniqueOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindUniqueOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find the first YoutubeVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find the first YoutubeVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindFirstOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find zero or more YoutubeVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany()
     * 
     * // Get first 10 YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeVideoWithIdOnly = await prisma.youtubeVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeVideoFindManyArgs>(
      args?: SelectSubset<T, YoutubeVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>>

    /**
     * Create a YoutubeVideo.
     * @param {YoutubeVideoCreateArgs} args - Arguments to create a YoutubeVideo.
     * @example
     * // Create one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.create({
     *   data: {
     *     // ... data to create a YoutubeVideo
     *   }
     * })
     * 
    **/
    create<T extends YoutubeVideoCreateArgs>(
      args: SelectSubset<T, YoutubeVideoCreateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Create many YoutubeVideos.
     *     @param {YoutubeVideoCreateManyArgs} args - Arguments to create many YoutubeVideos.
     *     @example
     *     // Create many YoutubeVideos
     *     const youtubeVideo = await prisma.youtubeVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeVideoCreateManyArgs>(
      args?: SelectSubset<T, YoutubeVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeVideo.
     * @param {YoutubeVideoDeleteArgs} args - Arguments to delete one YoutubeVideo.
     * @example
     * // Delete one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.delete({
     *   where: {
     *     // ... filter to delete one YoutubeVideo
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeVideoDeleteArgs>(
      args: SelectSubset<T, YoutubeVideoDeleteArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Update one YoutubeVideo.
     * @param {YoutubeVideoUpdateArgs} args - Arguments to update one YoutubeVideo.
     * @example
     * // Update one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeVideoUpdateArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Delete zero or more YoutubeVideos.
     * @param {YoutubeVideoDeleteManyArgs} args - Arguments to filter YoutubeVideos to delete.
     * @example
     * // Delete a few YoutubeVideos
     * const { count } = await prisma.youtubeVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeVideoDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeVideos
     * const youtubeVideo = await prisma.youtubeVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeVideoUpdateManyArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeVideo.
     * @param {YoutubeVideoUpsertArgs} args - Arguments to update or create a YoutubeVideo.
     * @example
     * // Update or create a YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.upsert({
     *   create: {
     *     // ... data to create a YoutubeVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeVideo we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeVideoUpsertArgs>(
      args: SelectSubset<T, YoutubeVideoUpsertArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Count the number of YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoCountArgs} args - Arguments to filter YoutubeVideos to count.
     * @example
     * // Count the number of YoutubeVideos
     * const count = await prisma.youtubeVideo.count({
     *   where: {
     *     // ... the filter for the YoutubeVideos we want to count
     *   }
     * })
    **/
    count<T extends YoutubeVideoCountArgs>(
      args?: Subset<T, YoutubeVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeVideoAggregateArgs>(args: Subset<T, YoutubeVideoAggregateArgs>): Prisma.PrismaPromise<GetYoutubeVideoAggregateType<T>>

    /**
     * Group by YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeVideoGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    likeorDislike<T extends YoutubeReactionArgs= {}>(args?: Subset<T, YoutubeReactionArgs>): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    commentToVideoes<T extends YoutubeVideo$commentToVideoesArgs= {}>(args?: Subset<T, YoutubeVideo$commentToVideoesArgs>): Prisma.PrismaPromise<Array<YoutubeCommentToVideoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeVideo base type for findUnique actions
   */
  export type YoutubeVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }

  /**
   * YoutubeVideo findUnique
   */
  export interface YoutubeVideoFindUniqueArgs extends YoutubeVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findUniqueOrThrow
   */
  export type YoutubeVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo base type for findFirst actions
   */
  export type YoutubeVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }

  /**
   * YoutubeVideo findFirst
   */
  export interface YoutubeVideoFindFirstArgs extends YoutubeVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findFirstOrThrow
   */
  export type YoutubeVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo findMany
   */
  export type YoutubeVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideos to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo create
   */
  export type YoutubeVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to create a YoutubeVideo.
     */
    data: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
  }


  /**
   * YoutubeVideo createMany
   */
  export type YoutubeVideoCreateManyArgs = {
    /**
     * The data used to create many YoutubeVideos.
     */
    data: Enumerable<YoutubeVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeVideo update
   */
  export type YoutubeVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to update a YoutubeVideo.
     */
    data: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
    /**
     * Choose, which YoutubeVideo to update.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo updateMany
   */
  export type YoutubeVideoUpdateManyArgs = {
    /**
     * The data used to update YoutubeVideos.
     */
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeVideos to update
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo upsert
   */
  export type YoutubeVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The filter to search for the YoutubeVideo to update in case it exists.
     */
    where: YoutubeVideoWhereUniqueInput
    /**
     * In case the YoutubeVideo found by the `where` argument doesn't exist, create a new YoutubeVideo with this data.
     */
    create: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
    /**
     * In case the YoutubeVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
  }


  /**
   * YoutubeVideo delete
   */
  export type YoutubeVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter which YoutubeVideo to delete.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo deleteMany
   */
  export type YoutubeVideoDeleteManyArgs = {
    /**
     * Filter which YoutubeVideos to delete
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo.commentToVideoes
   */
  export type YoutubeVideo$commentToVideoesArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    where?: YoutubeCommentToVideoWhereInput
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentToVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo without action
   */
  export type YoutubeVideoArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
  }



  /**
   * Model YoutubeChannel
   */


  export type AggregateYoutubeChannel = {
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  export type YoutubeChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeChannelCountAggregateOutputType = {
    id: number
    name: number
    image: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeChannelAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelSumAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeChannelMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeChannelCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeChannelAggregateArgs = {
    /**
     * Filter which YoutubeChannel to aggregate.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeChannels
    **/
    _count?: true | YoutubeChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeChannelMaxAggregateInputType
  }

  export type GetYoutubeChannelAggregateType<T extends YoutubeChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeChannel[P]>
  }




  export type YoutubeChannelGroupByArgs = {
    where?: YoutubeChannelWhereInput
    orderBy?: Enumerable<YoutubeChannelOrderByWithAggregationInput>
    by: YoutubeChannelScalarFieldEnum[]
    having?: YoutubeChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeChannelCountAggregateInputType | true
    _avg?: YoutubeChannelAvgAggregateInputType
    _sum?: YoutubeChannelSumAggregateInputType
    _min?: YoutubeChannelMinAggregateInputType
    _max?: YoutubeChannelMaxAggregateInputType
  }


  export type YoutubeChannelGroupByOutputType = {
    id: number
    name: string
    image: string
    createAt: Date
    updateAt: Date
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  type GetYoutubeChannelGroupByPayload<T extends YoutubeChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeChannelSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    subcribers?: boolean | YoutubeChannel$subcribersArgs
    playLists?: boolean | YoutubeChannel$playListsArgs
    userToChannel?: boolean | YoutubeChannel$userToChannelArgs
    createAt?: boolean
    updateAt?: boolean
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }


  export type YoutubeChannelInclude = {
    subcribers?: boolean | YoutubeChannel$subcribersArgs
    playLists?: boolean | YoutubeChannel$playListsArgs
    userToChannel?: boolean | YoutubeChannel$userToChannelArgs
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }

  export type YoutubeChannelGetPayload<S extends boolean | null | undefined | YoutubeChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
    ? YoutubeChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subcribers' ? Array < YoutubeUserGetPayload<S['include'][P]>>  :
        P extends 'playLists' ? Array < YoutubeVideoGetPayload<S['include'][P]>>  :
        P extends 'userToChannel' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subcribers' ? Array < YoutubeUserGetPayload<S['select'][P]>>  :
        P extends 'playLists' ? Array < YoutubeVideoGetPayload<S['select'][P]>>  :
        P extends 'userToChannel' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeChannel ? YoutubeChannel[P] : never
  } 
      : YoutubeChannel


  type YoutubeChannelCountArgs = 
    Omit<YoutubeChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeChannelCountAggregateInputType | true
    }

  export interface YoutubeChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeChannel that matches the filter.
     * @param {YoutubeChannelFindUniqueArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find the first YoutubeChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany()
     * 
     * // Get first 10 YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeChannelWithIdOnly = await prisma.youtubeChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeChannelGetPayload<T>>>

    /**
     * Create a YoutubeChannel.
     * @param {YoutubeChannelCreateArgs} args - Arguments to create a YoutubeChannel.
     * @example
     * // Create one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.create({
     *   data: {
     *     // ... data to create a YoutubeChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeChannelCreateArgs>(
      args: SelectSubset<T, YoutubeChannelCreateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Create many YoutubeChannels.
     *     @param {YoutubeChannelCreateManyArgs} args - Arguments to create many YoutubeChannels.
     *     @example
     *     // Create many YoutubeChannels
     *     const youtubeChannel = await prisma.youtubeChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeChannel.
     * @param {YoutubeChannelDeleteArgs} args - Arguments to delete one YoutubeChannel.
     * @example
     * // Delete one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeChannelDeleteArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Update one YoutubeChannel.
     * @param {YoutubeChannelUpdateArgs} args - Arguments to update one YoutubeChannel.
     * @example
     * // Update one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeChannels.
     * @param {YoutubeChannelDeleteManyArgs} args - Arguments to filter YoutubeChannels to delete.
     * @example
     * // Delete a few YoutubeChannels
     * const { count } = await prisma.youtubeChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeChannels
     * const youtubeChannel = await prisma.youtubeChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeChannel.
     * @param {YoutubeChannelUpsertArgs} args - Arguments to update or create a YoutubeChannel.
     * @example
     * // Update or create a YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeChannelUpsertArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Count the number of YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelCountArgs} args - Arguments to filter YoutubeChannels to count.
     * @example
     * // Count the number of YoutubeChannels
     * const count = await prisma.youtubeChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeChannelCountArgs>(
      args?: Subset<T, YoutubeChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeChannelAggregateArgs>(args: Subset<T, YoutubeChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeChannelAggregateType<T>>

    /**
     * Group by YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    subcribers<T extends YoutubeChannel$subcribersArgs= {}>(args?: Subset<T, YoutubeChannel$subcribersArgs>): Prisma.PrismaPromise<Array<YoutubeUserGetPayload<T>>| Null>;

    playLists<T extends YoutubeChannel$playListsArgs= {}>(args?: Subset<T, YoutubeChannel$playListsArgs>): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>| Null>;

    userToChannel<T extends YoutubeChannel$userToChannelArgs= {}>(args?: Subset<T, YoutubeChannel$userToChannelArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeChannel base type for findUnique actions
   */
  export type YoutubeChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }

  /**
   * YoutubeChannel findUnique
   */
  export interface YoutubeChannelFindUniqueArgs extends YoutubeChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findUniqueOrThrow
   */
  export type YoutubeChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel base type for findFirst actions
   */
  export type YoutubeChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }

  /**
   * YoutubeChannel findFirst
   */
  export interface YoutubeChannelFindFirstArgs extends YoutubeChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findFirstOrThrow
   */
  export type YoutubeChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel findMany
   */
  export type YoutubeChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannels to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel create
   */
  export type YoutubeChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to create a YoutubeChannel.
     */
    data: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
  }


  /**
   * YoutubeChannel createMany
   */
  export type YoutubeChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeChannels.
     */
    data: Enumerable<YoutubeChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeChannel update
   */
  export type YoutubeChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to update a YoutubeChannel.
     */
    data: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeChannel to update.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel updateMany
   */
  export type YoutubeChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeChannels.
     */
    data: XOR<YoutubeChannelUpdateManyMutationInput, YoutubeChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeChannels to update
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel upsert
   */
  export type YoutubeChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The filter to search for the YoutubeChannel to update in case it exists.
     */
    where: YoutubeChannelWhereUniqueInput
    /**
     * In case the YoutubeChannel found by the `where` argument doesn't exist, create a new YoutubeChannel with this data.
     */
    create: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
    /**
     * In case the YoutubeChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeChannel delete
   */
  export type YoutubeChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter which YoutubeChannel to delete.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel deleteMany
   */
  export type YoutubeChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeChannels to delete
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel.subcribers
   */
  export type YoutubeChannel$subcribersArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    where?: YoutubeUserWhereInput
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    cursor?: YoutubeUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeChannel.playLists
   */
  export type YoutubeChannel$playListsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    cursor?: YoutubeVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeChannel.userToChannel
   */
  export type YoutubeChannel$userToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel without action
   */
  export type YoutubeChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
  }



  /**
   * Model YoutubeCommentToVideo
   */


  export type AggregateYoutubeCommentToVideo = {
    _count: YoutubeCommentToVideoCountAggregateOutputType | null
    _avg: YoutubeCommentToVideoAvgAggregateOutputType | null
    _sum: YoutubeCommentToVideoSumAggregateOutputType | null
    _min: YoutubeCommentToVideoMinAggregateOutputType | null
    _max: YoutubeCommentToVideoMaxAggregateOutputType | null
  }

  export type YoutubeCommentToVideoAvgAggregateOutputType = {
    id: number | null
    video: number | null
    commenterId: number | null
  }

  export type YoutubeCommentToVideoSumAggregateOutputType = {
    id: number | null
    video: number | null
    commenterId: number | null
  }

  export type YoutubeCommentToVideoMinAggregateOutputType = {
    id: number | null
    video: number | null
    comment: string | null
    commenterId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeCommentToVideoMaxAggregateOutputType = {
    id: number | null
    video: number | null
    comment: string | null
    commenterId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeCommentToVideoCountAggregateOutputType = {
    id: number
    video: number
    comment: number
    commenterId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeCommentToVideoAvgAggregateInputType = {
    id?: true
    video?: true
    commenterId?: true
  }

  export type YoutubeCommentToVideoSumAggregateInputType = {
    id?: true
    video?: true
    commenterId?: true
  }

  export type YoutubeCommentToVideoMinAggregateInputType = {
    id?: true
    video?: true
    comment?: true
    commenterId?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeCommentToVideoMaxAggregateInputType = {
    id?: true
    video?: true
    comment?: true
    commenterId?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeCommentToVideoCountAggregateInputType = {
    id?: true
    video?: true
    comment?: true
    commenterId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeCommentToVideoAggregateArgs = {
    /**
     * Filter which YoutubeCommentToVideo to aggregate.
     */
    where?: YoutubeCommentToVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentToVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentToVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentToVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeCommentToVideos
    **/
    _count?: true | YoutubeCommentToVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeCommentToVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeCommentToVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeCommentToVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeCommentToVideoMaxAggregateInputType
  }

  export type GetYoutubeCommentToVideoAggregateType<T extends YoutubeCommentToVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeCommentToVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeCommentToVideo[P]>
      : GetScalarType<T[P], AggregateYoutubeCommentToVideo[P]>
  }




  export type YoutubeCommentToVideoGroupByArgs = {
    where?: YoutubeCommentToVideoWhereInput
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithAggregationInput>
    by: YoutubeCommentToVideoScalarFieldEnum[]
    having?: YoutubeCommentToVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeCommentToVideoCountAggregateInputType | true
    _avg?: YoutubeCommentToVideoAvgAggregateInputType
    _sum?: YoutubeCommentToVideoSumAggregateInputType
    _min?: YoutubeCommentToVideoMinAggregateInputType
    _max?: YoutubeCommentToVideoMaxAggregateInputType
  }


  export type YoutubeCommentToVideoGroupByOutputType = {
    id: number
    video: number
    comment: string
    commenterId: number
    createAt: Date
    updateAt: Date
    _count: YoutubeCommentToVideoCountAggregateOutputType | null
    _avg: YoutubeCommentToVideoAvgAggregateOutputType | null
    _sum: YoutubeCommentToVideoSumAggregateOutputType | null
    _min: YoutubeCommentToVideoMinAggregateOutputType | null
    _max: YoutubeCommentToVideoMaxAggregateOutputType | null
  }

  type GetYoutubeCommentToVideoGroupByPayload<T extends YoutubeCommentToVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeCommentToVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeCommentToVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeCommentToVideoGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeCommentToVideoGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeCommentToVideoSelect = {
    id?: boolean
    videoId?: boolean | YoutubeVideoArgs
    video?: boolean
    comment?: boolean
    commenter?: boolean | YoutubeUserArgs
    commenterId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type YoutubeCommentToVideoInclude = {
    videoId?: boolean | YoutubeVideoArgs
    commenter?: boolean | YoutubeUserArgs
  }

  export type YoutubeCommentToVideoGetPayload<S extends boolean | null | undefined | YoutubeCommentToVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeCommentToVideo :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentToVideoArgs | YoutubeCommentToVideoFindManyArgs)
    ? YoutubeCommentToVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'videoId' ? YoutubeVideoGetPayload<S['include'][P]> :
        P extends 'commenter' ? YoutubeUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeCommentToVideoArgs | YoutubeCommentToVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'videoId' ? YoutubeVideoGetPayload<S['select'][P]> :
        P extends 'commenter' ? YoutubeUserGetPayload<S['select'][P]> :  P extends keyof YoutubeCommentToVideo ? YoutubeCommentToVideo[P] : never
  } 
      : YoutubeCommentToVideo


  type YoutubeCommentToVideoCountArgs = 
    Omit<YoutubeCommentToVideoFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeCommentToVideoCountAggregateInputType | true
    }

  export interface YoutubeCommentToVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeCommentToVideo that matches the filter.
     * @param {YoutubeCommentToVideoFindUniqueArgs} args - Arguments to find a YoutubeCommentToVideo
     * @example
     * // Get one YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeCommentToVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeCommentToVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeCommentToVideo'> extends True ? Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>> : Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T> | null, null>

    /**
     * Find one YoutubeCommentToVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeCommentToVideoFindUniqueOrThrowArgs} args - Arguments to find a YoutubeCommentToVideo
     * @example
     * // Get one YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeCommentToVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentToVideoFindUniqueOrThrowArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Find the first YoutubeCommentToVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoFindFirstArgs} args - Arguments to find a YoutubeCommentToVideo
     * @example
     * // Get one YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeCommentToVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeCommentToVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeCommentToVideo'> extends True ? Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>> : Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T> | null, null>

    /**
     * Find the first YoutubeCommentToVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoFindFirstOrThrowArgs} args - Arguments to find a YoutubeCommentToVideo
     * @example
     * // Get one YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeCommentToVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentToVideoFindFirstOrThrowArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Find zero or more YoutubeCommentToVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeCommentToVideos
     * const youtubeCommentToVideos = await prisma.youtubeCommentToVideo.findMany()
     * 
     * // Get first 10 YoutubeCommentToVideos
     * const youtubeCommentToVideos = await prisma.youtubeCommentToVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeCommentToVideoWithIdOnly = await prisma.youtubeCommentToVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeCommentToVideoFindManyArgs>(
      args?: SelectSubset<T, YoutubeCommentToVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeCommentToVideoGetPayload<T>>>

    /**
     * Create a YoutubeCommentToVideo.
     * @param {YoutubeCommentToVideoCreateArgs} args - Arguments to create a YoutubeCommentToVideo.
     * @example
     * // Create one YoutubeCommentToVideo
     * const YoutubeCommentToVideo = await prisma.youtubeCommentToVideo.create({
     *   data: {
     *     // ... data to create a YoutubeCommentToVideo
     *   }
     * })
     * 
    **/
    create<T extends YoutubeCommentToVideoCreateArgs>(
      args: SelectSubset<T, YoutubeCommentToVideoCreateArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Create many YoutubeCommentToVideos.
     *     @param {YoutubeCommentToVideoCreateManyArgs} args - Arguments to create many YoutubeCommentToVideos.
     *     @example
     *     // Create many YoutubeCommentToVideos
     *     const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeCommentToVideoCreateManyArgs>(
      args?: SelectSubset<T, YoutubeCommentToVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeCommentToVideo.
     * @param {YoutubeCommentToVideoDeleteArgs} args - Arguments to delete one YoutubeCommentToVideo.
     * @example
     * // Delete one YoutubeCommentToVideo
     * const YoutubeCommentToVideo = await prisma.youtubeCommentToVideo.delete({
     *   where: {
     *     // ... filter to delete one YoutubeCommentToVideo
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeCommentToVideoDeleteArgs>(
      args: SelectSubset<T, YoutubeCommentToVideoDeleteArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Update one YoutubeCommentToVideo.
     * @param {YoutubeCommentToVideoUpdateArgs} args - Arguments to update one YoutubeCommentToVideo.
     * @example
     * // Update one YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeCommentToVideoUpdateArgs>(
      args: SelectSubset<T, YoutubeCommentToVideoUpdateArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Delete zero or more YoutubeCommentToVideos.
     * @param {YoutubeCommentToVideoDeleteManyArgs} args - Arguments to filter YoutubeCommentToVideos to delete.
     * @example
     * // Delete a few YoutubeCommentToVideos
     * const { count } = await prisma.youtubeCommentToVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeCommentToVideoDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeCommentToVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeCommentToVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeCommentToVideos
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeCommentToVideoUpdateManyArgs>(
      args: SelectSubset<T, YoutubeCommentToVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeCommentToVideo.
     * @param {YoutubeCommentToVideoUpsertArgs} args - Arguments to update or create a YoutubeCommentToVideo.
     * @example
     * // Update or create a YoutubeCommentToVideo
     * const youtubeCommentToVideo = await prisma.youtubeCommentToVideo.upsert({
     *   create: {
     *     // ... data to create a YoutubeCommentToVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeCommentToVideo we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeCommentToVideoUpsertArgs>(
      args: SelectSubset<T, YoutubeCommentToVideoUpsertArgs>
    ): Prisma__YoutubeCommentToVideoClient<YoutubeCommentToVideoGetPayload<T>>

    /**
     * Count the number of YoutubeCommentToVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoCountArgs} args - Arguments to filter YoutubeCommentToVideos to count.
     * @example
     * // Count the number of YoutubeCommentToVideos
     * const count = await prisma.youtubeCommentToVideo.count({
     *   where: {
     *     // ... the filter for the YoutubeCommentToVideos we want to count
     *   }
     * })
    **/
    count<T extends YoutubeCommentToVideoCountArgs>(
      args?: Subset<T, YoutubeCommentToVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeCommentToVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeCommentToVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeCommentToVideoAggregateArgs>(args: Subset<T, YoutubeCommentToVideoAggregateArgs>): Prisma.PrismaPromise<GetYoutubeCommentToVideoAggregateType<T>>

    /**
     * Group by YoutubeCommentToVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentToVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeCommentToVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeCommentToVideoGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeCommentToVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeCommentToVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeCommentToVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeCommentToVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeCommentToVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    videoId<T extends YoutubeVideoArgs= {}>(args?: Subset<T, YoutubeVideoArgs>): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | Null>;

    commenter<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeCommentToVideo base type for findUnique actions
   */
  export type YoutubeCommentToVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter, which YoutubeCommentToVideo to fetch.
     */
    where: YoutubeCommentToVideoWhereUniqueInput
  }

  /**
   * YoutubeCommentToVideo findUnique
   */
  export interface YoutubeCommentToVideoFindUniqueArgs extends YoutubeCommentToVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeCommentToVideo findUniqueOrThrow
   */
  export type YoutubeCommentToVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter, which YoutubeCommentToVideo to fetch.
     */
    where: YoutubeCommentToVideoWhereUniqueInput
  }


  /**
   * YoutubeCommentToVideo base type for findFirst actions
   */
  export type YoutubeCommentToVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter, which YoutubeCommentToVideo to fetch.
     */
    where?: YoutubeCommentToVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentToVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeCommentToVideos.
     */
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentToVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentToVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeCommentToVideos.
     */
    distinct?: Enumerable<YoutubeCommentToVideoScalarFieldEnum>
  }

  /**
   * YoutubeCommentToVideo findFirst
   */
  export interface YoutubeCommentToVideoFindFirstArgs extends YoutubeCommentToVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeCommentToVideo findFirstOrThrow
   */
  export type YoutubeCommentToVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter, which YoutubeCommentToVideo to fetch.
     */
    where?: YoutubeCommentToVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentToVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeCommentToVideos.
     */
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentToVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentToVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeCommentToVideos.
     */
    distinct?: Enumerable<YoutubeCommentToVideoScalarFieldEnum>
  }


  /**
   * YoutubeCommentToVideo findMany
   */
  export type YoutubeCommentToVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter, which YoutubeCommentToVideos to fetch.
     */
    where?: YoutubeCommentToVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeCommentToVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentToVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeCommentToVideos.
     */
    cursor?: YoutubeCommentToVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeCommentToVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeCommentToVideos.
     */
    skip?: number
    distinct?: Enumerable<YoutubeCommentToVideoScalarFieldEnum>
  }


  /**
   * YoutubeCommentToVideo create
   */
  export type YoutubeCommentToVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * The data needed to create a YoutubeCommentToVideo.
     */
    data: XOR<YoutubeCommentToVideoCreateInput, YoutubeCommentToVideoUncheckedCreateInput>
  }


  /**
   * YoutubeCommentToVideo createMany
   */
  export type YoutubeCommentToVideoCreateManyArgs = {
    /**
     * The data used to create many YoutubeCommentToVideos.
     */
    data: Enumerable<YoutubeCommentToVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeCommentToVideo update
   */
  export type YoutubeCommentToVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * The data needed to update a YoutubeCommentToVideo.
     */
    data: XOR<YoutubeCommentToVideoUpdateInput, YoutubeCommentToVideoUncheckedUpdateInput>
    /**
     * Choose, which YoutubeCommentToVideo to update.
     */
    where: YoutubeCommentToVideoWhereUniqueInput
  }


  /**
   * YoutubeCommentToVideo updateMany
   */
  export type YoutubeCommentToVideoUpdateManyArgs = {
    /**
     * The data used to update YoutubeCommentToVideos.
     */
    data: XOR<YoutubeCommentToVideoUpdateManyMutationInput, YoutubeCommentToVideoUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeCommentToVideos to update
     */
    where?: YoutubeCommentToVideoWhereInput
  }


  /**
   * YoutubeCommentToVideo upsert
   */
  export type YoutubeCommentToVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * The filter to search for the YoutubeCommentToVideo to update in case it exists.
     */
    where: YoutubeCommentToVideoWhereUniqueInput
    /**
     * In case the YoutubeCommentToVideo found by the `where` argument doesn't exist, create a new YoutubeCommentToVideo with this data.
     */
    create: XOR<YoutubeCommentToVideoCreateInput, YoutubeCommentToVideoUncheckedCreateInput>
    /**
     * In case the YoutubeCommentToVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeCommentToVideoUpdateInput, YoutubeCommentToVideoUncheckedUpdateInput>
  }


  /**
   * YoutubeCommentToVideo delete
   */
  export type YoutubeCommentToVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
    /**
     * Filter which YoutubeCommentToVideo to delete.
     */
    where: YoutubeCommentToVideoWhereUniqueInput
  }


  /**
   * YoutubeCommentToVideo deleteMany
   */
  export type YoutubeCommentToVideoDeleteManyArgs = {
    /**
     * Filter which YoutubeCommentToVideos to delete
     */
    where?: YoutubeCommentToVideoWhereInput
  }


  /**
   * YoutubeCommentToVideo without action
   */
  export type YoutubeCommentToVideoArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentToVideo
     */
    select?: YoutubeCommentToVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentToVideoInclude | null
  }



  /**
   * Model YoutubeUserToChannel
   */


  export type AggregateYoutubeUserToChannel = {
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  export type YoutubeUserToChannelAvgAggregateOutputType = {
    userId: number | null
    channelId: number | null
    roleId: number | null
  }

  export type YoutubeUserToChannelSumAggregateOutputType = {
    userId: number | null
    channelId: number | null
    roleId: number | null
  }

  export type YoutubeUserToChannelMinAggregateOutputType = {
    userId: number | null
    channelId: number | null
    roleId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeUserToChannelMaxAggregateOutputType = {
    userId: number | null
    channelId: number | null
    roleId: number | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type YoutubeUserToChannelCountAggregateOutputType = {
    userId: number
    channelId: number
    roleId: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type YoutubeUserToChannelAvgAggregateInputType = {
    userId?: true
    channelId?: true
    roleId?: true
  }

  export type YoutubeUserToChannelSumAggregateInputType = {
    userId?: true
    channelId?: true
    roleId?: true
  }

  export type YoutubeUserToChannelMinAggregateInputType = {
    userId?: true
    channelId?: true
    roleId?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeUserToChannelMaxAggregateInputType = {
    userId?: true
    channelId?: true
    roleId?: true
    createAt?: true
    updateAt?: true
  }

  export type YoutubeUserToChannelCountAggregateInputType = {
    userId?: true
    channelId?: true
    roleId?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type YoutubeUserToChannelAggregateArgs = {
    /**
     * Filter which YoutubeUserToChannel to aggregate.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUserToChannels
    **/
    _count?: true | YoutubeUserToChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserToChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserToChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }

  export type GetYoutubeUserToChannelAggregateType<T extends YoutubeUserToChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUserToChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
  }




  export type YoutubeUserToChannelGroupByArgs = {
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithAggregationInput>
    by: YoutubeUserToChannelScalarFieldEnum[]
    having?: YoutubeUserToChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserToChannelCountAggregateInputType | true
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    _sum?: YoutubeUserToChannelSumAggregateInputType
    _min?: YoutubeUserToChannelMinAggregateInputType
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }


  export type YoutubeUserToChannelGroupByOutputType = {
    userId: number
    channelId: number
    roleId: number
    createAt: Date
    updateAt: Date
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  type GetYoutubeUserToChannelGroupByPayload<T extends YoutubeUserToChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserToChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserToChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserToChannelSelect = {
    user?: boolean | YoutubeUserArgs
    userId?: boolean
    channel?: boolean | YoutubeChannelArgs
    channelId?: boolean
    role?: boolean | YoutubeRoleArgs
    roleId?: boolean
    createAt?: boolean
    updateAt?: boolean
  }


  export type YoutubeUserToChannelInclude = {
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
    role?: boolean | YoutubeRoleArgs
  }

  export type YoutubeUserToChannelGetPayload<S extends boolean | null | undefined | YoutubeUserToChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserToChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
    ? YoutubeUserToChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :
        P extends 'role' ? YoutubeRoleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :
        P extends 'role' ? YoutubeRoleGetPayload<S['select'][P]> :  P extends keyof YoutubeUserToChannel ? YoutubeUserToChannel[P] : never
  } 
      : YoutubeUserToChannel


  type YoutubeUserToChannelCountArgs = 
    Omit<YoutubeUserToChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserToChannelCountAggregateInputType | true
    }

  export interface YoutubeUserToChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUserToChannel that matches the filter.
     * @param {YoutubeUserToChannelFindUniqueArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserToChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserToChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeUserToChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserToChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserToChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find the first YoutubeUserToChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserToChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUserToChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserToChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeUserToChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
     * 
     * // Get first 10 YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const youtubeUserToChannelWithUserIdOnly = await prisma.youtubeUserToChannel.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends YoutubeUserToChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>>

    /**
     * Create a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelCreateArgs} args - Arguments to create a YoutubeUserToChannel.
     * @example
     * // Create one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.create({
     *   data: {
     *     // ... data to create a YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserToChannelCreateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelCreateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Create many YoutubeUserToChannels.
     *     @param {YoutubeUserToChannelCreateManyArgs} args - Arguments to create many YoutubeUserToChannels.
     *     @example
     *     // Create many YoutubeUserToChannels
     *     const youtubeUserToChannel = await prisma.youtubeUserToChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserToChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelDeleteArgs} args - Arguments to delete one YoutubeUserToChannel.
     * @example
     * // Delete one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserToChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeUserToChannelDeleteArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpdateArgs} args - Arguments to update one YoutubeUserToChannel.
     * @example
     * // Update one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserToChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeUserToChannels.
     * @param {YoutubeUserToChannelDeleteManyArgs} args - Arguments to filter YoutubeUserToChannels to delete.
     * @example
     * // Delete a few YoutubeUserToChannels
     * const { count } = await prisma.youtubeUserToChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserToChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUserToChannels
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserToChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpsertArgs} args - Arguments to update or create a YoutubeUserToChannel.
     * @example
     * // Update or create a YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeUserToChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUserToChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserToChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpsertArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Count the number of YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelCountArgs} args - Arguments to filter YoutubeUserToChannels to count.
     * @example
     * // Count the number of YoutubeUserToChannels
     * const count = await prisma.youtubeUserToChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeUserToChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserToChannelCountArgs>(
      args?: Subset<T, YoutubeUserToChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserToChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserToChannelAggregateArgs>(args: Subset<T, YoutubeUserToChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserToChannelAggregateType<T>>

    /**
     * Group by YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserToChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserToChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserToChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserToChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserToChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUserToChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserToChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    role<T extends YoutubeRoleArgs= {}>(args?: Subset<T, YoutubeRoleArgs>): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUserToChannel base type for findUnique actions
   */
  export type YoutubeUserToChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }

  /**
   * YoutubeUserToChannel findUnique
   */
  export interface YoutubeUserToChannelFindUniqueArgs extends YoutubeUserToChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findUniqueOrThrow
   */
  export type YoutubeUserToChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel base type for findFirst actions
   */
  export type YoutubeUserToChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }

  /**
   * YoutubeUserToChannel findFirst
   */
  export interface YoutubeUserToChannelFindFirstArgs extends YoutubeUserToChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findFirstOrThrow
   */
  export type YoutubeUserToChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel findMany
   */
  export type YoutubeUserToChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannels to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel create
   */
  export type YoutubeUserToChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to create a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
  }


  /**
   * YoutubeUserToChannel createMany
   */
  export type YoutubeUserToChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeUserToChannels.
     */
    data: Enumerable<YoutubeUserToChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUserToChannel update
   */
  export type YoutubeUserToChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to update a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUserToChannel to update.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel updateMany
   */
  export type YoutubeUserToChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeUserToChannels.
     */
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUserToChannels to update
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel upsert
   */
  export type YoutubeUserToChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The filter to search for the YoutubeUserToChannel to update in case it exists.
     */
    where: YoutubeUserToChannelWhereUniqueInput
    /**
     * In case the YoutubeUserToChannel found by the `where` argument doesn't exist, create a new YoutubeUserToChannel with this data.
     */
    create: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
    /**
     * In case the YoutubeUserToChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeUserToChannel delete
   */
  export type YoutubeUserToChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter which YoutubeUserToChannel to delete.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel deleteMany
   */
  export type YoutubeUserToChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeUserToChannels to delete
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel without action
   */
  export type YoutubeUserToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ActorsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ActorsScalarFieldEnum = (typeof ActorsScalarFieldEnum)[keyof typeof ActorsScalarFieldEnum]


  export const AuthorExScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AuthorExScalarFieldEnum = (typeof AuthorExScalarFieldEnum)[keyof typeof AuthorExScalarFieldEnum]


  export const BookExOnAuthorExScalarFieldEnum: {
    bookExampleId: 'bookExampleId',
    authorExampleId: 'authorExampleId'
  };

  export type BookExOnAuthorExScalarFieldEnum = (typeof BookExOnAuthorExScalarFieldEnum)[keyof typeof BookExOnAuthorExScalarFieldEnum]


  export const BookExScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type BookExScalarFieldEnum = (typeof BookExScalarFieldEnum)[keyof typeof BookExScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    ownerName: 'ownerName',
    tel: 'tel',
    address: 'address',
    area: 'area',
    totolMachine: 'totolMachine',
    mainCompanyId: 'mainCompanyId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const DewKitchenCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type DewKitchenCategoryScalarFieldEnum = (typeof DewKitchenCategoryScalarFieldEnum)[keyof typeof DewKitchenCategoryScalarFieldEnum]


  export const DewKitchenMenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryName: 'categoryName',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type DewKitchenMenuScalarFieldEnum = (typeof DewKitchenMenuScalarFieldEnum)[keyof typeof DewKitchenMenuScalarFieldEnum]


  export const DewKitchenOrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tableId: 'tableId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type DewKitchenOrderScalarFieldEnum = (typeof DewKitchenOrderScalarFieldEnum)[keyof typeof DewKitchenOrderScalarFieldEnum]


  export const DewOrderItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    orderId: 'orderId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type DewOrderItemScalarFieldEnum = (typeof DewOrderItemScalarFieldEnum)[keyof typeof DewOrderItemScalarFieldEnum]


  export const DewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    kadId: 'kadId'
  };

  export type DewScalarFieldEnum = (typeof DewScalarFieldEnum)[keyof typeof DewScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const HashTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt',
    postOnHashTagId: 'postOnHashTagId'
  };

  export type HashTagScalarFieldEnum = (typeof HashTagScalarFieldEnum)[keyof typeof HashTagScalarFieldEnum]


  export const KadScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type KadScalarFieldEnum = (typeof KadScalarFieldEnum)[keyof typeof KadScalarFieldEnum]


  export const MachineOnProgramScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    programId: 'programId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type MachineOnProgramScalarFieldEnum = (typeof MachineOnProgramScalarFieldEnum)[keyof typeof MachineOnProgramScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    size: 'size',
    category: 'category',
    model: 'model',
    mfg: 'mfg',
    insurance: 'insurance',
    branchId: 'branchId',
    washHistoryId: 'washHistoryId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const MainCompanyScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type MainCompanyScalarFieldEnum = (typeof MainCompanyScalarFieldEnum)[keyof typeof MainCompanyScalarFieldEnum]


  export const PostOnHashTagScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type PostOnHashTagScalarFieldEnum = (typeof PostOnHashTagScalarFieldEnum)[keyof typeof PostOnHashTagScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    message: 'message',
    userId: 'userId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const ProcessTypeScalarFieldEnum: {
    id: 'id',
    description: 'description',
    programId: 'programId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type ProcessTypeScalarFieldEnum = (typeof ProcessTypeScalarFieldEnum)[keyof typeof ProcessTypeScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    duration: 'duration',
    price: 'price',
    washHistoryId: 'washHistoryId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    idCategory: 'idCategory',
    idAnswer: 'idAnswer',
    idQuize: 'idQuize',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const QuizeAnswerScalarFieldEnum: {
    id: 'id',
    answer: 'answer',
    choiceId: 'choiceId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuizeAnswerScalarFieldEnum = (typeof QuizeAnswerScalarFieldEnum)[keyof typeof QuizeAnswerScalarFieldEnum]


  export const QuizeCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuizeCategoryScalarFieldEnum = (typeof QuizeCategoryScalarFieldEnum)[keyof typeof QuizeCategoryScalarFieldEnum]


  export const QuizeChoiceScalarFieldEnum: {
    id: 'id',
    choice: 'choice',
    questionId: 'questionId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuizeChoiceScalarFieldEnum = (typeof QuizeChoiceScalarFieldEnum)[keyof typeof QuizeChoiceScalarFieldEnum]


  export const QuizeGameRoundScalarFieldEnum: {
    id: 'id',
    user: 'user',
    score: 'score',
    answerId: 'answerId',
    questionId: 'questionId',
    choiceId: 'choiceId'
  };

  export type QuizeGameRoundScalarFieldEnum = (typeof QuizeGameRoundScalarFieldEnum)[keyof typeof QuizeGameRoundScalarFieldEnum]


  export const QuizeQuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    quizeCategoryId: 'quizeCategoryId',
    quizeAnswerId: 'quizeAnswerId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuizeQuestionScalarFieldEnum = (typeof QuizeQuestionScalarFieldEnum)[keyof typeof QuizeQuestionScalarFieldEnum]


  export const QuizeTableScalarFieldEnum: {
    id: 'id',
    idQuestion: 'idQuestion',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type QuizeTableScalarFieldEnum = (typeof QuizeTableScalarFieldEnum)[keyof typeof QuizeTableScalarFieldEnum]


  export const RepairDetailScalarFieldEnum: {
    id: 'id',
    date: 'date',
    damage: 'damage',
    cause: 'cause',
    machanics: 'machanics',
    createAt: 'createAt',
    updateAt: 'updateAt',
    repairHistoryId: 'repairHistoryId'
  };

  export type RepairDetailScalarFieldEnum = (typeof RepairDetailScalarFieldEnum)[keyof typeof RepairDetailScalarFieldEnum]


  export const RepairHistoryScalarFieldEnum: {
    id: 'id',
    time: 'time',
    machineId: 'machineId',
    repairDetailId: 'repairDetailId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type RepairHistoryScalarFieldEnum = (typeof RepairHistoryScalarFieldEnum)[keyof typeof RepairHistoryScalarFieldEnum]


  export const ReplyScalarFieldEnum: {
    id: 'id',
    message: 'message',
    postId: 'postId',
    createAt: 'createAt',
    updateAt: 'updateAt',
    userId: 'userId'
  };

  export type ReplyScalarFieldEnum = (typeof ReplyScalarFieldEnum)[keyof typeof ReplyScalarFieldEnum]


  export const RoundQuestionTableScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    userAnswerId: 'userAnswerId',
    quizId: 'quizId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type RoundQuestionTableScalarFieldEnum = (typeof RoundQuestionTableScalarFieldEnum)[keyof typeof RoundQuestionTableScalarFieldEnum]


  export const RoundTableScalarFieldEnum: {
    id: 'id',
    score: 'score',
    categoryId: 'categoryId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type RoundTableScalarFieldEnum = (typeof RoundTableScalarFieldEnum)[keyof typeof RoundTableScalarFieldEnum]


  export const SeriesTvScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SeriesTvScalarFieldEnum = (typeof SeriesTvScalarFieldEnum)[keyof typeof SeriesTvScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TodolistScalarFieldEnum: {
    id: 'id',
    task: 'task',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodolistScalarFieldEnum = (typeof TodolistScalarFieldEnum)[keyof typeof TodolistScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserRelationScalarFieldEnum: {
    id: 'id',
    fromId: 'fromId',
    toId: 'toId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type UserRelationScalarFieldEnum = (typeof UserRelationScalarFieldEnum)[keyof typeof UserRelationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WashHistoryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    price: 'price',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type WashHistoryScalarFieldEnum = (typeof WashHistoryScalarFieldEnum)[keyof typeof WashHistoryScalarFieldEnum]


  export const WashUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tel: 'tel',
    balance: 'balance',
    washHistoryId: 'washHistoryId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type WashUserScalarFieldEnum = (typeof WashUserScalarFieldEnum)[keyof typeof WashUserScalarFieldEnum]


  export const YoutubeChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeChannelScalarFieldEnum = (typeof YoutubeChannelScalarFieldEnum)[keyof typeof YoutubeChannelScalarFieldEnum]


  export const YoutubeCommentToVideoScalarFieldEnum: {
    id: 'id',
    video: 'video',
    comment: 'comment',
    commenterId: 'commenterId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeCommentToVideoScalarFieldEnum = (typeof YoutubeCommentToVideoScalarFieldEnum)[keyof typeof YoutubeCommentToVideoScalarFieldEnum]


  export const YoutubeReactionScalarFieldEnum: {
    id: 'id',
    reaction: 'reaction',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeReactionScalarFieldEnum = (typeof YoutubeReactionScalarFieldEnum)[keyof typeof YoutubeReactionScalarFieldEnum]


  export const YoutubeRoleScalarFieldEnum: {
    id: 'id',
    role: 'role',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeRoleScalarFieldEnum = (typeof YoutubeRoleScalarFieldEnum)[keyof typeof YoutubeRoleScalarFieldEnum]


  export const YoutubeUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeUserScalarFieldEnum = (typeof YoutubeUserScalarFieldEnum)[keyof typeof YoutubeUserScalarFieldEnum]


  export const YoutubeUserToChannelScalarFieldEnum: {
    userId: 'userId',
    channelId: 'channelId',
    roleId: 'roleId',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type YoutubeUserToChannelScalarFieldEnum = (typeof YoutubeUserToChannelScalarFieldEnum)[keyof typeof YoutubeUserToChannelScalarFieldEnum]


  export const YoutubeVideoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    url: 'url',
    channelId: 'channelId',
    createAt: 'createAt',
    updateAt: 'updateAt',
    youtubeReactionId: 'youtubeReactionId'
  };

  export type YoutubeVideoScalarFieldEnum = (typeof YoutubeVideoScalarFieldEnum)[keyof typeof YoutubeVideoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type DewKitchenCategoryWhereInput = {
    AND?: Enumerable<DewKitchenCategoryWhereInput>
    OR?: Enumerable<DewKitchenCategoryWhereInput>
    NOT?: Enumerable<DewKitchenCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menus?: DewKitchenMenuListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewKitchenCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    menus?: DewKitchenMenuOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type DewKitchenCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: DewKitchenCategoryCountOrderByAggregateInput
    _avg?: DewKitchenCategoryAvgOrderByAggregateInput
    _max?: DewKitchenCategoryMaxOrderByAggregateInput
    _min?: DewKitchenCategoryMinOrderByAggregateInput
    _sum?: DewKitchenCategorySumOrderByAggregateInput
  }

  export type DewKitchenCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DewKitchenCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<DewKitchenCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DewKitchenCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DewKitchenMenuWhereInput = {
    AND?: Enumerable<DewKitchenMenuWhereInput>
    OR?: Enumerable<DewKitchenMenuWhereInput>
    NOT?: Enumerable<DewKitchenMenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryKey?: XOR<DewKitchenCategoryRelationFilter, DewKitchenCategoryWhereInput> | null
    categoryName?: StringNullableFilter | string | null
    orderItems?: DewOrderItemListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewKitchenMenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryKey?: DewKitchenCategoryOrderByWithRelationInput
    categoryName?: SortOrder
    orderItems?: DewOrderItemOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenMenuWhereUniqueInput = {
    id?: number
  }

  export type DewKitchenMenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: DewKitchenMenuCountOrderByAggregateInput
    _avg?: DewKitchenMenuAvgOrderByAggregateInput
    _max?: DewKitchenMenuMaxOrderByAggregateInput
    _min?: DewKitchenMenuMinOrderByAggregateInput
    _sum?: DewKitchenMenuSumOrderByAggregateInput
  }

  export type DewKitchenMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DewKitchenMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<DewKitchenMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DewKitchenMenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DewKitchenOrderWhereInput = {
    AND?: Enumerable<DewKitchenOrderWhereInput>
    OR?: Enumerable<DewKitchenOrderWhereInput>
    NOT?: Enumerable<DewKitchenOrderWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    tableId?: IntFilter | number
    items?: DewOrderItemListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewKitchenOrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    items?: DewOrderItemOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenOrderWhereUniqueInput = {
    id?: number
  }

  export type DewKitchenOrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: DewKitchenOrderCountOrderByAggregateInput
    _avg?: DewKitchenOrderAvgOrderByAggregateInput
    _max?: DewKitchenOrderMaxOrderByAggregateInput
    _min?: DewKitchenOrderMinOrderByAggregateInput
    _sum?: DewKitchenOrderSumOrderByAggregateInput
  }

  export type DewKitchenOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DewKitchenOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<DewKitchenOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DewKitchenOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    tableId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DewOrderItemWhereInput = {
    AND?: Enumerable<DewOrderItemWhereInput>
    OR?: Enumerable<DewOrderItemWhereInput>
    NOT?: Enumerable<DewOrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<DewKitchenMenuRelationFilter, DewKitchenMenuWhereInput>
    menuId?: IntFilter | number
    order?: XOR<DewKitchenOrderRelationFilter, DewKitchenOrderWhereInput> | null
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: DewKitchenMenuOrderByWithRelationInput
    menuId?: SortOrder
    order?: DewKitchenOrderOrderByWithRelationInput
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewOrderItemWhereUniqueInput = {
    id?: number
  }

  export type DewOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: DewOrderItemCountOrderByAggregateInput
    _avg?: DewOrderItemAvgOrderByAggregateInput
    _max?: DewOrderItemMaxOrderByAggregateInput
    _min?: DewOrderItemMinOrderByAggregateInput
    _sum?: DewOrderItemSumOrderByAggregateInput
  }

  export type DewOrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DewOrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<DewOrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DewOrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BookExWhereInput = {
    AND?: Enumerable<BookExWhereInput>
    OR?: Enumerable<BookExWhereInput>
    NOT?: Enumerable<BookExWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    BookExampleOnAuthorExample?: BookExOnAuthorExListRelationFilter
  }

  export type BookExOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    BookExampleOnAuthorExample?: BookExOnAuthorExOrderByRelationAggregateInput
  }

  export type BookExWhereUniqueInput = {
    id?: number
  }

  export type BookExOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: BookExCountOrderByAggregateInput
    _avg?: BookExAvgOrderByAggregateInput
    _max?: BookExMaxOrderByAggregateInput
    _min?: BookExMinOrderByAggregateInput
    _sum?: BookExSumOrderByAggregateInput
  }

  export type BookExScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookExScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookExScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookExScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
  }

  export type AuthorExWhereInput = {
    AND?: Enumerable<AuthorExWhereInput>
    OR?: Enumerable<AuthorExWhereInput>
    NOT?: Enumerable<AuthorExWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    BookExampleOnAuthorExample?: BookExOnAuthorExListRelationFilter
  }

  export type AuthorExOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    BookExampleOnAuthorExample?: BookExOnAuthorExOrderByRelationAggregateInput
  }

  export type AuthorExWhereUniqueInput = {
    id?: number
  }

  export type AuthorExOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AuthorExCountOrderByAggregateInput
    _avg?: AuthorExAvgOrderByAggregateInput
    _max?: AuthorExMaxOrderByAggregateInput
    _min?: AuthorExMinOrderByAggregateInput
    _sum?: AuthorExSumOrderByAggregateInput
  }

  export type AuthorExScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthorExScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthorExScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthorExScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type BookExOnAuthorExWhereInput = {
    AND?: Enumerable<BookExOnAuthorExWhereInput>
    OR?: Enumerable<BookExOnAuthorExWhereInput>
    NOT?: Enumerable<BookExOnAuthorExWhereInput>
    bookExample?: XOR<BookExRelationFilter, BookExWhereInput>
    bookExampleId?: IntFilter | number
    authorExample?: XOR<AuthorExRelationFilter, AuthorExWhereInput>
    authorExampleId?: IntFilter | number
  }

  export type BookExOnAuthorExOrderByWithRelationInput = {
    bookExample?: BookExOrderByWithRelationInput
    bookExampleId?: SortOrder
    authorExample?: AuthorExOrderByWithRelationInput
    authorExampleId?: SortOrder
  }

  export type BookExOnAuthorExWhereUniqueInput = {
    bookExampleId?: number
  }

  export type BookExOnAuthorExOrderByWithAggregationInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
    _count?: BookExOnAuthorExCountOrderByAggregateInput
    _avg?: BookExOnAuthorExAvgOrderByAggregateInput
    _max?: BookExOnAuthorExMaxOrderByAggregateInput
    _min?: BookExOnAuthorExMinOrderByAggregateInput
    _sum?: BookExOnAuthorExSumOrderByAggregateInput
  }

  export type BookExOnAuthorExScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookExOnAuthorExScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookExOnAuthorExScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookExOnAuthorExScalarWhereWithAggregatesInput>
    bookExampleId?: IntWithAggregatesFilter | number
    authorExampleId?: IntWithAggregatesFilter | number
  }

  export type SeriesTvWhereInput = {
    AND?: Enumerable<SeriesTvWhereInput>
    OR?: Enumerable<SeriesTvWhereInput>
    NOT?: Enumerable<SeriesTvWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    actors?: ActorsListRelationFilter
  }

  export type SeriesTvOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    actors?: ActorsOrderByRelationAggregateInput
  }

  export type SeriesTvWhereUniqueInput = {
    id?: number
  }

  export type SeriesTvOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SeriesTvCountOrderByAggregateInput
    _avg?: SeriesTvAvgOrderByAggregateInput
    _max?: SeriesTvMaxOrderByAggregateInput
    _min?: SeriesTvMinOrderByAggregateInput
    _sum?: SeriesTvSumOrderByAggregateInput
  }

  export type SeriesTvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SeriesTvScalarWhereWithAggregatesInput>
    OR?: Enumerable<SeriesTvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SeriesTvScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type ActorsWhereInput = {
    AND?: Enumerable<ActorsWhereInput>
    OR?: Enumerable<ActorsWhereInput>
    NOT?: Enumerable<ActorsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    seriesTv?: SeriesTvListRelationFilter
  }

  export type ActorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    seriesTv?: SeriesTvOrderByRelationAggregateInput
  }

  export type ActorsWhereUniqueInput = {
    id?: number
  }

  export type ActorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ActorsCountOrderByAggregateInput
    _avg?: ActorsAvgOrderByAggregateInput
    _max?: ActorsMaxOrderByAggregateInput
    _min?: ActorsMinOrderByAggregateInput
    _sum?: ActorsSumOrderByAggregateInput
  }

  export type ActorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type DewWhereInput = {
    AND?: Enumerable<DewWhereInput>
    OR?: Enumerable<DewWhereInput>
    NOT?: Enumerable<DewWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    kad?: XOR<KadRelationFilter, KadWhereInput>
    kadId?: IntFilter | number
  }

  export type DewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    kad?: KadOrderByWithRelationInput
    kadId?: SortOrder
  }

  export type DewWhereUniqueInput = {
    id?: number
    kadId?: number
  }

  export type DewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    kadId?: SortOrder
    _count?: DewCountOrderByAggregateInput
    _avg?: DewAvgOrderByAggregateInput
    _max?: DewMaxOrderByAggregateInput
    _min?: DewMinOrderByAggregateInput
    _sum?: DewSumOrderByAggregateInput
  }

  export type DewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DewScalarWhereWithAggregatesInput>
    OR?: Enumerable<DewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    kadId?: IntWithAggregatesFilter | number
  }

  export type KadWhereInput = {
    AND?: Enumerable<KadWhereInput>
    OR?: Enumerable<KadWhereInput>
    NOT?: Enumerable<KadWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    Dew?: XOR<DewRelationFilter, DewWhereInput> | null
  }

  export type KadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Dew?: DewOrderByWithRelationInput
  }

  export type KadWhereUniqueInput = {
    id?: number
  }

  export type KadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: KadCountOrderByAggregateInput
    _avg?: KadAvgOrderByAggregateInput
    _max?: KadMaxOrderByAggregateInput
    _min?: KadMinOrderByAggregateInput
    _sum?: KadSumOrderByAggregateInput
  }

  export type KadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KadScalarWhereWithAggregatesInput>
    OR?: Enumerable<KadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type QuizeTableWhereInput = {
    AND?: Enumerable<QuizeTableWhereInput>
    OR?: Enumerable<QuizeTableWhereInput>
    NOT?: Enumerable<QuizeTableWhereInput>
    id?: IntFilter | number
    idQuestion?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type QuizeTableOrderByWithRelationInput = {
    id?: SortOrder
    idQuestion?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeTableWhereUniqueInput = {
    id?: number
  }

  export type QuizeTableOrderByWithAggregationInput = {
    id?: SortOrder
    idQuestion?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuizeTableCountOrderByAggregateInput
    _avg?: QuizeTableAvgOrderByAggregateInput
    _max?: QuizeTableMaxOrderByAggregateInput
    _min?: QuizeTableMinOrderByAggregateInput
    _sum?: QuizeTableSumOrderByAggregateInput
  }

  export type QuizeTableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeTableScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeTableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeTableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idQuestion?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionWhereInput = {
    AND?: Enumerable<QuestionWhereInput>
    OR?: Enumerable<QuestionWhereInput>
    NOT?: Enumerable<QuestionWhereInput>
    id?: IntFilter | number
    question?: StringFilter | string
    answer?: StringFilter | string
    idCategory?: IntFilter | number
    idAnswer?: IntFilter | number
    idQuize?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuestionWhereUniqueInput = {
    id?: number
  }

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    question?: StringWithAggregatesFilter | string
    answer?: StringWithAggregatesFilter | string
    idCategory?: IntWithAggregatesFilter | number
    idAnswer?: IntWithAggregatesFilter | number
    idQuize?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: number
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type roundTableWhereInput = {
    AND?: Enumerable<roundTableWhereInput>
    OR?: Enumerable<roundTableWhereInput>
    NOT?: Enumerable<roundTableWhereInput>
    id?: IntFilter | number
    score?: IntFilter | number
    categoryId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type roundTableOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundTableWhereUniqueInput = {
    id?: number
  }

  export type roundTableOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: roundTableCountOrderByAggregateInput
    _avg?: roundTableAvgOrderByAggregateInput
    _max?: roundTableMaxOrderByAggregateInput
    _min?: roundTableMinOrderByAggregateInput
    _sum?: roundTableSumOrderByAggregateInput
  }

  export type roundTableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<roundTableScalarWhereWithAggregatesInput>
    OR?: Enumerable<roundTableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<roundTableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type roundQuestionTableWhereInput = {
    AND?: Enumerable<roundQuestionTableWhereInput>
    OR?: Enumerable<roundQuestionTableWhereInput>
    NOT?: Enumerable<roundQuestionTableWhereInput>
    id?: IntFilter | number
    roundId?: IntFilter | number
    userAnswerId?: IntFilter | number
    quizId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type roundQuestionTableOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundQuestionTableWhereUniqueInput = {
    id?: number
  }

  export type roundQuestionTableOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: roundQuestionTableCountOrderByAggregateInput
    _avg?: roundQuestionTableAvgOrderByAggregateInput
    _max?: roundQuestionTableMaxOrderByAggregateInput
    _min?: roundQuestionTableMinOrderByAggregateInput
    _sum?: roundQuestionTableSumOrderByAggregateInput
  }

  export type roundQuestionTableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<roundQuestionTableScalarWhereWithAggregatesInput>
    OR?: Enumerable<roundQuestionTableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<roundQuestionTableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    roundId?: IntWithAggregatesFilter | number
    userAnswerId?: IntWithAggregatesFilter | number
    quizId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizeCategoryWhereInput = {
    AND?: Enumerable<QuizeCategoryWhereInput>
    OR?: Enumerable<QuizeCategoryWhereInput>
    NOT?: Enumerable<QuizeCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    questions?: QuizeQuestionListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type QuizeCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    questions?: QuizeQuestionOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeCategoryWhereUniqueInput = {
    id?: number
  }

  export type QuizeCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuizeCategoryCountOrderByAggregateInput
    _avg?: QuizeCategoryAvgOrderByAggregateInput
    _max?: QuizeCategoryMaxOrderByAggregateInput
    _min?: QuizeCategoryMinOrderByAggregateInput
    _sum?: QuizeCategorySumOrderByAggregateInput
  }

  export type QuizeCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizeQuestionWhereInput = {
    AND?: Enumerable<QuizeQuestionWhereInput>
    OR?: Enumerable<QuizeQuestionWhereInput>
    NOT?: Enumerable<QuizeQuestionWhereInput>
    id?: IntFilter | number
    question?: StringFilter | string
    quizeCategory?: XOR<QuizeCategoryRelationFilter, QuizeCategoryWhereInput> | null
    quizeCategoryId?: IntNullableFilter | number | null
    choices?: QuizeChoiceListRelationFilter
    answer?: XOR<QuizeAnswerRelationFilter, QuizeAnswerWhereInput> | null
    quizeAnswerId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    round?: XOR<QuizeGameRoundRelationFilter, QuizeGameRoundWhereInput> | null
  }

  export type QuizeQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    quizeCategory?: QuizeCategoryOrderByWithRelationInput
    quizeCategoryId?: SortOrder
    choices?: QuizeChoiceOrderByRelationAggregateInput
    answer?: QuizeAnswerOrderByWithRelationInput
    quizeAnswerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    round?: QuizeGameRoundOrderByWithRelationInput
  }

  export type QuizeQuestionWhereUniqueInput = {
    id?: number
    quizeAnswerId?: number
  }

  export type QuizeQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuizeQuestionCountOrderByAggregateInput
    _avg?: QuizeQuestionAvgOrderByAggregateInput
    _max?: QuizeQuestionMaxOrderByAggregateInput
    _min?: QuizeQuestionMinOrderByAggregateInput
    _sum?: QuizeQuestionSumOrderByAggregateInput
  }

  export type QuizeQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    question?: StringWithAggregatesFilter | string
    quizeCategoryId?: IntNullableWithAggregatesFilter | number | null
    quizeAnswerId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizeChoiceWhereInput = {
    AND?: Enumerable<QuizeChoiceWhereInput>
    OR?: Enumerable<QuizeChoiceWhereInput>
    NOT?: Enumerable<QuizeChoiceWhereInput>
    id?: IntFilter | number
    choice?: StringFilter | string
    quizeQuestion?: XOR<QuizeQuestionRelationFilter, QuizeQuestionWhereInput> | null
    questionId?: IntNullableFilter | number | null
    quizeAnswer?: XOR<QuizeAnswerRelationFilter, QuizeAnswerWhereInput> | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    round?: XOR<QuizeGameRoundRelationFilter, QuizeGameRoundWhereInput> | null
  }

  export type QuizeChoiceOrderByWithRelationInput = {
    id?: SortOrder
    choice?: SortOrder
    quizeQuestion?: QuizeQuestionOrderByWithRelationInput
    questionId?: SortOrder
    quizeAnswer?: QuizeAnswerOrderByWithRelationInput
    createAt?: SortOrder
    updateAt?: SortOrder
    round?: QuizeGameRoundOrderByWithRelationInput
  }

  export type QuizeChoiceWhereUniqueInput = {
    id?: number
  }

  export type QuizeChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    choice?: SortOrder
    questionId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuizeChoiceCountOrderByAggregateInput
    _avg?: QuizeChoiceAvgOrderByAggregateInput
    _max?: QuizeChoiceMaxOrderByAggregateInput
    _min?: QuizeChoiceMinOrderByAggregateInput
    _sum?: QuizeChoiceSumOrderByAggregateInput
  }

  export type QuizeChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    choice?: StringWithAggregatesFilter | string
    questionId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizeAnswerWhereInput = {
    AND?: Enumerable<QuizeAnswerWhereInput>
    OR?: Enumerable<QuizeAnswerWhereInput>
    NOT?: Enumerable<QuizeAnswerWhereInput>
    id?: IntFilter | number
    answer?: StringFilter | string
    quizeQuestion?: XOR<QuizeQuestionRelationFilter, QuizeQuestionWhereInput> | null
    choice?: XOR<QuizeChoiceRelationFilter, QuizeChoiceWhereInput>
    choiceId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    round?: XOR<QuizeGameRoundRelationFilter, QuizeGameRoundWhereInput> | null
  }

  export type QuizeAnswerOrderByWithRelationInput = {
    id?: SortOrder
    answer?: SortOrder
    quizeQuestion?: QuizeQuestionOrderByWithRelationInput
    choice?: QuizeChoiceOrderByWithRelationInput
    choiceId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    round?: QuizeGameRoundOrderByWithRelationInput
  }

  export type QuizeAnswerWhereUniqueInput = {
    id?: number
    choiceId?: number
  }

  export type QuizeAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    answer?: SortOrder
    choiceId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: QuizeAnswerCountOrderByAggregateInput
    _avg?: QuizeAnswerAvgOrderByAggregateInput
    _max?: QuizeAnswerMaxOrderByAggregateInput
    _min?: QuizeAnswerMinOrderByAggregateInput
    _sum?: QuizeAnswerSumOrderByAggregateInput
  }

  export type QuizeAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeAnswerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    answer?: StringWithAggregatesFilter | string
    choiceId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizeGameRoundWhereInput = {
    AND?: Enumerable<QuizeGameRoundWhereInput>
    OR?: Enumerable<QuizeGameRoundWhereInput>
    NOT?: Enumerable<QuizeGameRoundWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    score?: IntFilter | number
    answer?: XOR<QuizeAnswerRelationFilter, QuizeAnswerWhereInput>
    answerId?: IntFilter | number
    question?: XOR<QuizeQuestionRelationFilter, QuizeQuestionWhereInput>
    questionId?: IntFilter | number
    choice?: XOR<QuizeChoiceRelationFilter, QuizeChoiceWhereInput>
    choiceId?: IntFilter | number
  }

  export type QuizeGameRoundOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    score?: SortOrder
    answer?: QuizeAnswerOrderByWithRelationInput
    answerId?: SortOrder
    question?: QuizeQuestionOrderByWithRelationInput
    questionId?: SortOrder
    choice?: QuizeChoiceOrderByWithRelationInput
    choiceId?: SortOrder
  }

  export type QuizeGameRoundWhereUniqueInput = {
    id?: number
    answerId?: number
    questionId?: number
    choiceId?: number
  }

  export type QuizeGameRoundOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
    _count?: QuizeGameRoundCountOrderByAggregateInput
    _avg?: QuizeGameRoundAvgOrderByAggregateInput
    _max?: QuizeGameRoundMaxOrderByAggregateInput
    _min?: QuizeGameRoundMinOrderByAggregateInput
    _sum?: QuizeGameRoundSumOrderByAggregateInput
  }

  export type QuizeGameRoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizeGameRoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizeGameRoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizeGameRoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user?: StringWithAggregatesFilter | string
    score?: IntWithAggregatesFilter | number
    answerId?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    choiceId?: IntWithAggregatesFilter | number
  }

  export type MainCompanyWhereInput = {
    AND?: Enumerable<MainCompanyWhereInput>
    OR?: Enumerable<MainCompanyWhereInput>
    NOT?: Enumerable<MainCompanyWhereInput>
    id?: IntFilter | number
    branchIds?: BranchListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MainCompanyOrderByWithRelationInput = {
    id?: SortOrder
    branchIds?: BranchOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainCompanyWhereUniqueInput = {
    id?: number
  }

  export type MainCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: MainCompanyCountOrderByAggregateInput
    _avg?: MainCompanyAvgOrderByAggregateInput
    _max?: MainCompanyMaxOrderByAggregateInput
    _min?: MainCompanyMinOrderByAggregateInput
    _sum?: MainCompanySumOrderByAggregateInput
  }

  export type MainCompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MainCompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<MainCompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MainCompanyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BranchWhereInput = {
    AND?: Enumerable<BranchWhereInput>
    OR?: Enumerable<BranchWhereInput>
    NOT?: Enumerable<BranchWhereInput>
    id?: IntFilter | number
    ownerName?: StringFilter | string
    tel?: IntFilter | number
    address?: StringFilter | string
    area?: FloatFilter | number
    totolMachine?: IntFilter | number
    machines?: MachineListRelationFilter
    mainCompany?: XOR<MainCompanyRelationFilter, MainCompanyWhereInput> | null
    mainCompanyId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    ownerName?: SortOrder
    tel?: SortOrder
    address?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    machines?: MachineOrderByRelationAggregateInput
    mainCompany?: MainCompanyOrderByWithRelationInput
    mainCompanyId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchWhereUniqueInput = {
    id?: number
  }

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    ownerName?: SortOrder
    tel?: SortOrder
    address?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BranchScalarWhereWithAggregatesInput>
    OR?: Enumerable<BranchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BranchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ownerName?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
    area?: FloatWithAggregatesFilter | number
    totolMachine?: IntWithAggregatesFilter | number
    mainCompanyId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MachineWhereInput = {
    AND?: Enumerable<MachineWhereInput>
    OR?: Enumerable<MachineWhereInput>
    NOT?: Enumerable<MachineWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    size?: StringFilter | string
    category?: StringFilter | string
    model?: StringFilter | string
    mfg?: StringFilter | string
    insurance?: StringFilter | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput> | null
    branchId?: IntNullableFilter | number | null
    repairHistories?: RepairHistoryListRelationFilter
    washHistory?: XOR<WashHistoryRelationFilter, WashHistoryWhereInput> | null
    washHistoryId?: IntNullableFilter | number | null
    machineOnPrograms?: MachineOnProgramListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    category?: SortOrder
    model?: SortOrder
    mfg?: SortOrder
    insurance?: SortOrder
    branch?: BranchOrderByWithRelationInput
    branchId?: SortOrder
    repairHistories?: RepairHistoryOrderByRelationAggregateInput
    washHistory?: WashHistoryOrderByWithRelationInput
    washHistoryId?: SortOrder
    machineOnPrograms?: MachineOnProgramOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineWhereUniqueInput = {
    id?: number
  }

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    category?: SortOrder
    model?: SortOrder
    mfg?: SortOrder
    insurance?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _avg?: MachineAvgOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
    _sum?: MachineSumOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<MachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    brand?: StringWithAggregatesFilter | string
    size?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    mfg?: StringWithAggregatesFilter | string
    insurance?: StringWithAggregatesFilter | string
    branchId?: IntNullableWithAggregatesFilter | number | null
    washHistoryId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProgramWhereInput = {
    AND?: Enumerable<ProgramWhereInput>
    OR?: Enumerable<ProgramWhereInput>
    NOT?: Enumerable<ProgramWhereInput>
    id?: IntFilter | number
    duration?: IntFilter | number
    price?: IntFilter | number
    processes?: ProcessTypeListRelationFilter
    washHistory?: XOR<WashHistoryRelationFilter, WashHistoryWhereInput> | null
    washHistoryId?: IntNullableFilter | number | null
    machineOnPrograms?: MachineOnProgramListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    processes?: ProcessTypeOrderByRelationAggregateInput
    washHistory?: WashHistoryOrderByWithRelationInput
    washHistoryId?: SortOrder
    machineOnPrograms?: MachineOnProgramOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramWhereUniqueInput = {
    id?: number
  }

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    washHistoryId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MachineOnProgramWhereInput = {
    AND?: Enumerable<MachineOnProgramWhereInput>
    OR?: Enumerable<MachineOnProgramWhereInput>
    NOT?: Enumerable<MachineOnProgramWhereInput>
    id?: IntFilter | number
    machine?: XOR<MachineRelationFilter, MachineWhereInput>
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    machineId?: IntFilter | number
    programId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MachineOnProgramOrderByWithRelationInput = {
    id?: SortOrder
    machine?: MachineOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    machineId?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineOnProgramWhereUniqueInput = {
    id?: number
  }

  export type MachineOnProgramOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: MachineOnProgramCountOrderByAggregateInput
    _avg?: MachineOnProgramAvgOrderByAggregateInput
    _max?: MachineOnProgramMaxOrderByAggregateInput
    _min?: MachineOnProgramMinOrderByAggregateInput
    _sum?: MachineOnProgramSumOrderByAggregateInput
  }

  export type MachineOnProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MachineOnProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<MachineOnProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MachineOnProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    machineId?: IntWithAggregatesFilter | number
    programId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProcessTypeWhereInput = {
    AND?: Enumerable<ProcessTypeWhereInput>
    OR?: Enumerable<ProcessTypeWhereInput>
    NOT?: Enumerable<ProcessTypeWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput> | null
    programId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type ProcessTypeOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    program?: ProgramOrderByWithRelationInput
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProcessTypeWhereUniqueInput = {
    id?: number
  }

  export type ProcessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: ProcessTypeCountOrderByAggregateInput
    _avg?: ProcessTypeAvgOrderByAggregateInput
    _max?: ProcessTypeMaxOrderByAggregateInput
    _min?: ProcessTypeMinOrderByAggregateInput
    _sum?: ProcessTypeSumOrderByAggregateInput
  }

  export type ProcessTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProcessTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProcessTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProcessTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    programId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RepairHistoryWhereInput = {
    AND?: Enumerable<RepairHistoryWhereInput>
    OR?: Enumerable<RepairHistoryWhereInput>
    NOT?: Enumerable<RepairHistoryWhereInput>
    id?: IntFilter | number
    time?: IntFilter | number
    machine?: XOR<MachineRelationFilter, MachineWhereInput> | null
    machineId?: IntNullableFilter | number | null
    detail?: XOR<RepairDetailRelationFilter, RepairDetailWhereInput>
    repairDetailId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type RepairHistoryOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    machine?: MachineOrderByWithRelationInput
    machineId?: SortOrder
    detail?: RepairDetailOrderByWithRelationInput
    repairDetailId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RepairHistoryWhereUniqueInput = {
    id?: number
  }

  export type RepairHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: RepairHistoryCountOrderByAggregateInput
    _avg?: RepairHistoryAvgOrderByAggregateInput
    _max?: RepairHistoryMaxOrderByAggregateInput
    _min?: RepairHistoryMinOrderByAggregateInput
    _sum?: RepairHistorySumOrderByAggregateInput
  }

  export type RepairHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    time?: IntWithAggregatesFilter | number
    machineId?: IntNullableWithAggregatesFilter | number | null
    repairDetailId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RepairDetailWhereInput = {
    AND?: Enumerable<RepairDetailWhereInput>
    OR?: Enumerable<RepairDetailWhereInput>
    NOT?: Enumerable<RepairDetailWhereInput>
    id?: IntFilter | number
    date?: StringFilter | string
    damage?: StringFilter | string
    cause?: StringFilter | string
    machanics?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    repairHistoryId?: IntFilter | number
    RepairHistory?: RepairHistoryListRelationFilter
  }

  export type RepairDetailOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    damage?: SortOrder
    cause?: SortOrder
    machanics?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    repairHistoryId?: SortOrder
    RepairHistory?: RepairHistoryOrderByRelationAggregateInput
  }

  export type RepairDetailWhereUniqueInput = {
    id?: number
  }

  export type RepairDetailOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    damage?: SortOrder
    cause?: SortOrder
    machanics?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    repairHistoryId?: SortOrder
    _count?: RepairDetailCountOrderByAggregateInput
    _avg?: RepairDetailAvgOrderByAggregateInput
    _max?: RepairDetailMaxOrderByAggregateInput
    _min?: RepairDetailMinOrderByAggregateInput
    _sum?: RepairDetailSumOrderByAggregateInput
  }

  export type RepairDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RepairDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<RepairDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RepairDetailScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: StringWithAggregatesFilter | string
    damage?: StringWithAggregatesFilter | string
    cause?: StringWithAggregatesFilter | string
    machanics?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    repairHistoryId?: IntWithAggregatesFilter | number
  }

  export type washUserWhereInput = {
    AND?: Enumerable<washUserWhereInput>
    OR?: Enumerable<washUserWhereInput>
    NOT?: Enumerable<washUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    tel?: IntFilter | number
    balance?: FloatFilter | number
    washHistory?: XOR<WashHistoryRelationFilter, WashHistoryWhereInput> | null
    washHistoryId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type washUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistory?: WashHistoryOrderByWithRelationInput
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type washUserWhereUniqueInput = {
    id?: number
  }

  export type washUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: washUserCountOrderByAggregateInput
    _avg?: washUserAvgOrderByAggregateInput
    _max?: washUserMaxOrderByAggregateInput
    _min?: washUserMinOrderByAggregateInput
    _sum?: washUserSumOrderByAggregateInput
  }

  export type washUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<washUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<washUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<washUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    tel?: IntWithAggregatesFilter | number
    balance?: FloatWithAggregatesFilter | number
    washHistoryId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WashHistoryWhereInput = {
    AND?: Enumerable<WashHistoryWhereInput>
    OR?: Enumerable<WashHistoryWhereInput>
    NOT?: Enumerable<WashHistoryWhereInput>
    id?: IntFilter | number
    date?: StringFilter | string
    price?: IntFilter | number
    programs?: ProgramListRelationFilter
    machines?: MachineListRelationFilter
    users?: WashUserListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WashHistoryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    programs?: ProgramOrderByRelationAggregateInput
    machines?: MachineOrderByRelationAggregateInput
    users?: washUserOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WashHistoryWhereUniqueInput = {
    id?: number
  }

  export type WashHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: WashHistoryCountOrderByAggregateInput
    _avg?: WashHistoryAvgOrderByAggregateInput
    _max?: WashHistoryMaxOrderByAggregateInput
    _min?: WashHistoryMinOrderByAggregateInput
    _sum?: WashHistorySumOrderByAggregateInput
  }

  export type WashHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WashHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<WashHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WashHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodolistWhereInput = {
    AND?: Enumerable<TodolistWhereInput>
    OR?: Enumerable<TodolistWhereInput>
    NOT?: Enumerable<TodolistWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    notes?: StringNullableFilter | string | null
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TodolistOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodolistWhereUniqueInput = {
    id?: number
  }

  export type TodolistOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodolistCountOrderByAggregateInput
    _avg?: TodolistAvgOrderByAggregateInput
    _max?: TodolistMaxOrderByAggregateInput
    _min?: TodolistMinOrderByAggregateInput
    _sum?: TodolistSumOrderByAggregateInput
  }

  export type TodolistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodolistScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodolistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodolistScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    notes?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    directMessage?: DirectMessageListRelationFilter
    fromUserRelation?: UserRelationListRelationFilter
    toUserRelation?: UserRelationListRelationFilter
    posts?: PostListRelationFilter
    replies?: ReplyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    directMessage?: DirectMessageOrderByRelationAggregateInput
    fromUserRelation?: UserRelationOrderByRelationAggregateInput
    toUserRelation?: UserRelationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    replies?: ReplyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: Enumerable<DirectMessageWhereInput>
    OR?: Enumerable<DirectMessageWhereInput>
    NOT?: Enumerable<DirectMessageWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    message?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    message?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DirectMessageWhereUniqueInput = {
    id?: number
  }

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _avg?: DirectMessageAvgOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
    _sum?: DirectMessageSumOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserRelationWhereInput = {
    AND?: Enumerable<UserRelationWhereInput>
    OR?: Enumerable<UserRelationWhereInput>
    NOT?: Enumerable<UserRelationWhereInput>
    id?: IntFilter | number
    from?: XOR<UserRelationFilter, UserWhereInput>
    fromId?: IntFilter | number
    to?: XOR<UserRelationFilter, UserWhereInput>
    toId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type UserRelationOrderByWithRelationInput = {
    id?: SortOrder
    from?: UserOrderByWithRelationInput
    fromId?: SortOrder
    to?: UserOrderByWithRelationInput
    toId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserRelationWhereUniqueInput = {
    id?: number
  }

  export type UserRelationOrderByWithAggregationInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserRelationCountOrderByAggregateInput
    _avg?: UserRelationAvgOrderByAggregateInput
    _max?: UserRelationMaxOrderByAggregateInput
    _min?: UserRelationMinOrderByAggregateInput
    _sum?: UserRelationSumOrderByAggregateInput
  }

  export type UserRelationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRelationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromId?: IntWithAggregatesFilter | number
    toId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HashTagWhereInput = {
    AND?: Enumerable<HashTagWhereInput>
    OR?: Enumerable<HashTagWhereInput>
    NOT?: Enumerable<HashTagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    postOnHashTag?: XOR<PostOnHashTagRelationFilter, PostOnHashTagWhereInput> | null
    postOnHashTagId?: IntNullableFilter | number | null
  }

  export type HashTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    postOnHashTag?: PostOnHashTagOrderByWithRelationInput
    postOnHashTagId?: SortOrder
  }

  export type HashTagWhereUniqueInput = {
    id?: number
  }

  export type HashTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    postOnHashTagId?: SortOrder
    _count?: HashTagCountOrderByAggregateInput
    _avg?: HashTagAvgOrderByAggregateInput
    _max?: HashTagMaxOrderByAggregateInput
    _min?: HashTagMinOrderByAggregateInput
    _sum?: HashTagSumOrderByAggregateInput
  }

  export type HashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    postOnHashTagId?: IntNullableWithAggregatesFilter | number | null
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    postOnHashTags?: PostOnHashTagListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    replies?: ReplyListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    postOnHashTags?: PostOnHashTagOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
    replies?: ReplyOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostOnHashTagWhereInput = {
    AND?: Enumerable<PostOnHashTagWhereInput>
    OR?: Enumerable<PostOnHashTagWhereInput>
    NOT?: Enumerable<PostOnHashTagWhereInput>
    id?: IntFilter | number
    posts?: PostListRelationFilter
    hashTags?: HashTagListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type PostOnHashTagOrderByWithRelationInput = {
    id?: SortOrder
    posts?: PostOrderByRelationAggregateInput
    hashTags?: HashTagOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostOnHashTagWhereUniqueInput = {
    id?: number
  }

  export type PostOnHashTagOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: PostOnHashTagCountOrderByAggregateInput
    _avg?: PostOnHashTagAvgOrderByAggregateInput
    _max?: PostOnHashTagMaxOrderByAggregateInput
    _min?: PostOnHashTagMinOrderByAggregateInput
    _sum?: PostOnHashTagSumOrderByAggregateInput
  }

  export type PostOnHashTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostOnHashTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostOnHashTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostOnHashTagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReplyWhereInput = {
    AND?: Enumerable<ReplyWhereInput>
    OR?: Enumerable<ReplyWhereInput>
    NOT?: Enumerable<ReplyWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
    postId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
  }

  export type ReplyOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    user?: UserOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    postId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
  }

  export type ReplyWhereUniqueInput = {
    id?: number
  }

  export type ReplyOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    postId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
    _count?: ReplyCountOrderByAggregateInput
    _avg?: ReplyAvgOrderByAggregateInput
    _max?: ReplyMaxOrderByAggregateInput
    _min?: ReplyMinOrderByAggregateInput
    _sum?: ReplySumOrderByAggregateInput
  }

  export type ReplyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReplyScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReplyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReplyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    postId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
  }

  export type YoutubeUserWhereInput = {
    AND?: Enumerable<YoutubeUserWhereInput>
    OR?: Enumerable<YoutubeUserWhereInput>
    NOT?: Enumerable<YoutubeUserWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    image?: StringFilter | string
    subtoChannels?: YoutubeChannelListRelationFilter
    commentToVideoes?: YoutubeCommentToVideoListRelationFilter
    UserToChannel?: YoutubeUserToChannelListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    subtoChannels?: YoutubeChannelOrderByRelationAggregateInput
    commentToVideoes?: YoutubeCommentToVideoOrderByRelationAggregateInput
    UserToChannel?: YoutubeUserToChannelOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserWhereUniqueInput = {
    id?: number
  }

  export type YoutubeUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeUserCountOrderByAggregateInput
    _avg?: YoutubeUserAvgOrderByAggregateInput
    _max?: YoutubeUserMaxOrderByAggregateInput
    _min?: YoutubeUserMinOrderByAggregateInput
    _sum?: YoutubeUserSumOrderByAggregateInput
  }

  export type YoutubeUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeRoleWhereInput = {
    AND?: Enumerable<YoutubeRoleWhereInput>
    OR?: Enumerable<YoutubeRoleWhereInput>
    NOT?: Enumerable<YoutubeRoleWhereInput>
    id?: IntFilter | number
    role?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    userToChannel?: YoutubeUserToChannelListRelationFilter
  }

  export type YoutubeRoleOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userToChannel?: YoutubeUserToChannelOrderByRelationAggregateInput
  }

  export type YoutubeRoleWhereUniqueInput = {
    id?: number
  }

  export type YoutubeRoleOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeRoleCountOrderByAggregateInput
    _avg?: YoutubeRoleAvgOrderByAggregateInput
    _max?: YoutubeRoleMaxOrderByAggregateInput
    _min?: YoutubeRoleMinOrderByAggregateInput
    _sum?: YoutubeRoleSumOrderByAggregateInput
  }

  export type YoutubeRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    role?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeReactionWhereInput = {
    AND?: Enumerable<YoutubeReactionWhereInput>
    OR?: Enumerable<YoutubeReactionWhereInput>
    NOT?: Enumerable<YoutubeReactionWhereInput>
    id?: IntFilter | number
    reaction?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    Video?: YoutubeVideoListRelationFilter
  }

  export type YoutubeReactionOrderByWithRelationInput = {
    id?: SortOrder
    reaction?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    Video?: YoutubeVideoOrderByRelationAggregateInput
  }

  export type YoutubeReactionWhereUniqueInput = {
    id?: number
  }

  export type YoutubeReactionOrderByWithAggregationInput = {
    id?: SortOrder
    reaction?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeReactionCountOrderByAggregateInput
    _avg?: YoutubeReactionAvgOrderByAggregateInput
    _max?: YoutubeReactionMaxOrderByAggregateInput
    _min?: YoutubeReactionMinOrderByAggregateInput
    _sum?: YoutubeReactionSumOrderByAggregateInput
  }

  export type YoutubeReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reaction?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeVideoWhereInput = {
    AND?: Enumerable<YoutubeVideoWhereInput>
    OR?: Enumerable<YoutubeVideoWhereInput>
    NOT?: Enumerable<YoutubeVideoWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    url?: StringFilter | string
    likeorDislike?: XOR<YoutubeReactionRelationFilter, YoutubeReactionWhereInput>
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput> | null
    channelId?: IntNullableFilter | number | null
    commentToVideoes?: YoutubeCommentToVideoListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    youtubeReactionId?: IntFilter | number
  }

  export type YoutubeVideoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    likeorDislike?: YoutubeReactionOrderByWithRelationInput
    channel?: YoutubeChannelOrderByWithRelationInput
    channelId?: SortOrder
    commentToVideoes?: YoutubeCommentToVideoOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeVideoWhereUniqueInput = {
    id?: number
  }

  export type YoutubeVideoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    channelId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    youtubeReactionId?: SortOrder
    _count?: YoutubeVideoCountOrderByAggregateInput
    _avg?: YoutubeVideoAvgOrderByAggregateInput
    _max?: YoutubeVideoMaxOrderByAggregateInput
    _min?: YoutubeVideoMinOrderByAggregateInput
    _sum?: YoutubeVideoSumOrderByAggregateInput
  }

  export type YoutubeVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    channelId?: IntNullableWithAggregatesFilter | number | null
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    youtubeReactionId?: IntWithAggregatesFilter | number
  }

  export type YoutubeChannelWhereInput = {
    AND?: Enumerable<YoutubeChannelWhereInput>
    OR?: Enumerable<YoutubeChannelWhereInput>
    NOT?: Enumerable<YoutubeChannelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    subcribers?: YoutubeUserListRelationFilter
    playLists?: YoutubeVideoListRelationFilter
    userToChannel?: YoutubeUserToChannelListRelationFilter
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    subcribers?: YoutubeUserOrderByRelationAggregateInput
    playLists?: YoutubeVideoOrderByRelationAggregateInput
    userToChannel?: YoutubeUserToChannelOrderByRelationAggregateInput
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeChannelWhereUniqueInput = {
    id?: number
  }

  export type YoutubeChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeChannelCountOrderByAggregateInput
    _avg?: YoutubeChannelAvgOrderByAggregateInput
    _max?: YoutubeChannelMaxOrderByAggregateInput
    _min?: YoutubeChannelMinOrderByAggregateInput
    _sum?: YoutubeChannelSumOrderByAggregateInput
  }

  export type YoutubeChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeCommentToVideoWhereInput = {
    AND?: Enumerable<YoutubeCommentToVideoWhereInput>
    OR?: Enumerable<YoutubeCommentToVideoWhereInput>
    NOT?: Enumerable<YoutubeCommentToVideoWhereInput>
    id?: IntFilter | number
    videoId?: XOR<YoutubeVideoRelationFilter, YoutubeVideoWhereInput>
    video?: IntFilter | number
    comment?: StringFilter | string
    commenter?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    commenterId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeCommentToVideoOrderByWithRelationInput = {
    id?: SortOrder
    videoId?: YoutubeVideoOrderByWithRelationInput
    video?: SortOrder
    comment?: SortOrder
    commenter?: YoutubeUserOrderByWithRelationInput
    commenterId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeCommentToVideoWhereUniqueInput = {
    id?: number
  }

  export type YoutubeCommentToVideoOrderByWithAggregationInput = {
    id?: SortOrder
    video?: SortOrder
    comment?: SortOrder
    commenterId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeCommentToVideoCountOrderByAggregateInput
    _avg?: YoutubeCommentToVideoAvgOrderByAggregateInput
    _max?: YoutubeCommentToVideoMaxOrderByAggregateInput
    _min?: YoutubeCommentToVideoMinOrderByAggregateInput
    _sum?: YoutubeCommentToVideoSumOrderByAggregateInput
  }

  export type YoutubeCommentToVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeCommentToVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeCommentToVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeCommentToVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    video?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
    commenterId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeUserToChannelWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelWhereInput>
    OR?: Enumerable<YoutubeUserToChannelWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelWhereInput>
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    userId?: IntFilter | number
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    channelId?: IntFilter | number
    role?: XOR<YoutubeRoleRelationFilter, YoutubeRoleWhereInput>
    roleId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserToChannelOrderByWithRelationInput = {
    user?: YoutubeUserOrderByWithRelationInput
    userId?: SortOrder
    channel?: YoutubeChannelOrderByWithRelationInput
    channelId?: SortOrder
    role?: YoutubeRoleOrderByWithRelationInput
    roleId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserToChannelWhereUniqueInput = {
    userId?: number
  }

  export type YoutubeUserToChannelOrderByWithAggregationInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: YoutubeUserToChannelCountOrderByAggregateInput
    _avg?: YoutubeUserToChannelAvgOrderByAggregateInput
    _max?: YoutubeUserToChannelMaxOrderByAggregateInput
    _min?: YoutubeUserToChannelMinOrderByAggregateInput
    _sum?: YoutubeUserToChannelSumOrderByAggregateInput
  }

  export type YoutubeUserToChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    userId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    roleId?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DewKitchenCategoryCreateInput = {
    name: string
    menus?: DewKitchenMenuCreateNestedManyWithoutCategoryKeyInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenCategoryUncheckedCreateInput = {
    id?: number
    name: string
    menus?: DewKitchenMenuUncheckedCreateNestedManyWithoutCategoryKeyInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menus?: DewKitchenMenuUpdateManyWithoutCategoryKeyNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menus?: DewKitchenMenuUncheckedUpdateManyWithoutCategoryKeyNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenCategoryCreateManyInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuCreateInput = {
    name: string
    image: string
    price: number
    categoryKey?: DewKitchenCategoryCreateNestedOneWithoutMenusInput
    orderItems?: DewOrderItemCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    orderItems?: DewOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryKey?: DewKitchenCategoryUpdateOneWithoutMenusNestedInput
    orderItems?: DewOrderItemUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: DewOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderCreateInput = {
    status?: string
    tableId: number
    items?: DewOrderItemCreateNestedManyWithoutOrderInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenOrderUncheckedCreateInput = {
    id?: number
    status?: string
    tableId: number
    items?: DewOrderItemUncheckedCreateNestedManyWithoutOrderInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenOrderUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: DewOrderItemUpdateManyWithoutOrderNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: DewOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderCreateManyInput = {
    id?: number
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenOrderUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemCreateInput = {
    menu: DewKitchenMenuCreateNestedOneWithoutOrderItemsInput
    order?: DewKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUncheckedCreateInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUpdateInput = {
    menu?: DewKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: DewKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemCreateManyInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookExCreateInput = {
    title: string
    BookExampleOnAuthorExample?: BookExOnAuthorExCreateNestedManyWithoutBookExampleInput
  }

  export type BookExUncheckedCreateInput = {
    id?: number
    title: string
    BookExampleOnAuthorExample?: BookExOnAuthorExUncheckedCreateNestedManyWithoutBookExampleInput
  }

  export type BookExUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    BookExampleOnAuthorExample?: BookExOnAuthorExUpdateManyWithoutBookExampleNestedInput
  }

  export type BookExUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    BookExampleOnAuthorExample?: BookExOnAuthorExUncheckedUpdateManyWithoutBookExampleNestedInput
  }

  export type BookExCreateManyInput = {
    id?: number
    title: string
  }

  export type BookExUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type BookExUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorExCreateInput = {
    name: string
    BookExampleOnAuthorExample?: BookExOnAuthorExCreateNestedManyWithoutAuthorExampleInput
  }

  export type AuthorExUncheckedCreateInput = {
    id?: number
    name: string
    BookExampleOnAuthorExample?: BookExOnAuthorExUncheckedCreateNestedManyWithoutAuthorExampleInput
  }

  export type AuthorExUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    BookExampleOnAuthorExample?: BookExOnAuthorExUpdateManyWithoutAuthorExampleNestedInput
  }

  export type AuthorExUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    BookExampleOnAuthorExample?: BookExOnAuthorExUncheckedUpdateManyWithoutAuthorExampleNestedInput
  }

  export type AuthorExCreateManyInput = {
    id?: number
    name: string
  }

  export type AuthorExUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorExUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BookExOnAuthorExCreateInput = {
    bookExample: BookExCreateNestedOneWithoutBookExampleOnAuthorExampleInput
    authorExample: AuthorExCreateNestedOneWithoutBookExampleOnAuthorExampleInput
  }

  export type BookExOnAuthorExUncheckedCreateInput = {
    bookExampleId: number
    authorExampleId: number
  }

  export type BookExOnAuthorExUpdateInput = {
    bookExample?: BookExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput
    authorExample?: AuthorExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput
  }

  export type BookExOnAuthorExUncheckedUpdateInput = {
    bookExampleId?: IntFieldUpdateOperationsInput | number
    authorExampleId?: IntFieldUpdateOperationsInput | number
  }

  export type BookExOnAuthorExCreateManyInput = {
    bookExampleId: number
    authorExampleId: number
  }

  export type BookExOnAuthorExUpdateManyMutationInput = {

  }

  export type BookExOnAuthorExUncheckedUpdateManyInput = {
    bookExampleId?: IntFieldUpdateOperationsInput | number
    authorExampleId?: IntFieldUpdateOperationsInput | number
  }

  export type SeriesTvCreateInput = {
    name: string
    actors?: ActorsCreateNestedManyWithoutSeriesTvInput
  }

  export type SeriesTvUncheckedCreateInput = {
    id?: number
    name: string
    actors?: ActorsUncheckedCreateNestedManyWithoutSeriesTvInput
  }

  export type SeriesTvUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    actors?: ActorsUpdateManyWithoutSeriesTvNestedInput
  }

  export type SeriesTvUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    actors?: ActorsUncheckedUpdateManyWithoutSeriesTvNestedInput
  }

  export type SeriesTvCreateManyInput = {
    id?: number
    name: string
  }

  export type SeriesTvUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTvUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorsCreateInput = {
    name: string
    seriesTv?: SeriesTvCreateNestedManyWithoutActorsInput
  }

  export type ActorsUncheckedCreateInput = {
    id?: number
    name: string
    seriesTv?: SeriesTvUncheckedCreateNestedManyWithoutActorsInput
  }

  export type ActorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    seriesTv?: SeriesTvUpdateManyWithoutActorsNestedInput
  }

  export type ActorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    seriesTv?: SeriesTvUncheckedUpdateManyWithoutActorsNestedInput
  }

  export type ActorsCreateManyInput = {
    id?: number
    name: string
  }

  export type ActorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DewCreateInput = {
    name: string
    kad: KadCreateNestedOneWithoutDewInput
  }

  export type DewUncheckedCreateInput = {
    id?: number
    name: string
    kadId: number
  }

  export type DewUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    kad?: KadUpdateOneRequiredWithoutDewNestedInput
  }

  export type DewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kadId?: IntFieldUpdateOperationsInput | number
  }

  export type DewCreateManyInput = {
    id?: number
    name: string
    kadId: number
  }

  export type DewUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kadId?: IntFieldUpdateOperationsInput | number
  }

  export type KadCreateInput = {
    name: string
    Dew?: DewCreateNestedOneWithoutKadInput
  }

  export type KadUncheckedCreateInput = {
    id?: number
    name: string
    Dew?: DewUncheckedCreateNestedOneWithoutKadInput
  }

  export type KadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Dew?: DewUpdateOneWithoutKadNestedInput
  }

  export type KadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Dew?: DewUncheckedUpdateOneWithoutKadNestedInput
  }

  export type KadCreateManyInput = {
    id?: number
    name: string
  }

  export type KadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type QuizeTableCreateInput = {
    idQuestion: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeTableUncheckedCreateInput = {
    id?: number
    idQuestion: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeTableUpdateInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idQuestion?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeTableCreateManyInput = {
    id?: number
    idQuestion: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeTableUpdateManyMutationInput = {
    idQuestion?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idQuestion?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    question: string
    answer: string
    idCategory: number
    idAnswer: number
    idQuize: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuestionUncheckedCreateInput = {
    id?: number
    question: string
    answer: string
    idCategory: number
    idAnswer: number
    idQuize: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    idCategory?: IntFieldUpdateOperationsInput | number
    idAnswer?: IntFieldUpdateOperationsInput | number
    idQuize?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    idCategory?: IntFieldUpdateOperationsInput | number
    idAnswer?: IntFieldUpdateOperationsInput | number
    idQuize?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyInput = {
    id?: number
    question: string
    answer: string
    idCategory: number
    idAnswer: number
    idQuize: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    idCategory?: IntFieldUpdateOperationsInput | number
    idAnswer?: IntFieldUpdateOperationsInput | number
    idQuize?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    idCategory?: IntFieldUpdateOperationsInput | number
    idAnswer?: IntFieldUpdateOperationsInput | number
    idQuize?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundTableCreateInput = {
    score: number
    categoryId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundTableUncheckedCreateInput = {
    id?: number
    score: number
    categoryId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundTableUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundTableCreateManyInput = {
    id?: number
    score: number
    categoryId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundTableUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundQuestionTableCreateInput = {
    roundId: number
    userAnswerId: number
    quizId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundQuestionTableUncheckedCreateInput = {
    id?: number
    roundId: number
    userAnswerId: number
    quizId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundQuestionTableUpdateInput = {
    roundId?: IntFieldUpdateOperationsInput | number
    userAnswerId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundQuestionTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userAnswerId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundQuestionTableCreateManyInput = {
    id?: number
    roundId: number
    userAnswerId: number
    quizId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type roundQuestionTableUpdateManyMutationInput = {
    roundId?: IntFieldUpdateOperationsInput | number
    userAnswerId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roundQuestionTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    userAnswerId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeCategoryCreateInput = {
    name: string
    questions?: QuizeQuestionCreateNestedManyWithoutQuizeCategoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeCategoryUncheckedCreateInput = {
    id?: number
    name: string
    questions?: QuizeQuestionUncheckedCreateNestedManyWithoutQuizeCategoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    questions?: QuizeQuestionUpdateManyWithoutQuizeCategoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    questions?: QuizeQuestionUncheckedUpdateManyWithoutQuizeCategoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeCategoryCreateManyInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeQuestionCreateInput = {
    question: string
    quizeCategory?: QuizeCategoryCreateNestedOneWithoutQuestionsInput
    choices?: QuizeChoiceCreateNestedManyWithoutQuizeQuestionInput
    answer?: QuizeAnswerCreateNestedOneWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionUncheckedCreateInput = {
    id?: number
    question: string
    quizeCategoryId?: number | null
    choices?: QuizeChoiceUncheckedCreateNestedManyWithoutQuizeQuestionInput
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    quizeCategory?: QuizeCategoryUpdateOneWithoutQuestionsNestedInput
    choices?: QuizeChoiceUpdateManyWithoutQuizeQuestionNestedInput
    answer?: QuizeAnswerUpdateOneWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    choices?: QuizeChoiceUncheckedUpdateManyWithoutQuizeQuestionNestedInput
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionCreateManyInput = {
    id?: number
    question: string
    quizeCategoryId?: number | null
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceCreateInput = {
    choice: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutChoicesInput
    quizeAnswer?: QuizeAnswerCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceUncheckedCreateInput = {
    id?: number
    choice: string
    questionId?: number | null
    quizeAnswer?: QuizeAnswerUncheckedCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceUpdateInput = {
    choice?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutChoicesNestedInput
    quizeAnswer?: QuizeAnswerUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    quizeAnswer?: QuizeAnswerUncheckedUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeChoiceCreateManyInput = {
    id?: number
    choice: string
    questionId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeChoiceUpdateManyMutationInput = {
    choice?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeAnswerCreateInput = {
    answer: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutAnswerInput
    choice: QuizeChoiceCreateNestedOneWithoutQuizeAnswerInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerUncheckedCreateInput = {
    id?: number
    answer: string
    quizeQuestion?: QuizeQuestionUncheckedCreateNestedOneWithoutAnswerInput
    choiceId: number
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutAnswerNestedInput
    choice?: QuizeChoiceUpdateOneRequiredWithoutQuizeAnswerNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUncheckedUpdateOneWithoutAnswerNestedInput
    choiceId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeAnswerCreateManyInput = {
    id?: number
    answer: string
    choiceId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeAnswerUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    choiceId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeGameRoundCreateInput = {
    user: string
    score: number
    answer: QuizeAnswerCreateNestedOneWithoutRoundInput
    question: QuizeQuestionCreateNestedOneWithoutRoundInput
    choice: QuizeChoiceCreateNestedOneWithoutRoundInput
  }

  export type QuizeGameRoundUncheckedCreateInput = {
    id?: number
    user: string
    score: number
    answerId: number
    questionId: number
    choiceId: number
  }

  export type QuizeGameRoundUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answer?: QuizeAnswerUpdateOneRequiredWithoutRoundNestedInput
    question?: QuizeQuestionUpdateOneRequiredWithoutRoundNestedInput
    choice?: QuizeChoiceUpdateOneRequiredWithoutRoundNestedInput
  }

  export type QuizeGameRoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizeGameRoundCreateManyInput = {
    id?: number
    user: string
    score: number
    answerId: number
    questionId: number
    choiceId: number
  }

  export type QuizeGameRoundUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type QuizeGameRoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
  }

  export type MainCompanyCreateInput = {
    branchIds?: BranchCreateNestedManyWithoutMainCompanyInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MainCompanyUncheckedCreateInput = {
    id?: number
    branchIds?: BranchUncheckedCreateNestedManyWithoutMainCompanyInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MainCompanyUpdateInput = {
    branchIds?: BranchUpdateManyWithoutMainCompanyNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainCompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchIds?: BranchUncheckedUpdateManyWithoutMainCompanyNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainCompanyCreateManyInput = {
    id?: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MainCompanyUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainCompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateInput = {
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    machines?: MachineCreateNestedManyWithoutBranchInput
    mainCompany?: MainCompanyCreateNestedOneWithoutBranchIdsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    machines?: MachineUncheckedCreateNestedManyWithoutBranchInput
    mainCompanyId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUpdateInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    machines?: MachineUpdateManyWithoutBranchNestedInput
    mainCompany?: MainCompanyUpdateOneWithoutBranchIdsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    machines?: MachineUncheckedUpdateManyWithoutBranchNestedInput
    mainCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateManyInput = {
    id?: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    mainCompanyId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    mainCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateInput = {
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branch?: BranchCreateNestedOneWithoutMachinesInput
    repairHistories?: RepairHistoryCreateNestedManyWithoutMachineInput
    washHistory?: WashHistoryCreateNestedOneWithoutMachinesInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUncheckedCreateInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    repairHistories?: RepairHistoryUncheckedCreateNestedManyWithoutMachineInput
    washHistoryId?: number | null
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUpdateInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneWithoutMachinesNestedInput
    repairHistories?: RepairHistoryUpdateManyWithoutMachineNestedInput
    washHistory?: WashHistoryUpdateOneWithoutMachinesNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    repairHistories?: RepairHistoryUncheckedUpdateManyWithoutMachineNestedInput
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUpdateManyMutationInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    duration: number
    price: number
    processes?: ProcessTypeCreateNestedManyWithoutProgramInput
    washHistory?: WashHistoryCreateNestedOneWithoutProgramsInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    duration: number
    price: number
    processes?: ProcessTypeUncheckedCreateNestedManyWithoutProgramInput
    washHistoryId?: number | null
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUpdateInput = {
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUpdateManyWithoutProgramNestedInput
    washHistory?: WashHistoryUpdateOneWithoutProgramsNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUncheckedUpdateManyWithoutProgramNestedInput
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateManyInput = {
    id?: number
    duration: number
    price: number
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramCreateInput = {
    machine: MachineCreateNestedOneWithoutMachineOnProgramsInput
    program: ProgramCreateNestedOneWithoutMachineOnProgramsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramUncheckedCreateInput = {
    id?: number
    machineId: number
    programId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramUpdateInput = {
    machine?: MachineUpdateOneRequiredWithoutMachineOnProgramsNestedInput
    program?: ProgramUpdateOneRequiredWithoutMachineOnProgramsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramCreateManyInput = {
    id?: number
    machineId: number
    programId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeCreateInput = {
    description: string
    program?: ProgramCreateNestedOneWithoutProcessesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeUncheckedCreateInput = {
    id?: number
    description: string
    programId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutProcessesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeCreateManyInput = {
    id?: number
    description: string
    programId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateInput = {
    time: number
    machine?: MachineCreateNestedOneWithoutRepairHistoriesInput
    detail: RepairDetailCreateNestedOneWithoutRepairHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUncheckedCreateInput = {
    id?: number
    time: number
    machineId?: number | null
    repairDetailId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUpdateInput = {
    time?: IntFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneWithoutRepairHistoriesNestedInput
    detail?: RepairDetailUpdateOneRequiredWithoutRepairHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    machineId?: NullableIntFieldUpdateOperationsInput | number | null
    repairDetailId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateManyInput = {
    id?: number
    time: number
    machineId?: number | null
    repairDetailId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUpdateManyMutationInput = {
    time?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    machineId?: NullableIntFieldUpdateOperationsInput | number | null
    repairDetailId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairDetailCreateInput = {
    date: string
    damage: string
    cause: string
    machanics: string
    createAt?: Date | string
    updateAt?: Date | string
    repairHistoryId: number
    RepairHistory?: RepairHistoryCreateNestedManyWithoutDetailInput
  }

  export type RepairDetailUncheckedCreateInput = {
    id?: number
    date: string
    damage: string
    cause: string
    machanics: string
    createAt?: Date | string
    updateAt?: Date | string
    repairHistoryId: number
    RepairHistory?: RepairHistoryUncheckedCreateNestedManyWithoutDetailInput
  }

  export type RepairDetailUpdateInput = {
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
    RepairHistory?: RepairHistoryUpdateManyWithoutDetailNestedInput
  }

  export type RepairDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
    RepairHistory?: RepairHistoryUncheckedUpdateManyWithoutDetailNestedInput
  }

  export type RepairDetailCreateManyInput = {
    id?: number
    date: string
    damage: string
    cause: string
    machanics: string
    createAt?: Date | string
    updateAt?: Date | string
    repairHistoryId: number
  }

  export type RepairDetailUpdateManyMutationInput = {
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
  }

  export type washUserCreateInput = {
    name: string
    tel: number
    balance: number
    washHistory?: WashHistoryCreateNestedOneWithoutUsersInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserUncheckedCreateInput = {
    id?: number
    name: string
    tel: number
    balance: number
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    washHistory?: WashHistoryUpdateOneWithoutUsersNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserCreateManyInput = {
    id?: number
    name: string
    tel: number
    balance: number
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryCreateInput = {
    date: string
    price: number
    programs?: ProgramCreateNestedManyWithoutWashHistoryInput
    machines?: MachineCreateNestedManyWithoutWashHistoryInput
    users?: washUserCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUncheckedCreateInput = {
    id?: number
    date: string
    price: number
    programs?: ProgramUncheckedCreateNestedManyWithoutWashHistoryInput
    machines?: MachineUncheckedCreateNestedManyWithoutWashHistoryInput
    users?: washUserUncheckedCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUpdateInput = {
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUpdateManyWithoutWashHistoryNestedInput
    machines?: MachineUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUncheckedUpdateManyWithoutWashHistoryNestedInput
    machines?: MachineUncheckedUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUncheckedUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryCreateManyInput = {
    id?: number
    date: string
    price: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUpdateManyMutationInput = {
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodolistCreateInput = {
    task: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodolistUncheckedCreateInput = {
    id?: number
    task: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodolistUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodolistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodolistCreateManyInput = {
    id?: number
    task: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodolistUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodolistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationCreateNestedManyWithoutToInput
    posts?: PostCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationUncheckedCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationUncheckedCreateNestedManyWithoutToInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUpdateManyWithoutToNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUncheckedUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUncheckedUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUncheckedUpdateManyWithoutToNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    user: UserCreateNestedOneWithoutDirectMessageInput
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: number
    userId: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    user?: UserUpdateOneRequiredWithoutDirectMessageNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id?: number
    userId: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateInput = {
    from: UserCreateNestedOneWithoutFromUserRelationInput
    to: UserCreateNestedOneWithoutToUserRelationInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationUncheckedCreateInput = {
    id?: number
    fromId: number
    toId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationUpdateInput = {
    from?: UserUpdateOneRequiredWithoutFromUserRelationNestedInput
    to?: UserUpdateOneRequiredWithoutToUserRelationNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationCreateManyInput = {
    id?: number
    fromId: number
    toId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagCreateInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    postOnHashTag?: PostOnHashTagCreateNestedOneWithoutHashTagsInput
  }

  export type HashTagUncheckedCreateInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    postOnHashTagId?: number | null
  }

  export type HashTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashTag?: PostOnHashTagUpdateOneWithoutHashTagsNestedInput
  }

  export type HashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashTagId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type HashTagCreateManyInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    postOnHashTagId?: number | null
  }

  export type HashTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postOnHashTagId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostCreateInput = {
    message: string
    user: UserCreateNestedOneWithoutPostsInput
    postOnHashTags?: PostOnHashTagCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    message: string
    userId: number
    postOnHashTags?: PostOnHashTagUncheckedCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    postOnHashTags?: PostOnHashTagUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postOnHashTags?: PostOnHashTagUncheckedUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    message: string
    userId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagCreateInput = {
    posts?: PostCreateNestedManyWithoutPostOnHashTagsInput
    hashTags?: HashTagCreateNestedManyWithoutPostOnHashTagInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagUncheckedCreateInput = {
    id?: number
    posts?: PostUncheckedCreateNestedManyWithoutPostOnHashTagsInput
    hashTags?: HashTagUncheckedCreateNestedManyWithoutPostOnHashTagInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagUpdateInput = {
    posts?: PostUpdateManyWithoutPostOnHashTagsNestedInput
    hashTags?: HashTagUpdateManyWithoutPostOnHashTagNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    posts?: PostUncheckedUpdateManyWithoutPostOnHashTagsNestedInput
    hashTags?: HashTagUncheckedUpdateManyWithoutPostOnHashTagNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagCreateManyInput = {
    id?: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCreateInput = {
    message: string
    user: UserCreateNestedOneWithoutRepliesInput
    post: PostCreateNestedOneWithoutRepliesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReplyUncheckedCreateInput = {
    id?: number
    message: string
    postId: number
    createAt?: Date | string
    updateAt?: Date | string
    userId: number
  }

  export type ReplyUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
    post?: PostUpdateOneRequiredWithoutRepliesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyCreateManyInput = {
    id?: number
    message: string
    postId: number
    createAt?: Date | string
    updateAt?: Date | string
    userId: number
  }

  export type ReplyUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserCreateInput = {
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelCreateNestedManyWithoutSubcribersInput
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutCommenterInput
    UserToChannel?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelUncheckedCreateNestedManyWithoutSubcribersInput
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutCommenterInput
    UserToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUpdateManyWithoutSubcribersNestedInput
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutCommenterNestedInput
    UserToChannel?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUncheckedUpdateManyWithoutSubcribersNestedInput
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutCommenterNestedInput
    UserToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserCreateManyInput = {
    id?: number
    name: string
    email: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleCreateInput = {
    role: string
    createAt?: Date | string
    updateAt?: Date | string
    userToChannel?: YoutubeUserToChannelCreateNestedManyWithoutRoleInput
  }

  export type YoutubeRoleUncheckedCreateInput = {
    id?: number
    role: string
    createAt?: Date | string
    updateAt?: Date | string
    userToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutRoleInput
  }

  export type YoutubeRoleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannel?: YoutubeUserToChannelUpdateManyWithoutRoleNestedInput
  }

  export type YoutubeRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type YoutubeRoleCreateManyInput = {
    id?: number
    role: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeRoleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionCreateInput = {
    reaction: string
    createAt?: Date | string
    updateAt?: Date | string
    Video?: YoutubeVideoCreateNestedManyWithoutLikeorDislikeInput
  }

  export type YoutubeReactionUncheckedCreateInput = {
    id?: number
    reaction: string
    createAt?: Date | string
    updateAt?: Date | string
    Video?: YoutubeVideoUncheckedCreateNestedManyWithoutLikeorDislikeInput
  }

  export type YoutubeReactionUpdateInput = {
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: YoutubeVideoUpdateManyWithoutLikeorDislikeNestedInput
  }

  export type YoutubeReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Video?: YoutubeVideoUncheckedUpdateManyWithoutLikeorDislikeNestedInput
  }

  export type YoutubeReactionCreateManyInput = {
    id?: number
    reaction: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeReactionUpdateManyMutationInput = {
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoCreateInput = {
    name: string
    description: string
    url: string
    likeorDislike: YoutubeReactionCreateNestedOneWithoutVideoInput
    channel?: YoutubeChannelCreateNestedOneWithoutPlayListsInput
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    url: string
    channelId?: number | null
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
    youtubeReactionId: number
  }

  export type YoutubeVideoUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    likeorDislike?: YoutubeReactionUpdateOneRequiredWithoutVideoNestedInput
    channel?: YoutubeChannelUpdateOneWithoutPlayListsNestedInput
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactionId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeVideoCreateManyInput = {
    id?: number
    name: string
    description: string
    url: string
    channelId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    youtubeReactionId: number
  }

  export type YoutubeVideoUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactionId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeChannelCreateInput = {
    name: string
    image: string
    subcribers?: YoutubeUserCreateNestedManyWithoutSubtoChannelsInput
    playLists?: YoutubeVideoCreateNestedManyWithoutChannelInput
    userToChannel?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    subcribers?: YoutubeUserUncheckedCreateNestedManyWithoutSubtoChannelsInput
    playLists?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    userToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUpdateManyWithoutSubtoChannelsNestedInput
    playLists?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    userToChannel?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUncheckedUpdateManyWithoutSubtoChannelsNestedInput
    playLists?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    userToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelCreateManyInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoCreateInput = {
    videoId: YoutubeVideoCreateNestedOneWithoutCommentToVideoesInput
    comment: string
    commenter: YoutubeUserCreateNestedOneWithoutCommentToVideoesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUncheckedCreateInput = {
    id?: number
    video: number
    comment: string
    commenterId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUpdateInput = {
    videoId?: YoutubeVideoUpdateOneRequiredWithoutCommentToVideoesNestedInput
    comment?: StringFieldUpdateOperationsInput | string
    commenter?: YoutubeUserUpdateOneRequiredWithoutCommentToVideoesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    commenterId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoCreateManyInput = {
    id?: number
    video: number
    comment: string
    commenterId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    commenterId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelInput
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelInput
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateInput = {
    userId: number
    channelId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelNestedInput
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyInput = {
    userId: number
    channelId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DewKitchenMenuListRelationFilter = {
    every?: DewKitchenMenuWhereInput
    some?: DewKitchenMenuWhereInput
    none?: DewKitchenMenuWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DewKitchenMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DewKitchenCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DewKitchenCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DewKitchenCategoryRelationFilter = {
    is?: DewKitchenCategoryWhereInput | null
    isNot?: DewKitchenCategoryWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DewOrderItemListRelationFilter = {
    every?: DewOrderItemWhereInput
    some?: DewOrderItemWhereInput
    none?: DewOrderItemWhereInput
  }

  export type DewOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DewKitchenMenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenMenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type DewKitchenMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenMenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenMenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DewKitchenOrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type DewKitchenOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenOrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewKitchenOrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type DewKitchenMenuRelationFilter = {
    is?: DewKitchenMenuWhereInput
    isNot?: DewKitchenMenuWhereInput
  }

  export type DewKitchenOrderRelationFilter = {
    is?: DewKitchenOrderWhereInput | null
    isNot?: DewKitchenOrderWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DewOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type DewOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DewOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BookExOnAuthorExListRelationFilter = {
    every?: BookExOnAuthorExWhereInput
    some?: BookExOnAuthorExWhereInput
    none?: BookExOnAuthorExWhereInput
  }

  export type BookExOnAuthorExOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookExCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type BookExAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookExMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type BookExMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type BookExSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorExCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AuthorExAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorExMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AuthorExMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AuthorExSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookExRelationFilter = {
    is?: BookExWhereInput
    isNot?: BookExWhereInput
  }

  export type AuthorExRelationFilter = {
    is?: AuthorExWhereInput
    isNot?: AuthorExWhereInput
  }

  export type BookExOnAuthorExCountOrderByAggregateInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
  }

  export type BookExOnAuthorExAvgOrderByAggregateInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
  }

  export type BookExOnAuthorExMaxOrderByAggregateInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
  }

  export type BookExOnAuthorExMinOrderByAggregateInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
  }

  export type BookExOnAuthorExSumOrderByAggregateInput = {
    bookExampleId?: SortOrder
    authorExampleId?: SortOrder
  }

  export type ActorsListRelationFilter = {
    every?: ActorsWhereInput
    some?: ActorsWhereInput
    none?: ActorsWhereInput
  }

  export type ActorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesTvCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeriesTvAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeriesTvMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeriesTvMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SeriesTvSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeriesTvListRelationFilter = {
    every?: SeriesTvWhereInput
    some?: SeriesTvWhereInput
    none?: SeriesTvWhereInput
  }

  export type SeriesTvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ActorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KadRelationFilter = {
    is?: KadWhereInput
    isNot?: KadWhereInput
  }

  export type DewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kadId?: SortOrder
  }

  export type DewAvgOrderByAggregateInput = {
    id?: SortOrder
    kadId?: SortOrder
  }

  export type DewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kadId?: SortOrder
  }

  export type DewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kadId?: SortOrder
  }

  export type DewSumOrderByAggregateInput = {
    id?: SortOrder
    kadId?: SortOrder
  }

  export type DewRelationFilter = {
    is?: DewWhereInput | null
    isNot?: DewWhereInput | null
  }

  export type KadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KadAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KadSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizeTableCountOrderByAggregateInput = {
    id?: SortOrder
    idQuestion?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeTableAvgOrderByAggregateInput = {
    id?: SortOrder
    idQuestion?: SortOrder
  }

  export type QuizeTableMaxOrderByAggregateInput = {
    id?: SortOrder
    idQuestion?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeTableMinOrderByAggregateInput = {
    id?: SortOrder
    idQuestion?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeTableSumOrderByAggregateInput = {
    id?: SortOrder
    idQuestion?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    id?: SortOrder
    idCategory?: SortOrder
    idAnswer?: SortOrder
    idQuize?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roundTableCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundTableAvgOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
  }

  export type roundTableMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundTableMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundTableSumOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    categoryId?: SortOrder
  }

  export type roundQuestionTableCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundQuestionTableAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
  }

  export type roundQuestionTableMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundQuestionTableMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type roundQuestionTableSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    userAnswerId?: SortOrder
    quizId?: SortOrder
  }

  export type QuizeQuestionListRelationFilter = {
    every?: QuizeQuestionWhereInput
    some?: QuizeQuestionWhereInput
    none?: QuizeQuestionWhereInput
  }

  export type QuizeQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizeCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizeCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizeCategoryRelationFilter = {
    is?: QuizeCategoryWhereInput | null
    isNot?: QuizeCategoryWhereInput | null
  }

  export type QuizeChoiceListRelationFilter = {
    every?: QuizeChoiceWhereInput
    some?: QuizeChoiceWhereInput
    none?: QuizeChoiceWhereInput
  }

  export type QuizeAnswerRelationFilter = {
    is?: QuizeAnswerWhereInput
    isNot?: QuizeAnswerWhereInput
  }

  export type QuizeGameRoundRelationFilter = {
    is?: QuizeGameRoundWhereInput | null
    isNot?: QuizeGameRoundWhereInput | null
  }

  export type QuizeChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizeQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
  }

  export type QuizeQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    quizeCategoryId?: SortOrder
    quizeAnswerId?: SortOrder
  }

  export type QuizeQuestionRelationFilter = {
    is?: QuizeQuestionWhereInput | null
    isNot?: QuizeQuestionWhereInput | null
  }

  export type QuizeChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    choice?: SortOrder
    questionId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type QuizeChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    choice?: SortOrder
    questionId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    choice?: SortOrder
    questionId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type QuizeChoiceRelationFilter = {
    is?: QuizeChoiceWhereInput
    isNot?: QuizeChoiceWhereInput
  }

  export type QuizeAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    choiceId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    choiceId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    choiceId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type QuizeAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeGameRoundCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeGameRoundAvgOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeGameRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeGameRoundMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
  }

  export type QuizeGameRoundSumOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    answerId?: SortOrder
    questionId?: SortOrder
    choiceId?: SortOrder
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MainCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainCompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MainCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MainCompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MachineListRelationFilter = {
    every?: MachineWhereInput
    some?: MachineWhereInput
    none?: MachineWhereInput
  }

  export type MainCompanyRelationFilter = {
    is?: MainCompanyWhereInput | null
    isNot?: MainCompanyWhereInput | null
  }

  export type MachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    tel?: SortOrder
    address?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    tel?: SortOrder
    address?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    tel?: SortOrder
    address?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    area?: SortOrder
    totolMachine?: SortOrder
    mainCompanyId?: SortOrder
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type RepairHistoryListRelationFilter = {
    every?: RepairHistoryWhereInput
    some?: RepairHistoryWhereInput
    none?: RepairHistoryWhereInput
  }

  export type WashHistoryRelationFilter = {
    is?: WashHistoryWhereInput | null
    isNot?: WashHistoryWhereInput | null
  }

  export type MachineOnProgramListRelationFilter = {
    every?: MachineOnProgramWhereInput
    some?: MachineOnProgramWhereInput
    none?: MachineOnProgramWhereInput
  }

  export type RepairHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineOnProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    category?: SortOrder
    model?: SortOrder
    mfg?: SortOrder
    insurance?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    category?: SortOrder
    model?: SortOrder
    mfg?: SortOrder
    insurance?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    category?: SortOrder
    model?: SortOrder
    mfg?: SortOrder
    insurance?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    washHistoryId?: SortOrder
  }

  export type ProcessTypeListRelationFilter = {
    every?: ProcessTypeWhereInput
    some?: ProcessTypeWhereInput
    none?: ProcessTypeWhereInput
  }

  export type ProcessTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    washHistoryId?: SortOrder
  }

  export type MachineRelationFilter = {
    is?: MachineWhereInput | null
    isNot?: MachineWhereInput | null
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type MachineOnProgramCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineOnProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type MachineOnProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineOnProgramMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MachineOnProgramSumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type ProcessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProcessTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
  }

  export type ProcessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProcessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    programId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProcessTypeSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
  }

  export type RepairDetailRelationFilter = {
    is?: RepairDetailWhereInput
    isNot?: RepairDetailWhereInput
  }

  export type RepairHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RepairHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
  }

  export type RepairHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RepairHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RepairHistorySumOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    machineId?: SortOrder
    repairDetailId?: SortOrder
  }

  export type RepairDetailCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    damage?: SortOrder
    cause?: SortOrder
    machanics?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    repairHistoryId?: SortOrder
  }

  export type RepairDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    repairHistoryId?: SortOrder
  }

  export type RepairDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    damage?: SortOrder
    cause?: SortOrder
    machanics?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    repairHistoryId?: SortOrder
  }

  export type RepairDetailMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    damage?: SortOrder
    cause?: SortOrder
    machanics?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    repairHistoryId?: SortOrder
  }

  export type RepairDetailSumOrderByAggregateInput = {
    id?: SortOrder
    repairHistoryId?: SortOrder
  }

  export type washUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type washUserAvgOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
  }

  export type washUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type washUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type washUserSumOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    balance?: SortOrder
    washHistoryId?: SortOrder
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type WashUserListRelationFilter = {
    every?: washUserWhereInput
    some?: washUserWhereInput
    none?: washUserWhereInput
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type washUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WashHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WashHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type WashHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WashHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type WashHistorySumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type TodolistCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodolistAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodolistMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodolistMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodolistSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type UserRelationListRelationFilter = {
    every?: UserRelationWhereInput
    some?: UserRelationWhereInput
    none?: UserRelationWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ReplyListRelationFilter = {
    every?: ReplyWhereInput
    some?: ReplyWhereInput
    none?: ReplyWhereInput
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type DirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserRelationCountOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserRelationAvgOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type UserRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserRelationMinOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserRelationSumOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type PostOnHashTagRelationFilter = {
    is?: PostOnHashTagWhereInput | null
    isNot?: PostOnHashTagWhereInput | null
  }

  export type HashTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    postOnHashTagId?: SortOrder
  }

  export type HashTagAvgOrderByAggregateInput = {
    id?: SortOrder
    postOnHashTagId?: SortOrder
  }

  export type HashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    postOnHashTagId?: SortOrder
  }

  export type HashTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    postOnHashTagId?: SortOrder
  }

  export type HashTagSumOrderByAggregateInput = {
    id?: SortOrder
    postOnHashTagId?: SortOrder
  }

  export type PostOnHashTagListRelationFilter = {
    every?: PostOnHashTagWhereInput
    some?: PostOnHashTagWhereInput
    none?: PostOnHashTagWhereInput
  }

  export type PostOnHashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HashTagListRelationFilter = {
    every?: HashTagWhereInput
    some?: HashTagWhereInput
    none?: HashTagWhereInput
  }

  export type HashTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOnHashTagCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostOnHashTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostOnHashTagMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostOnHashTagMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type PostOnHashTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type ReplyCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    postId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
  }

  export type ReplyAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    postId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
  }

  export type ReplyMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    postId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    userId?: SortOrder
  }

  export type ReplySumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type YoutubeChannelListRelationFilter = {
    every?: YoutubeChannelWhereInput
    some?: YoutubeChannelWhereInput
    none?: YoutubeChannelWhereInput
  }

  export type YoutubeCommentToVideoListRelationFilter = {
    every?: YoutubeCommentToVideoWhereInput
    some?: YoutubeCommentToVideoWhereInput
    none?: YoutubeCommentToVideoWhereInput
  }

  export type YoutubeUserToChannelListRelationFilter = {
    every?: YoutubeUserToChannelWhereInput
    some?: YoutubeUserToChannelWhereInput
    none?: YoutubeUserToChannelWhereInput
  }

  export type YoutubeChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeCommentToVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeUserToChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeRoleCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeRoleMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeVideoListRelationFilter = {
    every?: YoutubeVideoWhereInput
    some?: YoutubeVideoWhereInput
    none?: YoutubeVideoWhereInput
  }

  export type YoutubeVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeReactionCountOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeReactionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeReactionMinOrderByAggregateInput = {
    id?: SortOrder
    reaction?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeReactionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeReactionRelationFilter = {
    is?: YoutubeReactionWhereInput
    isNot?: YoutubeReactionWhereInput
  }

  export type YoutubeChannelRelationFilter = {
    is?: YoutubeChannelWhereInput | null
    isNot?: YoutubeChannelWhereInput | null
  }

  export type YoutubeVideoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    channelId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    channelId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeVideoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    channelId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeVideoSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    youtubeReactionId?: SortOrder
  }

  export type YoutubeUserListRelationFilter = {
    every?: YoutubeUserWhereInput
    some?: YoutubeUserWhereInput
    none?: YoutubeUserWhereInput
  }

  export type YoutubeUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeVideoRelationFilter = {
    is?: YoutubeVideoWhereInput
    isNot?: YoutubeVideoWhereInput
  }

  export type YoutubeUserRelationFilter = {
    is?: YoutubeUserWhereInput
    isNot?: YoutubeUserWhereInput
  }

  export type YoutubeCommentToVideoCountOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    comment?: SortOrder
    commenterId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeCommentToVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    commenterId?: SortOrder
  }

  export type YoutubeCommentToVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    comment?: SortOrder
    commenterId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeCommentToVideoMinOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    comment?: SortOrder
    commenterId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeCommentToVideoSumOrderByAggregateInput = {
    id?: SortOrder
    video?: SortOrder
    commenterId?: SortOrder
  }

  export type YoutubeRoleRelationFilter = {
    is?: YoutubeRoleWhereInput
    isNot?: YoutubeRoleWhereInput
  }

  export type YoutubeUserToChannelCountOrderByAggregateInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserToChannelAvgOrderByAggregateInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
  }

  export type YoutubeUserToChannelMaxOrderByAggregateInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserToChannelMinOrderByAggregateInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type YoutubeUserToChannelSumOrderByAggregateInput = {
    userId?: SortOrder
    channelId?: SortOrder
    roleId?: SortOrder
  }

  export type DewKitchenMenuCreateNestedManyWithoutCategoryKeyInput = {
    create?: XOR<Enumerable<DewKitchenMenuCreateWithoutCategoryKeyInput>, Enumerable<DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>>
    connectOrCreate?: Enumerable<DewKitchenMenuCreateOrConnectWithoutCategoryKeyInput>
    createMany?: DewKitchenMenuCreateManyCategoryKeyInputEnvelope
    connect?: Enumerable<DewKitchenMenuWhereUniqueInput>
  }

  export type DewKitchenMenuUncheckedCreateNestedManyWithoutCategoryKeyInput = {
    create?: XOR<Enumerable<DewKitchenMenuCreateWithoutCategoryKeyInput>, Enumerable<DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>>
    connectOrCreate?: Enumerable<DewKitchenMenuCreateOrConnectWithoutCategoryKeyInput>
    createMany?: DewKitchenMenuCreateManyCategoryKeyInputEnvelope
    connect?: Enumerable<DewKitchenMenuWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DewKitchenMenuUpdateManyWithoutCategoryKeyNestedInput = {
    create?: XOR<Enumerable<DewKitchenMenuCreateWithoutCategoryKeyInput>, Enumerable<DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>>
    connectOrCreate?: Enumerable<DewKitchenMenuCreateOrConnectWithoutCategoryKeyInput>
    upsert?: Enumerable<DewKitchenMenuUpsertWithWhereUniqueWithoutCategoryKeyInput>
    createMany?: DewKitchenMenuCreateManyCategoryKeyInputEnvelope
    set?: Enumerable<DewKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<DewKitchenMenuWhereUniqueInput>
    delete?: Enumerable<DewKitchenMenuWhereUniqueInput>
    connect?: Enumerable<DewKitchenMenuWhereUniqueInput>
    update?: Enumerable<DewKitchenMenuUpdateWithWhereUniqueWithoutCategoryKeyInput>
    updateMany?: Enumerable<DewKitchenMenuUpdateManyWithWhereWithoutCategoryKeyInput>
    deleteMany?: Enumerable<DewKitchenMenuScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DewKitchenMenuUncheckedUpdateManyWithoutCategoryKeyNestedInput = {
    create?: XOR<Enumerable<DewKitchenMenuCreateWithoutCategoryKeyInput>, Enumerable<DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>>
    connectOrCreate?: Enumerable<DewKitchenMenuCreateOrConnectWithoutCategoryKeyInput>
    upsert?: Enumerable<DewKitchenMenuUpsertWithWhereUniqueWithoutCategoryKeyInput>
    createMany?: DewKitchenMenuCreateManyCategoryKeyInputEnvelope
    set?: Enumerable<DewKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<DewKitchenMenuWhereUniqueInput>
    delete?: Enumerable<DewKitchenMenuWhereUniqueInput>
    connect?: Enumerable<DewKitchenMenuWhereUniqueInput>
    update?: Enumerable<DewKitchenMenuUpdateWithWhereUniqueWithoutCategoryKeyInput>
    updateMany?: Enumerable<DewKitchenMenuUpdateManyWithWhereWithoutCategoryKeyInput>
    deleteMany?: Enumerable<DewKitchenMenuScalarWhereInput>
  }

  export type DewKitchenCategoryCreateNestedOneWithoutMenusInput = {
    create?: XOR<DewKitchenCategoryCreateWithoutMenusInput, DewKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: DewKitchenCategoryCreateOrConnectWithoutMenusInput
    connect?: DewKitchenCategoryWhereUniqueInput
  }

  export type DewOrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutMenuInput>, Enumerable<DewOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: DewOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
  }

  export type DewOrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutMenuInput>, Enumerable<DewOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: DewOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DewKitchenCategoryUpdateOneWithoutMenusNestedInput = {
    create?: XOR<DewKitchenCategoryCreateWithoutMenusInput, DewKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: DewKitchenCategoryCreateOrConnectWithoutMenusInput
    upsert?: DewKitchenCategoryUpsertWithoutMenusInput
    disconnect?: boolean
    delete?: boolean
    connect?: DewKitchenCategoryWhereUniqueInput
    update?: XOR<DewKitchenCategoryUpdateWithoutMenusInput, DewKitchenCategoryUncheckedUpdateWithoutMenusInput>
  }

  export type DewOrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutMenuInput>, Enumerable<DewOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<DewOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: DewOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<DewOrderItemWhereUniqueInput>
    disconnect?: Enumerable<DewOrderItemWhereUniqueInput>
    delete?: Enumerable<DewOrderItemWhereUniqueInput>
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
    update?: Enumerable<DewOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<DewOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<DewOrderItemScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DewOrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutMenuInput>, Enumerable<DewOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<DewOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: DewOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<DewOrderItemWhereUniqueInput>
    disconnect?: Enumerable<DewOrderItemWhereUniqueInput>
    delete?: Enumerable<DewOrderItemWhereUniqueInput>
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
    update?: Enumerable<DewOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<DewOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<DewOrderItemScalarWhereInput>
  }

  export type DewOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutOrderInput>, Enumerable<DewOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: DewOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
  }

  export type DewOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutOrderInput>, Enumerable<DewOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: DewOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
  }

  export type DewOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutOrderInput>, Enumerable<DewOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<DewOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: DewOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<DewOrderItemWhereUniqueInput>
    disconnect?: Enumerable<DewOrderItemWhereUniqueInput>
    delete?: Enumerable<DewOrderItemWhereUniqueInput>
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
    update?: Enumerable<DewOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<DewOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<DewOrderItemScalarWhereInput>
  }

  export type DewOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<DewOrderItemCreateWithoutOrderInput>, Enumerable<DewOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<DewOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<DewOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: DewOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<DewOrderItemWhereUniqueInput>
    disconnect?: Enumerable<DewOrderItemWhereUniqueInput>
    delete?: Enumerable<DewOrderItemWhereUniqueInput>
    connect?: Enumerable<DewOrderItemWhereUniqueInput>
    update?: Enumerable<DewOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<DewOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<DewOrderItemScalarWhereInput>
  }

  export type DewKitchenMenuCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<DewKitchenMenuCreateWithoutOrderItemsInput, DewKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: DewKitchenMenuCreateOrConnectWithoutOrderItemsInput
    connect?: DewKitchenMenuWhereUniqueInput
  }

  export type DewKitchenOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<DewKitchenOrderCreateWithoutItemsInput, DewKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DewKitchenOrderCreateOrConnectWithoutItemsInput
    connect?: DewKitchenOrderWhereUniqueInput
  }

  export type DewKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<DewKitchenMenuCreateWithoutOrderItemsInput, DewKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: DewKitchenMenuCreateOrConnectWithoutOrderItemsInput
    upsert?: DewKitchenMenuUpsertWithoutOrderItemsInput
    connect?: DewKitchenMenuWhereUniqueInput
    update?: XOR<DewKitchenMenuUpdateWithoutOrderItemsInput, DewKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
  }

  export type DewKitchenOrderUpdateOneWithoutItemsNestedInput = {
    create?: XOR<DewKitchenOrderCreateWithoutItemsInput, DewKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DewKitchenOrderCreateOrConnectWithoutItemsInput
    upsert?: DewKitchenOrderUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DewKitchenOrderWhereUniqueInput
    update?: XOR<DewKitchenOrderUpdateWithoutItemsInput, DewKitchenOrderUncheckedUpdateWithoutItemsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookExOnAuthorExCreateNestedManyWithoutBookExampleInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutBookExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutBookExampleInput>
    createMany?: BookExOnAuthorExCreateManyBookExampleInputEnvelope
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
  }

  export type BookExOnAuthorExUncheckedCreateNestedManyWithoutBookExampleInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutBookExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutBookExampleInput>
    createMany?: BookExOnAuthorExCreateManyBookExampleInputEnvelope
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
  }

  export type BookExOnAuthorExUpdateManyWithoutBookExampleNestedInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutBookExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutBookExampleInput>
    upsert?: Enumerable<BookExOnAuthorExUpsertWithWhereUniqueWithoutBookExampleInput>
    createMany?: BookExOnAuthorExCreateManyBookExampleInputEnvelope
    set?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    disconnect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    delete?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    update?: Enumerable<BookExOnAuthorExUpdateWithWhereUniqueWithoutBookExampleInput>
    updateMany?: Enumerable<BookExOnAuthorExUpdateManyWithWhereWithoutBookExampleInput>
    deleteMany?: Enumerable<BookExOnAuthorExScalarWhereInput>
  }

  export type BookExOnAuthorExUncheckedUpdateManyWithoutBookExampleNestedInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutBookExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutBookExampleInput>
    upsert?: Enumerable<BookExOnAuthorExUpsertWithWhereUniqueWithoutBookExampleInput>
    createMany?: BookExOnAuthorExCreateManyBookExampleInputEnvelope
    set?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    disconnect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    delete?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    update?: Enumerable<BookExOnAuthorExUpdateWithWhereUniqueWithoutBookExampleInput>
    updateMany?: Enumerable<BookExOnAuthorExUpdateManyWithWhereWithoutBookExampleInput>
    deleteMany?: Enumerable<BookExOnAuthorExScalarWhereInput>
  }

  export type BookExOnAuthorExCreateNestedManyWithoutAuthorExampleInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutAuthorExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutAuthorExampleInput>
    createMany?: BookExOnAuthorExCreateManyAuthorExampleInputEnvelope
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
  }

  export type BookExOnAuthorExUncheckedCreateNestedManyWithoutAuthorExampleInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutAuthorExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutAuthorExampleInput>
    createMany?: BookExOnAuthorExCreateManyAuthorExampleInputEnvelope
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
  }

  export type BookExOnAuthorExUpdateManyWithoutAuthorExampleNestedInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutAuthorExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutAuthorExampleInput>
    upsert?: Enumerable<BookExOnAuthorExUpsertWithWhereUniqueWithoutAuthorExampleInput>
    createMany?: BookExOnAuthorExCreateManyAuthorExampleInputEnvelope
    set?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    disconnect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    delete?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    update?: Enumerable<BookExOnAuthorExUpdateWithWhereUniqueWithoutAuthorExampleInput>
    updateMany?: Enumerable<BookExOnAuthorExUpdateManyWithWhereWithoutAuthorExampleInput>
    deleteMany?: Enumerable<BookExOnAuthorExScalarWhereInput>
  }

  export type BookExOnAuthorExUncheckedUpdateManyWithoutAuthorExampleNestedInput = {
    create?: XOR<Enumerable<BookExOnAuthorExCreateWithoutAuthorExampleInput>, Enumerable<BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>>
    connectOrCreate?: Enumerable<BookExOnAuthorExCreateOrConnectWithoutAuthorExampleInput>
    upsert?: Enumerable<BookExOnAuthorExUpsertWithWhereUniqueWithoutAuthorExampleInput>
    createMany?: BookExOnAuthorExCreateManyAuthorExampleInputEnvelope
    set?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    disconnect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    delete?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    connect?: Enumerable<BookExOnAuthorExWhereUniqueInput>
    update?: Enumerable<BookExOnAuthorExUpdateWithWhereUniqueWithoutAuthorExampleInput>
    updateMany?: Enumerable<BookExOnAuthorExUpdateManyWithWhereWithoutAuthorExampleInput>
    deleteMany?: Enumerable<BookExOnAuthorExScalarWhereInput>
  }

  export type BookExCreateNestedOneWithoutBookExampleOnAuthorExampleInput = {
    create?: XOR<BookExCreateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
    connectOrCreate?: BookExCreateOrConnectWithoutBookExampleOnAuthorExampleInput
    connect?: BookExWhereUniqueInput
  }

  export type AuthorExCreateNestedOneWithoutBookExampleOnAuthorExampleInput = {
    create?: XOR<AuthorExCreateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
    connectOrCreate?: AuthorExCreateOrConnectWithoutBookExampleOnAuthorExampleInput
    connect?: AuthorExWhereUniqueInput
  }

  export type BookExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput = {
    create?: XOR<BookExCreateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
    connectOrCreate?: BookExCreateOrConnectWithoutBookExampleOnAuthorExampleInput
    upsert?: BookExUpsertWithoutBookExampleOnAuthorExampleInput
    connect?: BookExWhereUniqueInput
    update?: XOR<BookExUpdateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput>
  }

  export type AuthorExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput = {
    create?: XOR<AuthorExCreateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
    connectOrCreate?: AuthorExCreateOrConnectWithoutBookExampleOnAuthorExampleInput
    upsert?: AuthorExUpsertWithoutBookExampleOnAuthorExampleInput
    connect?: AuthorExWhereUniqueInput
    update?: XOR<AuthorExUpdateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput>
  }

  export type ActorsCreateNestedManyWithoutSeriesTvInput = {
    create?: XOR<Enumerable<ActorsCreateWithoutSeriesTvInput>, Enumerable<ActorsUncheckedCreateWithoutSeriesTvInput>>
    connectOrCreate?: Enumerable<ActorsCreateOrConnectWithoutSeriesTvInput>
    connect?: Enumerable<ActorsWhereUniqueInput>
  }

  export type ActorsUncheckedCreateNestedManyWithoutSeriesTvInput = {
    create?: XOR<Enumerable<ActorsCreateWithoutSeriesTvInput>, Enumerable<ActorsUncheckedCreateWithoutSeriesTvInput>>
    connectOrCreate?: Enumerable<ActorsCreateOrConnectWithoutSeriesTvInput>
    connect?: Enumerable<ActorsWhereUniqueInput>
  }

  export type ActorsUpdateManyWithoutSeriesTvNestedInput = {
    create?: XOR<Enumerable<ActorsCreateWithoutSeriesTvInput>, Enumerable<ActorsUncheckedCreateWithoutSeriesTvInput>>
    connectOrCreate?: Enumerable<ActorsCreateOrConnectWithoutSeriesTvInput>
    upsert?: Enumerable<ActorsUpsertWithWhereUniqueWithoutSeriesTvInput>
    set?: Enumerable<ActorsWhereUniqueInput>
    disconnect?: Enumerable<ActorsWhereUniqueInput>
    delete?: Enumerable<ActorsWhereUniqueInput>
    connect?: Enumerable<ActorsWhereUniqueInput>
    update?: Enumerable<ActorsUpdateWithWhereUniqueWithoutSeriesTvInput>
    updateMany?: Enumerable<ActorsUpdateManyWithWhereWithoutSeriesTvInput>
    deleteMany?: Enumerable<ActorsScalarWhereInput>
  }

  export type ActorsUncheckedUpdateManyWithoutSeriesTvNestedInput = {
    create?: XOR<Enumerable<ActorsCreateWithoutSeriesTvInput>, Enumerable<ActorsUncheckedCreateWithoutSeriesTvInput>>
    connectOrCreate?: Enumerable<ActorsCreateOrConnectWithoutSeriesTvInput>
    upsert?: Enumerable<ActorsUpsertWithWhereUniqueWithoutSeriesTvInput>
    set?: Enumerable<ActorsWhereUniqueInput>
    disconnect?: Enumerable<ActorsWhereUniqueInput>
    delete?: Enumerable<ActorsWhereUniqueInput>
    connect?: Enumerable<ActorsWhereUniqueInput>
    update?: Enumerable<ActorsUpdateWithWhereUniqueWithoutSeriesTvInput>
    updateMany?: Enumerable<ActorsUpdateManyWithWhereWithoutSeriesTvInput>
    deleteMany?: Enumerable<ActorsScalarWhereInput>
  }

  export type SeriesTvCreateNestedManyWithoutActorsInput = {
    create?: XOR<Enumerable<SeriesTvCreateWithoutActorsInput>, Enumerable<SeriesTvUncheckedCreateWithoutActorsInput>>
    connectOrCreate?: Enumerable<SeriesTvCreateOrConnectWithoutActorsInput>
    connect?: Enumerable<SeriesTvWhereUniqueInput>
  }

  export type SeriesTvUncheckedCreateNestedManyWithoutActorsInput = {
    create?: XOR<Enumerable<SeriesTvCreateWithoutActorsInput>, Enumerable<SeriesTvUncheckedCreateWithoutActorsInput>>
    connectOrCreate?: Enumerable<SeriesTvCreateOrConnectWithoutActorsInput>
    connect?: Enumerable<SeriesTvWhereUniqueInput>
  }

  export type SeriesTvUpdateManyWithoutActorsNestedInput = {
    create?: XOR<Enumerable<SeriesTvCreateWithoutActorsInput>, Enumerable<SeriesTvUncheckedCreateWithoutActorsInput>>
    connectOrCreate?: Enumerable<SeriesTvCreateOrConnectWithoutActorsInput>
    upsert?: Enumerable<SeriesTvUpsertWithWhereUniqueWithoutActorsInput>
    set?: Enumerable<SeriesTvWhereUniqueInput>
    disconnect?: Enumerable<SeriesTvWhereUniqueInput>
    delete?: Enumerable<SeriesTvWhereUniqueInput>
    connect?: Enumerable<SeriesTvWhereUniqueInput>
    update?: Enumerable<SeriesTvUpdateWithWhereUniqueWithoutActorsInput>
    updateMany?: Enumerable<SeriesTvUpdateManyWithWhereWithoutActorsInput>
    deleteMany?: Enumerable<SeriesTvScalarWhereInput>
  }

  export type SeriesTvUncheckedUpdateManyWithoutActorsNestedInput = {
    create?: XOR<Enumerable<SeriesTvCreateWithoutActorsInput>, Enumerable<SeriesTvUncheckedCreateWithoutActorsInput>>
    connectOrCreate?: Enumerable<SeriesTvCreateOrConnectWithoutActorsInput>
    upsert?: Enumerable<SeriesTvUpsertWithWhereUniqueWithoutActorsInput>
    set?: Enumerable<SeriesTvWhereUniqueInput>
    disconnect?: Enumerable<SeriesTvWhereUniqueInput>
    delete?: Enumerable<SeriesTvWhereUniqueInput>
    connect?: Enumerable<SeriesTvWhereUniqueInput>
    update?: Enumerable<SeriesTvUpdateWithWhereUniqueWithoutActorsInput>
    updateMany?: Enumerable<SeriesTvUpdateManyWithWhereWithoutActorsInput>
    deleteMany?: Enumerable<SeriesTvScalarWhereInput>
  }

  export type KadCreateNestedOneWithoutDewInput = {
    create?: XOR<KadCreateWithoutDewInput, KadUncheckedCreateWithoutDewInput>
    connectOrCreate?: KadCreateOrConnectWithoutDewInput
    connect?: KadWhereUniqueInput
  }

  export type KadUpdateOneRequiredWithoutDewNestedInput = {
    create?: XOR<KadCreateWithoutDewInput, KadUncheckedCreateWithoutDewInput>
    connectOrCreate?: KadCreateOrConnectWithoutDewInput
    upsert?: KadUpsertWithoutDewInput
    connect?: KadWhereUniqueInput
    update?: XOR<KadUpdateWithoutDewInput, KadUncheckedUpdateWithoutDewInput>
  }

  export type DewCreateNestedOneWithoutKadInput = {
    create?: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
    connectOrCreate?: DewCreateOrConnectWithoutKadInput
    connect?: DewWhereUniqueInput
  }

  export type DewUncheckedCreateNestedOneWithoutKadInput = {
    create?: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
    connectOrCreate?: DewCreateOrConnectWithoutKadInput
    connect?: DewWhereUniqueInput
  }

  export type DewUpdateOneWithoutKadNestedInput = {
    create?: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
    connectOrCreate?: DewCreateOrConnectWithoutKadInput
    upsert?: DewUpsertWithoutKadInput
    disconnect?: boolean
    delete?: boolean
    connect?: DewWhereUniqueInput
    update?: XOR<DewUpdateWithoutKadInput, DewUncheckedUpdateWithoutKadInput>
  }

  export type DewUncheckedUpdateOneWithoutKadNestedInput = {
    create?: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
    connectOrCreate?: DewCreateOrConnectWithoutKadInput
    upsert?: DewUpsertWithoutKadInput
    disconnect?: boolean
    delete?: boolean
    connect?: DewWhereUniqueInput
    update?: XOR<DewUpdateWithoutKadInput, DewUncheckedUpdateWithoutKadInput>
  }

  export type QuizeQuestionCreateNestedManyWithoutQuizeCategoryInput = {
    create?: XOR<Enumerable<QuizeQuestionCreateWithoutQuizeCategoryInput>, Enumerable<QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>>
    connectOrCreate?: Enumerable<QuizeQuestionCreateOrConnectWithoutQuizeCategoryInput>
    createMany?: QuizeQuestionCreateManyQuizeCategoryInputEnvelope
    connect?: Enumerable<QuizeQuestionWhereUniqueInput>
  }

  export type QuizeQuestionUncheckedCreateNestedManyWithoutQuizeCategoryInput = {
    create?: XOR<Enumerable<QuizeQuestionCreateWithoutQuizeCategoryInput>, Enumerable<QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>>
    connectOrCreate?: Enumerable<QuizeQuestionCreateOrConnectWithoutQuizeCategoryInput>
    createMany?: QuizeQuestionCreateManyQuizeCategoryInputEnvelope
    connect?: Enumerable<QuizeQuestionWhereUniqueInput>
  }

  export type QuizeQuestionUpdateManyWithoutQuizeCategoryNestedInput = {
    create?: XOR<Enumerable<QuizeQuestionCreateWithoutQuizeCategoryInput>, Enumerable<QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>>
    connectOrCreate?: Enumerable<QuizeQuestionCreateOrConnectWithoutQuizeCategoryInput>
    upsert?: Enumerable<QuizeQuestionUpsertWithWhereUniqueWithoutQuizeCategoryInput>
    createMany?: QuizeQuestionCreateManyQuizeCategoryInputEnvelope
    set?: Enumerable<QuizeQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizeQuestionWhereUniqueInput>
    delete?: Enumerable<QuizeQuestionWhereUniqueInput>
    connect?: Enumerable<QuizeQuestionWhereUniqueInput>
    update?: Enumerable<QuizeQuestionUpdateWithWhereUniqueWithoutQuizeCategoryInput>
    updateMany?: Enumerable<QuizeQuestionUpdateManyWithWhereWithoutQuizeCategoryInput>
    deleteMany?: Enumerable<QuizeQuestionScalarWhereInput>
  }

  export type QuizeQuestionUncheckedUpdateManyWithoutQuizeCategoryNestedInput = {
    create?: XOR<Enumerable<QuizeQuestionCreateWithoutQuizeCategoryInput>, Enumerable<QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>>
    connectOrCreate?: Enumerable<QuizeQuestionCreateOrConnectWithoutQuizeCategoryInput>
    upsert?: Enumerable<QuizeQuestionUpsertWithWhereUniqueWithoutQuizeCategoryInput>
    createMany?: QuizeQuestionCreateManyQuizeCategoryInputEnvelope
    set?: Enumerable<QuizeQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizeQuestionWhereUniqueInput>
    delete?: Enumerable<QuizeQuestionWhereUniqueInput>
    connect?: Enumerable<QuizeQuestionWhereUniqueInput>
    update?: Enumerable<QuizeQuestionUpdateWithWhereUniqueWithoutQuizeCategoryInput>
    updateMany?: Enumerable<QuizeQuestionUpdateManyWithWhereWithoutQuizeCategoryInput>
    deleteMany?: Enumerable<QuizeQuestionScalarWhereInput>
  }

  export type QuizeCategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizeCategoryCreateWithoutQuestionsInput, QuizeCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizeCategoryCreateOrConnectWithoutQuestionsInput
    connect?: QuizeCategoryWhereUniqueInput
  }

  export type QuizeChoiceCreateNestedManyWithoutQuizeQuestionInput = {
    create?: XOR<Enumerable<QuizeChoiceCreateWithoutQuizeQuestionInput>, Enumerable<QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>>
    connectOrCreate?: Enumerable<QuizeChoiceCreateOrConnectWithoutQuizeQuestionInput>
    createMany?: QuizeChoiceCreateManyQuizeQuestionInputEnvelope
    connect?: Enumerable<QuizeChoiceWhereUniqueInput>
  }

  export type QuizeAnswerCreateNestedOneWithoutQuizeQuestionInput = {
    create?: XOR<QuizeAnswerCreateWithoutQuizeQuestionInput, QuizeAnswerUncheckedCreateWithoutQuizeQuestionInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutQuizeQuestionInput
    connect?: QuizeAnswerWhereUniqueInput
  }

  export type QuizeGameRoundCreateNestedOneWithoutQuestionInput = {
    create?: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutQuestionInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeChoiceUncheckedCreateNestedManyWithoutQuizeQuestionInput = {
    create?: XOR<Enumerable<QuizeChoiceCreateWithoutQuizeQuestionInput>, Enumerable<QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>>
    connectOrCreate?: Enumerable<QuizeChoiceCreateOrConnectWithoutQuizeQuestionInput>
    createMany?: QuizeChoiceCreateManyQuizeQuestionInputEnvelope
    connect?: Enumerable<QuizeChoiceWhereUniqueInput>
  }

  export type QuizeGameRoundUncheckedCreateNestedOneWithoutQuestionInput = {
    create?: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutQuestionInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeCategoryUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<QuizeCategoryCreateWithoutQuestionsInput, QuizeCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizeCategoryCreateOrConnectWithoutQuestionsInput
    upsert?: QuizeCategoryUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeCategoryWhereUniqueInput
    update?: XOR<QuizeCategoryUpdateWithoutQuestionsInput, QuizeCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizeChoiceUpdateManyWithoutQuizeQuestionNestedInput = {
    create?: XOR<Enumerable<QuizeChoiceCreateWithoutQuizeQuestionInput>, Enumerable<QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>>
    connectOrCreate?: Enumerable<QuizeChoiceCreateOrConnectWithoutQuizeQuestionInput>
    upsert?: Enumerable<QuizeChoiceUpsertWithWhereUniqueWithoutQuizeQuestionInput>
    createMany?: QuizeChoiceCreateManyQuizeQuestionInputEnvelope
    set?: Enumerable<QuizeChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizeChoiceWhereUniqueInput>
    delete?: Enumerable<QuizeChoiceWhereUniqueInput>
    connect?: Enumerable<QuizeChoiceWhereUniqueInput>
    update?: Enumerable<QuizeChoiceUpdateWithWhereUniqueWithoutQuizeQuestionInput>
    updateMany?: Enumerable<QuizeChoiceUpdateManyWithWhereWithoutQuizeQuestionInput>
    deleteMany?: Enumerable<QuizeChoiceScalarWhereInput>
  }

  export type QuizeAnswerUpdateOneWithoutQuizeQuestionNestedInput = {
    create?: XOR<QuizeAnswerCreateWithoutQuizeQuestionInput, QuizeAnswerUncheckedCreateWithoutQuizeQuestionInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutQuizeQuestionInput
    upsert?: QuizeAnswerUpsertWithoutQuizeQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeAnswerWhereUniqueInput
    update?: XOR<QuizeAnswerUpdateWithoutQuizeQuestionInput, QuizeAnswerUncheckedUpdateWithoutQuizeQuestionInput>
  }

  export type QuizeGameRoundUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutQuestionInput
    upsert?: QuizeGameRoundUpsertWithoutQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutQuestionInput, QuizeGameRoundUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizeChoiceUncheckedUpdateManyWithoutQuizeQuestionNestedInput = {
    create?: XOR<Enumerable<QuizeChoiceCreateWithoutQuizeQuestionInput>, Enumerable<QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>>
    connectOrCreate?: Enumerable<QuizeChoiceCreateOrConnectWithoutQuizeQuestionInput>
    upsert?: Enumerable<QuizeChoiceUpsertWithWhereUniqueWithoutQuizeQuestionInput>
    createMany?: QuizeChoiceCreateManyQuizeQuestionInputEnvelope
    set?: Enumerable<QuizeChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizeChoiceWhereUniqueInput>
    delete?: Enumerable<QuizeChoiceWhereUniqueInput>
    connect?: Enumerable<QuizeChoiceWhereUniqueInput>
    update?: Enumerable<QuizeChoiceUpdateWithWhereUniqueWithoutQuizeQuestionInput>
    updateMany?: Enumerable<QuizeChoiceUpdateManyWithWhereWithoutQuizeQuestionInput>
    deleteMany?: Enumerable<QuizeChoiceScalarWhereInput>
  }

  export type QuizeGameRoundUncheckedUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutQuestionInput
    upsert?: QuizeGameRoundUpsertWithoutQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutQuestionInput, QuizeGameRoundUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizeQuestionCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuizeQuestionCreateWithoutChoicesInput, QuizeQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutChoicesInput
    connect?: QuizeQuestionWhereUniqueInput
  }

  export type QuizeAnswerCreateNestedOneWithoutChoiceInput = {
    create?: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutChoiceInput
    connect?: QuizeAnswerWhereUniqueInput
  }

  export type QuizeGameRoundCreateNestedOneWithoutChoiceInput = {
    create?: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutChoiceInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeAnswerUncheckedCreateNestedOneWithoutChoiceInput = {
    create?: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutChoiceInput
    connect?: QuizeAnswerWhereUniqueInput
  }

  export type QuizeGameRoundUncheckedCreateNestedOneWithoutChoiceInput = {
    create?: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutChoiceInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeQuestionUpdateOneWithoutChoicesNestedInput = {
    create?: XOR<QuizeQuestionCreateWithoutChoicesInput, QuizeQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutChoicesInput
    upsert?: QuizeQuestionUpsertWithoutChoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeQuestionWhereUniqueInput
    update?: XOR<QuizeQuestionUpdateWithoutChoicesInput, QuizeQuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type QuizeAnswerUpdateOneWithoutChoiceNestedInput = {
    create?: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutChoiceInput
    upsert?: QuizeAnswerUpsertWithoutChoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeAnswerWhereUniqueInput
    update?: XOR<QuizeAnswerUpdateWithoutChoiceInput, QuizeAnswerUncheckedUpdateWithoutChoiceInput>
  }

  export type QuizeGameRoundUpdateOneWithoutChoiceNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutChoiceInput
    upsert?: QuizeGameRoundUpsertWithoutChoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutChoiceInput, QuizeGameRoundUncheckedUpdateWithoutChoiceInput>
  }

  export type QuizeAnswerUncheckedUpdateOneWithoutChoiceNestedInput = {
    create?: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutChoiceInput
    upsert?: QuizeAnswerUpsertWithoutChoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeAnswerWhereUniqueInput
    update?: XOR<QuizeAnswerUpdateWithoutChoiceInput, QuizeAnswerUncheckedUpdateWithoutChoiceInput>
  }

  export type QuizeGameRoundUncheckedUpdateOneWithoutChoiceNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutChoiceInput
    upsert?: QuizeGameRoundUpsertWithoutChoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutChoiceInput, QuizeGameRoundUncheckedUpdateWithoutChoiceInput>
  }

  export type QuizeQuestionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutAnswerInput
    connect?: QuizeQuestionWhereUniqueInput
  }

  export type QuizeChoiceCreateNestedOneWithoutQuizeAnswerInput = {
    create?: XOR<QuizeChoiceCreateWithoutQuizeAnswerInput, QuizeChoiceUncheckedCreateWithoutQuizeAnswerInput>
    connectOrCreate?: QuizeChoiceCreateOrConnectWithoutQuizeAnswerInput
    connect?: QuizeChoiceWhereUniqueInput
  }

  export type QuizeGameRoundCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutAnswerInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeQuestionUncheckedCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutAnswerInput
    connect?: QuizeQuestionWhereUniqueInput
  }

  export type QuizeGameRoundUncheckedCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutAnswerInput
    connect?: QuizeGameRoundWhereUniqueInput
  }

  export type QuizeQuestionUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutAnswerInput
    upsert?: QuizeQuestionUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeQuestionWhereUniqueInput
    update?: XOR<QuizeQuestionUpdateWithoutAnswerInput, QuizeQuestionUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizeChoiceUpdateOneRequiredWithoutQuizeAnswerNestedInput = {
    create?: XOR<QuizeChoiceCreateWithoutQuizeAnswerInput, QuizeChoiceUncheckedCreateWithoutQuizeAnswerInput>
    connectOrCreate?: QuizeChoiceCreateOrConnectWithoutQuizeAnswerInput
    upsert?: QuizeChoiceUpsertWithoutQuizeAnswerInput
    connect?: QuizeChoiceWhereUniqueInput
    update?: XOR<QuizeChoiceUpdateWithoutQuizeAnswerInput, QuizeChoiceUncheckedUpdateWithoutQuizeAnswerInput>
  }

  export type QuizeGameRoundUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutAnswerInput
    upsert?: QuizeGameRoundUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutAnswerInput, QuizeGameRoundUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizeQuestionUncheckedUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutAnswerInput
    upsert?: QuizeQuestionUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeQuestionWhereUniqueInput
    update?: XOR<QuizeQuestionUpdateWithoutAnswerInput, QuizeQuestionUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizeGameRoundUncheckedUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizeGameRoundCreateOrConnectWithoutAnswerInput
    upsert?: QuizeGameRoundUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizeGameRoundWhereUniqueInput
    update?: XOR<QuizeGameRoundUpdateWithoutAnswerInput, QuizeGameRoundUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizeAnswerCreateNestedOneWithoutRoundInput = {
    create?: XOR<QuizeAnswerCreateWithoutRoundInput, QuizeAnswerUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutRoundInput
    connect?: QuizeAnswerWhereUniqueInput
  }

  export type QuizeQuestionCreateNestedOneWithoutRoundInput = {
    create?: XOR<QuizeQuestionCreateWithoutRoundInput, QuizeQuestionUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutRoundInput
    connect?: QuizeQuestionWhereUniqueInput
  }

  export type QuizeChoiceCreateNestedOneWithoutRoundInput = {
    create?: XOR<QuizeChoiceCreateWithoutRoundInput, QuizeChoiceUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeChoiceCreateOrConnectWithoutRoundInput
    connect?: QuizeChoiceWhereUniqueInput
  }

  export type QuizeAnswerUpdateOneRequiredWithoutRoundNestedInput = {
    create?: XOR<QuizeAnswerCreateWithoutRoundInput, QuizeAnswerUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeAnswerCreateOrConnectWithoutRoundInput
    upsert?: QuizeAnswerUpsertWithoutRoundInput
    connect?: QuizeAnswerWhereUniqueInput
    update?: XOR<QuizeAnswerUpdateWithoutRoundInput, QuizeAnswerUncheckedUpdateWithoutRoundInput>
  }

  export type QuizeQuestionUpdateOneRequiredWithoutRoundNestedInput = {
    create?: XOR<QuizeQuestionCreateWithoutRoundInput, QuizeQuestionUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeQuestionCreateOrConnectWithoutRoundInput
    upsert?: QuizeQuestionUpsertWithoutRoundInput
    connect?: QuizeQuestionWhereUniqueInput
    update?: XOR<QuizeQuestionUpdateWithoutRoundInput, QuizeQuestionUncheckedUpdateWithoutRoundInput>
  }

  export type QuizeChoiceUpdateOneRequiredWithoutRoundNestedInput = {
    create?: XOR<QuizeChoiceCreateWithoutRoundInput, QuizeChoiceUncheckedCreateWithoutRoundInput>
    connectOrCreate?: QuizeChoiceCreateOrConnectWithoutRoundInput
    upsert?: QuizeChoiceUpsertWithoutRoundInput
    connect?: QuizeChoiceWhereUniqueInput
    update?: XOR<QuizeChoiceUpdateWithoutRoundInput, QuizeChoiceUncheckedUpdateWithoutRoundInput>
  }

  export type BranchCreateNestedManyWithoutMainCompanyInput = {
    create?: XOR<Enumerable<BranchCreateWithoutMainCompanyInput>, Enumerable<BranchUncheckedCreateWithoutMainCompanyInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutMainCompanyInput>
    createMany?: BranchCreateManyMainCompanyInputEnvelope
    connect?: Enumerable<BranchWhereUniqueInput>
  }

  export type BranchUncheckedCreateNestedManyWithoutMainCompanyInput = {
    create?: XOR<Enumerable<BranchCreateWithoutMainCompanyInput>, Enumerable<BranchUncheckedCreateWithoutMainCompanyInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutMainCompanyInput>
    createMany?: BranchCreateManyMainCompanyInputEnvelope
    connect?: Enumerable<BranchWhereUniqueInput>
  }

  export type BranchUpdateManyWithoutMainCompanyNestedInput = {
    create?: XOR<Enumerable<BranchCreateWithoutMainCompanyInput>, Enumerable<BranchUncheckedCreateWithoutMainCompanyInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutMainCompanyInput>
    upsert?: Enumerable<BranchUpsertWithWhereUniqueWithoutMainCompanyInput>
    createMany?: BranchCreateManyMainCompanyInputEnvelope
    set?: Enumerable<BranchWhereUniqueInput>
    disconnect?: Enumerable<BranchWhereUniqueInput>
    delete?: Enumerable<BranchWhereUniqueInput>
    connect?: Enumerable<BranchWhereUniqueInput>
    update?: Enumerable<BranchUpdateWithWhereUniqueWithoutMainCompanyInput>
    updateMany?: Enumerable<BranchUpdateManyWithWhereWithoutMainCompanyInput>
    deleteMany?: Enumerable<BranchScalarWhereInput>
  }

  export type BranchUncheckedUpdateManyWithoutMainCompanyNestedInput = {
    create?: XOR<Enumerable<BranchCreateWithoutMainCompanyInput>, Enumerable<BranchUncheckedCreateWithoutMainCompanyInput>>
    connectOrCreate?: Enumerable<BranchCreateOrConnectWithoutMainCompanyInput>
    upsert?: Enumerable<BranchUpsertWithWhereUniqueWithoutMainCompanyInput>
    createMany?: BranchCreateManyMainCompanyInputEnvelope
    set?: Enumerable<BranchWhereUniqueInput>
    disconnect?: Enumerable<BranchWhereUniqueInput>
    delete?: Enumerable<BranchWhereUniqueInput>
    connect?: Enumerable<BranchWhereUniqueInput>
    update?: Enumerable<BranchUpdateWithWhereUniqueWithoutMainCompanyInput>
    updateMany?: Enumerable<BranchUpdateManyWithWhereWithoutMainCompanyInput>
    deleteMany?: Enumerable<BranchScalarWhereInput>
  }

  export type MachineCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<MachineCreateWithoutBranchInput>, Enumerable<MachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutBranchInput>
    createMany?: MachineCreateManyBranchInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type MainCompanyCreateNestedOneWithoutBranchIdsInput = {
    create?: XOR<MainCompanyCreateWithoutBranchIdsInput, MainCompanyUncheckedCreateWithoutBranchIdsInput>
    connectOrCreate?: MainCompanyCreateOrConnectWithoutBranchIdsInput
    connect?: MainCompanyWhereUniqueInput
  }

  export type MachineUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<MachineCreateWithoutBranchInput>, Enumerable<MachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutBranchInput>
    createMany?: MachineCreateManyBranchInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type MachineUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutBranchInput>, Enumerable<MachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: MachineCreateManyBranchInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type MainCompanyUpdateOneWithoutBranchIdsNestedInput = {
    create?: XOR<MainCompanyCreateWithoutBranchIdsInput, MainCompanyUncheckedCreateWithoutBranchIdsInput>
    connectOrCreate?: MainCompanyCreateOrConnectWithoutBranchIdsInput
    upsert?: MainCompanyUpsertWithoutBranchIdsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MainCompanyWhereUniqueInput
    update?: XOR<MainCompanyUpdateWithoutBranchIdsInput, MainCompanyUncheckedUpdateWithoutBranchIdsInput>
  }

  export type MachineUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutBranchInput>, Enumerable<MachineUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: MachineCreateManyBranchInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type BranchCreateNestedOneWithoutMachinesInput = {
    create?: XOR<BranchCreateWithoutMachinesInput, BranchUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMachinesInput
    connect?: BranchWhereUniqueInput
  }

  export type RepairHistoryCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutMachineInput>, Enumerable<RepairHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutMachineInput>
    createMany?: RepairHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
  }

  export type WashHistoryCreateNestedOneWithoutMachinesInput = {
    create?: XOR<WashHistoryCreateWithoutMachinesInput, WashHistoryUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutMachinesInput
    connect?: WashHistoryWhereUniqueInput
  }

  export type MachineOnProgramCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutMachineInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutMachineInput>
    createMany?: MachineOnProgramCreateManyMachineInputEnvelope
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
  }

  export type RepairHistoryUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutMachineInput>, Enumerable<RepairHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutMachineInput>
    createMany?: RepairHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
  }

  export type MachineOnProgramUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutMachineInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutMachineInput>
    createMany?: MachineOnProgramCreateManyMachineInputEnvelope
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
  }

  export type BranchUpdateOneWithoutMachinesNestedInput = {
    create?: XOR<BranchCreateWithoutMachinesInput, BranchUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutMachinesInput
    upsert?: BranchUpsertWithoutMachinesInput
    disconnect?: boolean
    delete?: boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<BranchUpdateWithoutMachinesInput, BranchUncheckedUpdateWithoutMachinesInput>
  }

  export type RepairHistoryUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutMachineInput>, Enumerable<RepairHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<RepairHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: RepairHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<RepairHistoryWhereUniqueInput>
    disconnect?: Enumerable<RepairHistoryWhereUniqueInput>
    delete?: Enumerable<RepairHistoryWhereUniqueInput>
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
    update?: Enumerable<RepairHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<RepairHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<RepairHistoryScalarWhereInput>
  }

  export type WashHistoryUpdateOneWithoutMachinesNestedInput = {
    create?: XOR<WashHistoryCreateWithoutMachinesInput, WashHistoryUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutMachinesInput
    upsert?: WashHistoryUpsertWithoutMachinesInput
    disconnect?: boolean
    delete?: boolean
    connect?: WashHistoryWhereUniqueInput
    update?: XOR<WashHistoryUpdateWithoutMachinesInput, WashHistoryUncheckedUpdateWithoutMachinesInput>
  }

  export type MachineOnProgramUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutMachineInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<MachineOnProgramUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: MachineOnProgramCreateManyMachineInputEnvelope
    set?: Enumerable<MachineOnProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineOnProgramWhereUniqueInput>
    delete?: Enumerable<MachineOnProgramWhereUniqueInput>
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
    update?: Enumerable<MachineOnProgramUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<MachineOnProgramUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<MachineOnProgramScalarWhereInput>
  }

  export type RepairHistoryUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutMachineInput>, Enumerable<RepairHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<RepairHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: RepairHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<RepairHistoryWhereUniqueInput>
    disconnect?: Enumerable<RepairHistoryWhereUniqueInput>
    delete?: Enumerable<RepairHistoryWhereUniqueInput>
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
    update?: Enumerable<RepairHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<RepairHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<RepairHistoryScalarWhereInput>
  }

  export type MachineOnProgramUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutMachineInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<MachineOnProgramUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: MachineOnProgramCreateManyMachineInputEnvelope
    set?: Enumerable<MachineOnProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineOnProgramWhereUniqueInput>
    delete?: Enumerable<MachineOnProgramWhereUniqueInput>
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
    update?: Enumerable<MachineOnProgramUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<MachineOnProgramUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<MachineOnProgramScalarWhereInput>
  }

  export type ProcessTypeCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<ProcessTypeCreateWithoutProgramInput>, Enumerable<ProcessTypeUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<ProcessTypeCreateOrConnectWithoutProgramInput>
    createMany?: ProcessTypeCreateManyProgramInputEnvelope
    connect?: Enumerable<ProcessTypeWhereUniqueInput>
  }

  export type WashHistoryCreateNestedOneWithoutProgramsInput = {
    create?: XOR<WashHistoryCreateWithoutProgramsInput, WashHistoryUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutProgramsInput
    connect?: WashHistoryWhereUniqueInput
  }

  export type MachineOnProgramCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutProgramInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutProgramInput>
    createMany?: MachineOnProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
  }

  export type ProcessTypeUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<ProcessTypeCreateWithoutProgramInput>, Enumerable<ProcessTypeUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<ProcessTypeCreateOrConnectWithoutProgramInput>
    createMany?: ProcessTypeCreateManyProgramInputEnvelope
    connect?: Enumerable<ProcessTypeWhereUniqueInput>
  }

  export type MachineOnProgramUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutProgramInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutProgramInput>
    createMany?: MachineOnProgramCreateManyProgramInputEnvelope
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
  }

  export type ProcessTypeUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<ProcessTypeCreateWithoutProgramInput>, Enumerable<ProcessTypeUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<ProcessTypeCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<ProcessTypeUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: ProcessTypeCreateManyProgramInputEnvelope
    set?: Enumerable<ProcessTypeWhereUniqueInput>
    disconnect?: Enumerable<ProcessTypeWhereUniqueInput>
    delete?: Enumerable<ProcessTypeWhereUniqueInput>
    connect?: Enumerable<ProcessTypeWhereUniqueInput>
    update?: Enumerable<ProcessTypeUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<ProcessTypeUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<ProcessTypeScalarWhereInput>
  }

  export type WashHistoryUpdateOneWithoutProgramsNestedInput = {
    create?: XOR<WashHistoryCreateWithoutProgramsInput, WashHistoryUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutProgramsInput
    upsert?: WashHistoryUpsertWithoutProgramsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WashHistoryWhereUniqueInput
    update?: XOR<WashHistoryUpdateWithoutProgramsInput, WashHistoryUncheckedUpdateWithoutProgramsInput>
  }

  export type MachineOnProgramUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutProgramInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MachineOnProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MachineOnProgramCreateManyProgramInputEnvelope
    set?: Enumerable<MachineOnProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineOnProgramWhereUniqueInput>
    delete?: Enumerable<MachineOnProgramWhereUniqueInput>
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
    update?: Enumerable<MachineOnProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MachineOnProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MachineOnProgramScalarWhereInput>
  }

  export type ProcessTypeUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<ProcessTypeCreateWithoutProgramInput>, Enumerable<ProcessTypeUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<ProcessTypeCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<ProcessTypeUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: ProcessTypeCreateManyProgramInputEnvelope
    set?: Enumerable<ProcessTypeWhereUniqueInput>
    disconnect?: Enumerable<ProcessTypeWhereUniqueInput>
    delete?: Enumerable<ProcessTypeWhereUniqueInput>
    connect?: Enumerable<ProcessTypeWhereUniqueInput>
    update?: Enumerable<ProcessTypeUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<ProcessTypeUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<ProcessTypeScalarWhereInput>
  }

  export type MachineOnProgramUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MachineOnProgramCreateWithoutProgramInput>, Enumerable<MachineOnProgramUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MachineOnProgramCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MachineOnProgramUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MachineOnProgramCreateManyProgramInputEnvelope
    set?: Enumerable<MachineOnProgramWhereUniqueInput>
    disconnect?: Enumerable<MachineOnProgramWhereUniqueInput>
    delete?: Enumerable<MachineOnProgramWhereUniqueInput>
    connect?: Enumerable<MachineOnProgramWhereUniqueInput>
    update?: Enumerable<MachineOnProgramUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MachineOnProgramUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MachineOnProgramScalarWhereInput>
  }

  export type MachineCreateNestedOneWithoutMachineOnProgramsInput = {
    create?: XOR<MachineCreateWithoutMachineOnProgramsInput, MachineUncheckedCreateWithoutMachineOnProgramsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutMachineOnProgramsInput
    connect?: MachineWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutMachineOnProgramsInput = {
    create?: XOR<ProgramCreateWithoutMachineOnProgramsInput, ProgramUncheckedCreateWithoutMachineOnProgramsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMachineOnProgramsInput
    connect?: ProgramWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutMachineOnProgramsNestedInput = {
    create?: XOR<MachineCreateWithoutMachineOnProgramsInput, MachineUncheckedCreateWithoutMachineOnProgramsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutMachineOnProgramsInput
    upsert?: MachineUpsertWithoutMachineOnProgramsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<MachineUpdateWithoutMachineOnProgramsInput, MachineUncheckedUpdateWithoutMachineOnProgramsInput>
  }

  export type ProgramUpdateOneRequiredWithoutMachineOnProgramsNestedInput = {
    create?: XOR<ProgramCreateWithoutMachineOnProgramsInput, ProgramUncheckedCreateWithoutMachineOnProgramsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMachineOnProgramsInput
    upsert?: ProgramUpsertWithoutMachineOnProgramsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<ProgramUpdateWithoutMachineOnProgramsInput, ProgramUncheckedUpdateWithoutMachineOnProgramsInput>
  }

  export type ProgramCreateNestedOneWithoutProcessesInput = {
    create?: XOR<ProgramCreateWithoutProcessesInput, ProgramUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProcessesInput
    connect?: ProgramWhereUniqueInput
  }

  export type ProgramUpdateOneWithoutProcessesNestedInput = {
    create?: XOR<ProgramCreateWithoutProcessesInput, ProgramUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProcessesInput
    upsert?: ProgramUpsertWithoutProcessesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<ProgramUpdateWithoutProcessesInput, ProgramUncheckedUpdateWithoutProcessesInput>
  }

  export type MachineCreateNestedOneWithoutRepairHistoriesInput = {
    create?: XOR<MachineCreateWithoutRepairHistoriesInput, MachineUncheckedCreateWithoutRepairHistoriesInput>
    connectOrCreate?: MachineCreateOrConnectWithoutRepairHistoriesInput
    connect?: MachineWhereUniqueInput
  }

  export type RepairDetailCreateNestedOneWithoutRepairHistoryInput = {
    create?: XOR<RepairDetailCreateWithoutRepairHistoryInput, RepairDetailUncheckedCreateWithoutRepairHistoryInput>
    connectOrCreate?: RepairDetailCreateOrConnectWithoutRepairHistoryInput
    connect?: RepairDetailWhereUniqueInput
  }

  export type MachineUpdateOneWithoutRepairHistoriesNestedInput = {
    create?: XOR<MachineCreateWithoutRepairHistoriesInput, MachineUncheckedCreateWithoutRepairHistoriesInput>
    connectOrCreate?: MachineCreateOrConnectWithoutRepairHistoriesInput
    upsert?: MachineUpsertWithoutRepairHistoriesInput
    disconnect?: boolean
    delete?: boolean
    connect?: MachineWhereUniqueInput
    update?: XOR<MachineUpdateWithoutRepairHistoriesInput, MachineUncheckedUpdateWithoutRepairHistoriesInput>
  }

  export type RepairDetailUpdateOneRequiredWithoutRepairHistoryNestedInput = {
    create?: XOR<RepairDetailCreateWithoutRepairHistoryInput, RepairDetailUncheckedCreateWithoutRepairHistoryInput>
    connectOrCreate?: RepairDetailCreateOrConnectWithoutRepairHistoryInput
    upsert?: RepairDetailUpsertWithoutRepairHistoryInput
    connect?: RepairDetailWhereUniqueInput
    update?: XOR<RepairDetailUpdateWithoutRepairHistoryInput, RepairDetailUncheckedUpdateWithoutRepairHistoryInput>
  }

  export type RepairHistoryCreateNestedManyWithoutDetailInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutDetailInput>, Enumerable<RepairHistoryUncheckedCreateWithoutDetailInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutDetailInput>
    createMany?: RepairHistoryCreateManyDetailInputEnvelope
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
  }

  export type RepairHistoryUncheckedCreateNestedManyWithoutDetailInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutDetailInput>, Enumerable<RepairHistoryUncheckedCreateWithoutDetailInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutDetailInput>
    createMany?: RepairHistoryCreateManyDetailInputEnvelope
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
  }

  export type RepairHistoryUpdateManyWithoutDetailNestedInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutDetailInput>, Enumerable<RepairHistoryUncheckedCreateWithoutDetailInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutDetailInput>
    upsert?: Enumerable<RepairHistoryUpsertWithWhereUniqueWithoutDetailInput>
    createMany?: RepairHistoryCreateManyDetailInputEnvelope
    set?: Enumerable<RepairHistoryWhereUniqueInput>
    disconnect?: Enumerable<RepairHistoryWhereUniqueInput>
    delete?: Enumerable<RepairHistoryWhereUniqueInput>
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
    update?: Enumerable<RepairHistoryUpdateWithWhereUniqueWithoutDetailInput>
    updateMany?: Enumerable<RepairHistoryUpdateManyWithWhereWithoutDetailInput>
    deleteMany?: Enumerable<RepairHistoryScalarWhereInput>
  }

  export type RepairHistoryUncheckedUpdateManyWithoutDetailNestedInput = {
    create?: XOR<Enumerable<RepairHistoryCreateWithoutDetailInput>, Enumerable<RepairHistoryUncheckedCreateWithoutDetailInput>>
    connectOrCreate?: Enumerable<RepairHistoryCreateOrConnectWithoutDetailInput>
    upsert?: Enumerable<RepairHistoryUpsertWithWhereUniqueWithoutDetailInput>
    createMany?: RepairHistoryCreateManyDetailInputEnvelope
    set?: Enumerable<RepairHistoryWhereUniqueInput>
    disconnect?: Enumerable<RepairHistoryWhereUniqueInput>
    delete?: Enumerable<RepairHistoryWhereUniqueInput>
    connect?: Enumerable<RepairHistoryWhereUniqueInput>
    update?: Enumerable<RepairHistoryUpdateWithWhereUniqueWithoutDetailInput>
    updateMany?: Enumerable<RepairHistoryUpdateManyWithWhereWithoutDetailInput>
    deleteMany?: Enumerable<RepairHistoryScalarWhereInput>
  }

  export type WashHistoryCreateNestedOneWithoutUsersInput = {
    create?: XOR<WashHistoryCreateWithoutUsersInput, WashHistoryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutUsersInput
    connect?: WashHistoryWhereUniqueInput
  }

  export type WashHistoryUpdateOneWithoutUsersNestedInput = {
    create?: XOR<WashHistoryCreateWithoutUsersInput, WashHistoryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WashHistoryCreateOrConnectWithoutUsersInput
    upsert?: WashHistoryUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: WashHistoryWhereUniqueInput
    update?: XOR<WashHistoryUpdateWithoutUsersInput, WashHistoryUncheckedUpdateWithoutUsersInput>
  }

  export type ProgramCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<ProgramCreateWithoutWashHistoryInput>, Enumerable<ProgramUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<ProgramCreateOrConnectWithoutWashHistoryInput>
    createMany?: ProgramCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<ProgramWhereUniqueInput>
  }

  export type MachineCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<MachineCreateWithoutWashHistoryInput>, Enumerable<MachineUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutWashHistoryInput>
    createMany?: MachineCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type washUserCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<washUserCreateWithoutWashHistoryInput>, Enumerable<washUserUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<washUserCreateOrConnectWithoutWashHistoryInput>
    createMany?: washUserCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<washUserWhereUniqueInput>
  }

  export type ProgramUncheckedCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<ProgramCreateWithoutWashHistoryInput>, Enumerable<ProgramUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<ProgramCreateOrConnectWithoutWashHistoryInput>
    createMany?: ProgramCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<ProgramWhereUniqueInput>
  }

  export type MachineUncheckedCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<MachineCreateWithoutWashHistoryInput>, Enumerable<MachineUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutWashHistoryInput>
    createMany?: MachineCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<MachineWhereUniqueInput>
  }

  export type washUserUncheckedCreateNestedManyWithoutWashHistoryInput = {
    create?: XOR<Enumerable<washUserCreateWithoutWashHistoryInput>, Enumerable<washUserUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<washUserCreateOrConnectWithoutWashHistoryInput>
    createMany?: washUserCreateManyWashHistoryInputEnvelope
    connect?: Enumerable<washUserWhereUniqueInput>
  }

  export type ProgramUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<ProgramCreateWithoutWashHistoryInput>, Enumerable<ProgramUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<ProgramCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<ProgramUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: ProgramCreateManyWashHistoryInputEnvelope
    set?: Enumerable<ProgramWhereUniqueInput>
    disconnect?: Enumerable<ProgramWhereUniqueInput>
    delete?: Enumerable<ProgramWhereUniqueInput>
    connect?: Enumerable<ProgramWhereUniqueInput>
    update?: Enumerable<ProgramUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<ProgramUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<ProgramScalarWhereInput>
  }

  export type MachineUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutWashHistoryInput>, Enumerable<MachineUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: MachineCreateManyWashHistoryInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type washUserUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<washUserCreateWithoutWashHistoryInput>, Enumerable<washUserUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<washUserCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<washUserUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: washUserCreateManyWashHistoryInputEnvelope
    set?: Enumerable<washUserWhereUniqueInput>
    disconnect?: Enumerable<washUserWhereUniqueInput>
    delete?: Enumerable<washUserWhereUniqueInput>
    connect?: Enumerable<washUserWhereUniqueInput>
    update?: Enumerable<washUserUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<washUserUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<washUserScalarWhereInput>
  }

  export type ProgramUncheckedUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<ProgramCreateWithoutWashHistoryInput>, Enumerable<ProgramUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<ProgramCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<ProgramUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: ProgramCreateManyWashHistoryInputEnvelope
    set?: Enumerable<ProgramWhereUniqueInput>
    disconnect?: Enumerable<ProgramWhereUniqueInput>
    delete?: Enumerable<ProgramWhereUniqueInput>
    connect?: Enumerable<ProgramWhereUniqueInput>
    update?: Enumerable<ProgramUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<ProgramUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<ProgramScalarWhereInput>
  }

  export type MachineUncheckedUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<MachineCreateWithoutWashHistoryInput>, Enumerable<MachineUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<MachineCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<MachineUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: MachineCreateManyWashHistoryInputEnvelope
    set?: Enumerable<MachineWhereUniqueInput>
    disconnect?: Enumerable<MachineWhereUniqueInput>
    delete?: Enumerable<MachineWhereUniqueInput>
    connect?: Enumerable<MachineWhereUniqueInput>
    update?: Enumerable<MachineUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<MachineUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<MachineScalarWhereInput>
  }

  export type washUserUncheckedUpdateManyWithoutWashHistoryNestedInput = {
    create?: XOR<Enumerable<washUserCreateWithoutWashHistoryInput>, Enumerable<washUserUncheckedCreateWithoutWashHistoryInput>>
    connectOrCreate?: Enumerable<washUserCreateOrConnectWithoutWashHistoryInput>
    upsert?: Enumerable<washUserUpsertWithWhereUniqueWithoutWashHistoryInput>
    createMany?: washUserCreateManyWashHistoryInputEnvelope
    set?: Enumerable<washUserWhereUniqueInput>
    disconnect?: Enumerable<washUserWhereUniqueInput>
    delete?: Enumerable<washUserWhereUniqueInput>
    connect?: Enumerable<washUserWhereUniqueInput>
    update?: Enumerable<washUserUpdateWithWhereUniqueWithoutWashHistoryInput>
    updateMany?: Enumerable<washUserUpdateManyWithWhereWithoutWashHistoryInput>
    deleteMany?: Enumerable<washUserScalarWhereInput>
  }

  export type DirectMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutUserInput>
    createMany?: DirectMessageCreateManyUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFromInput>, Enumerable<UserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFromInput>
    createMany?: UserRelationCreateManyFromInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutToInput>, Enumerable<UserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutToInput>
    createMany?: UserRelationCreateManyToInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type ReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutUserInput>, Enumerable<ReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutUserInput>
    createMany?: ReplyCreateManyUserInputEnvelope
    connect?: Enumerable<ReplyWhereUniqueInput>
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutUserInput>
    createMany?: DirectMessageCreateManyUserInputEnvelope
    connect?: Enumerable<DirectMessageWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFromInput>, Enumerable<UserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFromInput>
    createMany?: UserRelationCreateManyFromInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type UserRelationUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutToInput>, Enumerable<UserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutToInput>
    createMany?: UserRelationCreateManyToInputEnvelope
    connect?: Enumerable<UserRelationWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type ReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutUserInput>, Enumerable<ReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutUserInput>
    createMany?: ReplyCreateManyUserInputEnvelope
    connect?: Enumerable<ReplyWhereUniqueInput>
  }

  export type DirectMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DirectMessageCreateManyUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserRelationUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFromInput>, Enumerable<UserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: UserRelationCreateManyFromInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutToInput>, Enumerable<UserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutToInput>
    createMany?: UserRelationCreateManyToInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type ReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutUserInput>, Enumerable<ReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReplyCreateManyUserInputEnvelope
    set?: Enumerable<ReplyWhereUniqueInput>
    disconnect?: Enumerable<ReplyWhereUniqueInput>
    delete?: Enumerable<ReplyWhereUniqueInput>
    connect?: Enumerable<ReplyWhereUniqueInput>
    update?: Enumerable<ReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReplyScalarWhereInput>
  }

  export type DirectMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DirectMessageCreateWithoutUserInput>, Enumerable<DirectMessageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DirectMessageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DirectMessageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DirectMessageCreateManyUserInputEnvelope
    set?: Enumerable<DirectMessageWhereUniqueInput>
    disconnect?: Enumerable<DirectMessageWhereUniqueInput>
    delete?: Enumerable<DirectMessageWhereUniqueInput>
    connect?: Enumerable<DirectMessageWhereUniqueInput>
    update?: Enumerable<DirectMessageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DirectMessageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DirectMessageScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutFromInput>, Enumerable<UserRelationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: UserRelationCreateManyFromInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type UserRelationUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<UserRelationCreateWithoutToInput>, Enumerable<UserRelationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<UserRelationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<UserRelationUpsertWithWhereUniqueWithoutToInput>
    createMany?: UserRelationCreateManyToInputEnvelope
    set?: Enumerable<UserRelationWhereUniqueInput>
    disconnect?: Enumerable<UserRelationWhereUniqueInput>
    delete?: Enumerable<UserRelationWhereUniqueInput>
    connect?: Enumerable<UserRelationWhereUniqueInput>
    update?: Enumerable<UserRelationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<UserRelationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<UserRelationScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type ReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutUserInput>, Enumerable<ReplyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReplyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReplyCreateManyUserInputEnvelope
    set?: Enumerable<ReplyWhereUniqueInput>
    disconnect?: Enumerable<ReplyWhereUniqueInput>
    delete?: Enumerable<ReplyWhereUniqueInput>
    connect?: Enumerable<ReplyWhereUniqueInput>
    update?: Enumerable<ReplyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReplyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReplyScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDirectMessageInput = {
    create?: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDirectMessageNestedInput = {
    create?: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectMessageInput
    upsert?: UserUpsertWithoutDirectMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDirectMessageInput, UserUncheckedUpdateWithoutDirectMessageInput>
  }

  export type UserCreateNestedOneWithoutFromUserRelationInput = {
    create?: XOR<UserCreateWithoutFromUserRelationInput, UserUncheckedCreateWithoutFromUserRelationInput>
    connectOrCreate?: UserCreateOrConnectWithoutFromUserRelationInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutToUserRelationInput = {
    create?: XOR<UserCreateWithoutToUserRelationInput, UserUncheckedCreateWithoutToUserRelationInput>
    connectOrCreate?: UserCreateOrConnectWithoutToUserRelationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFromUserRelationNestedInput = {
    create?: XOR<UserCreateWithoutFromUserRelationInput, UserUncheckedCreateWithoutFromUserRelationInput>
    connectOrCreate?: UserCreateOrConnectWithoutFromUserRelationInput
    upsert?: UserUpsertWithoutFromUserRelationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFromUserRelationInput, UserUncheckedUpdateWithoutFromUserRelationInput>
  }

  export type UserUpdateOneRequiredWithoutToUserRelationNestedInput = {
    create?: XOR<UserCreateWithoutToUserRelationInput, UserUncheckedCreateWithoutToUserRelationInput>
    connectOrCreate?: UserCreateOrConnectWithoutToUserRelationInput
    upsert?: UserUpsertWithoutToUserRelationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutToUserRelationInput, UserUncheckedUpdateWithoutToUserRelationInput>
  }

  export type PostOnHashTagCreateNestedOneWithoutHashTagsInput = {
    create?: XOR<PostOnHashTagCreateWithoutHashTagsInput, PostOnHashTagUncheckedCreateWithoutHashTagsInput>
    connectOrCreate?: PostOnHashTagCreateOrConnectWithoutHashTagsInput
    connect?: PostOnHashTagWhereUniqueInput
  }

  export type PostOnHashTagUpdateOneWithoutHashTagsNestedInput = {
    create?: XOR<PostOnHashTagCreateWithoutHashTagsInput, PostOnHashTagUncheckedCreateWithoutHashTagsInput>
    connectOrCreate?: PostOnHashTagCreateOrConnectWithoutHashTagsInput
    upsert?: PostOnHashTagUpsertWithoutHashTagsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PostOnHashTagWhereUniqueInput
    update?: XOR<PostOnHashTagUpdateWithoutHashTagsInput, PostOnHashTagUncheckedUpdateWithoutHashTagsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostOnHashTagCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<PostOnHashTagCreateWithoutPostsInput>, Enumerable<PostOnHashTagUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostOnHashTagCreateOrConnectWithoutPostsInput>
    connect?: Enumerable<PostOnHashTagWhereUniqueInput>
  }

  export type ReplyCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutPostInput>, Enumerable<ReplyUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutPostInput>
    createMany?: ReplyCreateManyPostInputEnvelope
    connect?: Enumerable<ReplyWhereUniqueInput>
  }

  export type PostOnHashTagUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<PostOnHashTagCreateWithoutPostsInput>, Enumerable<PostOnHashTagUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostOnHashTagCreateOrConnectWithoutPostsInput>
    connect?: Enumerable<PostOnHashTagWhereUniqueInput>
  }

  export type ReplyUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutPostInput>, Enumerable<ReplyUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutPostInput>
    createMany?: ReplyCreateManyPostInputEnvelope
    connect?: Enumerable<ReplyWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostOnHashTagUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<PostOnHashTagCreateWithoutPostsInput>, Enumerable<PostOnHashTagUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostOnHashTagCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<PostOnHashTagUpsertWithWhereUniqueWithoutPostsInput>
    set?: Enumerable<PostOnHashTagWhereUniqueInput>
    disconnect?: Enumerable<PostOnHashTagWhereUniqueInput>
    delete?: Enumerable<PostOnHashTagWhereUniqueInput>
    connect?: Enumerable<PostOnHashTagWhereUniqueInput>
    update?: Enumerable<PostOnHashTagUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<PostOnHashTagUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<PostOnHashTagScalarWhereInput>
  }

  export type ReplyUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutPostInput>, Enumerable<ReplyUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<ReplyUpsertWithWhereUniqueWithoutPostInput>
    createMany?: ReplyCreateManyPostInputEnvelope
    set?: Enumerable<ReplyWhereUniqueInput>
    disconnect?: Enumerable<ReplyWhereUniqueInput>
    delete?: Enumerable<ReplyWhereUniqueInput>
    connect?: Enumerable<ReplyWhereUniqueInput>
    update?: Enumerable<ReplyUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<ReplyUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<ReplyScalarWhereInput>
  }

  export type PostOnHashTagUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<PostOnHashTagCreateWithoutPostsInput>, Enumerable<PostOnHashTagUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<PostOnHashTagCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<PostOnHashTagUpsertWithWhereUniqueWithoutPostsInput>
    set?: Enumerable<PostOnHashTagWhereUniqueInput>
    disconnect?: Enumerable<PostOnHashTagWhereUniqueInput>
    delete?: Enumerable<PostOnHashTagWhereUniqueInput>
    connect?: Enumerable<PostOnHashTagWhereUniqueInput>
    update?: Enumerable<PostOnHashTagUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<PostOnHashTagUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<PostOnHashTagScalarWhereInput>
  }

  export type ReplyUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<ReplyCreateWithoutPostInput>, Enumerable<ReplyUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<ReplyCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<ReplyUpsertWithWhereUniqueWithoutPostInput>
    createMany?: ReplyCreateManyPostInputEnvelope
    set?: Enumerable<ReplyWhereUniqueInput>
    disconnect?: Enumerable<ReplyWhereUniqueInput>
    delete?: Enumerable<ReplyWhereUniqueInput>
    connect?: Enumerable<ReplyWhereUniqueInput>
    update?: Enumerable<ReplyUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<ReplyUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<ReplyScalarWhereInput>
  }

  export type PostCreateNestedManyWithoutPostOnHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostOnHashTagsInput>, Enumerable<PostUncheckedCreateWithoutPostOnHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostOnHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type HashTagCreateNestedManyWithoutPostOnHashTagInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutPostOnHashTagInput>, Enumerable<HashTagUncheckedCreateWithoutPostOnHashTagInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutPostOnHashTagInput>
    createMany?: HashTagCreateManyPostOnHashTagInputEnvelope
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutPostOnHashTagsInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostOnHashTagsInput>, Enumerable<PostUncheckedCreateWithoutPostOnHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostOnHashTagsInput>
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type HashTagUncheckedCreateNestedManyWithoutPostOnHashTagInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutPostOnHashTagInput>, Enumerable<HashTagUncheckedCreateWithoutPostOnHashTagInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutPostOnHashTagInput>
    createMany?: HashTagCreateManyPostOnHashTagInputEnvelope
    connect?: Enumerable<HashTagWhereUniqueInput>
  }

  export type PostUpdateManyWithoutPostOnHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostOnHashTagsInput>, Enumerable<PostUncheckedCreateWithoutPostOnHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostOnHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostOnHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostOnHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostOnHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type HashTagUpdateManyWithoutPostOnHashTagNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutPostOnHashTagInput>, Enumerable<HashTagUncheckedCreateWithoutPostOnHashTagInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutPostOnHashTagInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutPostOnHashTagInput>
    createMany?: HashTagCreateManyPostOnHashTagInputEnvelope
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutPostOnHashTagInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutPostOnHashTagInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutPostOnHashTagsNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutPostOnHashTagsInput>, Enumerable<PostUncheckedCreateWithoutPostOnHashTagsInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutPostOnHashTagsInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutPostOnHashTagsInput>
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutPostOnHashTagsInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutPostOnHashTagsInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type HashTagUncheckedUpdateManyWithoutPostOnHashTagNestedInput = {
    create?: XOR<Enumerable<HashTagCreateWithoutPostOnHashTagInput>, Enumerable<HashTagUncheckedCreateWithoutPostOnHashTagInput>>
    connectOrCreate?: Enumerable<HashTagCreateOrConnectWithoutPostOnHashTagInput>
    upsert?: Enumerable<HashTagUpsertWithWhereUniqueWithoutPostOnHashTagInput>
    createMany?: HashTagCreateManyPostOnHashTagInputEnvelope
    set?: Enumerable<HashTagWhereUniqueInput>
    disconnect?: Enumerable<HashTagWhereUniqueInput>
    delete?: Enumerable<HashTagWhereUniqueInput>
    connect?: Enumerable<HashTagWhereUniqueInput>
    update?: Enumerable<HashTagUpdateWithWhereUniqueWithoutPostOnHashTagInput>
    updateMany?: Enumerable<HashTagUpdateManyWithWhereWithoutPostOnHashTagInput>
    deleteMany?: Enumerable<HashTagScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRepliesInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutRepliesInput = {
    create?: XOR<PostCreateWithoutRepliesInput, PostUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: PostCreateOrConnectWithoutRepliesInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    upsert?: UserUpsertWithoutRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
  }

  export type PostUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<PostCreateWithoutRepliesInput, PostUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: PostCreateOrConnectWithoutRepliesInput
    upsert?: PostUpsertWithoutRepliesInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutRepliesInput, PostUncheckedUpdateWithoutRepliesInput>
  }

  export type YoutubeChannelCreateNestedManyWithoutSubcribersInput = {
    create?: XOR<Enumerable<YoutubeChannelCreateWithoutSubcribersInput>, Enumerable<YoutubeChannelUncheckedCreateWithoutSubcribersInput>>
    connectOrCreate?: Enumerable<YoutubeChannelCreateOrConnectWithoutSubcribersInput>
    connect?: Enumerable<YoutubeChannelWhereUniqueInput>
  }

  export type YoutubeCommentToVideoCreateNestedManyWithoutCommenterInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutCommenterInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutCommenterInput>
    createMany?: YoutubeCommentToVideoCreateManyCommenterInputEnvelope
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeChannelUncheckedCreateNestedManyWithoutSubcribersInput = {
    create?: XOR<Enumerable<YoutubeChannelCreateWithoutSubcribersInput>, Enumerable<YoutubeChannelUncheckedCreateWithoutSubcribersInput>>
    connectOrCreate?: Enumerable<YoutubeChannelCreateOrConnectWithoutSubcribersInput>
    connect?: Enumerable<YoutubeChannelWhereUniqueInput>
  }

  export type YoutubeCommentToVideoUncheckedCreateNestedManyWithoutCommenterInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutCommenterInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutCommenterInput>
    createMany?: YoutubeCommentToVideoCreateManyCommenterInputEnvelope
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeChannelUpdateManyWithoutSubcribersNestedInput = {
    create?: XOR<Enumerable<YoutubeChannelCreateWithoutSubcribersInput>, Enumerable<YoutubeChannelUncheckedCreateWithoutSubcribersInput>>
    connectOrCreate?: Enumerable<YoutubeChannelCreateOrConnectWithoutSubcribersInput>
    upsert?: Enumerable<YoutubeChannelUpsertWithWhereUniqueWithoutSubcribersInput>
    set?: Enumerable<YoutubeChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeChannelWhereUniqueInput>
    update?: Enumerable<YoutubeChannelUpdateWithWhereUniqueWithoutSubcribersInput>
    updateMany?: Enumerable<YoutubeChannelUpdateManyWithWhereWithoutSubcribersInput>
    deleteMany?: Enumerable<YoutubeChannelScalarWhereInput>
  }

  export type YoutubeCommentToVideoUpdateManyWithoutCommenterNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutCommenterInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutCommenterInput>
    upsert?: Enumerable<YoutubeCommentToVideoUpsertWithWhereUniqueWithoutCommenterInput>
    createMany?: YoutubeCommentToVideoCreateManyCommenterInputEnvelope
    set?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    update?: Enumerable<YoutubeCommentToVideoUpdateWithWhereUniqueWithoutCommenterInput>
    updateMany?: Enumerable<YoutubeCommentToVideoUpdateManyWithWhereWithoutCommenterInput>
    deleteMany?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeChannelUncheckedUpdateManyWithoutSubcribersNestedInput = {
    create?: XOR<Enumerable<YoutubeChannelCreateWithoutSubcribersInput>, Enumerable<YoutubeChannelUncheckedCreateWithoutSubcribersInput>>
    connectOrCreate?: Enumerable<YoutubeChannelCreateOrConnectWithoutSubcribersInput>
    upsert?: Enumerable<YoutubeChannelUpsertWithWhereUniqueWithoutSubcribersInput>
    set?: Enumerable<YoutubeChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeChannelWhereUniqueInput>
    update?: Enumerable<YoutubeChannelUpdateWithWhereUniqueWithoutSubcribersInput>
    updateMany?: Enumerable<YoutubeChannelUpdateManyWithWhereWithoutSubcribersInput>
    deleteMany?: Enumerable<YoutubeChannelScalarWhereInput>
  }

  export type YoutubeCommentToVideoUncheckedUpdateManyWithoutCommenterNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutCommenterInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutCommenterInput>
    upsert?: Enumerable<YoutubeCommentToVideoUpsertWithWhereUniqueWithoutCommenterInput>
    createMany?: YoutubeCommentToVideoCreateManyCommenterInputEnvelope
    set?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    update?: Enumerable<YoutubeCommentToVideoUpdateWithWhereUniqueWithoutCommenterInput>
    updateMany?: Enumerable<YoutubeCommentToVideoUpdateManyWithWhereWithoutCommenterInput>
    deleteMany?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoCreateNestedManyWithoutLikeorDislikeInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutLikeorDislikeInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutLikeorDislikeInput>
    createMany?: YoutubeVideoCreateManyLikeorDislikeInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeVideoUncheckedCreateNestedManyWithoutLikeorDislikeInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutLikeorDislikeInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutLikeorDislikeInput>
    createMany?: YoutubeVideoCreateManyLikeorDislikeInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeVideoUpdateManyWithoutLikeorDislikeNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutLikeorDislikeInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutLikeorDislikeInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutLikeorDislikeInput>
    createMany?: YoutubeVideoCreateManyLikeorDislikeInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutLikeorDislikeInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutLikeorDislikeInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutLikeorDislikeNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutLikeorDislikeInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutLikeorDislikeInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutLikeorDislikeInput>
    createMany?: YoutubeVideoCreateManyLikeorDislikeInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutLikeorDislikeInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutLikeorDislikeInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeReactionCreateNestedOneWithoutVideoInput = {
    create?: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
    connectOrCreate?: YoutubeReactionCreateOrConnectWithoutVideoInput
    connect?: YoutubeReactionWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutPlayListsInput = {
    create?: XOR<YoutubeChannelCreateWithoutPlayListsInput, YoutubeChannelUncheckedCreateWithoutPlayListsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutPlayListsInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeCommentToVideoCreateNestedManyWithoutVideoIdInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutVideoIdInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutVideoIdInput>
    createMany?: YoutubeCommentToVideoCreateManyVideoIdInputEnvelope
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
  }

  export type YoutubeCommentToVideoUncheckedCreateNestedManyWithoutVideoIdInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutVideoIdInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutVideoIdInput>
    createMany?: YoutubeCommentToVideoCreateManyVideoIdInputEnvelope
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
  }

  export type YoutubeReactionUpdateOneRequiredWithoutVideoNestedInput = {
    create?: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
    connectOrCreate?: YoutubeReactionCreateOrConnectWithoutVideoInput
    upsert?: YoutubeReactionUpsertWithoutVideoInput
    connect?: YoutubeReactionWhereUniqueInput
    update?: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
  }

  export type YoutubeChannelUpdateOneWithoutPlayListsNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutPlayListsInput, YoutubeChannelUncheckedCreateWithoutPlayListsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutPlayListsInput
    upsert?: YoutubeChannelUpsertWithoutPlayListsInput
    disconnect?: boolean
    delete?: boolean
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutPlayListsInput, YoutubeChannelUncheckedUpdateWithoutPlayListsInput>
  }

  export type YoutubeCommentToVideoUpdateManyWithoutVideoIdNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutVideoIdInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutVideoIdInput>
    upsert?: Enumerable<YoutubeCommentToVideoUpsertWithWhereUniqueWithoutVideoIdInput>
    createMany?: YoutubeCommentToVideoCreateManyVideoIdInputEnvelope
    set?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    update?: Enumerable<YoutubeCommentToVideoUpdateWithWhereUniqueWithoutVideoIdInput>
    updateMany?: Enumerable<YoutubeCommentToVideoUpdateManyWithWhereWithoutVideoIdInput>
    deleteMany?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
  }

  export type YoutubeCommentToVideoUncheckedUpdateManyWithoutVideoIdNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentToVideoCreateWithoutVideoIdInput>, Enumerable<YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>>
    connectOrCreate?: Enumerable<YoutubeCommentToVideoCreateOrConnectWithoutVideoIdInput>
    upsert?: Enumerable<YoutubeCommentToVideoUpsertWithWhereUniqueWithoutVideoIdInput>
    createMany?: YoutubeCommentToVideoCreateManyVideoIdInputEnvelope
    set?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentToVideoWhereUniqueInput>
    update?: Enumerable<YoutubeCommentToVideoUpdateWithWhereUniqueWithoutVideoIdInput>
    updateMany?: Enumerable<YoutubeCommentToVideoUpdateManyWithWhereWithoutVideoIdInput>
    deleteMany?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
  }

  export type YoutubeUserCreateNestedManyWithoutSubtoChannelsInput = {
    create?: XOR<Enumerable<YoutubeUserCreateWithoutSubtoChannelsInput>, Enumerable<YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>>
    connectOrCreate?: Enumerable<YoutubeUserCreateOrConnectWithoutSubtoChannelsInput>
    connect?: Enumerable<YoutubeUserWhereUniqueInput>
  }

  export type YoutubeVideoCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserUncheckedCreateNestedManyWithoutSubtoChannelsInput = {
    create?: XOR<Enumerable<YoutubeUserCreateWithoutSubtoChannelsInput>, Enumerable<YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>>
    connectOrCreate?: Enumerable<YoutubeUserCreateOrConnectWithoutSubtoChannelsInput>
    connect?: Enumerable<YoutubeUserWhereUniqueInput>
  }

  export type YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserUpdateManyWithoutSubtoChannelsNestedInput = {
    create?: XOR<Enumerable<YoutubeUserCreateWithoutSubtoChannelsInput>, Enumerable<YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>>
    connectOrCreate?: Enumerable<YoutubeUserCreateOrConnectWithoutSubtoChannelsInput>
    upsert?: Enumerable<YoutubeUserUpsertWithWhereUniqueWithoutSubtoChannelsInput>
    set?: Enumerable<YoutubeUserWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserWhereUniqueInput>
    delete?: Enumerable<YoutubeUserWhereUniqueInput>
    connect?: Enumerable<YoutubeUserWhereUniqueInput>
    update?: Enumerable<YoutubeUserUpdateWithWhereUniqueWithoutSubtoChannelsInput>
    updateMany?: Enumerable<YoutubeUserUpdateManyWithWhereWithoutSubtoChannelsInput>
    deleteMany?: Enumerable<YoutubeUserScalarWhereInput>
  }

  export type YoutubeVideoUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeUserUncheckedUpdateManyWithoutSubtoChannelsNestedInput = {
    create?: XOR<Enumerable<YoutubeUserCreateWithoutSubtoChannelsInput>, Enumerable<YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>>
    connectOrCreate?: Enumerable<YoutubeUserCreateOrConnectWithoutSubtoChannelsInput>
    upsert?: Enumerable<YoutubeUserUpsertWithWhereUniqueWithoutSubtoChannelsInput>
    set?: Enumerable<YoutubeUserWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserWhereUniqueInput>
    delete?: Enumerable<YoutubeUserWhereUniqueInput>
    connect?: Enumerable<YoutubeUserWhereUniqueInput>
    update?: Enumerable<YoutubeUserUpdateWithWhereUniqueWithoutSubtoChannelsInput>
    updateMany?: Enumerable<YoutubeUserUpdateManyWithWhereWithoutSubtoChannelsInput>
    deleteMany?: Enumerable<YoutubeUserScalarWhereInput>
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoCreateNestedOneWithoutCommentToVideoesInput = {
    create?: XOR<YoutubeVideoCreateWithoutCommentToVideoesInput, YoutubeVideoUncheckedCreateWithoutCommentToVideoesInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutCommentToVideoesInput
    connect?: YoutubeVideoWhereUniqueInput
  }

  export type YoutubeUserCreateNestedOneWithoutCommentToVideoesInput = {
    create?: XOR<YoutubeUserCreateWithoutCommentToVideoesInput, YoutubeUserUncheckedCreateWithoutCommentToVideoesInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutCommentToVideoesInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeVideoUpdateOneRequiredWithoutCommentToVideoesNestedInput = {
    create?: XOR<YoutubeVideoCreateWithoutCommentToVideoesInput, YoutubeVideoUncheckedCreateWithoutCommentToVideoesInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutCommentToVideoesInput
    upsert?: YoutubeVideoUpsertWithoutCommentToVideoesInput
    connect?: YoutubeVideoWhereUniqueInput
    update?: XOR<YoutubeVideoUpdateWithoutCommentToVideoesInput, YoutubeVideoUncheckedUpdateWithoutCommentToVideoesInput>
  }

  export type YoutubeUserUpdateOneRequiredWithoutCommentToVideoesNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutCommentToVideoesInput, YoutubeUserUncheckedCreateWithoutCommentToVideoesInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutCommentToVideoesInput
    upsert?: YoutubeUserUpsertWithoutCommentToVideoesInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutCommentToVideoesInput, YoutubeUserUncheckedUpdateWithoutCommentToVideoesInput>
  }

  export type YoutubeUserCreateNestedOneWithoutUserToChannelInput = {
    create?: XOR<YoutubeUserCreateWithoutUserToChannelInput, YoutubeUserUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutUserToChannelInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutUserToChannelInput = {
    create?: XOR<YoutubeChannelCreateWithoutUserToChannelInput, YoutubeChannelUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutUserToChannelInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeRoleCreateNestedOneWithoutUserToChannelInput = {
    create?: XOR<YoutubeRoleCreateWithoutUserToChannelInput, YoutubeRoleUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeRoleCreateOrConnectWithoutUserToChannelInput
    connect?: YoutubeRoleWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutUserToChannelNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutUserToChannelInput, YoutubeUserUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutUserToChannelInput
    upsert?: YoutubeUserUpsertWithoutUserToChannelInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutUserToChannelInput, YoutubeUserUncheckedUpdateWithoutUserToChannelInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutUserToChannelNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutUserToChannelInput, YoutubeChannelUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutUserToChannelInput
    upsert?: YoutubeChannelUpsertWithoutUserToChannelInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutUserToChannelInput, YoutubeChannelUncheckedUpdateWithoutUserToChannelInput>
  }

  export type YoutubeRoleUpdateOneRequiredWithoutUserToChannelNestedInput = {
    create?: XOR<YoutubeRoleCreateWithoutUserToChannelInput, YoutubeRoleUncheckedCreateWithoutUserToChannelInput>
    connectOrCreate?: YoutubeRoleCreateOrConnectWithoutUserToChannelInput
    upsert?: YoutubeRoleUpsertWithoutUserToChannelInput
    connect?: YoutubeRoleWhereUniqueInput
    update?: XOR<YoutubeRoleUpdateWithoutUserToChannelInput, YoutubeRoleUncheckedUpdateWithoutUserToChannelInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DewKitchenMenuCreateWithoutCategoryKeyInput = {
    name: string
    image: string
    price: number
    orderItems?: DewOrderItemCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput = {
    id?: number
    name: string
    image: string
    price: number
    orderItems?: DewOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuCreateOrConnectWithoutCategoryKeyInput = {
    where: DewKitchenMenuWhereUniqueInput
    create: XOR<DewKitchenMenuCreateWithoutCategoryKeyInput, DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>
  }

  export type DewKitchenMenuCreateManyCategoryKeyInputEnvelope = {
    data: Enumerable<DewKitchenMenuCreateManyCategoryKeyInput>
    skipDuplicates?: boolean
  }

  export type DewKitchenMenuUpsertWithWhereUniqueWithoutCategoryKeyInput = {
    where: DewKitchenMenuWhereUniqueInput
    update: XOR<DewKitchenMenuUpdateWithoutCategoryKeyInput, DewKitchenMenuUncheckedUpdateWithoutCategoryKeyInput>
    create: XOR<DewKitchenMenuCreateWithoutCategoryKeyInput, DewKitchenMenuUncheckedCreateWithoutCategoryKeyInput>
  }

  export type DewKitchenMenuUpdateWithWhereUniqueWithoutCategoryKeyInput = {
    where: DewKitchenMenuWhereUniqueInput
    data: XOR<DewKitchenMenuUpdateWithoutCategoryKeyInput, DewKitchenMenuUncheckedUpdateWithoutCategoryKeyInput>
  }

  export type DewKitchenMenuUpdateManyWithWhereWithoutCategoryKeyInput = {
    where: DewKitchenMenuScalarWhereInput
    data: XOR<DewKitchenMenuUpdateManyMutationInput, DewKitchenMenuUncheckedUpdateManyWithoutMenusInput>
  }

  export type DewKitchenMenuScalarWhereInput = {
    AND?: Enumerable<DewKitchenMenuScalarWhereInput>
    OR?: Enumerable<DewKitchenMenuScalarWhereInput>
    NOT?: Enumerable<DewKitchenMenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryName?: StringNullableFilter | string | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewKitchenCategoryCreateWithoutMenusInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenCategoryUncheckedCreateWithoutMenusInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenCategoryCreateOrConnectWithoutMenusInput = {
    where: DewKitchenCategoryWhereUniqueInput
    create: XOR<DewKitchenCategoryCreateWithoutMenusInput, DewKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type DewOrderItemCreateWithoutMenuInput = {
    order?: DewKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemCreateOrConnectWithoutMenuInput = {
    where: DewOrderItemWhereUniqueInput
    create: XOR<DewOrderItemCreateWithoutMenuInput, DewOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type DewOrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<DewOrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type DewKitchenCategoryUpsertWithoutMenusInput = {
    update: XOR<DewKitchenCategoryUpdateWithoutMenusInput, DewKitchenCategoryUncheckedUpdateWithoutMenusInput>
    create: XOR<DewKitchenCategoryCreateWithoutMenusInput, DewKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type DewKitchenCategoryUpdateWithoutMenusInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenCategoryUncheckedUpdateWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: DewOrderItemWhereUniqueInput
    update: XOR<DewOrderItemUpdateWithoutMenuInput, DewOrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<DewOrderItemCreateWithoutMenuInput, DewOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type DewOrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: DewOrderItemWhereUniqueInput
    data: XOR<DewOrderItemUpdateWithoutMenuInput, DewOrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type DewOrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: DewOrderItemScalarWhereInput
    data: XOR<DewOrderItemUpdateManyMutationInput, DewOrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type DewOrderItemScalarWhereInput = {
    AND?: Enumerable<DewOrderItemScalarWhereInput>
    OR?: Enumerable<DewOrderItemScalarWhereInput>
    NOT?: Enumerable<DewOrderItemScalarWhereInput>
    id?: IntFilter | number
    menuId?: IntFilter | number
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DewOrderItemCreateWithoutOrderInput = {
    menu: DewKitchenMenuCreateNestedOneWithoutOrderItemsInput
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemCreateOrConnectWithoutOrderInput = {
    where: DewOrderItemWhereUniqueInput
    create: XOR<DewOrderItemCreateWithoutOrderInput, DewOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type DewOrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<DewOrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type DewOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: DewOrderItemWhereUniqueInput
    update: XOR<DewOrderItemUpdateWithoutOrderInput, DewOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<DewOrderItemCreateWithoutOrderInput, DewOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type DewOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: DewOrderItemWhereUniqueInput
    data: XOR<DewOrderItemUpdateWithoutOrderInput, DewOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type DewOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: DewOrderItemScalarWhereInput
    data: XOR<DewOrderItemUpdateManyMutationInput, DewOrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type DewKitchenMenuCreateWithoutOrderItemsInput = {
    name: string
    image: string
    price: number
    categoryKey?: DewKitchenCategoryCreateNestedOneWithoutMenusInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuCreateOrConnectWithoutOrderItemsInput = {
    where: DewKitchenMenuWhereUniqueInput
    create: XOR<DewKitchenMenuCreateWithoutOrderItemsInput, DewKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type DewKitchenOrderCreateWithoutItemsInput = {
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    status?: string
    tableId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenOrderCreateOrConnectWithoutItemsInput = {
    where: DewKitchenOrderWhereUniqueInput
    create: XOR<DewKitchenOrderCreateWithoutItemsInput, DewKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type DewKitchenMenuUpsertWithoutOrderItemsInput = {
    update: XOR<DewKitchenMenuUpdateWithoutOrderItemsInput, DewKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<DewKitchenMenuCreateWithoutOrderItemsInput, DewKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type DewKitchenMenuUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryKey?: DewKitchenCategoryUpdateOneWithoutMenusNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderUpsertWithoutItemsInput = {
    update: XOR<DewKitchenOrderUpdateWithoutItemsInput, DewKitchenOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<DewKitchenOrderCreateWithoutItemsInput, DewKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type DewKitchenOrderUpdateWithoutItemsInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookExOnAuthorExCreateWithoutBookExampleInput = {
    authorExample: AuthorExCreateNestedOneWithoutBookExampleOnAuthorExampleInput
  }

  export type BookExOnAuthorExUncheckedCreateWithoutBookExampleInput = {
    authorExampleId: number
  }

  export type BookExOnAuthorExCreateOrConnectWithoutBookExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    create: XOR<BookExOnAuthorExCreateWithoutBookExampleInput, BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>
  }

  export type BookExOnAuthorExCreateManyBookExampleInputEnvelope = {
    data: Enumerable<BookExOnAuthorExCreateManyBookExampleInput>
    skipDuplicates?: boolean
  }

  export type BookExOnAuthorExUpsertWithWhereUniqueWithoutBookExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    update: XOR<BookExOnAuthorExUpdateWithoutBookExampleInput, BookExOnAuthorExUncheckedUpdateWithoutBookExampleInput>
    create: XOR<BookExOnAuthorExCreateWithoutBookExampleInput, BookExOnAuthorExUncheckedCreateWithoutBookExampleInput>
  }

  export type BookExOnAuthorExUpdateWithWhereUniqueWithoutBookExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    data: XOR<BookExOnAuthorExUpdateWithoutBookExampleInput, BookExOnAuthorExUncheckedUpdateWithoutBookExampleInput>
  }

  export type BookExOnAuthorExUpdateManyWithWhereWithoutBookExampleInput = {
    where: BookExOnAuthorExScalarWhereInput
    data: XOR<BookExOnAuthorExUpdateManyMutationInput, BookExOnAuthorExUncheckedUpdateManyWithoutBookExampleOnAuthorExampleInput>
  }

  export type BookExOnAuthorExScalarWhereInput = {
    AND?: Enumerable<BookExOnAuthorExScalarWhereInput>
    OR?: Enumerable<BookExOnAuthorExScalarWhereInput>
    NOT?: Enumerable<BookExOnAuthorExScalarWhereInput>
    bookExampleId?: IntFilter | number
    authorExampleId?: IntFilter | number
  }

  export type BookExOnAuthorExCreateWithoutAuthorExampleInput = {
    bookExample: BookExCreateNestedOneWithoutBookExampleOnAuthorExampleInput
  }

  export type BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput = {
    bookExampleId: number
  }

  export type BookExOnAuthorExCreateOrConnectWithoutAuthorExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    create: XOR<BookExOnAuthorExCreateWithoutAuthorExampleInput, BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>
  }

  export type BookExOnAuthorExCreateManyAuthorExampleInputEnvelope = {
    data: Enumerable<BookExOnAuthorExCreateManyAuthorExampleInput>
    skipDuplicates?: boolean
  }

  export type BookExOnAuthorExUpsertWithWhereUniqueWithoutAuthorExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    update: XOR<BookExOnAuthorExUpdateWithoutAuthorExampleInput, BookExOnAuthorExUncheckedUpdateWithoutAuthorExampleInput>
    create: XOR<BookExOnAuthorExCreateWithoutAuthorExampleInput, BookExOnAuthorExUncheckedCreateWithoutAuthorExampleInput>
  }

  export type BookExOnAuthorExUpdateWithWhereUniqueWithoutAuthorExampleInput = {
    where: BookExOnAuthorExWhereUniqueInput
    data: XOR<BookExOnAuthorExUpdateWithoutAuthorExampleInput, BookExOnAuthorExUncheckedUpdateWithoutAuthorExampleInput>
  }

  export type BookExOnAuthorExUpdateManyWithWhereWithoutAuthorExampleInput = {
    where: BookExOnAuthorExScalarWhereInput
    data: XOR<BookExOnAuthorExUpdateManyMutationInput, BookExOnAuthorExUncheckedUpdateManyWithoutBookExampleOnAuthorExampleInput>
  }

  export type BookExCreateWithoutBookExampleOnAuthorExampleInput = {
    title: string
  }

  export type BookExUncheckedCreateWithoutBookExampleOnAuthorExampleInput = {
    id?: number
    title: string
  }

  export type BookExCreateOrConnectWithoutBookExampleOnAuthorExampleInput = {
    where: BookExWhereUniqueInput
    create: XOR<BookExCreateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
  }

  export type AuthorExCreateWithoutBookExampleOnAuthorExampleInput = {
    name: string
  }

  export type AuthorExUncheckedCreateWithoutBookExampleOnAuthorExampleInput = {
    id?: number
    name: string
  }

  export type AuthorExCreateOrConnectWithoutBookExampleOnAuthorExampleInput = {
    where: AuthorExWhereUniqueInput
    create: XOR<AuthorExCreateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
  }

  export type BookExUpsertWithoutBookExampleOnAuthorExampleInput = {
    update: XOR<BookExUpdateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput>
    create: XOR<BookExCreateWithoutBookExampleOnAuthorExampleInput, BookExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
  }

  export type BookExUpdateWithoutBookExampleOnAuthorExampleInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type BookExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorExUpsertWithoutBookExampleOnAuthorExampleInput = {
    update: XOR<AuthorExUpdateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput>
    create: XOR<AuthorExCreateWithoutBookExampleOnAuthorExampleInput, AuthorExUncheckedCreateWithoutBookExampleOnAuthorExampleInput>
  }

  export type AuthorExUpdateWithoutBookExampleOnAuthorExampleInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorExUncheckedUpdateWithoutBookExampleOnAuthorExampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorsCreateWithoutSeriesTvInput = {
    name: string
  }

  export type ActorsUncheckedCreateWithoutSeriesTvInput = {
    id?: number
    name: string
  }

  export type ActorsCreateOrConnectWithoutSeriesTvInput = {
    where: ActorsWhereUniqueInput
    create: XOR<ActorsCreateWithoutSeriesTvInput, ActorsUncheckedCreateWithoutSeriesTvInput>
  }

  export type ActorsUpsertWithWhereUniqueWithoutSeriesTvInput = {
    where: ActorsWhereUniqueInput
    update: XOR<ActorsUpdateWithoutSeriesTvInput, ActorsUncheckedUpdateWithoutSeriesTvInput>
    create: XOR<ActorsCreateWithoutSeriesTvInput, ActorsUncheckedCreateWithoutSeriesTvInput>
  }

  export type ActorsUpdateWithWhereUniqueWithoutSeriesTvInput = {
    where: ActorsWhereUniqueInput
    data: XOR<ActorsUpdateWithoutSeriesTvInput, ActorsUncheckedUpdateWithoutSeriesTvInput>
  }

  export type ActorsUpdateManyWithWhereWithoutSeriesTvInput = {
    where: ActorsScalarWhereInput
    data: XOR<ActorsUpdateManyMutationInput, ActorsUncheckedUpdateManyWithoutActorsInput>
  }

  export type ActorsScalarWhereInput = {
    AND?: Enumerable<ActorsScalarWhereInput>
    OR?: Enumerable<ActorsScalarWhereInput>
    NOT?: Enumerable<ActorsScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type SeriesTvCreateWithoutActorsInput = {
    name: string
  }

  export type SeriesTvUncheckedCreateWithoutActorsInput = {
    id?: number
    name: string
  }

  export type SeriesTvCreateOrConnectWithoutActorsInput = {
    where: SeriesTvWhereUniqueInput
    create: XOR<SeriesTvCreateWithoutActorsInput, SeriesTvUncheckedCreateWithoutActorsInput>
  }

  export type SeriesTvUpsertWithWhereUniqueWithoutActorsInput = {
    where: SeriesTvWhereUniqueInput
    update: XOR<SeriesTvUpdateWithoutActorsInput, SeriesTvUncheckedUpdateWithoutActorsInput>
    create: XOR<SeriesTvCreateWithoutActorsInput, SeriesTvUncheckedCreateWithoutActorsInput>
  }

  export type SeriesTvUpdateWithWhereUniqueWithoutActorsInput = {
    where: SeriesTvWhereUniqueInput
    data: XOR<SeriesTvUpdateWithoutActorsInput, SeriesTvUncheckedUpdateWithoutActorsInput>
  }

  export type SeriesTvUpdateManyWithWhereWithoutActorsInput = {
    where: SeriesTvScalarWhereInput
    data: XOR<SeriesTvUpdateManyMutationInput, SeriesTvUncheckedUpdateManyWithoutSeriesTvInput>
  }

  export type SeriesTvScalarWhereInput = {
    AND?: Enumerable<SeriesTvScalarWhereInput>
    OR?: Enumerable<SeriesTvScalarWhereInput>
    NOT?: Enumerable<SeriesTvScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type KadCreateWithoutDewInput = {
    name: string
  }

  export type KadUncheckedCreateWithoutDewInput = {
    id?: number
    name: string
  }

  export type KadCreateOrConnectWithoutDewInput = {
    where: KadWhereUniqueInput
    create: XOR<KadCreateWithoutDewInput, KadUncheckedCreateWithoutDewInput>
  }

  export type KadUpsertWithoutDewInput = {
    update: XOR<KadUpdateWithoutDewInput, KadUncheckedUpdateWithoutDewInput>
    create: XOR<KadCreateWithoutDewInput, KadUncheckedCreateWithoutDewInput>
  }

  export type KadUpdateWithoutDewInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KadUncheckedUpdateWithoutDewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DewCreateWithoutKadInput = {
    name: string
  }

  export type DewUncheckedCreateWithoutKadInput = {
    id?: number
    name: string
  }

  export type DewCreateOrConnectWithoutKadInput = {
    where: DewWhereUniqueInput
    create: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
  }

  export type DewUpsertWithoutKadInput = {
    update: XOR<DewUpdateWithoutKadInput, DewUncheckedUpdateWithoutKadInput>
    create: XOR<DewCreateWithoutKadInput, DewUncheckedCreateWithoutKadInput>
  }

  export type DewUpdateWithoutKadInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DewUncheckedUpdateWithoutKadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type QuizeQuestionCreateWithoutQuizeCategoryInput = {
    question: string
    choices?: QuizeChoiceCreateNestedManyWithoutQuizeQuestionInput
    answer?: QuizeAnswerCreateNestedOneWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput = {
    id?: number
    question: string
    choices?: QuizeChoiceUncheckedCreateNestedManyWithoutQuizeQuestionInput
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionCreateOrConnectWithoutQuizeCategoryInput = {
    where: QuizeQuestionWhereUniqueInput
    create: XOR<QuizeQuestionCreateWithoutQuizeCategoryInput, QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>
  }

  export type QuizeQuestionCreateManyQuizeCategoryInputEnvelope = {
    data: Enumerable<QuizeQuestionCreateManyQuizeCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizeQuestionUpsertWithWhereUniqueWithoutQuizeCategoryInput = {
    where: QuizeQuestionWhereUniqueInput
    update: XOR<QuizeQuestionUpdateWithoutQuizeCategoryInput, QuizeQuestionUncheckedUpdateWithoutQuizeCategoryInput>
    create: XOR<QuizeQuestionCreateWithoutQuizeCategoryInput, QuizeQuestionUncheckedCreateWithoutQuizeCategoryInput>
  }

  export type QuizeQuestionUpdateWithWhereUniqueWithoutQuizeCategoryInput = {
    where: QuizeQuestionWhereUniqueInput
    data: XOR<QuizeQuestionUpdateWithoutQuizeCategoryInput, QuizeQuestionUncheckedUpdateWithoutQuizeCategoryInput>
  }

  export type QuizeQuestionUpdateManyWithWhereWithoutQuizeCategoryInput = {
    where: QuizeQuestionScalarWhereInput
    data: XOR<QuizeQuestionUpdateManyMutationInput, QuizeQuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuizeQuestionScalarWhereInput = {
    AND?: Enumerable<QuizeQuestionScalarWhereInput>
    OR?: Enumerable<QuizeQuestionScalarWhereInput>
    NOT?: Enumerable<QuizeQuestionScalarWhereInput>
    id?: IntFilter | number
    question?: StringFilter | string
    quizeCategoryId?: IntNullableFilter | number | null
    quizeAnswerId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type QuizeCategoryCreateWithoutQuestionsInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeCategoryUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeCategoryCreateOrConnectWithoutQuestionsInput = {
    where: QuizeCategoryWhereUniqueInput
    create: XOR<QuizeCategoryCreateWithoutQuestionsInput, QuizeCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizeChoiceCreateWithoutQuizeQuestionInput = {
    choice: string
    quizeAnswer?: QuizeAnswerCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput = {
    id?: number
    choice: string
    quizeAnswer?: QuizeAnswerUncheckedCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceCreateOrConnectWithoutQuizeQuestionInput = {
    where: QuizeChoiceWhereUniqueInput
    create: XOR<QuizeChoiceCreateWithoutQuizeQuestionInput, QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>
  }

  export type QuizeChoiceCreateManyQuizeQuestionInputEnvelope = {
    data: Enumerable<QuizeChoiceCreateManyQuizeQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuizeAnswerCreateWithoutQuizeQuestionInput = {
    answer: string
    choice: QuizeChoiceCreateNestedOneWithoutQuizeAnswerInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerUncheckedCreateWithoutQuizeQuestionInput = {
    id?: number
    answer: string
    choiceId: number
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerCreateOrConnectWithoutQuizeQuestionInput = {
    where: QuizeAnswerWhereUniqueInput
    create: XOR<QuizeAnswerCreateWithoutQuizeQuestionInput, QuizeAnswerUncheckedCreateWithoutQuizeQuestionInput>
  }

  export type QuizeGameRoundCreateWithoutQuestionInput = {
    user: string
    score: number
    answer: QuizeAnswerCreateNestedOneWithoutRoundInput
    choice: QuizeChoiceCreateNestedOneWithoutRoundInput
  }

  export type QuizeGameRoundUncheckedCreateWithoutQuestionInput = {
    id?: number
    user: string
    score: number
    answerId: number
    choiceId: number
  }

  export type QuizeGameRoundCreateOrConnectWithoutQuestionInput = {
    where: QuizeGameRoundWhereUniqueInput
    create: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
  }

  export type QuizeCategoryUpsertWithoutQuestionsInput = {
    update: XOR<QuizeCategoryUpdateWithoutQuestionsInput, QuizeCategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizeCategoryCreateWithoutQuestionsInput, QuizeCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizeCategoryUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeCategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceUpsertWithWhereUniqueWithoutQuizeQuestionInput = {
    where: QuizeChoiceWhereUniqueInput
    update: XOR<QuizeChoiceUpdateWithoutQuizeQuestionInput, QuizeChoiceUncheckedUpdateWithoutQuizeQuestionInput>
    create: XOR<QuizeChoiceCreateWithoutQuizeQuestionInput, QuizeChoiceUncheckedCreateWithoutQuizeQuestionInput>
  }

  export type QuizeChoiceUpdateWithWhereUniqueWithoutQuizeQuestionInput = {
    where: QuizeChoiceWhereUniqueInput
    data: XOR<QuizeChoiceUpdateWithoutQuizeQuestionInput, QuizeChoiceUncheckedUpdateWithoutQuizeQuestionInput>
  }

  export type QuizeChoiceUpdateManyWithWhereWithoutQuizeQuestionInput = {
    where: QuizeChoiceScalarWhereInput
    data: XOR<QuizeChoiceUpdateManyMutationInput, QuizeChoiceUncheckedUpdateManyWithoutChoicesInput>
  }

  export type QuizeChoiceScalarWhereInput = {
    AND?: Enumerable<QuizeChoiceScalarWhereInput>
    OR?: Enumerable<QuizeChoiceScalarWhereInput>
    NOT?: Enumerable<QuizeChoiceScalarWhereInput>
    id?: IntFilter | number
    choice?: StringFilter | string
    questionId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type QuizeAnswerUpsertWithoutQuizeQuestionInput = {
    update: XOR<QuizeAnswerUpdateWithoutQuizeQuestionInput, QuizeAnswerUncheckedUpdateWithoutQuizeQuestionInput>
    create: XOR<QuizeAnswerCreateWithoutQuizeQuestionInput, QuizeAnswerUncheckedCreateWithoutQuizeQuestionInput>
  }

  export type QuizeAnswerUpdateWithoutQuizeQuestionInput = {
    answer?: StringFieldUpdateOperationsInput | string
    choice?: QuizeChoiceUpdateOneRequiredWithoutQuizeAnswerNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeAnswerUncheckedUpdateWithoutQuizeQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    choiceId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeGameRoundUpsertWithoutQuestionInput = {
    update: XOR<QuizeGameRoundUpdateWithoutQuestionInput, QuizeGameRoundUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizeGameRoundCreateWithoutQuestionInput, QuizeGameRoundUncheckedCreateWithoutQuestionInput>
  }

  export type QuizeGameRoundUpdateWithoutQuestionInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answer?: QuizeAnswerUpdateOneRequiredWithoutRoundNestedInput
    choice?: QuizeChoiceUpdateOneRequiredWithoutRoundNestedInput
  }

  export type QuizeGameRoundUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizeQuestionCreateWithoutChoicesInput = {
    question: string
    quizeCategory?: QuizeCategoryCreateNestedOneWithoutQuestionsInput
    answer?: QuizeAnswerCreateNestedOneWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionUncheckedCreateWithoutChoicesInput = {
    id?: number
    question: string
    quizeCategoryId?: number | null
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionCreateOrConnectWithoutChoicesInput = {
    where: QuizeQuestionWhereUniqueInput
    create: XOR<QuizeQuestionCreateWithoutChoicesInput, QuizeQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type QuizeAnswerCreateWithoutChoiceInput = {
    answer: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutAnswerInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerUncheckedCreateWithoutChoiceInput = {
    id?: number
    answer: string
    quizeQuestion?: QuizeQuestionUncheckedCreateNestedOneWithoutAnswerInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutAnswerInput
  }

  export type QuizeAnswerCreateOrConnectWithoutChoiceInput = {
    where: QuizeAnswerWhereUniqueInput
    create: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
  }

  export type QuizeGameRoundCreateWithoutChoiceInput = {
    user: string
    score: number
    answer: QuizeAnswerCreateNestedOneWithoutRoundInput
    question: QuizeQuestionCreateNestedOneWithoutRoundInput
  }

  export type QuizeGameRoundUncheckedCreateWithoutChoiceInput = {
    id?: number
    user: string
    score: number
    answerId: number
    questionId: number
  }

  export type QuizeGameRoundCreateOrConnectWithoutChoiceInput = {
    where: QuizeGameRoundWhereUniqueInput
    create: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
  }

  export type QuizeQuestionUpsertWithoutChoicesInput = {
    update: XOR<QuizeQuestionUpdateWithoutChoicesInput, QuizeQuestionUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuizeQuestionCreateWithoutChoicesInput, QuizeQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type QuizeQuestionUpdateWithoutChoicesInput = {
    question?: StringFieldUpdateOperationsInput | string
    quizeCategory?: QuizeCategoryUpdateOneWithoutQuestionsNestedInput
    answer?: QuizeAnswerUpdateOneWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeAnswerUpsertWithoutChoiceInput = {
    update: XOR<QuizeAnswerUpdateWithoutChoiceInput, QuizeAnswerUncheckedUpdateWithoutChoiceInput>
    create: XOR<QuizeAnswerCreateWithoutChoiceInput, QuizeAnswerUncheckedCreateWithoutChoiceInput>
  }

  export type QuizeAnswerUpdateWithoutChoiceInput = {
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutAnswerNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeAnswerUncheckedUpdateWithoutChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUncheckedUpdateOneWithoutAnswerNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutAnswerNestedInput
  }

  export type QuizeGameRoundUpsertWithoutChoiceInput = {
    update: XOR<QuizeGameRoundUpdateWithoutChoiceInput, QuizeGameRoundUncheckedUpdateWithoutChoiceInput>
    create: XOR<QuizeGameRoundCreateWithoutChoiceInput, QuizeGameRoundUncheckedCreateWithoutChoiceInput>
  }

  export type QuizeGameRoundUpdateWithoutChoiceInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answer?: QuizeAnswerUpdateOneRequiredWithoutRoundNestedInput
    question?: QuizeQuestionUpdateOneRequiredWithoutRoundNestedInput
  }

  export type QuizeGameRoundUncheckedUpdateWithoutChoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizeQuestionCreateWithoutAnswerInput = {
    question: string
    quizeCategory?: QuizeCategoryCreateNestedOneWithoutQuestionsInput
    choices?: QuizeChoiceCreateNestedManyWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionUncheckedCreateWithoutAnswerInput = {
    id?: number
    question: string
    quizeCategoryId?: number | null
    choices?: QuizeChoiceUncheckedCreateNestedManyWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type QuizeQuestionCreateOrConnectWithoutAnswerInput = {
    where: QuizeQuestionWhereUniqueInput
    create: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
  }

  export type QuizeChoiceCreateWithoutQuizeAnswerInput = {
    choice: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutChoicesInput
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceUncheckedCreateWithoutQuizeAnswerInput = {
    id?: number
    choice: string
    questionId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    round?: QuizeGameRoundUncheckedCreateNestedOneWithoutChoiceInput
  }

  export type QuizeChoiceCreateOrConnectWithoutQuizeAnswerInput = {
    where: QuizeChoiceWhereUniqueInput
    create: XOR<QuizeChoiceCreateWithoutQuizeAnswerInput, QuizeChoiceUncheckedCreateWithoutQuizeAnswerInput>
  }

  export type QuizeGameRoundCreateWithoutAnswerInput = {
    user: string
    score: number
    question: QuizeQuestionCreateNestedOneWithoutRoundInput
    choice: QuizeChoiceCreateNestedOneWithoutRoundInput
  }

  export type QuizeGameRoundUncheckedCreateWithoutAnswerInput = {
    id?: number
    user: string
    score: number
    questionId: number
    choiceId: number
  }

  export type QuizeGameRoundCreateOrConnectWithoutAnswerInput = {
    where: QuizeGameRoundWhereUniqueInput
    create: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
  }

  export type QuizeQuestionUpsertWithoutAnswerInput = {
    update: XOR<QuizeQuestionUpdateWithoutAnswerInput, QuizeQuestionUncheckedUpdateWithoutAnswerInput>
    create: XOR<QuizeQuestionCreateWithoutAnswerInput, QuizeQuestionUncheckedCreateWithoutAnswerInput>
  }

  export type QuizeQuestionUpdateWithoutAnswerInput = {
    question?: StringFieldUpdateOperationsInput | string
    quizeCategory?: QuizeCategoryUpdateOneWithoutQuestionsNestedInput
    choices?: QuizeChoiceUpdateManyWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    choices?: QuizeChoiceUncheckedUpdateManyWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeChoiceUpsertWithoutQuizeAnswerInput = {
    update: XOR<QuizeChoiceUpdateWithoutQuizeAnswerInput, QuizeChoiceUncheckedUpdateWithoutQuizeAnswerInput>
    create: XOR<QuizeChoiceCreateWithoutQuizeAnswerInput, QuizeChoiceUncheckedCreateWithoutQuizeAnswerInput>
  }

  export type QuizeChoiceUpdateWithoutQuizeAnswerInput = {
    choice?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutChoicesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeChoiceUncheckedUpdateWithoutQuizeAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeGameRoundUpsertWithoutAnswerInput = {
    update: XOR<QuizeGameRoundUpdateWithoutAnswerInput, QuizeGameRoundUncheckedUpdateWithoutAnswerInput>
    create: XOR<QuizeGameRoundCreateWithoutAnswerInput, QuizeGameRoundUncheckedCreateWithoutAnswerInput>
  }

  export type QuizeGameRoundUpdateWithoutAnswerInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    question?: QuizeQuestionUpdateOneRequiredWithoutRoundNestedInput
    choice?: QuizeChoiceUpdateOneRequiredWithoutRoundNestedInput
  }

  export type QuizeGameRoundUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    choiceId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizeAnswerCreateWithoutRoundInput = {
    answer: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutAnswerInput
    choice: QuizeChoiceCreateNestedOneWithoutQuizeAnswerInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeAnswerUncheckedCreateWithoutRoundInput = {
    id?: number
    answer: string
    quizeQuestion?: QuizeQuestionUncheckedCreateNestedOneWithoutAnswerInput
    choiceId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeAnswerCreateOrConnectWithoutRoundInput = {
    where: QuizeAnswerWhereUniqueInput
    create: XOR<QuizeAnswerCreateWithoutRoundInput, QuizeAnswerUncheckedCreateWithoutRoundInput>
  }

  export type QuizeQuestionCreateWithoutRoundInput = {
    question: string
    quizeCategory?: QuizeCategoryCreateNestedOneWithoutQuestionsInput
    choices?: QuizeChoiceCreateNestedManyWithoutQuizeQuestionInput
    answer?: QuizeAnswerCreateNestedOneWithoutQuizeQuestionInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeQuestionUncheckedCreateWithoutRoundInput = {
    id?: number
    question: string
    quizeCategoryId?: number | null
    choices?: QuizeChoiceUncheckedCreateNestedManyWithoutQuizeQuestionInput
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeQuestionCreateOrConnectWithoutRoundInput = {
    where: QuizeQuestionWhereUniqueInput
    create: XOR<QuizeQuestionCreateWithoutRoundInput, QuizeQuestionUncheckedCreateWithoutRoundInput>
  }

  export type QuizeChoiceCreateWithoutRoundInput = {
    choice: string
    quizeQuestion?: QuizeQuestionCreateNestedOneWithoutChoicesInput
    quizeAnswer?: QuizeAnswerCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeChoiceUncheckedCreateWithoutRoundInput = {
    id?: number
    choice: string
    questionId?: number | null
    quizeAnswer?: QuizeAnswerUncheckedCreateNestedOneWithoutChoiceInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeChoiceCreateOrConnectWithoutRoundInput = {
    where: QuizeChoiceWhereUniqueInput
    create: XOR<QuizeChoiceCreateWithoutRoundInput, QuizeChoiceUncheckedCreateWithoutRoundInput>
  }

  export type QuizeAnswerUpsertWithoutRoundInput = {
    update: XOR<QuizeAnswerUpdateWithoutRoundInput, QuizeAnswerUncheckedUpdateWithoutRoundInput>
    create: XOR<QuizeAnswerCreateWithoutRoundInput, QuizeAnswerUncheckedCreateWithoutRoundInput>
  }

  export type QuizeAnswerUpdateWithoutRoundInput = {
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutAnswerNestedInput
    choice?: QuizeChoiceUpdateOneRequiredWithoutQuizeAnswerNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeAnswerUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUncheckedUpdateOneWithoutAnswerNestedInput
    choiceId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeQuestionUpsertWithoutRoundInput = {
    update: XOR<QuizeQuestionUpdateWithoutRoundInput, QuizeQuestionUncheckedUpdateWithoutRoundInput>
    create: XOR<QuizeQuestionCreateWithoutRoundInput, QuizeQuestionUncheckedCreateWithoutRoundInput>
  }

  export type QuizeQuestionUpdateWithoutRoundInput = {
    question?: StringFieldUpdateOperationsInput | string
    quizeCategory?: QuizeCategoryUpdateOneWithoutQuestionsNestedInput
    choices?: QuizeChoiceUpdateManyWithoutQuizeQuestionNestedInput
    answer?: QuizeAnswerUpdateOneWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeQuestionUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    choices?: QuizeChoiceUncheckedUpdateManyWithoutQuizeQuestionNestedInput
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceUpsertWithoutRoundInput = {
    update: XOR<QuizeChoiceUpdateWithoutRoundInput, QuizeChoiceUncheckedUpdateWithoutRoundInput>
    create: XOR<QuizeChoiceCreateWithoutRoundInput, QuizeChoiceUncheckedCreateWithoutRoundInput>
  }

  export type QuizeChoiceUpdateWithoutRoundInput = {
    choice?: StringFieldUpdateOperationsInput | string
    quizeQuestion?: QuizeQuestionUpdateOneWithoutChoicesNestedInput
    quizeAnswer?: QuizeAnswerUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    quizeAnswer?: QuizeAnswerUncheckedUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutMainCompanyInput = {
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    machines?: MachineCreateNestedManyWithoutBranchInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUncheckedCreateWithoutMainCompanyInput = {
    id?: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    machines?: MachineUncheckedCreateNestedManyWithoutBranchInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchCreateOrConnectWithoutMainCompanyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMainCompanyInput, BranchUncheckedCreateWithoutMainCompanyInput>
  }

  export type BranchCreateManyMainCompanyInputEnvelope = {
    data: Enumerable<BranchCreateManyMainCompanyInput>
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithWhereUniqueWithoutMainCompanyInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutMainCompanyInput, BranchUncheckedUpdateWithoutMainCompanyInput>
    create: XOR<BranchCreateWithoutMainCompanyInput, BranchUncheckedCreateWithoutMainCompanyInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutMainCompanyInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutMainCompanyInput, BranchUncheckedUpdateWithoutMainCompanyInput>
  }

  export type BranchUpdateManyWithWhereWithoutMainCompanyInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutBranchIdsInput>
  }

  export type BranchScalarWhereInput = {
    AND?: Enumerable<BranchScalarWhereInput>
    OR?: Enumerable<BranchScalarWhereInput>
    NOT?: Enumerable<BranchScalarWhereInput>
    id?: IntFilter | number
    ownerName?: StringFilter | string
    tel?: IntFilter | number
    address?: StringFilter | string
    area?: FloatFilter | number
    totolMachine?: IntFilter | number
    mainCompanyId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MachineCreateWithoutBranchInput = {
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    repairHistories?: RepairHistoryCreateNestedManyWithoutMachineInput
    washHistory?: WashHistoryCreateNestedOneWithoutMachinesInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutBranchInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    repairHistories?: RepairHistoryUncheckedCreateNestedManyWithoutMachineInput
    washHistoryId?: number | null
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutBranchInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutBranchInput, MachineUncheckedCreateWithoutBranchInput>
  }

  export type MachineCreateManyBranchInputEnvelope = {
    data: Enumerable<MachineCreateManyBranchInput>
    skipDuplicates?: boolean
  }

  export type MainCompanyCreateWithoutBranchIdsInput = {
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MainCompanyUncheckedCreateWithoutBranchIdsInput = {
    id?: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MainCompanyCreateOrConnectWithoutBranchIdsInput = {
    where: MainCompanyWhereUniqueInput
    create: XOR<MainCompanyCreateWithoutBranchIdsInput, MainCompanyUncheckedCreateWithoutBranchIdsInput>
  }

  export type MachineUpsertWithWhereUniqueWithoutBranchInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutBranchInput, MachineUncheckedUpdateWithoutBranchInput>
    create: XOR<MachineCreateWithoutBranchInput, MachineUncheckedCreateWithoutBranchInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutBranchInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutBranchInput, MachineUncheckedUpdateWithoutBranchInput>
  }

  export type MachineUpdateManyWithWhereWithoutBranchInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutMachinesInput>
  }

  export type MachineScalarWhereInput = {
    AND?: Enumerable<MachineScalarWhereInput>
    OR?: Enumerable<MachineScalarWhereInput>
    NOT?: Enumerable<MachineScalarWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    size?: StringFilter | string
    category?: StringFilter | string
    model?: StringFilter | string
    mfg?: StringFilter | string
    insurance?: StringFilter | string
    branchId?: IntNullableFilter | number | null
    washHistoryId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MainCompanyUpsertWithoutBranchIdsInput = {
    update: XOR<MainCompanyUpdateWithoutBranchIdsInput, MainCompanyUncheckedUpdateWithoutBranchIdsInput>
    create: XOR<MainCompanyCreateWithoutBranchIdsInput, MainCompanyUncheckedCreateWithoutBranchIdsInput>
  }

  export type MainCompanyUpdateWithoutBranchIdsInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MainCompanyUncheckedUpdateWithoutBranchIdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutMachinesInput = {
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    mainCompany?: MainCompanyCreateNestedOneWithoutBranchIdsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUncheckedCreateWithoutMachinesInput = {
    id?: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    mainCompanyId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchCreateOrConnectWithoutMachinesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutMachinesInput, BranchUncheckedCreateWithoutMachinesInput>
  }

  export type RepairHistoryCreateWithoutMachineInput = {
    time: number
    detail: RepairDetailCreateNestedOneWithoutRepairHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUncheckedCreateWithoutMachineInput = {
    id?: number
    time: number
    repairDetailId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryCreateOrConnectWithoutMachineInput = {
    where: RepairHistoryWhereUniqueInput
    create: XOR<RepairHistoryCreateWithoutMachineInput, RepairHistoryUncheckedCreateWithoutMachineInput>
  }

  export type RepairHistoryCreateManyMachineInputEnvelope = {
    data: Enumerable<RepairHistoryCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type WashHistoryCreateWithoutMachinesInput = {
    date: string
    price: number
    programs?: ProgramCreateNestedManyWithoutWashHistoryInput
    users?: washUserCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUncheckedCreateWithoutMachinesInput = {
    id?: number
    date: string
    price: number
    programs?: ProgramUncheckedCreateNestedManyWithoutWashHistoryInput
    users?: washUserUncheckedCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryCreateOrConnectWithoutMachinesInput = {
    where: WashHistoryWhereUniqueInput
    create: XOR<WashHistoryCreateWithoutMachinesInput, WashHistoryUncheckedCreateWithoutMachinesInput>
  }

  export type MachineOnProgramCreateWithoutMachineInput = {
    program: ProgramCreateNestedOneWithoutMachineOnProgramsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramUncheckedCreateWithoutMachineInput = {
    id?: number
    programId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramCreateOrConnectWithoutMachineInput = {
    where: MachineOnProgramWhereUniqueInput
    create: XOR<MachineOnProgramCreateWithoutMachineInput, MachineOnProgramUncheckedCreateWithoutMachineInput>
  }

  export type MachineOnProgramCreateManyMachineInputEnvelope = {
    data: Enumerable<MachineOnProgramCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutMachinesInput = {
    update: XOR<BranchUpdateWithoutMachinesInput, BranchUncheckedUpdateWithoutMachinesInput>
    create: XOR<BranchCreateWithoutMachinesInput, BranchUncheckedCreateWithoutMachinesInput>
  }

  export type BranchUpdateWithoutMachinesInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    mainCompany?: MainCompanyUpdateOneWithoutBranchIdsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    mainCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUpsertWithWhereUniqueWithoutMachineInput = {
    where: RepairHistoryWhereUniqueInput
    update: XOR<RepairHistoryUpdateWithoutMachineInput, RepairHistoryUncheckedUpdateWithoutMachineInput>
    create: XOR<RepairHistoryCreateWithoutMachineInput, RepairHistoryUncheckedCreateWithoutMachineInput>
  }

  export type RepairHistoryUpdateWithWhereUniqueWithoutMachineInput = {
    where: RepairHistoryWhereUniqueInput
    data: XOR<RepairHistoryUpdateWithoutMachineInput, RepairHistoryUncheckedUpdateWithoutMachineInput>
  }

  export type RepairHistoryUpdateManyWithWhereWithoutMachineInput = {
    where: RepairHistoryScalarWhereInput
    data: XOR<RepairHistoryUpdateManyMutationInput, RepairHistoryUncheckedUpdateManyWithoutRepairHistoriesInput>
  }

  export type RepairHistoryScalarWhereInput = {
    AND?: Enumerable<RepairHistoryScalarWhereInput>
    OR?: Enumerable<RepairHistoryScalarWhereInput>
    NOT?: Enumerable<RepairHistoryScalarWhereInput>
    id?: IntFilter | number
    time?: IntFilter | number
    machineId?: IntNullableFilter | number | null
    repairDetailId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WashHistoryUpsertWithoutMachinesInput = {
    update: XOR<WashHistoryUpdateWithoutMachinesInput, WashHistoryUncheckedUpdateWithoutMachinesInput>
    create: XOR<WashHistoryCreateWithoutMachinesInput, WashHistoryUncheckedCreateWithoutMachinesInput>
  }

  export type WashHistoryUpdateWithoutMachinesInput = {
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUncheckedUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUncheckedUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUpsertWithWhereUniqueWithoutMachineInput = {
    where: MachineOnProgramWhereUniqueInput
    update: XOR<MachineOnProgramUpdateWithoutMachineInput, MachineOnProgramUncheckedUpdateWithoutMachineInput>
    create: XOR<MachineOnProgramCreateWithoutMachineInput, MachineOnProgramUncheckedCreateWithoutMachineInput>
  }

  export type MachineOnProgramUpdateWithWhereUniqueWithoutMachineInput = {
    where: MachineOnProgramWhereUniqueInput
    data: XOR<MachineOnProgramUpdateWithoutMachineInput, MachineOnProgramUncheckedUpdateWithoutMachineInput>
  }

  export type MachineOnProgramUpdateManyWithWhereWithoutMachineInput = {
    where: MachineOnProgramScalarWhereInput
    data: XOR<MachineOnProgramUpdateManyMutationInput, MachineOnProgramUncheckedUpdateManyWithoutMachineOnProgramsInput>
  }

  export type MachineOnProgramScalarWhereInput = {
    AND?: Enumerable<MachineOnProgramScalarWhereInput>
    OR?: Enumerable<MachineOnProgramScalarWhereInput>
    NOT?: Enumerable<MachineOnProgramScalarWhereInput>
    id?: IntFilter | number
    machineId?: IntFilter | number
    programId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type ProcessTypeCreateWithoutProgramInput = {
    description: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeUncheckedCreateWithoutProgramInput = {
    id?: number
    description: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeCreateOrConnectWithoutProgramInput = {
    where: ProcessTypeWhereUniqueInput
    create: XOR<ProcessTypeCreateWithoutProgramInput, ProcessTypeUncheckedCreateWithoutProgramInput>
  }

  export type ProcessTypeCreateManyProgramInputEnvelope = {
    data: Enumerable<ProcessTypeCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type WashHistoryCreateWithoutProgramsInput = {
    date: string
    price: number
    machines?: MachineCreateNestedManyWithoutWashHistoryInput
    users?: washUserCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUncheckedCreateWithoutProgramsInput = {
    id?: number
    date: string
    price: number
    machines?: MachineUncheckedCreateNestedManyWithoutWashHistoryInput
    users?: washUserUncheckedCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryCreateOrConnectWithoutProgramsInput = {
    where: WashHistoryWhereUniqueInput
    create: XOR<WashHistoryCreateWithoutProgramsInput, WashHistoryUncheckedCreateWithoutProgramsInput>
  }

  export type MachineOnProgramCreateWithoutProgramInput = {
    machine: MachineCreateNestedOneWithoutMachineOnProgramsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramUncheckedCreateWithoutProgramInput = {
    id?: number
    machineId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramCreateOrConnectWithoutProgramInput = {
    where: MachineOnProgramWhereUniqueInput
    create: XOR<MachineOnProgramCreateWithoutProgramInput, MachineOnProgramUncheckedCreateWithoutProgramInput>
  }

  export type MachineOnProgramCreateManyProgramInputEnvelope = {
    data: Enumerable<MachineOnProgramCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type ProcessTypeUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProcessTypeWhereUniqueInput
    update: XOR<ProcessTypeUpdateWithoutProgramInput, ProcessTypeUncheckedUpdateWithoutProgramInput>
    create: XOR<ProcessTypeCreateWithoutProgramInput, ProcessTypeUncheckedCreateWithoutProgramInput>
  }

  export type ProcessTypeUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProcessTypeWhereUniqueInput
    data: XOR<ProcessTypeUpdateWithoutProgramInput, ProcessTypeUncheckedUpdateWithoutProgramInput>
  }

  export type ProcessTypeUpdateManyWithWhereWithoutProgramInput = {
    where: ProcessTypeScalarWhereInput
    data: XOR<ProcessTypeUpdateManyMutationInput, ProcessTypeUncheckedUpdateManyWithoutProcessesInput>
  }

  export type ProcessTypeScalarWhereInput = {
    AND?: Enumerable<ProcessTypeScalarWhereInput>
    OR?: Enumerable<ProcessTypeScalarWhereInput>
    NOT?: Enumerable<ProcessTypeScalarWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    programId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type WashHistoryUpsertWithoutProgramsInput = {
    update: XOR<WashHistoryUpdateWithoutProgramsInput, WashHistoryUncheckedUpdateWithoutProgramsInput>
    create: XOR<WashHistoryCreateWithoutProgramsInput, WashHistoryUncheckedCreateWithoutProgramsInput>
  }

  export type WashHistoryUpdateWithoutProgramsInput = {
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    machines?: MachineUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    machines?: MachineUncheckedUpdateManyWithoutWashHistoryNestedInput
    users?: washUserUncheckedUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUpsertWithWhereUniqueWithoutProgramInput = {
    where: MachineOnProgramWhereUniqueInput
    update: XOR<MachineOnProgramUpdateWithoutProgramInput, MachineOnProgramUncheckedUpdateWithoutProgramInput>
    create: XOR<MachineOnProgramCreateWithoutProgramInput, MachineOnProgramUncheckedCreateWithoutProgramInput>
  }

  export type MachineOnProgramUpdateWithWhereUniqueWithoutProgramInput = {
    where: MachineOnProgramWhereUniqueInput
    data: XOR<MachineOnProgramUpdateWithoutProgramInput, MachineOnProgramUncheckedUpdateWithoutProgramInput>
  }

  export type MachineOnProgramUpdateManyWithWhereWithoutProgramInput = {
    where: MachineOnProgramScalarWhereInput
    data: XOR<MachineOnProgramUpdateManyMutationInput, MachineOnProgramUncheckedUpdateManyWithoutMachineOnProgramsInput>
  }

  export type MachineCreateWithoutMachineOnProgramsInput = {
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branch?: BranchCreateNestedOneWithoutMachinesInput
    repairHistories?: RepairHistoryCreateNestedManyWithoutMachineInput
    washHistory?: WashHistoryCreateNestedOneWithoutMachinesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutMachineOnProgramsInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    repairHistories?: RepairHistoryUncheckedCreateNestedManyWithoutMachineInput
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutMachineOnProgramsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutMachineOnProgramsInput, MachineUncheckedCreateWithoutMachineOnProgramsInput>
  }

  export type ProgramCreateWithoutMachineOnProgramsInput = {
    duration: number
    price: number
    processes?: ProcessTypeCreateNestedManyWithoutProgramInput
    washHistory?: WashHistoryCreateNestedOneWithoutProgramsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUncheckedCreateWithoutMachineOnProgramsInput = {
    id?: number
    duration: number
    price: number
    processes?: ProcessTypeUncheckedCreateNestedManyWithoutProgramInput
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutMachineOnProgramsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutMachineOnProgramsInput, ProgramUncheckedCreateWithoutMachineOnProgramsInput>
  }

  export type MachineUpsertWithoutMachineOnProgramsInput = {
    update: XOR<MachineUpdateWithoutMachineOnProgramsInput, MachineUncheckedUpdateWithoutMachineOnProgramsInput>
    create: XOR<MachineCreateWithoutMachineOnProgramsInput, MachineUncheckedCreateWithoutMachineOnProgramsInput>
  }

  export type MachineUpdateWithoutMachineOnProgramsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneWithoutMachinesNestedInput
    repairHistories?: RepairHistoryUpdateManyWithoutMachineNestedInput
    washHistory?: WashHistoryUpdateOneWithoutMachinesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutMachineOnProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    repairHistories?: RepairHistoryUncheckedUpdateManyWithoutMachineNestedInput
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpsertWithoutMachineOnProgramsInput = {
    update: XOR<ProgramUpdateWithoutMachineOnProgramsInput, ProgramUncheckedUpdateWithoutMachineOnProgramsInput>
    create: XOR<ProgramCreateWithoutMachineOnProgramsInput, ProgramUncheckedCreateWithoutMachineOnProgramsInput>
  }

  export type ProgramUpdateWithoutMachineOnProgramsInput = {
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUpdateManyWithoutProgramNestedInput
    washHistory?: WashHistoryUpdateOneWithoutProgramsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateWithoutMachineOnProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUncheckedUpdateManyWithoutProgramNestedInput
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateWithoutProcessesInput = {
    duration: number
    price: number
    washHistory?: WashHistoryCreateNestedOneWithoutProgramsInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUncheckedCreateWithoutProcessesInput = {
    id?: number
    duration: number
    price: number
    washHistoryId?: number | null
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutProcessesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProcessesInput, ProgramUncheckedCreateWithoutProcessesInput>
  }

  export type ProgramUpsertWithoutProcessesInput = {
    update: XOR<ProgramUpdateWithoutProcessesInput, ProgramUncheckedUpdateWithoutProcessesInput>
    create: XOR<ProgramCreateWithoutProcessesInput, ProgramUncheckedCreateWithoutProcessesInput>
  }

  export type ProgramUpdateWithoutProcessesInput = {
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    washHistory?: WashHistoryUpdateOneWithoutProgramsNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateWithoutProcessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateWithoutRepairHistoriesInput = {
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branch?: BranchCreateNestedOneWithoutMachinesInput
    washHistory?: WashHistoryCreateNestedOneWithoutMachinesInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutRepairHistoriesInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    washHistoryId?: number | null
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutRepairHistoriesInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutRepairHistoriesInput, MachineUncheckedCreateWithoutRepairHistoriesInput>
  }

  export type RepairDetailCreateWithoutRepairHistoryInput = {
    date: string
    damage: string
    cause: string
    machanics: string
    createAt?: Date | string
    updateAt?: Date | string
    repairHistoryId: number
  }

  export type RepairDetailUncheckedCreateWithoutRepairHistoryInput = {
    id?: number
    date: string
    damage: string
    cause: string
    machanics: string
    createAt?: Date | string
    updateAt?: Date | string
    repairHistoryId: number
  }

  export type RepairDetailCreateOrConnectWithoutRepairHistoryInput = {
    where: RepairDetailWhereUniqueInput
    create: XOR<RepairDetailCreateWithoutRepairHistoryInput, RepairDetailUncheckedCreateWithoutRepairHistoryInput>
  }

  export type MachineUpsertWithoutRepairHistoriesInput = {
    update: XOR<MachineUpdateWithoutRepairHistoriesInput, MachineUncheckedUpdateWithoutRepairHistoriesInput>
    create: XOR<MachineCreateWithoutRepairHistoriesInput, MachineUncheckedCreateWithoutRepairHistoriesInput>
  }

  export type MachineUpdateWithoutRepairHistoriesInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneWithoutMachinesNestedInput
    washHistory?: WashHistoryUpdateOneWithoutMachinesNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutRepairHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairDetailUpsertWithoutRepairHistoryInput = {
    update: XOR<RepairDetailUpdateWithoutRepairHistoryInput, RepairDetailUncheckedUpdateWithoutRepairHistoryInput>
    create: XOR<RepairDetailCreateWithoutRepairHistoryInput, RepairDetailUncheckedCreateWithoutRepairHistoryInput>
  }

  export type RepairDetailUpdateWithoutRepairHistoryInput = {
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairDetailUncheckedUpdateWithoutRepairHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    machanics?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    repairHistoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RepairHistoryCreateWithoutDetailInput = {
    time: number
    machine?: MachineCreateNestedOneWithoutRepairHistoriesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUncheckedCreateWithoutDetailInput = {
    id?: number
    time: number
    machineId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryCreateOrConnectWithoutDetailInput = {
    where: RepairHistoryWhereUniqueInput
    create: XOR<RepairHistoryCreateWithoutDetailInput, RepairHistoryUncheckedCreateWithoutDetailInput>
  }

  export type RepairHistoryCreateManyDetailInputEnvelope = {
    data: Enumerable<RepairHistoryCreateManyDetailInput>
    skipDuplicates?: boolean
  }

  export type RepairHistoryUpsertWithWhereUniqueWithoutDetailInput = {
    where: RepairHistoryWhereUniqueInput
    update: XOR<RepairHistoryUpdateWithoutDetailInput, RepairHistoryUncheckedUpdateWithoutDetailInput>
    create: XOR<RepairHistoryCreateWithoutDetailInput, RepairHistoryUncheckedCreateWithoutDetailInput>
  }

  export type RepairHistoryUpdateWithWhereUniqueWithoutDetailInput = {
    where: RepairHistoryWhereUniqueInput
    data: XOR<RepairHistoryUpdateWithoutDetailInput, RepairHistoryUncheckedUpdateWithoutDetailInput>
  }

  export type RepairHistoryUpdateManyWithWhereWithoutDetailInput = {
    where: RepairHistoryScalarWhereInput
    data: XOR<RepairHistoryUpdateManyMutationInput, RepairHistoryUncheckedUpdateManyWithoutRepairHistoryInput>
  }

  export type WashHistoryCreateWithoutUsersInput = {
    date: string
    price: number
    programs?: ProgramCreateNestedManyWithoutWashHistoryInput
    machines?: MachineCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryUncheckedCreateWithoutUsersInput = {
    id?: number
    date: string
    price: number
    programs?: ProgramUncheckedCreateNestedManyWithoutWashHistoryInput
    machines?: MachineUncheckedCreateNestedManyWithoutWashHistoryInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type WashHistoryCreateOrConnectWithoutUsersInput = {
    where: WashHistoryWhereUniqueInput
    create: XOR<WashHistoryCreateWithoutUsersInput, WashHistoryUncheckedCreateWithoutUsersInput>
  }

  export type WashHistoryUpsertWithoutUsersInput = {
    update: XOR<WashHistoryUpdateWithoutUsersInput, WashHistoryUncheckedUpdateWithoutUsersInput>
    create: XOR<WashHistoryCreateWithoutUsersInput, WashHistoryUncheckedCreateWithoutUsersInput>
  }

  export type WashHistoryUpdateWithoutUsersInput = {
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUpdateManyWithoutWashHistoryNestedInput
    machines?: MachineUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashHistoryUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    programs?: ProgramUncheckedUpdateManyWithoutWashHistoryNestedInput
    machines?: MachineUncheckedUpdateManyWithoutWashHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateWithoutWashHistoryInput = {
    duration: number
    price: number
    processes?: ProcessTypeCreateNestedManyWithoutProgramInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUncheckedCreateWithoutWashHistoryInput = {
    id?: number
    duration: number
    price: number
    processes?: ProcessTypeUncheckedCreateNestedManyWithoutProgramInput
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutProgramInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramCreateOrConnectWithoutWashHistoryInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutWashHistoryInput, ProgramUncheckedCreateWithoutWashHistoryInput>
  }

  export type ProgramCreateManyWashHistoryInputEnvelope = {
    data: Enumerable<ProgramCreateManyWashHistoryInput>
    skipDuplicates?: boolean
  }

  export type MachineCreateWithoutWashHistoryInput = {
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branch?: BranchCreateNestedOneWithoutMachinesInput
    repairHistories?: RepairHistoryCreateNestedManyWithoutMachineInput
    machineOnPrograms?: MachineOnProgramCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutWashHistoryInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    repairHistories?: RepairHistoryUncheckedCreateNestedManyWithoutMachineInput
    machineOnPrograms?: MachineOnProgramUncheckedCreateNestedManyWithoutMachineInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutWashHistoryInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutWashHistoryInput, MachineUncheckedCreateWithoutWashHistoryInput>
  }

  export type MachineCreateManyWashHistoryInputEnvelope = {
    data: Enumerable<MachineCreateManyWashHistoryInput>
    skipDuplicates?: boolean
  }

  export type washUserCreateWithoutWashHistoryInput = {
    name: string
    tel: number
    balance: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserUncheckedCreateWithoutWashHistoryInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserCreateOrConnectWithoutWashHistoryInput = {
    where: washUserWhereUniqueInput
    create: XOR<washUserCreateWithoutWashHistoryInput, washUserUncheckedCreateWithoutWashHistoryInput>
  }

  export type washUserCreateManyWashHistoryInputEnvelope = {
    data: Enumerable<washUserCreateManyWashHistoryInput>
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithWhereUniqueWithoutWashHistoryInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutWashHistoryInput, ProgramUncheckedUpdateWithoutWashHistoryInput>
    create: XOR<ProgramCreateWithoutWashHistoryInput, ProgramUncheckedCreateWithoutWashHistoryInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutWashHistoryInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutWashHistoryInput, ProgramUncheckedUpdateWithoutWashHistoryInput>
  }

  export type ProgramUpdateManyWithWhereWithoutWashHistoryInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutProgramsInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: Enumerable<ProgramScalarWhereInput>
    OR?: Enumerable<ProgramScalarWhereInput>
    NOT?: Enumerable<ProgramScalarWhereInput>
    id?: IntFilter | number
    duration?: IntFilter | number
    price?: IntFilter | number
    washHistoryId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MachineUpsertWithWhereUniqueWithoutWashHistoryInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutWashHistoryInput, MachineUncheckedUpdateWithoutWashHistoryInput>
    create: XOR<MachineCreateWithoutWashHistoryInput, MachineUncheckedCreateWithoutWashHistoryInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutWashHistoryInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutWashHistoryInput, MachineUncheckedUpdateWithoutWashHistoryInput>
  }

  export type MachineUpdateManyWithWhereWithoutWashHistoryInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutMachinesInput>
  }

  export type washUserUpsertWithWhereUniqueWithoutWashHistoryInput = {
    where: washUserWhereUniqueInput
    update: XOR<washUserUpdateWithoutWashHistoryInput, washUserUncheckedUpdateWithoutWashHistoryInput>
    create: XOR<washUserCreateWithoutWashHistoryInput, washUserUncheckedCreateWithoutWashHistoryInput>
  }

  export type washUserUpdateWithWhereUniqueWithoutWashHistoryInput = {
    where: washUserWhereUniqueInput
    data: XOR<washUserUpdateWithoutWashHistoryInput, washUserUncheckedUpdateWithoutWashHistoryInput>
  }

  export type washUserUpdateManyWithWhereWithoutWashHistoryInput = {
    where: washUserScalarWhereInput
    data: XOR<washUserUpdateManyMutationInput, washUserUncheckedUpdateManyWithoutUsersInput>
  }

  export type washUserScalarWhereInput = {
    AND?: Enumerable<washUserScalarWhereInput>
    OR?: Enumerable<washUserScalarWhereInput>
    NOT?: Enumerable<washUserScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    tel?: IntFilter | number
    balance?: FloatFilter | number
    washHistoryId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type DirectMessageCreateWithoutUserInput = {
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutUserInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutUserInput, DirectMessageUncheckedCreateWithoutUserInput>
  }

  export type DirectMessageCreateManyUserInputEnvelope = {
    data: Enumerable<DirectMessageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserRelationCreateWithoutFromInput = {
    to: UserCreateNestedOneWithoutToUserRelationInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutFromInput = {
    id?: number
    toId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutFromInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutFromInput, UserRelationUncheckedCreateWithoutFromInput>
  }

  export type UserRelationCreateManyFromInputEnvelope = {
    data: Enumerable<UserRelationCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type UserRelationCreateWithoutToInput = {
    from: UserCreateNestedOneWithoutFromUserRelationInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationUncheckedCreateWithoutToInput = {
    id?: number
    fromId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationCreateOrConnectWithoutToInput = {
    where: UserRelationWhereUniqueInput
    create: XOR<UserRelationCreateWithoutToInput, UserRelationUncheckedCreateWithoutToInput>
  }

  export type UserRelationCreateManyToInputEnvelope = {
    data: Enumerable<UserRelationCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    message: string
    postOnHashTags?: PostOnHashTagCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    postOnHashTags?: PostOnHashTagUncheckedCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: Enumerable<PostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReplyCreateWithoutUserInput = {
    message: string
    post: PostCreateNestedOneWithoutRepliesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReplyUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    postId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReplyCreateOrConnectWithoutUserInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput>
  }

  export type ReplyCreateManyUserInputEnvelope = {
    data: Enumerable<ReplyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutUserInput, DirectMessageUncheckedUpdateWithoutUserInput>
    create: XOR<DirectMessageCreateWithoutUserInput, DirectMessageUncheckedCreateWithoutUserInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutUserInput, DirectMessageUncheckedUpdateWithoutUserInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutUserInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutDirectMessageInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: Enumerable<DirectMessageScalarWhereInput>
    OR?: Enumerable<DirectMessageScalarWhereInput>
    NOT?: Enumerable<DirectMessageScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    message?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type UserRelationUpsertWithWhereUniqueWithoutFromInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutFromInput, UserRelationUncheckedUpdateWithoutFromInput>
    create: XOR<UserRelationCreateWithoutFromInput, UserRelationUncheckedCreateWithoutFromInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutFromInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutFromInput, UserRelationUncheckedUpdateWithoutFromInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutFromInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutFromUserRelationInput>
  }

  export type UserRelationScalarWhereInput = {
    AND?: Enumerable<UserRelationScalarWhereInput>
    OR?: Enumerable<UserRelationScalarWhereInput>
    NOT?: Enumerable<UserRelationScalarWhereInput>
    id?: IntFilter | number
    fromId?: IntFilter | number
    toId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type UserRelationUpsertWithWhereUniqueWithoutToInput = {
    where: UserRelationWhereUniqueInput
    update: XOR<UserRelationUpdateWithoutToInput, UserRelationUncheckedUpdateWithoutToInput>
    create: XOR<UserRelationCreateWithoutToInput, UserRelationUncheckedCreateWithoutToInput>
  }

  export type UserRelationUpdateWithWhereUniqueWithoutToInput = {
    where: UserRelationWhereUniqueInput
    data: XOR<UserRelationUpdateWithoutToInput, UserRelationUncheckedUpdateWithoutToInput>
  }

  export type UserRelationUpdateManyWithWhereWithoutToInput = {
    where: UserRelationScalarWhereInput
    data: XOR<UserRelationUpdateManyMutationInput, UserRelationUncheckedUpdateManyWithoutToUserRelationInput>
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    userId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type ReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutUserInput, ReplyUncheckedUpdateWithoutUserInput>
    create: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutUserInput, ReplyUncheckedUpdateWithoutUserInput>
  }

  export type ReplyUpdateManyWithWhereWithoutUserInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutRepliesInput>
  }

  export type ReplyScalarWhereInput = {
    AND?: Enumerable<ReplyScalarWhereInput>
    OR?: Enumerable<ReplyScalarWhereInput>
    NOT?: Enumerable<ReplyScalarWhereInput>
    id?: IntFilter | number
    message?: StringFilter | string
    postId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
  }

  export type UserCreateWithoutDirectMessageInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    fromUserRelation?: UserRelationCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationCreateNestedManyWithoutToInput
    posts?: PostCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDirectMessageInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    fromUserRelation?: UserRelationUncheckedCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationUncheckedCreateNestedManyWithoutToInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDirectMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
  }

  export type UserUpsertWithoutDirectMessageInput = {
    update: XOR<UserUpdateWithoutDirectMessageInput, UserUncheckedUpdateWithoutDirectMessageInput>
    create: XOR<UserCreateWithoutDirectMessageInput, UserUncheckedCreateWithoutDirectMessageInput>
  }

  export type UserUpdateWithoutDirectMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserRelation?: UserRelationUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUpdateManyWithoutToNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUserRelation?: UserRelationUncheckedUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUncheckedUpdateManyWithoutToNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFromUserRelationInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageCreateNestedManyWithoutUserInput
    toUserRelation?: UserRelationCreateNestedManyWithoutToInput
    posts?: PostCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFromUserRelationInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutUserInput
    toUserRelation?: UserRelationUncheckedCreateNestedManyWithoutToInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFromUserRelationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFromUserRelationInput, UserUncheckedCreateWithoutFromUserRelationInput>
  }

  export type UserCreateWithoutToUserRelationInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationCreateNestedManyWithoutFromInput
    posts?: PostCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutToUserRelationInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationUncheckedCreateNestedManyWithoutFromInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutToUserRelationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutToUserRelationInput, UserUncheckedCreateWithoutToUserRelationInput>
  }

  export type UserUpsertWithoutFromUserRelationInput = {
    update: XOR<UserUpdateWithoutFromUserRelationInput, UserUncheckedUpdateWithoutFromUserRelationInput>
    create: XOR<UserCreateWithoutFromUserRelationInput, UserUncheckedCreateWithoutFromUserRelationInput>
  }

  export type UserUpdateWithoutFromUserRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUpdateManyWithoutUserNestedInput
    toUserRelation?: UserRelationUpdateManyWithoutToNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFromUserRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUncheckedUpdateManyWithoutUserNestedInput
    toUserRelation?: UserRelationUncheckedUpdateManyWithoutToNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutToUserRelationInput = {
    update: XOR<UserUpdateWithoutToUserRelationInput, UserUncheckedUpdateWithoutToUserRelationInput>
    create: XOR<UserCreateWithoutToUserRelationInput, UserUncheckedCreateWithoutToUserRelationInput>
  }

  export type UserUpdateWithoutToUserRelationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUpdateManyWithoutFromNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutToUserRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUncheckedUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUncheckedUpdateManyWithoutFromNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostOnHashTagCreateWithoutHashTagsInput = {
    posts?: PostCreateNestedManyWithoutPostOnHashTagsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagUncheckedCreateWithoutHashTagsInput = {
    id?: number
    posts?: PostUncheckedCreateNestedManyWithoutPostOnHashTagsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagCreateOrConnectWithoutHashTagsInput = {
    where: PostOnHashTagWhereUniqueInput
    create: XOR<PostOnHashTagCreateWithoutHashTagsInput, PostOnHashTagUncheckedCreateWithoutHashTagsInput>
  }

  export type PostOnHashTagUpsertWithoutHashTagsInput = {
    update: XOR<PostOnHashTagUpdateWithoutHashTagsInput, PostOnHashTagUncheckedUpdateWithoutHashTagsInput>
    create: XOR<PostOnHashTagCreateWithoutHashTagsInput, PostOnHashTagUncheckedCreateWithoutHashTagsInput>
  }

  export type PostOnHashTagUpdateWithoutHashTagsInput = {
    posts?: PostUpdateManyWithoutPostOnHashTagsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagUncheckedUpdateWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    posts?: PostUncheckedUpdateManyWithoutPostOnHashTagsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPostsInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationCreateNestedManyWithoutToInput
    replies?: ReplyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationUncheckedCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationUncheckedCreateNestedManyWithoutToInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostOnHashTagCreateWithoutPostsInput = {
    hashTags?: HashTagCreateNestedManyWithoutPostOnHashTagInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagUncheckedCreateWithoutPostsInput = {
    id?: number
    hashTags?: HashTagUncheckedCreateNestedManyWithoutPostOnHashTagInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostOnHashTagCreateOrConnectWithoutPostsInput = {
    where: PostOnHashTagWhereUniqueInput
    create: XOR<PostOnHashTagCreateWithoutPostsInput, PostOnHashTagUncheckedCreateWithoutPostsInput>
  }

  export type ReplyCreateWithoutPostInput = {
    message: string
    user: UserCreateNestedOneWithoutRepliesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReplyUncheckedCreateWithoutPostInput = {
    id?: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: number
  }

  export type ReplyCreateOrConnectWithoutPostInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutPostInput, ReplyUncheckedCreateWithoutPostInput>
  }

  export type ReplyCreateManyPostInputEnvelope = {
    data: Enumerable<ReplyCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUpdateManyWithoutToNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUncheckedUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUncheckedUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUncheckedUpdateManyWithoutToNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostOnHashTagUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostOnHashTagWhereUniqueInput
    update: XOR<PostOnHashTagUpdateWithoutPostsInput, PostOnHashTagUncheckedUpdateWithoutPostsInput>
    create: XOR<PostOnHashTagCreateWithoutPostsInput, PostOnHashTagUncheckedCreateWithoutPostsInput>
  }

  export type PostOnHashTagUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostOnHashTagWhereUniqueInput
    data: XOR<PostOnHashTagUpdateWithoutPostsInput, PostOnHashTagUncheckedUpdateWithoutPostsInput>
  }

  export type PostOnHashTagUpdateManyWithWhereWithoutPostsInput = {
    where: PostOnHashTagScalarWhereInput
    data: XOR<PostOnHashTagUpdateManyMutationInput, PostOnHashTagUncheckedUpdateManyWithoutPostOnHashTagsInput>
  }

  export type PostOnHashTagScalarWhereInput = {
    AND?: Enumerable<PostOnHashTagScalarWhereInput>
    OR?: Enumerable<PostOnHashTagScalarWhereInput>
    NOT?: Enumerable<PostOnHashTagScalarWhereInput>
    id?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type ReplyUpsertWithWhereUniqueWithoutPostInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutPostInput, ReplyUncheckedUpdateWithoutPostInput>
    create: XOR<ReplyCreateWithoutPostInput, ReplyUncheckedCreateWithoutPostInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutPostInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutPostInput, ReplyUncheckedUpdateWithoutPostInput>
  }

  export type ReplyUpdateManyWithWhereWithoutPostInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutRepliesInput>
  }

  export type PostCreateWithoutPostOnHashTagsInput = {
    message: string
    user: UserCreateNestedOneWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostOnHashTagsInput = {
    id?: number
    message: string
    userId: number
    createAt?: Date | string
    updateAt?: Date | string
    replies?: ReplyUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostOnHashTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostOnHashTagsInput, PostUncheckedCreateWithoutPostOnHashTagsInput>
  }

  export type HashTagCreateWithoutPostOnHashTagInput = {
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type HashTagUncheckedCreateWithoutPostOnHashTagInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type HashTagCreateOrConnectWithoutPostOnHashTagInput = {
    where: HashTagWhereUniqueInput
    create: XOR<HashTagCreateWithoutPostOnHashTagInput, HashTagUncheckedCreateWithoutPostOnHashTagInput>
  }

  export type HashTagCreateManyPostOnHashTagInputEnvelope = {
    data: Enumerable<HashTagCreateManyPostOnHashTagInput>
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutPostOnHashTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPostOnHashTagsInput, PostUncheckedUpdateWithoutPostOnHashTagsInput>
    create: XOR<PostCreateWithoutPostOnHashTagsInput, PostUncheckedCreateWithoutPostOnHashTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPostOnHashTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPostOnHashTagsInput, PostUncheckedUpdateWithoutPostOnHashTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutPostOnHashTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type HashTagUpsertWithWhereUniqueWithoutPostOnHashTagInput = {
    where: HashTagWhereUniqueInput
    update: XOR<HashTagUpdateWithoutPostOnHashTagInput, HashTagUncheckedUpdateWithoutPostOnHashTagInput>
    create: XOR<HashTagCreateWithoutPostOnHashTagInput, HashTagUncheckedCreateWithoutPostOnHashTagInput>
  }

  export type HashTagUpdateWithWhereUniqueWithoutPostOnHashTagInput = {
    where: HashTagWhereUniqueInput
    data: XOR<HashTagUpdateWithoutPostOnHashTagInput, HashTagUncheckedUpdateWithoutPostOnHashTagInput>
  }

  export type HashTagUpdateManyWithWhereWithoutPostOnHashTagInput = {
    where: HashTagScalarWhereInput
    data: XOR<HashTagUpdateManyMutationInput, HashTagUncheckedUpdateManyWithoutHashTagsInput>
  }

  export type HashTagScalarWhereInput = {
    AND?: Enumerable<HashTagScalarWhereInput>
    OR?: Enumerable<HashTagScalarWhereInput>
    NOT?: Enumerable<HashTagScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    postOnHashTagId?: IntNullableFilter | number | null
  }

  export type UserCreateWithoutRepliesInput = {
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationCreateNestedManyWithoutToInput
    posts?: PostCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRepliesInput = {
    id?: number
    name: string
    image: string
    createAt?: Date | string
    updateAt?: Date | string
    directMessage?: DirectMessageUncheckedCreateNestedManyWithoutUserInput
    fromUserRelation?: UserRelationUncheckedCreateNestedManyWithoutFromInput
    toUserRelation?: UserRelationUncheckedCreateNestedManyWithoutToInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
  }

  export type PostCreateWithoutRepliesInput = {
    message: string
    user: UserCreateNestedOneWithoutPostsInput
    postOnHashTags?: PostOnHashTagCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostUncheckedCreateWithoutRepliesInput = {
    id?: number
    message: string
    userId: number
    postOnHashTags?: PostOnHashTagUncheckedCreateNestedManyWithoutPostsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostCreateOrConnectWithoutRepliesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutRepliesInput, PostUncheckedCreateWithoutRepliesInput>
  }

  export type UserUpsertWithoutRepliesInput = {
    update: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
  }

  export type UserUpdateWithoutRepliesInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUpdateManyWithoutToNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    directMessage?: DirectMessageUncheckedUpdateManyWithoutUserNestedInput
    fromUserRelation?: UserRelationUncheckedUpdateManyWithoutFromNestedInput
    toUserRelation?: UserRelationUncheckedUpdateManyWithoutToNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithoutRepliesInput = {
    update: XOR<PostUpdateWithoutRepliesInput, PostUncheckedUpdateWithoutRepliesInput>
    create: XOR<PostCreateWithoutRepliesInput, PostUncheckedCreateWithoutRepliesInput>
  }

  export type PostUpdateWithoutRepliesInput = {
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    postOnHashTags?: PostOnHashTagUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postOnHashTags?: PostOnHashTagUncheckedUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelCreateWithoutSubcribersInput = {
    name: string
    image: string
    playLists?: YoutubeVideoCreateNestedManyWithoutChannelInput
    userToChannel?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUncheckedCreateWithoutSubcribersInput = {
    id?: number
    name: string
    image: string
    playLists?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    userToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelCreateOrConnectWithoutSubcribersInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutSubcribersInput, YoutubeChannelUncheckedCreateWithoutSubcribersInput>
  }

  export type YoutubeCommentToVideoCreateWithoutCommenterInput = {
    videoId: YoutubeVideoCreateNestedOneWithoutCommentToVideoesInput
    comment: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput = {
    id?: number
    video: number
    comment: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoCreateOrConnectWithoutCommenterInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    create: XOR<YoutubeCommentToVideoCreateWithoutCommenterInput, YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>
  }

  export type YoutubeCommentToVideoCreateManyCommenterInputEnvelope = {
    data: Enumerable<YoutubeCommentToVideoCreateManyCommenterInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelCreateWithoutUserInput = {
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelInput
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutUserInput = {
    channelId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeChannelUpsertWithWhereUniqueWithoutSubcribersInput = {
    where: YoutubeChannelWhereUniqueInput
    update: XOR<YoutubeChannelUpdateWithoutSubcribersInput, YoutubeChannelUncheckedUpdateWithoutSubcribersInput>
    create: XOR<YoutubeChannelCreateWithoutSubcribersInput, YoutubeChannelUncheckedCreateWithoutSubcribersInput>
  }

  export type YoutubeChannelUpdateWithWhereUniqueWithoutSubcribersInput = {
    where: YoutubeChannelWhereUniqueInput
    data: XOR<YoutubeChannelUpdateWithoutSubcribersInput, YoutubeChannelUncheckedUpdateWithoutSubcribersInput>
  }

  export type YoutubeChannelUpdateManyWithWhereWithoutSubcribersInput = {
    where: YoutubeChannelScalarWhereInput
    data: XOR<YoutubeChannelUpdateManyMutationInput, YoutubeChannelUncheckedUpdateManyWithoutSubtoChannelsInput>
  }

  export type YoutubeChannelScalarWhereInput = {
    AND?: Enumerable<YoutubeChannelScalarWhereInput>
    OR?: Enumerable<YoutubeChannelScalarWhereInput>
    NOT?: Enumerable<YoutubeChannelScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeCommentToVideoUpsertWithWhereUniqueWithoutCommenterInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    update: XOR<YoutubeCommentToVideoUpdateWithoutCommenterInput, YoutubeCommentToVideoUncheckedUpdateWithoutCommenterInput>
    create: XOR<YoutubeCommentToVideoCreateWithoutCommenterInput, YoutubeCommentToVideoUncheckedCreateWithoutCommenterInput>
  }

  export type YoutubeCommentToVideoUpdateWithWhereUniqueWithoutCommenterInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    data: XOR<YoutubeCommentToVideoUpdateWithoutCommenterInput, YoutubeCommentToVideoUncheckedUpdateWithoutCommenterInput>
  }

  export type YoutubeCommentToVideoUpdateManyWithWhereWithoutCommenterInput = {
    where: YoutubeCommentToVideoScalarWhereInput
    data: XOR<YoutubeCommentToVideoUpdateManyMutationInput, YoutubeCommentToVideoUncheckedUpdateManyWithoutCommentToVideoesInput>
  }

  export type YoutubeCommentToVideoScalarWhereInput = {
    AND?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
    OR?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
    NOT?: Enumerable<YoutubeCommentToVideoScalarWhereInput>
    id?: IntFilter | number
    video?: IntFilter | number
    comment?: StringFilter | string
    commenterId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelInput>
  }

  export type YoutubeUserToChannelScalarWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    userId?: IntFilter | number
    channelId?: IntFilter | number
    roleId?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserToChannelCreateWithoutRoleInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelInput
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutRoleInput = {
    userId: number
    channelId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutRoleInput, YoutubeUserToChannelUncheckedCreateWithoutRoleInput>
  }

  export type YoutubeUserToChannelCreateManyRoleInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutRoleInput, YoutubeUserToChannelUncheckedUpdateWithoutRoleInput>
    create: XOR<YoutubeUserToChannelCreateWithoutRoleInput, YoutubeUserToChannelUncheckedCreateWithoutRoleInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutRoleInput, YoutubeUserToChannelUncheckedUpdateWithoutRoleInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelInput>
  }

  export type YoutubeVideoCreateWithoutLikeorDislikeInput = {
    name: string
    description: string
    url: string
    channel?: YoutubeChannelCreateNestedOneWithoutPlayListsInput
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput = {
    id?: number
    name: string
    description: string
    url: string
    channelId?: number | null
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoCreateOrConnectWithoutLikeorDislikeInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutLikeorDislikeInput, YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>
  }

  export type YoutubeVideoCreateManyLikeorDislikeInputEnvelope = {
    data: Enumerable<YoutubeVideoCreateManyLikeorDislikeInput>
    skipDuplicates?: boolean
  }

  export type YoutubeVideoUpsertWithWhereUniqueWithoutLikeorDislikeInput = {
    where: YoutubeVideoWhereUniqueInput
    update: XOR<YoutubeVideoUpdateWithoutLikeorDislikeInput, YoutubeVideoUncheckedUpdateWithoutLikeorDislikeInput>
    create: XOR<YoutubeVideoCreateWithoutLikeorDislikeInput, YoutubeVideoUncheckedCreateWithoutLikeorDislikeInput>
  }

  export type YoutubeVideoUpdateWithWhereUniqueWithoutLikeorDislikeInput = {
    where: YoutubeVideoWhereUniqueInput
    data: XOR<YoutubeVideoUpdateWithoutLikeorDislikeInput, YoutubeVideoUncheckedUpdateWithoutLikeorDislikeInput>
  }

  export type YoutubeVideoUpdateManyWithWhereWithoutLikeorDislikeInput = {
    where: YoutubeVideoScalarWhereInput
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyWithoutVideoInput>
  }

  export type YoutubeVideoScalarWhereInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereInput>
    OR?: Enumerable<YoutubeVideoScalarWhereInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    url?: StringFilter | string
    channelId?: IntNullableFilter | number | null
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    youtubeReactionId?: IntFilter | number
  }

  export type YoutubeReactionCreateWithoutVideoInput = {
    reaction: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeReactionUncheckedCreateWithoutVideoInput = {
    id?: number
    reaction: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeReactionCreateOrConnectWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeChannelCreateWithoutPlayListsInput = {
    name: string
    image: string
    subcribers?: YoutubeUserCreateNestedManyWithoutSubtoChannelsInput
    userToChannel?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUncheckedCreateWithoutPlayListsInput = {
    id?: number
    name: string
    image: string
    subcribers?: YoutubeUserUncheckedCreateNestedManyWithoutSubtoChannelsInput
    userToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelCreateOrConnectWithoutPlayListsInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutPlayListsInput, YoutubeChannelUncheckedCreateWithoutPlayListsInput>
  }

  export type YoutubeCommentToVideoCreateWithoutVideoIdInput = {
    comment: string
    commenter: YoutubeUserCreateNestedOneWithoutCommentToVideoesInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput = {
    id?: number
    comment: string
    commenterId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoCreateOrConnectWithoutVideoIdInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    create: XOR<YoutubeCommentToVideoCreateWithoutVideoIdInput, YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>
  }

  export type YoutubeCommentToVideoCreateManyVideoIdInputEnvelope = {
    data: Enumerable<YoutubeCommentToVideoCreateManyVideoIdInput>
    skipDuplicates?: boolean
  }

  export type YoutubeReactionUpsertWithoutVideoInput = {
    update: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeReactionUpdateWithoutVideoInput = {
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUpsertWithoutPlayListsInput = {
    update: XOR<YoutubeChannelUpdateWithoutPlayListsInput, YoutubeChannelUncheckedUpdateWithoutPlayListsInput>
    create: XOR<YoutubeChannelCreateWithoutPlayListsInput, YoutubeChannelUncheckedCreateWithoutPlayListsInput>
  }

  export type YoutubeChannelUpdateWithoutPlayListsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUpdateManyWithoutSubtoChannelsNestedInput
    userToChannel?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateWithoutPlayListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUncheckedUpdateManyWithoutSubtoChannelsNestedInput
    userToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUpsertWithWhereUniqueWithoutVideoIdInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    update: XOR<YoutubeCommentToVideoUpdateWithoutVideoIdInput, YoutubeCommentToVideoUncheckedUpdateWithoutVideoIdInput>
    create: XOR<YoutubeCommentToVideoCreateWithoutVideoIdInput, YoutubeCommentToVideoUncheckedCreateWithoutVideoIdInput>
  }

  export type YoutubeCommentToVideoUpdateWithWhereUniqueWithoutVideoIdInput = {
    where: YoutubeCommentToVideoWhereUniqueInput
    data: XOR<YoutubeCommentToVideoUpdateWithoutVideoIdInput, YoutubeCommentToVideoUncheckedUpdateWithoutVideoIdInput>
  }

  export type YoutubeCommentToVideoUpdateManyWithWhereWithoutVideoIdInput = {
    where: YoutubeCommentToVideoScalarWhereInput
    data: XOR<YoutubeCommentToVideoUpdateManyMutationInput, YoutubeCommentToVideoUncheckedUpdateManyWithoutCommentToVideoesInput>
  }

  export type YoutubeUserCreateWithoutSubtoChannelsInput = {
    name: string
    email: string
    image: string
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutCommenterInput
    UserToChannel?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUncheckedCreateWithoutSubtoChannelsInput = {
    id?: number
    name: string
    email: string
    image: string
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutCommenterInput
    UserToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserCreateOrConnectWithoutSubtoChannelsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutSubtoChannelsInput, YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>
  }

  export type YoutubeVideoCreateWithoutChannelInput = {
    name: string
    description: string
    url: string
    likeorDislike: YoutubeReactionCreateNestedOneWithoutVideoInput
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoUncheckedCreateWithoutChannelInput = {
    id?: number
    name: string
    description: string
    url: string
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutVideoIdInput
    createAt?: Date | string
    updateAt?: Date | string
    youtubeReactionId: number
  }

  export type YoutubeVideoCreateOrConnectWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeVideoCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelCreateWithoutChannelInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelInput
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutChannelInput = {
    userId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserUpsertWithWhereUniqueWithoutSubtoChannelsInput = {
    where: YoutubeUserWhereUniqueInput
    update: XOR<YoutubeUserUpdateWithoutSubtoChannelsInput, YoutubeUserUncheckedUpdateWithoutSubtoChannelsInput>
    create: XOR<YoutubeUserCreateWithoutSubtoChannelsInput, YoutubeUserUncheckedCreateWithoutSubtoChannelsInput>
  }

  export type YoutubeUserUpdateWithWhereUniqueWithoutSubtoChannelsInput = {
    where: YoutubeUserWhereUniqueInput
    data: XOR<YoutubeUserUpdateWithoutSubtoChannelsInput, YoutubeUserUncheckedUpdateWithoutSubtoChannelsInput>
  }

  export type YoutubeUserUpdateManyWithWhereWithoutSubtoChannelsInput = {
    where: YoutubeUserScalarWhereInput
    data: XOR<YoutubeUserUpdateManyMutationInput, YoutubeUserUncheckedUpdateManyWithoutSubcribersInput>
  }

  export type YoutubeUserScalarWhereInput = {
    AND?: Enumerable<YoutubeUserScalarWhereInput>
    OR?: Enumerable<YoutubeUserScalarWhereInput>
    NOT?: Enumerable<YoutubeUserScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    image?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    update: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    data: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeVideoScalarWhereInput
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyWithoutPlayListsInput>
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelInput>
  }

  export type YoutubeVideoCreateWithoutCommentToVideoesInput = {
    name: string
    description: string
    url: string
    likeorDislike: YoutubeReactionCreateNestedOneWithoutVideoInput
    channel?: YoutubeChannelCreateNestedOneWithoutPlayListsInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoUncheckedCreateWithoutCommentToVideoesInput = {
    id?: number
    name: string
    description: string
    url: string
    channelId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
    youtubeReactionId: number
  }

  export type YoutubeVideoCreateOrConnectWithoutCommentToVideoesInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutCommentToVideoesInput, YoutubeVideoUncheckedCreateWithoutCommentToVideoesInput>
  }

  export type YoutubeUserCreateWithoutCommentToVideoesInput = {
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelCreateNestedManyWithoutSubcribersInput
    UserToChannel?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUncheckedCreateWithoutCommentToVideoesInput = {
    id?: number
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelUncheckedCreateNestedManyWithoutSubcribersInput
    UserToChannel?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserCreateOrConnectWithoutCommentToVideoesInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutCommentToVideoesInput, YoutubeUserUncheckedCreateWithoutCommentToVideoesInput>
  }

  export type YoutubeVideoUpsertWithoutCommentToVideoesInput = {
    update: XOR<YoutubeVideoUpdateWithoutCommentToVideoesInput, YoutubeVideoUncheckedUpdateWithoutCommentToVideoesInput>
    create: XOR<YoutubeVideoCreateWithoutCommentToVideoesInput, YoutubeVideoUncheckedCreateWithoutCommentToVideoesInput>
  }

  export type YoutubeVideoUpdateWithoutCommentToVideoesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    likeorDislike?: YoutubeReactionUpdateOneRequiredWithoutVideoNestedInput
    channel?: YoutubeChannelUpdateOneWithoutPlayListsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateWithoutCommentToVideoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactionId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserUpsertWithoutCommentToVideoesInput = {
    update: XOR<YoutubeUserUpdateWithoutCommentToVideoesInput, YoutubeUserUncheckedUpdateWithoutCommentToVideoesInput>
    create: XOR<YoutubeUserCreateWithoutCommentToVideoesInput, YoutubeUserUncheckedCreateWithoutCommentToVideoesInput>
  }

  export type YoutubeUserUpdateWithoutCommentToVideoesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUpdateManyWithoutSubcribersNestedInput
    UserToChannel?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateWithoutCommentToVideoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUncheckedUpdateManyWithoutSubcribersNestedInput
    UserToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserCreateWithoutUserToChannelInput = {
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelCreateNestedManyWithoutSubcribersInput
    commentToVideoes?: YoutubeCommentToVideoCreateNestedManyWithoutCommenterInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUncheckedCreateWithoutUserToChannelInput = {
    id?: number
    name: string
    email: string
    image: string
    subtoChannels?: YoutubeChannelUncheckedCreateNestedManyWithoutSubcribersInput
    commentToVideoes?: YoutubeCommentToVideoUncheckedCreateNestedManyWithoutCommenterInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserCreateOrConnectWithoutUserToChannelInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutUserToChannelInput, YoutubeUserUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeChannelCreateWithoutUserToChannelInput = {
    name: string
    image: string
    subcribers?: YoutubeUserCreateNestedManyWithoutSubtoChannelsInput
    playLists?: YoutubeVideoCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUncheckedCreateWithoutUserToChannelInput = {
    id?: number
    name: string
    image: string
    subcribers?: YoutubeUserUncheckedCreateNestedManyWithoutSubtoChannelsInput
    playLists?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelCreateOrConnectWithoutUserToChannelInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutUserToChannelInput, YoutubeChannelUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeRoleCreateWithoutUserToChannelInput = {
    role: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeRoleUncheckedCreateWithoutUserToChannelInput = {
    id?: number
    role: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeRoleCreateOrConnectWithoutUserToChannelInput = {
    where: YoutubeRoleWhereUniqueInput
    create: XOR<YoutubeRoleCreateWithoutUserToChannelInput, YoutubeRoleUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeUserUpsertWithoutUserToChannelInput = {
    update: XOR<YoutubeUserUpdateWithoutUserToChannelInput, YoutubeUserUncheckedUpdateWithoutUserToChannelInput>
    create: XOR<YoutubeUserCreateWithoutUserToChannelInput, YoutubeUserUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeUserUpdateWithoutUserToChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUpdateManyWithoutSubcribersNestedInput
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutCommenterNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateWithoutUserToChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subtoChannels?: YoutubeChannelUncheckedUpdateManyWithoutSubcribersNestedInput
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutCommenterNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUpsertWithoutUserToChannelInput = {
    update: XOR<YoutubeChannelUpdateWithoutUserToChannelInput, YoutubeChannelUncheckedUpdateWithoutUserToChannelInput>
    create: XOR<YoutubeChannelCreateWithoutUserToChannelInput, YoutubeChannelUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeChannelUpdateWithoutUserToChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUpdateManyWithoutSubtoChannelsNestedInput
    playLists?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateWithoutUserToChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    subcribers?: YoutubeUserUncheckedUpdateManyWithoutSubtoChannelsNestedInput
    playLists?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleUpsertWithoutUserToChannelInput = {
    update: XOR<YoutubeRoleUpdateWithoutUserToChannelInput, YoutubeRoleUncheckedUpdateWithoutUserToChannelInput>
    create: XOR<YoutubeRoleCreateWithoutUserToChannelInput, YoutubeRoleUncheckedCreateWithoutUserToChannelInput>
  }

  export type YoutubeRoleUpdateWithoutUserToChannelInput = {
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleUncheckedUpdateWithoutUserToChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuCreateManyCategoryKeyInput = {
    id?: number
    name: string
    image: string
    price: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewKitchenMenuUpdateWithoutCategoryKeyInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: DewOrderItemUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuUncheckedUpdateWithoutCategoryKeyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: DewOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewKitchenMenuUncheckedUpdateManyWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemCreateManyMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUpdateWithoutMenuInput = {
    order?: DewKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemCreateManyOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DewOrderItemUpdateWithoutOrderInput = {
    menu?: DewKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DewOrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookExOnAuthorExCreateManyBookExampleInput = {
    authorExampleId: number
  }

  export type BookExOnAuthorExUpdateWithoutBookExampleInput = {
    authorExample?: AuthorExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput
  }

  export type BookExOnAuthorExUncheckedUpdateWithoutBookExampleInput = {
    authorExampleId?: IntFieldUpdateOperationsInput | number
  }

  export type BookExOnAuthorExUncheckedUpdateManyWithoutBookExampleOnAuthorExampleInput = {
    authorExampleId?: IntFieldUpdateOperationsInput | number
  }

  export type BookExOnAuthorExCreateManyAuthorExampleInput = {
    bookExampleId: number
  }

  export type BookExOnAuthorExUpdateWithoutAuthorExampleInput = {
    bookExample?: BookExUpdateOneRequiredWithoutBookExampleOnAuthorExampleNestedInput
  }

  export type BookExOnAuthorExUncheckedUpdateWithoutAuthorExampleInput = {
    bookExampleId?: IntFieldUpdateOperationsInput | number
  }

  export type ActorsUpdateWithoutSeriesTvInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorsUncheckedUpdateWithoutSeriesTvInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActorsUncheckedUpdateManyWithoutActorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTvUpdateWithoutActorsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTvUncheckedUpdateWithoutActorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesTvUncheckedUpdateManyWithoutSeriesTvInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type QuizeQuestionCreateManyQuizeCategoryInput = {
    id?: number
    question: string
    quizeAnswerId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeQuestionUpdateWithoutQuizeCategoryInput = {
    question?: StringFieldUpdateOperationsInput | string
    choices?: QuizeChoiceUpdateManyWithoutQuizeQuestionNestedInput
    answer?: QuizeAnswerUpdateOneWithoutQuizeQuestionNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionUncheckedUpdateWithoutQuizeCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    choices?: QuizeChoiceUncheckedUpdateManyWithoutQuizeQuestionNestedInput
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type QuizeQuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quizeAnswerId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizeChoiceCreateManyQuizeQuestionInput = {
    id?: number
    choice: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type QuizeChoiceUpdateWithoutQuizeQuestionInput = {
    choice?: StringFieldUpdateOperationsInput | string
    quizeAnswer?: QuizeAnswerUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeChoiceUncheckedUpdateWithoutQuizeQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    quizeAnswer?: QuizeAnswerUncheckedUpdateOneWithoutChoiceNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    round?: QuizeGameRoundUncheckedUpdateOneWithoutChoiceNestedInput
  }

  export type QuizeChoiceUncheckedUpdateManyWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    choice?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateManyMainCompanyInput = {
    id?: number
    ownerName: string
    tel: number
    address: string
    area: number
    totolMachine: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type BranchUpdateWithoutMainCompanyInput = {
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    machines?: MachineUpdateManyWithoutBranchNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateWithoutMainCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    machines?: MachineUncheckedUpdateManyWithoutBranchNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyWithoutBranchIdsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    area?: FloatFieldUpdateOperationsInput | number
    totolMachine?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyBranchInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    washHistoryId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineUpdateWithoutBranchInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    repairHistories?: RepairHistoryUpdateManyWithoutMachineNestedInput
    washHistory?: WashHistoryUpdateOneWithoutMachinesNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    repairHistories?: RepairHistoryUncheckedUpdateManyWithoutMachineNestedInput
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    washHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateManyMachineInput = {
    id?: number
    time: number
    repairDetailId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramCreateManyMachineInput = {
    id?: number
    programId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUpdateWithoutMachineInput = {
    time?: IntFieldUpdateOperationsInput | number
    detail?: RepairDetailUpdateOneRequiredWithoutRepairHistoryNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    repairDetailId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateManyWithoutRepairHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    repairDetailId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUpdateWithoutMachineInput = {
    program?: ProgramUpdateOneRequiredWithoutMachineOnProgramsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUncheckedUpdateManyWithoutMachineOnProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeCreateManyProgramInput = {
    id?: number
    description: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineOnProgramCreateManyProgramInput = {
    id?: number
    machineId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProcessTypeUpdateWithoutProgramInput = {
    description?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessTypeUncheckedUpdateManyWithoutProcessesInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUpdateWithoutProgramInput = {
    machine?: MachineUpdateOneRequiredWithoutMachineOnProgramsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineOnProgramUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryCreateManyDetailInput = {
    id?: number
    time: number
    machineId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RepairHistoryUpdateWithoutDetailInput = {
    time?: IntFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneWithoutRepairHistoriesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateWithoutDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    machineId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairHistoryUncheckedUpdateManyWithoutRepairHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
    machineId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateManyWashHistoryInput = {
    id?: number
    duration: number
    price: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MachineCreateManyWashHistoryInput = {
    id?: number
    brand: string
    size: string
    category: string
    model: string
    mfg: string
    insurance: string
    branchId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type washUserCreateManyWashHistoryInput = {
    id?: number
    name: string
    tel: number
    balance: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProgramUpdateWithoutWashHistoryInput = {
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUpdateManyWithoutProgramNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateWithoutWashHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    processes?: ProcessTypeUncheckedUpdateManyWithoutProgramNestedInput
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutProgramNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUpdateWithoutWashHistoryInput = {
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branch?: BranchUpdateOneWithoutMachinesNestedInput
    repairHistories?: RepairHistoryUpdateManyWithoutMachineNestedInput
    machineOnPrograms?: MachineOnProgramUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutWashHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    mfg?: StringFieldUpdateOperationsInput | string
    insurance?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    repairHistories?: RepairHistoryUncheckedUpdateManyWithoutMachineNestedInput
    machineOnPrograms?: MachineOnProgramUncheckedUpdateManyWithoutMachineNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserUpdateWithoutWashHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserUncheckedUpdateWithoutWashHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type washUserUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tel?: IntFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyUserInput = {
    id?: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationCreateManyFromInput = {
    id?: number
    toId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type UserRelationCreateManyToInput = {
    id?: number
    fromId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostCreateManyUserInput = {
    id?: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReplyCreateManyUserInput = {
    id?: number
    message: string
    postId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type DirectMessageUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutDirectMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUpdateWithoutFromInput = {
    to?: UserUpdateOneRequiredWithoutToUserRelationNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutFromUserRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUpdateWithoutToInput = {
    from?: UserUpdateOneRequiredWithoutFromUserRelationNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRelationUncheckedUpdateManyWithoutToUserRelationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    postOnHashTags?: PostOnHashTagUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    postOnHashTags?: PostOnHashTagUncheckedUpdateManyWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutRepliesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUncheckedUpdateManyWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCreateManyPostInput = {
    id?: number
    message: string
    createAt?: Date | string
    updateAt?: Date | string
    userId: number
  }

  export type PostOnHashTagUpdateWithoutPostsInput = {
    hashTags?: HashTagUpdateManyWithoutPostOnHashTagNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashTags?: HashTagUncheckedUpdateManyWithoutPostOnHashTagNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostOnHashTagUncheckedUpdateManyWithoutPostOnHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUpdateWithoutPostInput = {
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HashTagCreateManyPostOnHashTagInput = {
    id?: number
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type PostUpdateWithoutPostOnHashTagsInput = {
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostOnHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyUncheckedUpdateManyWithoutPostNestedInput
  }

  export type HashTagUpdateWithoutPostOnHashTagInput = {
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateWithoutPostOnHashTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HashTagUncheckedUpdateManyWithoutHashTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoCreateManyCommenterInput = {
    id?: number
    video: number
    comment: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelCreateManyUserInput = {
    channelId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeChannelUpdateWithoutSubcribersInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    playLists?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    userToChannel?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateWithoutSubcribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    playLists?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    userToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateManyWithoutSubtoChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUpdateWithoutCommenterInput = {
    videoId?: YoutubeVideoUpdateOneRequiredWithoutCommentToVideoesNestedInput
    comment?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUncheckedUpdateWithoutCommenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUncheckedUpdateManyWithoutCommentToVideoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUpdateWithoutUserInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelNestedInput
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutUserInput = {
    channelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelInput = {
    channelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyRoleInput = {
    userId: number
    channelId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateWithoutRoleInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoCreateManyLikeorDislikeInput = {
    id?: number
    name: string
    description: string
    url: string
    channelId?: number | null
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeVideoUpdateWithoutLikeorDislikeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channel?: YoutubeChannelUpdateOneWithoutPlayListsNestedInput
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateWithoutLikeorDislikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoCreateManyVideoIdInput = {
    id?: number
    comment: string
    commenterId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeCommentToVideoUpdateWithoutVideoIdInput = {
    comment?: StringFieldUpdateOperationsInput | string
    commenter?: YoutubeUserUpdateOneRequiredWithoutCommentToVideoesNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentToVideoUncheckedUpdateWithoutVideoIdInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    commenterId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoCreateManyChannelInput = {
    id?: number
    name: string
    description: string
    url: string
    createAt?: Date | string
    updateAt?: Date | string
    youtubeReactionId: number
  }

  export type YoutubeUserToChannelCreateManyChannelInput = {
    userId: number
    roleId: number
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type YoutubeUserUpdateWithoutSubtoChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutCommenterNestedInput
    UserToChannel?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateWithoutSubtoChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutCommenterNestedInput
    UserToChannel?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateManyWithoutSubcribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    likeorDislike?: YoutubeReactionUpdateOneRequiredWithoutVideoNestedInput
    commentToVideoes?: YoutubeCommentToVideoUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    commentToVideoes?: YoutubeCommentToVideoUncheckedUpdateManyWithoutVideoIdNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactionId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutPlayListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    youtubeReactionId?: IntFieldUpdateOperationsInput | number
  }

  export type YoutubeUserToChannelUpdateWithoutChannelInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelNestedInput
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelNestedInput
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutChannelInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}