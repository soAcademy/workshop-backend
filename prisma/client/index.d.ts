
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model BinKitchenCategory
 * 
 */
export type BinKitchenCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenMenu
 * 
 */
export type BinKitchenMenu = {
  id: number
  name: string
  image: string
  price: number
  categoryName: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenOrder
 * 
 */
export type BinKitchenOrder = {
  id: number
  status: string
  tableId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model BinKitchenOrderItem
 * 
 */
export type BinKitchenOrderItem = {
  id: number
  menuId: number
  orderId: number | null
  quantity: number
  totalPrice: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizCategory
 * 
 */
export type QuizCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = {
  id: number
  questName: string
  categoryId: number
  answerChoiceId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizChoice
 * 
 */
export type QuizChoice = {
  id: number
  choiceName: string
  questionId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizRoundQuestion
 * 
 */
export type QuizRoundQuestion = {
  id: number
  userChoiceId: number
  questionId: number
  roundId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuizRound
 * 
 */
export type QuizRound = {
  id: number
  user: string
  categoryId: number
  score: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUser
 * 
 */
export type FacebookUser = {
  id: number
  username: string
  image: string | null
  coverImage: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUserRelationship
 * 
 */
export type FacebookUserRelationship = {
  id: number
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookDirectMessage
 * 
 */
export type FacebookDirectMessage = {
  id: number
  fromUserId: number
  toUserId: number
  message: string
  image: string | null
  readStatus: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookLocation
 * 
 */
export type FacebookLocation = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookHashtag
 * 
 */
export type FacebookHashtag = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookLike
 * 
 */
export type FacebookLike = {
  id: number
  type: FacebookLikeTypeEnum
  userId: number
  postId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookShareType
 * 
 */
export type FacebookShareType = {
  id: number
  type: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookGroup
 * 
 */
export type FacebookGroup = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookUserInGroup
 * 
 */
export type FacebookUserInGroup = {
  id: number
  userId: number
  groupId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookPostDestination
 * 
 */
export type FacebookPostDestination = {
  id: number
  type: string
  userId: number
  groupId: number
  postId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookPost
 * 
 */
export type FacebookPost = {
  id: number
  userId: number
  message: string | null
  image: string | null
  locationId: number
  hashtagId: number
  shareToId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FacebookCommentPost
 * 
 */
export type FacebookCommentPost = {
  id: number
  postId: number
  userId: number
  message: string | null
  image: string | null
  commentToId: number | null
  shareToId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterUser
 * 
 */
export type TwitterUser = {
  id: number
  username: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPost
 * 
 */
export type TwitterPost = {
  id: number
  userId: number
  message: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterUserRelationship
 * 
 */
export type TwitterUserRelationship = {
  id: number
  fromUserId: number
  toUserId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterHashtag
 * 
 */
export type TwitterHashtag = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterPostAndHashtag
 * 
 */
export type TwitterPostAndHashtag = {
  id: number
  postId: number
  hashtagId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterReplyPost
 * 
 */
export type TwitterReplyPost = {
  id: number
  userId: number
  message: string
  image: string | null
  postId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TwitterDirectMessage
 * 
 */
export type TwitterDirectMessage = {
  id: number
  fromUserId: number
  toUserId: number
  message: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeUser
 * 
 */
export type YoutubeUser = {
  id: number
  username: string
  email: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeRole
 * 
 */
export type YoutubeRole = {
  id: number
  role: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeChannel
 * 
 */
export type YoutubeChannel = {
  id: number
  name: string
  descriptions: string
  image: string | null
  coverImage: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeUserToChannel
 * 
 */
export type YoutubeUserToChannel = {
  id: number
  userId: number
  roleId: number
  channelId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeVideo
 * 
 */
export type YoutubeVideo = {
  id: number
  channelId: number
  name: string
  urlFile: string
  coverImage: string | null
  descriptions: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeSubscriber
 * 
 */
export type YoutubeSubscriber = {
  id: number
  userId: number
  channelId: number
  membership: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeReaction
 * 
 */
export type YoutubeReaction = {
  id: number
  type: ReactionEnum
  userId: number
  videoId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model YoutubeComment
 * 
 */
export type YoutubeComment = {
  id: number
  videoId: number
  userId: number
  message: string
  commentToId: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderBranchInfo
 * 
 */
export type LaunderBranchInfo = {
  id: number
  owner: string
  phone: number
  location: string
  areaSize: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderMachine
 * 
 */
export type LaunderMachine = {
  id: number
  brand: string
  Capacity: number
  type: string
  serialNumber: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryMachineInStore
 * 
 */
export type LaundryMachineInStore = {
  id: number
  branchId: number
  machineId: number
  mfd: string
  Warranty: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderTechnician
 * 
 */
export type LaunderTechnician = {
  id: number
  firstName: string
  lastName: string
  image: string | null
  phone: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderServiceHistory
 * 
 */
export type LaunderServiceHistory = {
  id: number
  date: Date
  machineId: number
  technicianId: number
  descriptions: string
  image: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderWashingProgram
 * 
 */
export type LaunderWashingProgram = {
  id: number
  program: string
  price: number
  duration: number
  capacityLimit: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderProgramInMachine
 * 
 */
export type LaunderProgramInMachine = {
  id: number
  machineId: number
  programId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaunderUser
 * 
 */
export type LaunderUser = {
  id: number
  username: string
  phone: number
  walletBalance: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryTopupHistory
 * 
 */
export type LaundryTopupHistory = {
  id: number
  userId: number
  value: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LaundryWashingHistory
 * 
 */
export type LaundryWashingHistory = {
  id: number
  machineId: number
  programId: number
  date: Date
  price: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryStudent
 * 
 */
export type LibraryStudent = {
  id: number
  firstName: string
  lastName: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryUniversity
 * 
 */
export type LibraryUniversity = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryCategory
 * 
 */
export type LibraryCategory = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryAuthor
 * 
 */
export type LibraryAuthor = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBook
 * 
 */
export type LibraryBook = {
  id: number
  name: string
  isbn: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBookCategory
 * 
 */
export type LibraryBookCategory = {
  id: number
  bookId: number
  categoryId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBookAuthor
 * 
 */
export type LibraryBookAuthor = {
  id: number
  bookId: number
  authorId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBookCopy
 * 
 */
export type LibraryBookCopy = {
  id: number
  bookId: number
  universityId: number
  status: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryRequest
 * 
 */
export type LibraryRequest = {
  id: number
  borrowDate: Date
  returnDate: Date
  bookId: number
  studentId: number
  fromUniversityId: number
  toUniversityId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model LibraryBorrowing
 * 
 */
export type LibraryBorrowing = {
  id: number
  bookId: number
  borrowDate: Date
  returnDate: Date
  actualReturnDate: Date
  studentId: number
  universityId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TodoList
 * 
 */
export type TodoList = {
  id: number
  task: string
  status: string
  note: string | null
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const FacebookLikeTypeEnum: {
  SAD: 'SAD',
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  CARE: 'CARE',
  ANGRY: 'ANGRY',
  HAHA: 'HAHA',
  WOW: 'WOW'
};

export type FacebookLikeTypeEnum = (typeof FacebookLikeTypeEnum)[keyof typeof FacebookLikeTypeEnum]


export const ReactionEnum: {
  LIKE: 'LIKE',
  DISELIKE: 'DISELIKE'
};

export type ReactionEnum = (typeof ReactionEnum)[keyof typeof ReactionEnum]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BinKitchenCategories
 * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BinKitchenCategories
   * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.binKitchenCategory`: Exposes CRUD operations for the **BinKitchenCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenCategories
    * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
    * ```
    */
  get binKitchenCategory(): Prisma.BinKitchenCategoryDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenMenu`: Exposes CRUD operations for the **BinKitchenMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenMenus
    * const binKitchenMenus = await prisma.binKitchenMenu.findMany()
    * ```
    */
  get binKitchenMenu(): Prisma.BinKitchenMenuDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenOrder`: Exposes CRUD operations for the **BinKitchenOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenOrders
    * const binKitchenOrders = await prisma.binKitchenOrder.findMany()
    * ```
    */
  get binKitchenOrder(): Prisma.BinKitchenOrderDelegate<GlobalReject>;

  /**
   * `prisma.binKitchenOrderItem`: Exposes CRUD operations for the **BinKitchenOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BinKitchenOrderItems
    * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany()
    * ```
    */
  get binKitchenOrderItem(): Prisma.BinKitchenOrderItemDelegate<GlobalReject>;

  /**
   * `prisma.quizCategory`: Exposes CRUD operations for the **QuizCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizCategories
    * const quizCategories = await prisma.quizCategory.findMany()
    * ```
    */
  get quizCategory(): Prisma.QuizCategoryDelegate<GlobalReject>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<GlobalReject>;

  /**
   * `prisma.quizChoice`: Exposes CRUD operations for the **QuizChoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizChoices
    * const quizChoices = await prisma.quizChoice.findMany()
    * ```
    */
  get quizChoice(): Prisma.QuizChoiceDelegate<GlobalReject>;

  /**
   * `prisma.quizRoundQuestion`: Exposes CRUD operations for the **QuizRoundQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizRoundQuestions
    * const quizRoundQuestions = await prisma.quizRoundQuestion.findMany()
    * ```
    */
  get quizRoundQuestion(): Prisma.QuizRoundQuestionDelegate<GlobalReject>;

  /**
   * `prisma.quizRound`: Exposes CRUD operations for the **QuizRound** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizRounds
    * const quizRounds = await prisma.quizRound.findMany()
    * ```
    */
  get quizRound(): Prisma.QuizRoundDelegate<GlobalReject>;

  /**
   * `prisma.facebookUser`: Exposes CRUD operations for the **FacebookUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUsers
    * const facebookUsers = await prisma.facebookUser.findMany()
    * ```
    */
  get facebookUser(): Prisma.FacebookUserDelegate<GlobalReject>;

  /**
   * `prisma.facebookUserRelationship`: Exposes CRUD operations for the **FacebookUserRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUserRelationships
    * const facebookUserRelationships = await prisma.facebookUserRelationship.findMany()
    * ```
    */
  get facebookUserRelationship(): Prisma.FacebookUserRelationshipDelegate<GlobalReject>;

  /**
   * `prisma.facebookDirectMessage`: Exposes CRUD operations for the **FacebookDirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookDirectMessages
    * const facebookDirectMessages = await prisma.facebookDirectMessage.findMany()
    * ```
    */
  get facebookDirectMessage(): Prisma.FacebookDirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.facebookLocation`: Exposes CRUD operations for the **FacebookLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookLocations
    * const facebookLocations = await prisma.facebookLocation.findMany()
    * ```
    */
  get facebookLocation(): Prisma.FacebookLocationDelegate<GlobalReject>;

  /**
   * `prisma.facebookHashtag`: Exposes CRUD operations for the **FacebookHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookHashtags
    * const facebookHashtags = await prisma.facebookHashtag.findMany()
    * ```
    */
  get facebookHashtag(): Prisma.FacebookHashtagDelegate<GlobalReject>;

  /**
   * `prisma.facebookLike`: Exposes CRUD operations for the **FacebookLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookLikes
    * const facebookLikes = await prisma.facebookLike.findMany()
    * ```
    */
  get facebookLike(): Prisma.FacebookLikeDelegate<GlobalReject>;

  /**
   * `prisma.facebookShareType`: Exposes CRUD operations for the **FacebookShareType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookShareTypes
    * const facebookShareTypes = await prisma.facebookShareType.findMany()
    * ```
    */
  get facebookShareType(): Prisma.FacebookShareTypeDelegate<GlobalReject>;

  /**
   * `prisma.facebookGroup`: Exposes CRUD operations for the **FacebookGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookGroups
    * const facebookGroups = await prisma.facebookGroup.findMany()
    * ```
    */
  get facebookGroup(): Prisma.FacebookGroupDelegate<GlobalReject>;

  /**
   * `prisma.facebookUserInGroup`: Exposes CRUD operations for the **FacebookUserInGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookUserInGroups
    * const facebookUserInGroups = await prisma.facebookUserInGroup.findMany()
    * ```
    */
  get facebookUserInGroup(): Prisma.FacebookUserInGroupDelegate<GlobalReject>;

  /**
   * `prisma.facebookPostDestination`: Exposes CRUD operations for the **FacebookPostDestination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookPostDestinations
    * const facebookPostDestinations = await prisma.facebookPostDestination.findMany()
    * ```
    */
  get facebookPostDestination(): Prisma.FacebookPostDestinationDelegate<GlobalReject>;

  /**
   * `prisma.facebookPost`: Exposes CRUD operations for the **FacebookPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookPosts
    * const facebookPosts = await prisma.facebookPost.findMany()
    * ```
    */
  get facebookPost(): Prisma.FacebookPostDelegate<GlobalReject>;

  /**
   * `prisma.facebookCommentPost`: Exposes CRUD operations for the **FacebookCommentPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacebookCommentPosts
    * const facebookCommentPosts = await prisma.facebookCommentPost.findMany()
    * ```
    */
  get facebookCommentPost(): Prisma.FacebookCommentPostDelegate<GlobalReject>;

  /**
   * `prisma.twitterUser`: Exposes CRUD operations for the **TwitterUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUsers
    * const twitterUsers = await prisma.twitterUser.findMany()
    * ```
    */
  get twitterUser(): Prisma.TwitterUserDelegate<GlobalReject>;

  /**
   * `prisma.twitterPost`: Exposes CRUD operations for the **TwitterPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPosts
    * const twitterPosts = await prisma.twitterPost.findMany()
    * ```
    */
  get twitterPost(): Prisma.TwitterPostDelegate<GlobalReject>;

  /**
   * `prisma.twitterUserRelationship`: Exposes CRUD operations for the **TwitterUserRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterUserRelationships
    * const twitterUserRelationships = await prisma.twitterUserRelationship.findMany()
    * ```
    */
  get twitterUserRelationship(): Prisma.TwitterUserRelationshipDelegate<GlobalReject>;

  /**
   * `prisma.twitterHashtag`: Exposes CRUD operations for the **TwitterHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterHashtags
    * const twitterHashtags = await prisma.twitterHashtag.findMany()
    * ```
    */
  get twitterHashtag(): Prisma.TwitterHashtagDelegate<GlobalReject>;

  /**
   * `prisma.twitterPostAndHashtag`: Exposes CRUD operations for the **TwitterPostAndHashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterPostAndHashtags
    * const twitterPostAndHashtags = await prisma.twitterPostAndHashtag.findMany()
    * ```
    */
  get twitterPostAndHashtag(): Prisma.TwitterPostAndHashtagDelegate<GlobalReject>;

  /**
   * `prisma.twitterReplyPost`: Exposes CRUD operations for the **TwitterReplyPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterReplyPosts
    * const twitterReplyPosts = await prisma.twitterReplyPost.findMany()
    * ```
    */
  get twitterReplyPost(): Prisma.TwitterReplyPostDelegate<GlobalReject>;

  /**
   * `prisma.twitterDirectMessage`: Exposes CRUD operations for the **TwitterDirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterDirectMessages
    * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
    * ```
    */
  get twitterDirectMessage(): Prisma.TwitterDirectMessageDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUser`: Exposes CRUD operations for the **YoutubeUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUsers
    * const youtubeUsers = await prisma.youtubeUser.findMany()
    * ```
    */
  get youtubeUser(): Prisma.YoutubeUserDelegate<GlobalReject>;

  /**
   * `prisma.youtubeRole`: Exposes CRUD operations for the **YoutubeRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeRoles
    * const youtubeRoles = await prisma.youtubeRole.findMany()
    * ```
    */
  get youtubeRole(): Prisma.YoutubeRoleDelegate<GlobalReject>;

  /**
   * `prisma.youtubeChannel`: Exposes CRUD operations for the **YoutubeChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeChannels
    * const youtubeChannels = await prisma.youtubeChannel.findMany()
    * ```
    */
  get youtubeChannel(): Prisma.YoutubeChannelDelegate<GlobalReject>;

  /**
   * `prisma.youtubeUserToChannel`: Exposes CRUD operations for the **YoutubeUserToChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeUserToChannels
    * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
    * ```
    */
  get youtubeUserToChannel(): Prisma.YoutubeUserToChannelDelegate<GlobalReject>;

  /**
   * `prisma.youtubeVideo`: Exposes CRUD operations for the **YoutubeVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeVideos
    * const youtubeVideos = await prisma.youtubeVideo.findMany()
    * ```
    */
  get youtubeVideo(): Prisma.YoutubeVideoDelegate<GlobalReject>;

  /**
   * `prisma.youtubeSubscriber`: Exposes CRUD operations for the **YoutubeSubscriber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeSubscribers
    * const youtubeSubscribers = await prisma.youtubeSubscriber.findMany()
    * ```
    */
  get youtubeSubscriber(): Prisma.YoutubeSubscriberDelegate<GlobalReject>;

  /**
   * `prisma.youtubeReaction`: Exposes CRUD operations for the **YoutubeReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeReactions
    * const youtubeReactions = await prisma.youtubeReaction.findMany()
    * ```
    */
  get youtubeReaction(): Prisma.YoutubeReactionDelegate<GlobalReject>;

  /**
   * `prisma.youtubeComment`: Exposes CRUD operations for the **YoutubeComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YoutubeComments
    * const youtubeComments = await prisma.youtubeComment.findMany()
    * ```
    */
  get youtubeComment(): Prisma.YoutubeCommentDelegate<GlobalReject>;

  /**
   * `prisma.launderBranchInfo`: Exposes CRUD operations for the **LaunderBranchInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderBranchInfos
    * const launderBranchInfos = await prisma.launderBranchInfo.findMany()
    * ```
    */
  get launderBranchInfo(): Prisma.LaunderBranchInfoDelegate<GlobalReject>;

  /**
   * `prisma.launderMachine`: Exposes CRUD operations for the **LaunderMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderMachines
    * const launderMachines = await prisma.launderMachine.findMany()
    * ```
    */
  get launderMachine(): Prisma.LaunderMachineDelegate<GlobalReject>;

  /**
   * `prisma.laundryMachineInStore`: Exposes CRUD operations for the **LaundryMachineInStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryMachineInStores
    * const laundryMachineInStores = await prisma.laundryMachineInStore.findMany()
    * ```
    */
  get laundryMachineInStore(): Prisma.LaundryMachineInStoreDelegate<GlobalReject>;

  /**
   * `prisma.launderTechnician`: Exposes CRUD operations for the **LaunderTechnician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderTechnicians
    * const launderTechnicians = await prisma.launderTechnician.findMany()
    * ```
    */
  get launderTechnician(): Prisma.LaunderTechnicianDelegate<GlobalReject>;

  /**
   * `prisma.launderServiceHistory`: Exposes CRUD operations for the **LaunderServiceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderServiceHistories
    * const launderServiceHistories = await prisma.launderServiceHistory.findMany()
    * ```
    */
  get launderServiceHistory(): Prisma.LaunderServiceHistoryDelegate<GlobalReject>;

  /**
   * `prisma.launderWashingProgram`: Exposes CRUD operations for the **LaunderWashingProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderWashingPrograms
    * const launderWashingPrograms = await prisma.launderWashingProgram.findMany()
    * ```
    */
  get launderWashingProgram(): Prisma.LaunderWashingProgramDelegate<GlobalReject>;

  /**
   * `prisma.launderProgramInMachine`: Exposes CRUD operations for the **LaunderProgramInMachine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderProgramInMachines
    * const launderProgramInMachines = await prisma.launderProgramInMachine.findMany()
    * ```
    */
  get launderProgramInMachine(): Prisma.LaunderProgramInMachineDelegate<GlobalReject>;

  /**
   * `prisma.launderUser`: Exposes CRUD operations for the **LaunderUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunderUsers
    * const launderUsers = await prisma.launderUser.findMany()
    * ```
    */
  get launderUser(): Prisma.LaunderUserDelegate<GlobalReject>;

  /**
   * `prisma.laundryTopupHistory`: Exposes CRUD operations for the **LaundryTopupHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryTopupHistories
    * const laundryTopupHistories = await prisma.laundryTopupHistory.findMany()
    * ```
    */
  get laundryTopupHistory(): Prisma.LaundryTopupHistoryDelegate<GlobalReject>;

  /**
   * `prisma.laundryWashingHistory`: Exposes CRUD operations for the **LaundryWashingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaundryWashingHistories
    * const laundryWashingHistories = await prisma.laundryWashingHistory.findMany()
    * ```
    */
  get laundryWashingHistory(): Prisma.LaundryWashingHistoryDelegate<GlobalReject>;

  /**
   * `prisma.libraryStudent`: Exposes CRUD operations for the **LibraryStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryStudents
    * const libraryStudents = await prisma.libraryStudent.findMany()
    * ```
    */
  get libraryStudent(): Prisma.LibraryStudentDelegate<GlobalReject>;

  /**
   * `prisma.libraryUniversity`: Exposes CRUD operations for the **LibraryUniversity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryUniversities
    * const libraryUniversities = await prisma.libraryUniversity.findMany()
    * ```
    */
  get libraryUniversity(): Prisma.LibraryUniversityDelegate<GlobalReject>;

  /**
   * `prisma.libraryCategory`: Exposes CRUD operations for the **LibraryCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryCategories
    * const libraryCategories = await prisma.libraryCategory.findMany()
    * ```
    */
  get libraryCategory(): Prisma.LibraryCategoryDelegate<GlobalReject>;

  /**
   * `prisma.libraryAuthor`: Exposes CRUD operations for the **LibraryAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryAuthors
    * const libraryAuthors = await prisma.libraryAuthor.findMany()
    * ```
    */
  get libraryAuthor(): Prisma.LibraryAuthorDelegate<GlobalReject>;

  /**
   * `prisma.libraryBook`: Exposes CRUD operations for the **LibraryBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBooks
    * const libraryBooks = await prisma.libraryBook.findMany()
    * ```
    */
  get libraryBook(): Prisma.LibraryBookDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookCategory`: Exposes CRUD operations for the **LibraryBookCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookCategories
    * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
    * ```
    */
  get libraryBookCategory(): Prisma.LibraryBookCategoryDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookAuthor`: Exposes CRUD operations for the **LibraryBookAuthor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookAuthors
    * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany()
    * ```
    */
  get libraryBookAuthor(): Prisma.LibraryBookAuthorDelegate<GlobalReject>;

  /**
   * `prisma.libraryBookCopy`: Exposes CRUD operations for the **LibraryBookCopy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBookCopies
    * const libraryBookCopies = await prisma.libraryBookCopy.findMany()
    * ```
    */
  get libraryBookCopy(): Prisma.LibraryBookCopyDelegate<GlobalReject>;

  /**
   * `prisma.libraryRequest`: Exposes CRUD operations for the **LibraryRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryRequests
    * const libraryRequests = await prisma.libraryRequest.findMany()
    * ```
    */
  get libraryRequest(): Prisma.LibraryRequestDelegate<GlobalReject>;

  /**
   * `prisma.libraryBorrowing`: Exposes CRUD operations for the **LibraryBorrowing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryBorrowings
    * const libraryBorrowings = await prisma.libraryBorrowing.findMany()
    * ```
    */
  get libraryBorrowing(): Prisma.LibraryBorrowingDelegate<GlobalReject>;

  /**
   * `prisma.todoList`: Exposes CRUD operations for the **TodoList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TodoLists
    * const todoLists = await prisma.todoList.findMany()
    * ```
    */
  get todoList(): Prisma.TodoListDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: aead147aa326ccb985dcfed5b065b4fdabd44b19
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BinKitchenCategory: 'BinKitchenCategory',
    BinKitchenMenu: 'BinKitchenMenu',
    BinKitchenOrder: 'BinKitchenOrder',
    BinKitchenOrderItem: 'BinKitchenOrderItem',
    QuizCategory: 'QuizCategory',
    QuizQuestion: 'QuizQuestion',
    QuizChoice: 'QuizChoice',
    QuizRoundQuestion: 'QuizRoundQuestion',
    QuizRound: 'QuizRound',
    FacebookUser: 'FacebookUser',
    FacebookUserRelationship: 'FacebookUserRelationship',
    FacebookDirectMessage: 'FacebookDirectMessage',
    FacebookLocation: 'FacebookLocation',
    FacebookHashtag: 'FacebookHashtag',
    FacebookLike: 'FacebookLike',
    FacebookShareType: 'FacebookShareType',
    FacebookGroup: 'FacebookGroup',
    FacebookUserInGroup: 'FacebookUserInGroup',
    FacebookPostDestination: 'FacebookPostDestination',
    FacebookPost: 'FacebookPost',
    FacebookCommentPost: 'FacebookCommentPost',
    TwitterUser: 'TwitterUser',
    TwitterPost: 'TwitterPost',
    TwitterUserRelationship: 'TwitterUserRelationship',
    TwitterHashtag: 'TwitterHashtag',
    TwitterPostAndHashtag: 'TwitterPostAndHashtag',
    TwitterReplyPost: 'TwitterReplyPost',
    TwitterDirectMessage: 'TwitterDirectMessage',
    YoutubeUser: 'YoutubeUser',
    YoutubeRole: 'YoutubeRole',
    YoutubeChannel: 'YoutubeChannel',
    YoutubeUserToChannel: 'YoutubeUserToChannel',
    YoutubeVideo: 'YoutubeVideo',
    YoutubeSubscriber: 'YoutubeSubscriber',
    YoutubeReaction: 'YoutubeReaction',
    YoutubeComment: 'YoutubeComment',
    LaunderBranchInfo: 'LaunderBranchInfo',
    LaunderMachine: 'LaunderMachine',
    LaundryMachineInStore: 'LaundryMachineInStore',
    LaunderTechnician: 'LaunderTechnician',
    LaunderServiceHistory: 'LaunderServiceHistory',
    LaunderWashingProgram: 'LaunderWashingProgram',
    LaunderProgramInMachine: 'LaunderProgramInMachine',
    LaunderUser: 'LaunderUser',
    LaundryTopupHistory: 'LaundryTopupHistory',
    LaundryWashingHistory: 'LaundryWashingHistory',
    LibraryStudent: 'LibraryStudent',
    LibraryUniversity: 'LibraryUniversity',
    LibraryCategory: 'LibraryCategory',
    LibraryAuthor: 'LibraryAuthor',
    LibraryBook: 'LibraryBook',
    LibraryBookCategory: 'LibraryBookCategory',
    LibraryBookAuthor: 'LibraryBookAuthor',
    LibraryBookCopy: 'LibraryBookCopy',
    LibraryRequest: 'LibraryRequest',
    LibraryBorrowing: 'LibraryBorrowing',
    TodoList: 'TodoList'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BinKitchenCategoryCountOutputType
   */


  export type BinKitchenCategoryCountOutputType = {
    menus: number
  }

  export type BinKitchenCategoryCountOutputTypeSelect = {
    menus?: boolean
  }

  export type BinKitchenCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenCategoryCountOutputTypeArgs)
    ? BinKitchenCategoryCountOutputType 
    : S extends { select: any } & (BinKitchenCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenCategoryCountOutputType ? BinKitchenCategoryCountOutputType[P] : never
  } 
      : BinKitchenCategoryCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenCategoryCountOutputType without action
   */
  export type BinKitchenCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategoryCountOutputType
     */
    select?: BinKitchenCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type BinKitchenMenuCountOutputType
   */


  export type BinKitchenMenuCountOutputType = {
    orderItems: number
  }

  export type BinKitchenMenuCountOutputTypeSelect = {
    orderItems?: boolean
  }

  export type BinKitchenMenuCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenMenuCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenMenuCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenMenuCountOutputTypeArgs)
    ? BinKitchenMenuCountOutputType 
    : S extends { select: any } & (BinKitchenMenuCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenMenuCountOutputType ? BinKitchenMenuCountOutputType[P] : never
  } 
      : BinKitchenMenuCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenMenuCountOutputType without action
   */
  export type BinKitchenMenuCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenuCountOutputType
     */
    select?: BinKitchenMenuCountOutputTypeSelect | null
  }



  /**
   * Count Type BinKitchenOrderCountOutputType
   */


  export type BinKitchenOrderCountOutputType = {
    items: number
  }

  export type BinKitchenOrderCountOutputTypeSelect = {
    items?: boolean
  }

  export type BinKitchenOrderCountOutputTypeGetPayload<S extends boolean | null | undefined | BinKitchenOrderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderCountOutputTypeArgs)
    ? BinKitchenOrderCountOutputType 
    : S extends { select: any } & (BinKitchenOrderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BinKitchenOrderCountOutputType ? BinKitchenOrderCountOutputType[P] : never
  } 
      : BinKitchenOrderCountOutputType




  // Custom InputTypes

  /**
   * BinKitchenOrderCountOutputType without action
   */
  export type BinKitchenOrderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderCountOutputType
     */
    select?: BinKitchenOrderCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizCategoryCountOutputType
   */


  export type QuizCategoryCountOutputType = {
    questions: number
    rounds: number
  }

  export type QuizCategoryCountOutputTypeSelect = {
    questions?: boolean
    rounds?: boolean
  }

  export type QuizCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryCountOutputTypeArgs)
    ? QuizCategoryCountOutputType 
    : S extends { select: any } & (QuizCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizCategoryCountOutputType ? QuizCategoryCountOutputType[P] : never
  } 
      : QuizCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuizCategoryCountOutputType without action
   */
  export type QuizCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizCategoryCountOutputType
     */
    select?: QuizCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizQuestionCountOutputType
   */


  export type QuizQuestionCountOutputType = {
    choices: number
    roundQuestions: number
  }

  export type QuizQuestionCountOutputTypeSelect = {
    choices?: boolean
    roundQuestions?: boolean
  }

  export type QuizQuestionCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizQuestionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizQuestionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizQuestionCountOutputTypeArgs)
    ? QuizQuestionCountOutputType 
    : S extends { select: any } & (QuizQuestionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizQuestionCountOutputType ? QuizQuestionCountOutputType[P] : never
  } 
      : QuizQuestionCountOutputType




  // Custom InputTypes

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuizRoundCountOutputType
   */


  export type QuizRoundCountOutputType = {
    questions: number
  }

  export type QuizRoundCountOutputTypeSelect = {
    questions?: boolean
  }

  export type QuizRoundCountOutputTypeGetPayload<S extends boolean | null | undefined | QuizRoundCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRoundCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuizRoundCountOutputTypeArgs)
    ? QuizRoundCountOutputType 
    : S extends { select: any } & (QuizRoundCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuizRoundCountOutputType ? QuizRoundCountOutputType[P] : never
  } 
      : QuizRoundCountOutputType




  // Custom InputTypes

  /**
   * QuizRoundCountOutputType without action
   */
  export type QuizRoundCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundCountOutputType
     */
    select?: QuizRoundCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookUserCountOutputType
   */


  export type FacebookUserCountOutputType = {
    from: number
    to: number
    userInGroups: number
    posts: number
    directMessageFrom: number
    directMessageTo: number
    commentPosts: number
    likes: number
    postDestinations: number
  }

  export type FacebookUserCountOutputTypeSelect = {
    from?: boolean
    to?: boolean
    userInGroups?: boolean
    posts?: boolean
    directMessageFrom?: boolean
    directMessageTo?: boolean
    commentPosts?: boolean
    likes?: boolean
    postDestinations?: boolean
  }

  export type FacebookUserCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserCountOutputTypeArgs)
    ? FacebookUserCountOutputType 
    : S extends { select: any } & (FacebookUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookUserCountOutputType ? FacebookUserCountOutputType[P] : never
  } 
      : FacebookUserCountOutputType




  // Custom InputTypes

  /**
   * FacebookUserCountOutputType without action
   */
  export type FacebookUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserCountOutputType
     */
    select?: FacebookUserCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookLocationCountOutputType
   */


  export type FacebookLocationCountOutputType = {
    posts: number
  }

  export type FacebookLocationCountOutputTypeSelect = {
    posts?: boolean
  }

  export type FacebookLocationCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookLocationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookLocationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookLocationCountOutputTypeArgs)
    ? FacebookLocationCountOutputType 
    : S extends { select: any } & (FacebookLocationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookLocationCountOutputType ? FacebookLocationCountOutputType[P] : never
  } 
      : FacebookLocationCountOutputType




  // Custom InputTypes

  /**
   * FacebookLocationCountOutputType without action
   */
  export type FacebookLocationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocationCountOutputType
     */
    select?: FacebookLocationCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookHashtagCountOutputType
   */


  export type FacebookHashtagCountOutputType = {
    posts: number
  }

  export type FacebookHashtagCountOutputTypeSelect = {
    posts?: boolean
  }

  export type FacebookHashtagCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookHashtagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashtagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashtagCountOutputTypeArgs)
    ? FacebookHashtagCountOutputType 
    : S extends { select: any } & (FacebookHashtagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookHashtagCountOutputType ? FacebookHashtagCountOutputType[P] : never
  } 
      : FacebookHashtagCountOutputType




  // Custom InputTypes

  /**
   * FacebookHashtagCountOutputType without action
   */
  export type FacebookHashtagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtagCountOutputType
     */
    select?: FacebookHashtagCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookShareTypeCountOutputType
   */


  export type FacebookShareTypeCountOutputType = {
    commentPosts: number
    posts: number
  }

  export type FacebookShareTypeCountOutputTypeSelect = {
    commentPosts?: boolean
    posts?: boolean
  }

  export type FacebookShareTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookShareTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookShareTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookShareTypeCountOutputTypeArgs)
    ? FacebookShareTypeCountOutputType 
    : S extends { select: any } & (FacebookShareTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookShareTypeCountOutputType ? FacebookShareTypeCountOutputType[P] : never
  } 
      : FacebookShareTypeCountOutputType




  // Custom InputTypes

  /**
   * FacebookShareTypeCountOutputType without action
   */
  export type FacebookShareTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareTypeCountOutputType
     */
    select?: FacebookShareTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookGroupCountOutputType
   */


  export type FacebookGroupCountOutputType = {
    userInGroups: number
    postDestinations: number
  }

  export type FacebookGroupCountOutputTypeSelect = {
    userInGroups?: boolean
    postDestinations?: boolean
  }

  export type FacebookGroupCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookGroupCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookGroupCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookGroupCountOutputTypeArgs)
    ? FacebookGroupCountOutputType 
    : S extends { select: any } & (FacebookGroupCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookGroupCountOutputType ? FacebookGroupCountOutputType[P] : never
  } 
      : FacebookGroupCountOutputType




  // Custom InputTypes

  /**
   * FacebookGroupCountOutputType without action
   */
  export type FacebookGroupCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroupCountOutputType
     */
    select?: FacebookGroupCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookPostCountOutputType
   */


  export type FacebookPostCountOutputType = {
    likes: number
    commentPosts: number
    postDestionations: number
  }

  export type FacebookPostCountOutputTypeSelect = {
    likes?: boolean
    commentPosts?: boolean
    postDestionations?: boolean
  }

  export type FacebookPostCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookPostCountOutputTypeArgs)
    ? FacebookPostCountOutputType 
    : S extends { select: any } & (FacebookPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookPostCountOutputType ? FacebookPostCountOutputType[P] : never
  } 
      : FacebookPostCountOutputType




  // Custom InputTypes

  /**
   * FacebookPostCountOutputType without action
   */
  export type FacebookPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostCountOutputType
     */
    select?: FacebookPostCountOutputTypeSelect | null
  }



  /**
   * Count Type FacebookCommentPostCountOutputType
   */


  export type FacebookCommentPostCountOutputType = {
    commentPosts: number
  }

  export type FacebookCommentPostCountOutputTypeSelect = {
    commentPosts?: boolean
  }

  export type FacebookCommentPostCountOutputTypeGetPayload<S extends boolean | null | undefined | FacebookCommentPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookCommentPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookCommentPostCountOutputTypeArgs)
    ? FacebookCommentPostCountOutputType 
    : S extends { select: any } & (FacebookCommentPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FacebookCommentPostCountOutputType ? FacebookCommentPostCountOutputType[P] : never
  } 
      : FacebookCommentPostCountOutputType




  // Custom InputTypes

  /**
   * FacebookCommentPostCountOutputType without action
   */
  export type FacebookCommentPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPostCountOutputType
     */
    select?: FacebookCommentPostCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterUserCountOutputType
   */


  export type TwitterUserCountOutputType = {
    posts: number
    followings: number
    followers: number
    replyPosts: number
    directMessageFrom: number
    directMessageTo: number
  }

  export type TwitterUserCountOutputTypeSelect = {
    posts?: boolean
    followings?: boolean
    followers?: boolean
    replyPosts?: boolean
    directMessageFrom?: boolean
    directMessageTo?: boolean
  }

  export type TwitterUserCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserCountOutputTypeArgs)
    ? TwitterUserCountOutputType 
    : S extends { select: any } & (TwitterUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterUserCountOutputType ? TwitterUserCountOutputType[P] : never
  } 
      : TwitterUserCountOutputType




  // Custom InputTypes

  /**
   * TwitterUserCountOutputType without action
   */
  export type TwitterUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserCountOutputType
     */
    select?: TwitterUserCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterPostCountOutputType
   */


  export type TwitterPostCountOutputType = {
    postAndHashtags: number
    replyPosts: number
  }

  export type TwitterPostCountOutputTypeSelect = {
    postAndHashtags?: boolean
    replyPosts?: boolean
  }

  export type TwitterPostCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostCountOutputTypeArgs)
    ? TwitterPostCountOutputType 
    : S extends { select: any } & (TwitterPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterPostCountOutputType ? TwitterPostCountOutputType[P] : never
  } 
      : TwitterPostCountOutputType




  // Custom InputTypes

  /**
   * TwitterPostCountOutputType without action
   */
  export type TwitterPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostCountOutputType
     */
    select?: TwitterPostCountOutputTypeSelect | null
  }



  /**
   * Count Type TwitterHashtagCountOutputType
   */


  export type TwitterHashtagCountOutputType = {
    postAndHashtags: number
  }

  export type TwitterHashtagCountOutputTypeSelect = {
    postAndHashtags?: boolean
  }

  export type TwitterHashtagCountOutputTypeGetPayload<S extends boolean | null | undefined | TwitterHashtagCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtagCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagCountOutputTypeArgs)
    ? TwitterHashtagCountOutputType 
    : S extends { select: any } & (TwitterHashtagCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TwitterHashtagCountOutputType ? TwitterHashtagCountOutputType[P] : never
  } 
      : TwitterHashtagCountOutputType




  // Custom InputTypes

  /**
   * TwitterHashtagCountOutputType without action
   */
  export type TwitterHashtagCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtagCountOutputType
     */
    select?: TwitterHashtagCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeUserCountOutputType
   */


  export type YoutubeUserCountOutputType = {
    userToChannels: number
    subscribers: number
    reactions: number
    comments: number
  }

  export type YoutubeUserCountOutputTypeSelect = {
    userToChannels?: boolean
    subscribers?: boolean
    reactions?: boolean
    comments?: boolean
  }

  export type YoutubeUserCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserCountOutputTypeArgs)
    ? YoutubeUserCountOutputType 
    : S extends { select: any } & (YoutubeUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeUserCountOutputType ? YoutubeUserCountOutputType[P] : never
  } 
      : YoutubeUserCountOutputType




  // Custom InputTypes

  /**
   * YoutubeUserCountOutputType without action
   */
  export type YoutubeUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserCountOutputType
     */
    select?: YoutubeUserCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeRoleCountOutputType
   */


  export type YoutubeRoleCountOutputType = {
    userToChannels: number
  }

  export type YoutubeRoleCountOutputTypeSelect = {
    userToChannels?: boolean
  }

  export type YoutubeRoleCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeRoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeRoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeRoleCountOutputTypeArgs)
    ? YoutubeRoleCountOutputType 
    : S extends { select: any } & (YoutubeRoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeRoleCountOutputType ? YoutubeRoleCountOutputType[P] : never
  } 
      : YoutubeRoleCountOutputType




  // Custom InputTypes

  /**
   * YoutubeRoleCountOutputType without action
   */
  export type YoutubeRoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRoleCountOutputType
     */
    select?: YoutubeRoleCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeChannelCountOutputType
   */


  export type YoutubeChannelCountOutputType = {
    userToChannels: number
    videos: number
    subscribers: number
  }

  export type YoutubeChannelCountOutputTypeSelect = {
    userToChannels?: boolean
    videos?: boolean
    subscribers?: boolean
  }

  export type YoutubeChannelCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeChannelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelCountOutputTypeArgs)
    ? YoutubeChannelCountOutputType 
    : S extends { select: any } & (YoutubeChannelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeChannelCountOutputType ? YoutubeChannelCountOutputType[P] : never
  } 
      : YoutubeChannelCountOutputType




  // Custom InputTypes

  /**
   * YoutubeChannelCountOutputType without action
   */
  export type YoutubeChannelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannelCountOutputType
     */
    select?: YoutubeChannelCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeVideoCountOutputType
   */


  export type YoutubeVideoCountOutputType = {
    comments: number
    reactions: number
  }

  export type YoutubeVideoCountOutputTypeSelect = {
    comments?: boolean
    reactions?: boolean
  }

  export type YoutubeVideoCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeVideoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoCountOutputTypeArgs)
    ? YoutubeVideoCountOutputType 
    : S extends { select: any } & (YoutubeVideoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeVideoCountOutputType ? YoutubeVideoCountOutputType[P] : never
  } 
      : YoutubeVideoCountOutputType




  // Custom InputTypes

  /**
   * YoutubeVideoCountOutputType without action
   */
  export type YoutubeVideoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideoCountOutputType
     */
    select?: YoutubeVideoCountOutputTypeSelect | null
  }



  /**
   * Count Type YoutubeCommentCountOutputType
   */


  export type YoutubeCommentCountOutputType = {
    commentPosts: number
  }

  export type YoutubeCommentCountOutputTypeSelect = {
    commentPosts?: boolean
  }

  export type YoutubeCommentCountOutputTypeGetPayload<S extends boolean | null | undefined | YoutubeCommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeCommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentCountOutputTypeArgs)
    ? YoutubeCommentCountOutputType 
    : S extends { select: any } & (YoutubeCommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof YoutubeCommentCountOutputType ? YoutubeCommentCountOutputType[P] : never
  } 
      : YoutubeCommentCountOutputType




  // Custom InputTypes

  /**
   * YoutubeCommentCountOutputType without action
   */
  export type YoutubeCommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the YoutubeCommentCountOutputType
     */
    select?: YoutubeCommentCountOutputTypeSelect | null
  }



  /**
   * Count Type LaunderBranchInfoCountOutputType
   */


  export type LaunderBranchInfoCountOutputType = {
    machineInStores: number
  }

  export type LaunderBranchInfoCountOutputTypeSelect = {
    machineInStores?: boolean
  }

  export type LaunderBranchInfoCountOutputTypeGetPayload<S extends boolean | null | undefined | LaunderBranchInfoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderBranchInfoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaunderBranchInfoCountOutputTypeArgs)
    ? LaunderBranchInfoCountOutputType 
    : S extends { select: any } & (LaunderBranchInfoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaunderBranchInfoCountOutputType ? LaunderBranchInfoCountOutputType[P] : never
  } 
      : LaunderBranchInfoCountOutputType




  // Custom InputTypes

  /**
   * LaunderBranchInfoCountOutputType without action
   */
  export type LaunderBranchInfoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfoCountOutputType
     */
    select?: LaunderBranchInfoCountOutputTypeSelect | null
  }



  /**
   * Count Type LaunderMachineCountOutputType
   */


  export type LaunderMachineCountOutputType = {
    machineInStores: number
    serviceHistories: number
  }

  export type LaunderMachineCountOutputTypeSelect = {
    machineInStores?: boolean
    serviceHistories?: boolean
  }

  export type LaunderMachineCountOutputTypeGetPayload<S extends boolean | null | undefined | LaunderMachineCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderMachineCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaunderMachineCountOutputTypeArgs)
    ? LaunderMachineCountOutputType 
    : S extends { select: any } & (LaunderMachineCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaunderMachineCountOutputType ? LaunderMachineCountOutputType[P] : never
  } 
      : LaunderMachineCountOutputType




  // Custom InputTypes

  /**
   * LaunderMachineCountOutputType without action
   */
  export type LaunderMachineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachineCountOutputType
     */
    select?: LaunderMachineCountOutputTypeSelect | null
  }



  /**
   * Count Type LaundryMachineInStoreCountOutputType
   */


  export type LaundryMachineInStoreCountOutputType = {
    programInMachines: number
    washingHistories: number
  }

  export type LaundryMachineInStoreCountOutputTypeSelect = {
    programInMachines?: boolean
    washingHistories?: boolean
  }

  export type LaundryMachineInStoreCountOutputTypeGetPayload<S extends boolean | null | undefined | LaundryMachineInStoreCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryMachineInStoreCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaundryMachineInStoreCountOutputTypeArgs)
    ? LaundryMachineInStoreCountOutputType 
    : S extends { select: any } & (LaundryMachineInStoreCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaundryMachineInStoreCountOutputType ? LaundryMachineInStoreCountOutputType[P] : never
  } 
      : LaundryMachineInStoreCountOutputType




  // Custom InputTypes

  /**
   * LaundryMachineInStoreCountOutputType without action
   */
  export type LaundryMachineInStoreCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStoreCountOutputType
     */
    select?: LaundryMachineInStoreCountOutputTypeSelect | null
  }



  /**
   * Count Type LaunderTechnicianCountOutputType
   */


  export type LaunderTechnicianCountOutputType = {
    serviceHistories: number
  }

  export type LaunderTechnicianCountOutputTypeSelect = {
    serviceHistories?: boolean
  }

  export type LaunderTechnicianCountOutputTypeGetPayload<S extends boolean | null | undefined | LaunderTechnicianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderTechnicianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaunderTechnicianCountOutputTypeArgs)
    ? LaunderTechnicianCountOutputType 
    : S extends { select: any } & (LaunderTechnicianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaunderTechnicianCountOutputType ? LaunderTechnicianCountOutputType[P] : never
  } 
      : LaunderTechnicianCountOutputType




  // Custom InputTypes

  /**
   * LaunderTechnicianCountOutputType without action
   */
  export type LaunderTechnicianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnicianCountOutputType
     */
    select?: LaunderTechnicianCountOutputTypeSelect | null
  }



  /**
   * Count Type LaunderWashingProgramCountOutputType
   */


  export type LaunderWashingProgramCountOutputType = {
    programInMachines: number
    washingHistories: number
  }

  export type LaunderWashingProgramCountOutputTypeSelect = {
    programInMachines?: boolean
    washingHistories?: boolean
  }

  export type LaunderWashingProgramCountOutputTypeGetPayload<S extends boolean | null | undefined | LaunderWashingProgramCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderWashingProgramCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaunderWashingProgramCountOutputTypeArgs)
    ? LaunderWashingProgramCountOutputType 
    : S extends { select: any } & (LaunderWashingProgramCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaunderWashingProgramCountOutputType ? LaunderWashingProgramCountOutputType[P] : never
  } 
      : LaunderWashingProgramCountOutputType




  // Custom InputTypes

  /**
   * LaunderWashingProgramCountOutputType without action
   */
  export type LaunderWashingProgramCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgramCountOutputType
     */
    select?: LaunderWashingProgramCountOutputTypeSelect | null
  }



  /**
   * Count Type LaunderUserCountOutputType
   */


  export type LaunderUserCountOutputType = {
    topupHistories: number
  }

  export type LaunderUserCountOutputTypeSelect = {
    topupHistories?: boolean
  }

  export type LaunderUserCountOutputTypeGetPayload<S extends boolean | null | undefined | LaunderUserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderUserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LaunderUserCountOutputTypeArgs)
    ? LaunderUserCountOutputType 
    : S extends { select: any } & (LaunderUserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LaunderUserCountOutputType ? LaunderUserCountOutputType[P] : never
  } 
      : LaunderUserCountOutputType




  // Custom InputTypes

  /**
   * LaunderUserCountOutputType without action
   */
  export type LaunderUserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LaunderUserCountOutputType
     */
    select?: LaunderUserCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryStudentCountOutputType
   */


  export type LibraryStudentCountOutputType = {
    requests: number
    borrowings: number
  }

  export type LibraryStudentCountOutputTypeSelect = {
    requests?: boolean
    borrowings?: boolean
  }

  export type LibraryStudentCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryStudentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryStudentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryStudentCountOutputTypeArgs)
    ? LibraryStudentCountOutputType 
    : S extends { select: any } & (LibraryStudentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryStudentCountOutputType ? LibraryStudentCountOutputType[P] : never
  } 
      : LibraryStudentCountOutputType




  // Custom InputTypes

  /**
   * LibraryStudentCountOutputType without action
   */
  export type LibraryStudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudentCountOutputType
     */
    select?: LibraryStudentCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryUniversityCountOutputType
   */


  export type LibraryUniversityCountOutputType = {
    bookCopies: number
    fromRequests: number
    toRequests: number
    borrowings: number
  }

  export type LibraryUniversityCountOutputTypeSelect = {
    bookCopies?: boolean
    fromRequests?: boolean
    toRequests?: boolean
    borrowings?: boolean
  }

  export type LibraryUniversityCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryUniversityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryUniversityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryUniversityCountOutputTypeArgs)
    ? LibraryUniversityCountOutputType 
    : S extends { select: any } & (LibraryUniversityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryUniversityCountOutputType ? LibraryUniversityCountOutputType[P] : never
  } 
      : LibraryUniversityCountOutputType




  // Custom InputTypes

  /**
   * LibraryUniversityCountOutputType without action
   */
  export type LibraryUniversityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversityCountOutputType
     */
    select?: LibraryUniversityCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryCategoryCountOutputType
   */


  export type LibraryCategoryCountOutputType = {
    bookCategories: number
  }

  export type LibraryCategoryCountOutputTypeSelect = {
    bookCategories?: boolean
  }

  export type LibraryCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryCategoryCountOutputTypeArgs)
    ? LibraryCategoryCountOutputType 
    : S extends { select: any } & (LibraryCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryCategoryCountOutputType ? LibraryCategoryCountOutputType[P] : never
  } 
      : LibraryCategoryCountOutputType




  // Custom InputTypes

  /**
   * LibraryCategoryCountOutputType without action
   */
  export type LibraryCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategoryCountOutputType
     */
    select?: LibraryCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryAuthorCountOutputType
   */


  export type LibraryAuthorCountOutputType = {
    bookAuthors: number
  }

  export type LibraryAuthorCountOutputTypeSelect = {
    bookAuthors?: boolean
  }

  export type LibraryAuthorCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryAuthorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryAuthorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryAuthorCountOutputTypeArgs)
    ? LibraryAuthorCountOutputType 
    : S extends { select: any } & (LibraryAuthorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryAuthorCountOutputType ? LibraryAuthorCountOutputType[P] : never
  } 
      : LibraryAuthorCountOutputType




  // Custom InputTypes

  /**
   * LibraryAuthorCountOutputType without action
   */
  export type LibraryAuthorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthorCountOutputType
     */
    select?: LibraryAuthorCountOutputTypeSelect | null
  }



  /**
   * Count Type LibraryBookCountOutputType
   */


  export type LibraryBookCountOutputType = {
    bookCategories: number
    bookAuthors: number
    bookCopies: number
    requests: number
    borrowings: number
  }

  export type LibraryBookCountOutputTypeSelect = {
    bookCategories?: boolean
    bookAuthors?: boolean
    bookCopies?: boolean
    requests?: boolean
    borrowings?: boolean
  }

  export type LibraryBookCountOutputTypeGetPayload<S extends boolean | null | undefined | LibraryBookCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCountOutputTypeArgs)
    ? LibraryBookCountOutputType 
    : S extends { select: any } & (LibraryBookCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LibraryBookCountOutputType ? LibraryBookCountOutputType[P] : never
  } 
      : LibraryBookCountOutputType




  // Custom InputTypes

  /**
   * LibraryBookCountOutputType without action
   */
  export type LibraryBookCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCountOutputType
     */
    select?: LibraryBookCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model BinKitchenCategory
   */


  export type AggregateBinKitchenCategory = {
    _count: BinKitchenCategoryCountAggregateOutputType | null
    _avg: BinKitchenCategoryAvgAggregateOutputType | null
    _sum: BinKitchenCategorySumAggregateOutputType | null
    _min: BinKitchenCategoryMinAggregateOutputType | null
    _max: BinKitchenCategoryMaxAggregateOutputType | null
  }

  export type BinKitchenCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type BinKitchenCategorySumAggregateOutputType = {
    id: number | null
  }

  export type BinKitchenCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenCategoryAvgAggregateInputType = {
    id?: true
  }

  export type BinKitchenCategorySumAggregateInputType = {
    id?: true
  }

  export type BinKitchenCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenCategoryAggregateArgs = {
    /**
     * Filter which BinKitchenCategory to aggregate.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenCategories
    **/
    _count?: true | BinKitchenCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenCategoryMaxAggregateInputType
  }

  export type GetBinKitchenCategoryAggregateType<T extends BinKitchenCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenCategory[P]>
      : GetScalarType<T[P], AggregateBinKitchenCategory[P]>
  }




  export type BinKitchenCategoryGroupByArgs = {
    where?: BinKitchenCategoryWhereInput
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithAggregationInput>
    by: BinKitchenCategoryScalarFieldEnum[]
    having?: BinKitchenCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenCategoryCountAggregateInputType | true
    _avg?: BinKitchenCategoryAvgAggregateInputType
    _sum?: BinKitchenCategorySumAggregateInputType
    _min?: BinKitchenCategoryMinAggregateInputType
    _max?: BinKitchenCategoryMaxAggregateInputType
  }


  export type BinKitchenCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenCategoryCountAggregateOutputType | null
    _avg: BinKitchenCategoryAvgAggregateOutputType | null
    _sum: BinKitchenCategorySumAggregateOutputType | null
    _min: BinKitchenCategoryMinAggregateOutputType | null
    _max: BinKitchenCategoryMaxAggregateOutputType | null
  }

  type GetBinKitchenCategoryGroupByPayload<T extends BinKitchenCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenCategorySelect = {
    id?: boolean
    name?: boolean
    menus?: boolean | BinKitchenCategory$menusArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BinKitchenCategoryCountOutputTypeArgs
  }


  export type BinKitchenCategoryInclude = {
    menus?: boolean | BinKitchenCategory$menusArgs
    _count?: boolean | BinKitchenCategoryCountOutputTypeArgs
  }

  export type BinKitchenCategoryGetPayload<S extends boolean | null | undefined | BinKitchenCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenCategory :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenCategoryArgs | BinKitchenCategoryFindManyArgs)
    ? BinKitchenCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menus' ? Array < BinKitchenMenuGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenCategoryArgs | BinKitchenCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menus' ? Array < BinKitchenMenuGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenCategory ? BinKitchenCategory[P] : never
  } 
      : BinKitchenCategory


  type BinKitchenCategoryCountArgs = 
    Omit<BinKitchenCategoryFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenCategoryCountAggregateInputType | true
    }

  export interface BinKitchenCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenCategory that matches the filter.
     * @param {BinKitchenCategoryFindUniqueArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenCategory'> extends True ? Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>> : Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find one BinKitchenCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenCategoryFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Find the first BinKitchenCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindFirstArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenCategory'> extends True ? Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>> : Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindFirstOrThrowArgs} args - Arguments to find a BinKitchenCategory
     * @example
     * // Get one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindFirstOrThrowArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Find zero or more BinKitchenCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenCategories
     * const binKitchenCategories = await prisma.binKitchenCategory.findMany()
     * 
     * // Get first 10 BinKitchenCategories
     * const binKitchenCategories = await prisma.binKitchenCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenCategoryWithIdOnly = await prisma.binKitchenCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenCategoryFindManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenCategoryGetPayload<T>>>

    /**
     * Create a BinKitchenCategory.
     * @param {BinKitchenCategoryCreateArgs} args - Arguments to create a BinKitchenCategory.
     * @example
     * // Create one BinKitchenCategory
     * const BinKitchenCategory = await prisma.binKitchenCategory.create({
     *   data: {
     *     // ... data to create a BinKitchenCategory
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenCategoryCreateArgs>(
      args: SelectSubset<T, BinKitchenCategoryCreateArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Create many BinKitchenCategories.
     *     @param {BinKitchenCategoryCreateManyArgs} args - Arguments to create many BinKitchenCategories.
     *     @example
     *     // Create many BinKitchenCategories
     *     const binKitchenCategory = await prisma.binKitchenCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenCategoryCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenCategory.
     * @param {BinKitchenCategoryDeleteArgs} args - Arguments to delete one BinKitchenCategory.
     * @example
     * // Delete one BinKitchenCategory
     * const BinKitchenCategory = await prisma.binKitchenCategory.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenCategory
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenCategoryDeleteArgs>(
      args: SelectSubset<T, BinKitchenCategoryDeleteArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Update one BinKitchenCategory.
     * @param {BinKitchenCategoryUpdateArgs} args - Arguments to update one BinKitchenCategory.
     * @example
     * // Update one BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenCategoryUpdateArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpdateArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Delete zero or more BinKitchenCategories.
     * @param {BinKitchenCategoryDeleteManyArgs} args - Arguments to filter BinKitchenCategories to delete.
     * @example
     * // Delete a few BinKitchenCategories
     * const { count } = await prisma.binKitchenCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenCategoryDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenCategories
     * const binKitchenCategory = await prisma.binKitchenCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenCategoryUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenCategory.
     * @param {BinKitchenCategoryUpsertArgs} args - Arguments to update or create a BinKitchenCategory.
     * @example
     * // Update or create a BinKitchenCategory
     * const binKitchenCategory = await prisma.binKitchenCategory.upsert({
     *   create: {
     *     // ... data to create a BinKitchenCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenCategory we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenCategoryUpsertArgs>(
      args: SelectSubset<T, BinKitchenCategoryUpsertArgs>
    ): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T>>

    /**
     * Count the number of BinKitchenCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryCountArgs} args - Arguments to filter BinKitchenCategories to count.
     * @example
     * // Count the number of BinKitchenCategories
     * const count = await prisma.binKitchenCategory.count({
     *   where: {
     *     // ... the filter for the BinKitchenCategories we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenCategoryCountArgs>(
      args?: Subset<T, BinKitchenCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenCategoryAggregateArgs>(args: Subset<T, BinKitchenCategoryAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenCategoryAggregateType<T>>

    /**
     * Group by BinKitchenCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menus<T extends BinKitchenCategory$menusArgs= {}>(args?: Subset<T, BinKitchenCategory$menusArgs>): Prisma.PrismaPromise<Array<BinKitchenMenuGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenCategory base type for findUnique actions
   */
  export type BinKitchenCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }

  /**
   * BinKitchenCategory findUnique
   */
  export interface BinKitchenCategoryFindUniqueArgs extends BinKitchenCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenCategory findUniqueOrThrow
   */
  export type BinKitchenCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory base type for findFirst actions
   */
  export type BinKitchenCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenCategories.
     */
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }

  /**
   * BinKitchenCategory findFirst
   */
  export interface BinKitchenCategoryFindFirstArgs extends BinKitchenCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenCategory findFirstOrThrow
   */
  export type BinKitchenCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategory to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenCategories.
     */
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }


  /**
   * BinKitchenCategory findMany
   */
  export type BinKitchenCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter, which BinKitchenCategories to fetch.
     */
    where?: BinKitchenCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenCategories to fetch.
     */
    orderBy?: Enumerable<BinKitchenCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenCategories.
     */
    cursor?: BinKitchenCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenCategories.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenCategoryScalarFieldEnum>
  }


  /**
   * BinKitchenCategory create
   */
  export type BinKitchenCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The data needed to create a BinKitchenCategory.
     */
    data: XOR<BinKitchenCategoryCreateInput, BinKitchenCategoryUncheckedCreateInput>
  }


  /**
   * BinKitchenCategory createMany
   */
  export type BinKitchenCategoryCreateManyArgs = {
    /**
     * The data used to create many BinKitchenCategories.
     */
    data: Enumerable<BinKitchenCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenCategory update
   */
  export type BinKitchenCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The data needed to update a BinKitchenCategory.
     */
    data: XOR<BinKitchenCategoryUpdateInput, BinKitchenCategoryUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenCategory to update.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory updateMany
   */
  export type BinKitchenCategoryUpdateManyArgs = {
    /**
     * The data used to update BinKitchenCategories.
     */
    data: XOR<BinKitchenCategoryUpdateManyMutationInput, BinKitchenCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenCategories to update
     */
    where?: BinKitchenCategoryWhereInput
  }


  /**
   * BinKitchenCategory upsert
   */
  export type BinKitchenCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * The filter to search for the BinKitchenCategory to update in case it exists.
     */
    where: BinKitchenCategoryWhereUniqueInput
    /**
     * In case the BinKitchenCategory found by the `where` argument doesn't exist, create a new BinKitchenCategory with this data.
     */
    create: XOR<BinKitchenCategoryCreateInput, BinKitchenCategoryUncheckedCreateInput>
    /**
     * In case the BinKitchenCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenCategoryUpdateInput, BinKitchenCategoryUncheckedUpdateInput>
  }


  /**
   * BinKitchenCategory delete
   */
  export type BinKitchenCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
    /**
     * Filter which BinKitchenCategory to delete.
     */
    where: BinKitchenCategoryWhereUniqueInput
  }


  /**
   * BinKitchenCategory deleteMany
   */
  export type BinKitchenCategoryDeleteManyArgs = {
    /**
     * Filter which BinKitchenCategories to delete
     */
    where?: BinKitchenCategoryWhereInput
  }


  /**
   * BinKitchenCategory.menus
   */
  export type BinKitchenCategory$menusArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    where?: BinKitchenMenuWhereInput
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    cursor?: BinKitchenMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenCategory without action
   */
  export type BinKitchenCategoryArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenCategory
     */
    select?: BinKitchenCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenCategoryInclude | null
  }



  /**
   * Model BinKitchenMenu
   */


  export type AggregateBinKitchenMenu = {
    _count: BinKitchenMenuCountAggregateOutputType | null
    _avg: BinKitchenMenuAvgAggregateOutputType | null
    _sum: BinKitchenMenuSumAggregateOutputType | null
    _min: BinKitchenMenuMinAggregateOutputType | null
    _max: BinKitchenMenuMaxAggregateOutputType | null
  }

  export type BinKitchenMenuAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BinKitchenMenuSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type BinKitchenMenuMinAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenMenuMaxAggregateOutputType = {
    id: number | null
    name: string | null
    image: string | null
    price: number | null
    categoryName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenMenuCountAggregateOutputType = {
    id: number
    name: number
    image: number
    price: number
    categoryName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenMenuAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type BinKitchenMenuSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type BinKitchenMenuMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenMenuMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenMenuCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    price?: true
    categoryName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenMenuAggregateArgs = {
    /**
     * Filter which BinKitchenMenu to aggregate.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenMenus
    **/
    _count?: true | BinKitchenMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenMenuMaxAggregateInputType
  }

  export type GetBinKitchenMenuAggregateType<T extends BinKitchenMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenMenu[P]>
      : GetScalarType<T[P], AggregateBinKitchenMenu[P]>
  }




  export type BinKitchenMenuGroupByArgs = {
    where?: BinKitchenMenuWhereInput
    orderBy?: Enumerable<BinKitchenMenuOrderByWithAggregationInput>
    by: BinKitchenMenuScalarFieldEnum[]
    having?: BinKitchenMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenMenuCountAggregateInputType | true
    _avg?: BinKitchenMenuAvgAggregateInputType
    _sum?: BinKitchenMenuSumAggregateInputType
    _min?: BinKitchenMenuMinAggregateInputType
    _max?: BinKitchenMenuMaxAggregateInputType
  }


  export type BinKitchenMenuGroupByOutputType = {
    id: number
    name: string
    image: string
    price: number
    categoryName: string | null
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenMenuCountAggregateOutputType | null
    _avg: BinKitchenMenuAvgAggregateOutputType | null
    _sum: BinKitchenMenuSumAggregateOutputType | null
    _min: BinKitchenMenuMinAggregateOutputType | null
    _max: BinKitchenMenuMaxAggregateOutputType | null
  }

  type GetBinKitchenMenuGroupByPayload<T extends BinKitchenMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenMenuGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenMenuGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenMenuSelect = {
    id?: boolean
    name?: boolean
    image?: boolean
    price?: boolean
    category?: boolean | BinKitchenCategoryArgs
    categoryName?: boolean
    orderItems?: boolean | BinKitchenMenu$orderItemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BinKitchenMenuCountOutputTypeArgs
  }


  export type BinKitchenMenuInclude = {
    category?: boolean | BinKitchenCategoryArgs
    orderItems?: boolean | BinKitchenMenu$orderItemsArgs
    _count?: boolean | BinKitchenMenuCountOutputTypeArgs
  }

  export type BinKitchenMenuGetPayload<S extends boolean | null | undefined | BinKitchenMenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenMenu :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenMenuArgs | BinKitchenMenuFindManyArgs)
    ? BinKitchenMenu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? BinKitchenCategoryGetPayload<S['include'][P]> | null :
        P extends 'orderItems' ? Array < BinKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenMenuCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenMenuArgs | BinKitchenMenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? BinKitchenCategoryGetPayload<S['select'][P]> | null :
        P extends 'orderItems' ? Array < BinKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenMenuCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenMenu ? BinKitchenMenu[P] : never
  } 
      : BinKitchenMenu


  type BinKitchenMenuCountArgs = 
    Omit<BinKitchenMenuFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenMenuCountAggregateInputType | true
    }

  export interface BinKitchenMenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenMenu that matches the filter.
     * @param {BinKitchenMenuFindUniqueArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenMenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenMenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenMenu'> extends True ? Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>> : Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | null, null>

    /**
     * Find one BinKitchenMenu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenMenuFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenMenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Find the first BinKitchenMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindFirstArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenMenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenMenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenMenu'> extends True ? Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>> : Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenMenu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindFirstOrThrowArgs} args - Arguments to find a BinKitchenMenu
     * @example
     * // Get one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenMenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindFirstOrThrowArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Find zero or more BinKitchenMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenMenus
     * const binKitchenMenus = await prisma.binKitchenMenu.findMany()
     * 
     * // Get first 10 BinKitchenMenus
     * const binKitchenMenus = await prisma.binKitchenMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenMenuWithIdOnly = await prisma.binKitchenMenu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenMenuFindManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenMenuGetPayload<T>>>

    /**
     * Create a BinKitchenMenu.
     * @param {BinKitchenMenuCreateArgs} args - Arguments to create a BinKitchenMenu.
     * @example
     * // Create one BinKitchenMenu
     * const BinKitchenMenu = await prisma.binKitchenMenu.create({
     *   data: {
     *     // ... data to create a BinKitchenMenu
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenMenuCreateArgs>(
      args: SelectSubset<T, BinKitchenMenuCreateArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Create many BinKitchenMenus.
     *     @param {BinKitchenMenuCreateManyArgs} args - Arguments to create many BinKitchenMenus.
     *     @example
     *     // Create many BinKitchenMenus
     *     const binKitchenMenu = await prisma.binKitchenMenu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenMenuCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenMenu.
     * @param {BinKitchenMenuDeleteArgs} args - Arguments to delete one BinKitchenMenu.
     * @example
     * // Delete one BinKitchenMenu
     * const BinKitchenMenu = await prisma.binKitchenMenu.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenMenu
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenMenuDeleteArgs>(
      args: SelectSubset<T, BinKitchenMenuDeleteArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Update one BinKitchenMenu.
     * @param {BinKitchenMenuUpdateArgs} args - Arguments to update one BinKitchenMenu.
     * @example
     * // Update one BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenMenuUpdateArgs>(
      args: SelectSubset<T, BinKitchenMenuUpdateArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Delete zero or more BinKitchenMenus.
     * @param {BinKitchenMenuDeleteManyArgs} args - Arguments to filter BinKitchenMenus to delete.
     * @example
     * // Delete a few BinKitchenMenus
     * const { count } = await prisma.binKitchenMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenMenuDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenMenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenMenus
     * const binKitchenMenu = await prisma.binKitchenMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenMenuUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenMenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenMenu.
     * @param {BinKitchenMenuUpsertArgs} args - Arguments to update or create a BinKitchenMenu.
     * @example
     * // Update or create a BinKitchenMenu
     * const binKitchenMenu = await prisma.binKitchenMenu.upsert({
     *   create: {
     *     // ... data to create a BinKitchenMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenMenu we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenMenuUpsertArgs>(
      args: SelectSubset<T, BinKitchenMenuUpsertArgs>
    ): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T>>

    /**
     * Count the number of BinKitchenMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuCountArgs} args - Arguments to filter BinKitchenMenus to count.
     * @example
     * // Count the number of BinKitchenMenus
     * const count = await prisma.binKitchenMenu.count({
     *   where: {
     *     // ... the filter for the BinKitchenMenus we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenMenuCountArgs>(
      args?: Subset<T, BinKitchenMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenMenuAggregateArgs>(args: Subset<T, BinKitchenMenuAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenMenuAggregateType<T>>

    /**
     * Group by BinKitchenMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenMenuGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenMenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends BinKitchenCategoryArgs= {}>(args?: Subset<T, BinKitchenCategoryArgs>): Prisma__BinKitchenCategoryClient<BinKitchenCategoryGetPayload<T> | Null>;

    orderItems<T extends BinKitchenMenu$orderItemsArgs= {}>(args?: Subset<T, BinKitchenMenu$orderItemsArgs>): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenMenu base type for findUnique actions
   */
  export type BinKitchenMenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where: BinKitchenMenuWhereUniqueInput
  }

  /**
   * BinKitchenMenu findUnique
   */
  export interface BinKitchenMenuFindUniqueArgs extends BinKitchenMenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenMenu findUniqueOrThrow
   */
  export type BinKitchenMenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu base type for findFirst actions
   */
  export type BinKitchenMenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenMenus.
     */
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }

  /**
   * BinKitchenMenu findFirst
   */
  export interface BinKitchenMenuFindFirstArgs extends BinKitchenMenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenMenu findFirstOrThrow
   */
  export type BinKitchenMenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenu to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenMenus.
     */
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenMenu findMany
   */
  export type BinKitchenMenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter, which BinKitchenMenus to fetch.
     */
    where?: BinKitchenMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenMenus to fetch.
     */
    orderBy?: Enumerable<BinKitchenMenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenMenus.
     */
    cursor?: BinKitchenMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenMenus.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenMenuScalarFieldEnum>
  }


  /**
   * BinKitchenMenu create
   */
  export type BinKitchenMenuCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The data needed to create a BinKitchenMenu.
     */
    data: XOR<BinKitchenMenuCreateInput, BinKitchenMenuUncheckedCreateInput>
  }


  /**
   * BinKitchenMenu createMany
   */
  export type BinKitchenMenuCreateManyArgs = {
    /**
     * The data used to create many BinKitchenMenus.
     */
    data: Enumerable<BinKitchenMenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenMenu update
   */
  export type BinKitchenMenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The data needed to update a BinKitchenMenu.
     */
    data: XOR<BinKitchenMenuUpdateInput, BinKitchenMenuUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenMenu to update.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu updateMany
   */
  export type BinKitchenMenuUpdateManyArgs = {
    /**
     * The data used to update BinKitchenMenus.
     */
    data: XOR<BinKitchenMenuUpdateManyMutationInput, BinKitchenMenuUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenMenus to update
     */
    where?: BinKitchenMenuWhereInput
  }


  /**
   * BinKitchenMenu upsert
   */
  export type BinKitchenMenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * The filter to search for the BinKitchenMenu to update in case it exists.
     */
    where: BinKitchenMenuWhereUniqueInput
    /**
     * In case the BinKitchenMenu found by the `where` argument doesn't exist, create a new BinKitchenMenu with this data.
     */
    create: XOR<BinKitchenMenuCreateInput, BinKitchenMenuUncheckedCreateInput>
    /**
     * In case the BinKitchenMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenMenuUpdateInput, BinKitchenMenuUncheckedUpdateInput>
  }


  /**
   * BinKitchenMenu delete
   */
  export type BinKitchenMenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
    /**
     * Filter which BinKitchenMenu to delete.
     */
    where: BinKitchenMenuWhereUniqueInput
  }


  /**
   * BinKitchenMenu deleteMany
   */
  export type BinKitchenMenuDeleteManyArgs = {
    /**
     * Filter which BinKitchenMenus to delete
     */
    where?: BinKitchenMenuWhereInput
  }


  /**
   * BinKitchenMenu.orderItems
   */
  export type BinKitchenMenu$orderItemsArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    cursor?: BinKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenMenu without action
   */
  export type BinKitchenMenuArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenMenu
     */
    select?: BinKitchenMenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenMenuInclude | null
  }



  /**
   * Model BinKitchenOrder
   */


  export type AggregateBinKitchenOrder = {
    _count: BinKitchenOrderCountAggregateOutputType | null
    _avg: BinKitchenOrderAvgAggregateOutputType | null
    _sum: BinKitchenOrderSumAggregateOutputType | null
    _min: BinKitchenOrderMinAggregateOutputType | null
    _max: BinKitchenOrderMaxAggregateOutputType | null
  }

  export type BinKitchenOrderAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type BinKitchenOrderSumAggregateOutputType = {
    id: number | null
    tableId: number | null
  }

  export type BinKitchenOrderMinAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderMaxAggregateOutputType = {
    id: number | null
    status: string | null
    tableId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderCountAggregateOutputType = {
    id: number
    status: number
    tableId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenOrderAvgAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type BinKitchenOrderSumAggregateInputType = {
    id?: true
    tableId?: true
  }

  export type BinKitchenOrderMinAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderMaxAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderCountAggregateInputType = {
    id?: true
    status?: true
    tableId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenOrderAggregateArgs = {
    /**
     * Filter which BinKitchenOrder to aggregate.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenOrders
    **/
    _count?: true | BinKitchenOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenOrderMaxAggregateInputType
  }

  export type GetBinKitchenOrderAggregateType<T extends BinKitchenOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenOrder[P]>
      : GetScalarType<T[P], AggregateBinKitchenOrder[P]>
  }




  export type BinKitchenOrderGroupByArgs = {
    where?: BinKitchenOrderWhereInput
    orderBy?: Enumerable<BinKitchenOrderOrderByWithAggregationInput>
    by: BinKitchenOrderScalarFieldEnum[]
    having?: BinKitchenOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenOrderCountAggregateInputType | true
    _avg?: BinKitchenOrderAvgAggregateInputType
    _sum?: BinKitchenOrderSumAggregateInputType
    _min?: BinKitchenOrderMinAggregateInputType
    _max?: BinKitchenOrderMaxAggregateInputType
  }


  export type BinKitchenOrderGroupByOutputType = {
    id: number
    status: string
    tableId: number
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenOrderCountAggregateOutputType | null
    _avg: BinKitchenOrderAvgAggregateOutputType | null
    _sum: BinKitchenOrderSumAggregateOutputType | null
    _min: BinKitchenOrderMinAggregateOutputType | null
    _max: BinKitchenOrderMaxAggregateOutputType | null
  }

  type GetBinKitchenOrderGroupByPayload<T extends BinKitchenOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenOrderGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenOrderGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenOrderSelect = {
    id?: boolean
    status?: boolean
    tableId?: boolean
    items?: boolean | BinKitchenOrder$itemsArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | BinKitchenOrderCountOutputTypeArgs
  }


  export type BinKitchenOrderInclude = {
    items?: boolean | BinKitchenOrder$itemsArgs
    _count?: boolean | BinKitchenOrderCountOutputTypeArgs
  }

  export type BinKitchenOrderGetPayload<S extends boolean | null | undefined | BinKitchenOrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrder :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderArgs | BinKitchenOrderFindManyArgs)
    ? BinKitchenOrder  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? BinKitchenOrderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BinKitchenOrderArgs | BinKitchenOrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < BinKitchenOrderItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? BinKitchenOrderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BinKitchenOrder ? BinKitchenOrder[P] : never
  } 
      : BinKitchenOrder


  type BinKitchenOrderCountArgs = 
    Omit<BinKitchenOrderFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenOrderCountAggregateInputType | true
    }

  export interface BinKitchenOrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenOrder that matches the filter.
     * @param {BinKitchenOrderFindUniqueArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenOrder'> extends True ? Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>> : Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | null, null>

    /**
     * Find one BinKitchenOrder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenOrderFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenOrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Find the first BinKitchenOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindFirstArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenOrder'> extends True ? Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>> : Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenOrder that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindFirstOrThrowArgs} args - Arguments to find a BinKitchenOrder
     * @example
     * // Get one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindFirstOrThrowArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Find zero or more BinKitchenOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenOrders
     * const binKitchenOrders = await prisma.binKitchenOrder.findMany()
     * 
     * // Get first 10 BinKitchenOrders
     * const binKitchenOrders = await prisma.binKitchenOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenOrderWithIdOnly = await prisma.binKitchenOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenOrderFindManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenOrderGetPayload<T>>>

    /**
     * Create a BinKitchenOrder.
     * @param {BinKitchenOrderCreateArgs} args - Arguments to create a BinKitchenOrder.
     * @example
     * // Create one BinKitchenOrder
     * const BinKitchenOrder = await prisma.binKitchenOrder.create({
     *   data: {
     *     // ... data to create a BinKitchenOrder
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenOrderCreateArgs>(
      args: SelectSubset<T, BinKitchenOrderCreateArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Create many BinKitchenOrders.
     *     @param {BinKitchenOrderCreateManyArgs} args - Arguments to create many BinKitchenOrders.
     *     @example
     *     // Create many BinKitchenOrders
     *     const binKitchenOrder = await prisma.binKitchenOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenOrderCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenOrder.
     * @param {BinKitchenOrderDeleteArgs} args - Arguments to delete one BinKitchenOrder.
     * @example
     * // Delete one BinKitchenOrder
     * const BinKitchenOrder = await prisma.binKitchenOrder.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenOrder
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenOrderDeleteArgs>(
      args: SelectSubset<T, BinKitchenOrderDeleteArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Update one BinKitchenOrder.
     * @param {BinKitchenOrderUpdateArgs} args - Arguments to update one BinKitchenOrder.
     * @example
     * // Update one BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenOrderUpdateArgs>(
      args: SelectSubset<T, BinKitchenOrderUpdateArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Delete zero or more BinKitchenOrders.
     * @param {BinKitchenOrderDeleteManyArgs} args - Arguments to filter BinKitchenOrders to delete.
     * @example
     * // Delete a few BinKitchenOrders
     * const { count } = await prisma.binKitchenOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenOrderDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenOrders
     * const binKitchenOrder = await prisma.binKitchenOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenOrderUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenOrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenOrder.
     * @param {BinKitchenOrderUpsertArgs} args - Arguments to update or create a BinKitchenOrder.
     * @example
     * // Update or create a BinKitchenOrder
     * const binKitchenOrder = await prisma.binKitchenOrder.upsert({
     *   create: {
     *     // ... data to create a BinKitchenOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenOrder we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenOrderUpsertArgs>(
      args: SelectSubset<T, BinKitchenOrderUpsertArgs>
    ): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T>>

    /**
     * Count the number of BinKitchenOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderCountArgs} args - Arguments to filter BinKitchenOrders to count.
     * @example
     * // Count the number of BinKitchenOrders
     * const count = await prisma.binKitchenOrder.count({
     *   where: {
     *     // ... the filter for the BinKitchenOrders we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenOrderCountArgs>(
      args?: Subset<T, BinKitchenOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenOrderAggregateArgs>(args: Subset<T, BinKitchenOrderAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenOrderAggregateType<T>>

    /**
     * Group by BinKitchenOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenOrderGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenOrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends BinKitchenOrder$itemsArgs= {}>(args?: Subset<T, BinKitchenOrder$itemsArgs>): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenOrder base type for findUnique actions
   */
  export type BinKitchenOrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where: BinKitchenOrderWhereUniqueInput
  }

  /**
   * BinKitchenOrder findUnique
   */
  export interface BinKitchenOrderFindUniqueArgs extends BinKitchenOrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrder findUniqueOrThrow
   */
  export type BinKitchenOrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder base type for findFirst actions
   */
  export type BinKitchenOrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrders.
     */
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }

  /**
   * BinKitchenOrder findFirst
   */
  export interface BinKitchenOrderFindFirstArgs extends BinKitchenOrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrder findFirstOrThrow
   */
  export type BinKitchenOrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrder to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrders.
     */
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }


  /**
   * BinKitchenOrder findMany
   */
  export type BinKitchenOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter, which BinKitchenOrders to fetch.
     */
    where?: BinKitchenOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrders to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenOrders.
     */
    cursor?: BinKitchenOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrders.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenOrderScalarFieldEnum>
  }


  /**
   * BinKitchenOrder create
   */
  export type BinKitchenOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The data needed to create a BinKitchenOrder.
     */
    data: XOR<BinKitchenOrderCreateInput, BinKitchenOrderUncheckedCreateInput>
  }


  /**
   * BinKitchenOrder createMany
   */
  export type BinKitchenOrderCreateManyArgs = {
    /**
     * The data used to create many BinKitchenOrders.
     */
    data: Enumerable<BinKitchenOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenOrder update
   */
  export type BinKitchenOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The data needed to update a BinKitchenOrder.
     */
    data: XOR<BinKitchenOrderUpdateInput, BinKitchenOrderUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenOrder to update.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder updateMany
   */
  export type BinKitchenOrderUpdateManyArgs = {
    /**
     * The data used to update BinKitchenOrders.
     */
    data: XOR<BinKitchenOrderUpdateManyMutationInput, BinKitchenOrderUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenOrders to update
     */
    where?: BinKitchenOrderWhereInput
  }


  /**
   * BinKitchenOrder upsert
   */
  export type BinKitchenOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * The filter to search for the BinKitchenOrder to update in case it exists.
     */
    where: BinKitchenOrderWhereUniqueInput
    /**
     * In case the BinKitchenOrder found by the `where` argument doesn't exist, create a new BinKitchenOrder with this data.
     */
    create: XOR<BinKitchenOrderCreateInput, BinKitchenOrderUncheckedCreateInput>
    /**
     * In case the BinKitchenOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenOrderUpdateInput, BinKitchenOrderUncheckedUpdateInput>
  }


  /**
   * BinKitchenOrder delete
   */
  export type BinKitchenOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
    /**
     * Filter which BinKitchenOrder to delete.
     */
    where: BinKitchenOrderWhereUniqueInput
  }


  /**
   * BinKitchenOrder deleteMany
   */
  export type BinKitchenOrderDeleteManyArgs = {
    /**
     * Filter which BinKitchenOrders to delete
     */
    where?: BinKitchenOrderWhereInput
  }


  /**
   * BinKitchenOrder.items
   */
  export type BinKitchenOrder$itemsArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    cursor?: BinKitchenOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrder without action
   */
  export type BinKitchenOrderArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrder
     */
    select?: BinKitchenOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderInclude | null
  }



  /**
   * Model BinKitchenOrderItem
   */


  export type AggregateBinKitchenOrderItem = {
    _count: BinKitchenOrderItemCountAggregateOutputType | null
    _avg: BinKitchenOrderItemAvgAggregateOutputType | null
    _sum: BinKitchenOrderItemSumAggregateOutputType | null
    _min: BinKitchenOrderItemMinAggregateOutputType | null
    _max: BinKitchenOrderItemMaxAggregateOutputType | null
  }

  export type BinKitchenOrderItemAvgAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type BinKitchenOrderItemSumAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type BinKitchenOrderItemMinAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderItemMaxAggregateOutputType = {
    id: number | null
    menuId: number | null
    orderId: number | null
    quantity: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BinKitchenOrderItemCountAggregateOutputType = {
    id: number
    menuId: number
    orderId: number
    quantity: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BinKitchenOrderItemAvgAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type BinKitchenOrderItemSumAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
  }

  export type BinKitchenOrderItemMinAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BinKitchenOrderItemCountAggregateInputType = {
    id?: true
    menuId?: true
    orderId?: true
    quantity?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BinKitchenOrderItemAggregateArgs = {
    /**
     * Filter which BinKitchenOrderItem to aggregate.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BinKitchenOrderItems
    **/
    _count?: true | BinKitchenOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BinKitchenOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BinKitchenOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinKitchenOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinKitchenOrderItemMaxAggregateInputType
  }

  export type GetBinKitchenOrderItemAggregateType<T extends BinKitchenOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBinKitchenOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBinKitchenOrderItem[P]>
      : GetScalarType<T[P], AggregateBinKitchenOrderItem[P]>
  }




  export type BinKitchenOrderItemGroupByArgs = {
    where?: BinKitchenOrderItemWhereInput
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithAggregationInput>
    by: BinKitchenOrderItemScalarFieldEnum[]
    having?: BinKitchenOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinKitchenOrderItemCountAggregateInputType | true
    _avg?: BinKitchenOrderItemAvgAggregateInputType
    _sum?: BinKitchenOrderItemSumAggregateInputType
    _min?: BinKitchenOrderItemMinAggregateInputType
    _max?: BinKitchenOrderItemMaxAggregateInputType
  }


  export type BinKitchenOrderItemGroupByOutputType = {
    id: number
    menuId: number
    orderId: number | null
    quantity: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: BinKitchenOrderItemCountAggregateOutputType | null
    _avg: BinKitchenOrderItemAvgAggregateOutputType | null
    _sum: BinKitchenOrderItemSumAggregateOutputType | null
    _min: BinKitchenOrderItemMinAggregateOutputType | null
    _max: BinKitchenOrderItemMaxAggregateOutputType | null
  }

  type GetBinKitchenOrderItemGroupByPayload<T extends BinKitchenOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BinKitchenOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinKitchenOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinKitchenOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], BinKitchenOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type BinKitchenOrderItemSelect = {
    id?: boolean
    menu?: boolean | BinKitchenMenuArgs
    menuId?: boolean
    order?: boolean | BinKitchenOrderArgs
    orderId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type BinKitchenOrderItemInclude = {
    menu?: boolean | BinKitchenMenuArgs
    order?: boolean | BinKitchenOrderArgs
  }

  export type BinKitchenOrderItemGetPayload<S extends boolean | null | undefined | BinKitchenOrderItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BinKitchenOrderItem :
    S extends undefined ? never :
    S extends { include: any } & (BinKitchenOrderItemArgs | BinKitchenOrderItemFindManyArgs)
    ? BinKitchenOrderItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'menu' ? BinKitchenMenuGetPayload<S['include'][P]> :
        P extends 'order' ? BinKitchenOrderGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (BinKitchenOrderItemArgs | BinKitchenOrderItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'menu' ? BinKitchenMenuGetPayload<S['select'][P]> :
        P extends 'order' ? BinKitchenOrderGetPayload<S['select'][P]> | null :  P extends keyof BinKitchenOrderItem ? BinKitchenOrderItem[P] : never
  } 
      : BinKitchenOrderItem


  type BinKitchenOrderItemCountArgs = 
    Omit<BinKitchenOrderItemFindManyArgs, 'select' | 'include'> & {
      select?: BinKitchenOrderItemCountAggregateInputType | true
    }

  export interface BinKitchenOrderItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BinKitchenOrderItem that matches the filter.
     * @param {BinKitchenOrderItemFindUniqueArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BinKitchenOrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BinKitchenOrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BinKitchenOrderItem'> extends True ? Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>> : Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find one BinKitchenOrderItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BinKitchenOrderItemFindUniqueOrThrowArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BinKitchenOrderItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindUniqueOrThrowArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Find the first BinKitchenOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindFirstArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BinKitchenOrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BinKitchenOrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BinKitchenOrderItem'> extends True ? Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>> : Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T> | null, null>

    /**
     * Find the first BinKitchenOrderItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindFirstOrThrowArgs} args - Arguments to find a BinKitchenOrderItem
     * @example
     * // Get one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BinKitchenOrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindFirstOrThrowArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Find zero or more BinKitchenOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BinKitchenOrderItems
     * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany()
     * 
     * // Get first 10 BinKitchenOrderItems
     * const binKitchenOrderItems = await prisma.binKitchenOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binKitchenOrderItemWithIdOnly = await prisma.binKitchenOrderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BinKitchenOrderItemFindManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<BinKitchenOrderItemGetPayload<T>>>

    /**
     * Create a BinKitchenOrderItem.
     * @param {BinKitchenOrderItemCreateArgs} args - Arguments to create a BinKitchenOrderItem.
     * @example
     * // Create one BinKitchenOrderItem
     * const BinKitchenOrderItem = await prisma.binKitchenOrderItem.create({
     *   data: {
     *     // ... data to create a BinKitchenOrderItem
     *   }
     * })
     * 
    **/
    create<T extends BinKitchenOrderItemCreateArgs>(
      args: SelectSubset<T, BinKitchenOrderItemCreateArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Create many BinKitchenOrderItems.
     *     @param {BinKitchenOrderItemCreateManyArgs} args - Arguments to create many BinKitchenOrderItems.
     *     @example
     *     // Create many BinKitchenOrderItems
     *     const binKitchenOrderItem = await prisma.binKitchenOrderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BinKitchenOrderItemCreateManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BinKitchenOrderItem.
     * @param {BinKitchenOrderItemDeleteArgs} args - Arguments to delete one BinKitchenOrderItem.
     * @example
     * // Delete one BinKitchenOrderItem
     * const BinKitchenOrderItem = await prisma.binKitchenOrderItem.delete({
     *   where: {
     *     // ... filter to delete one BinKitchenOrderItem
     *   }
     * })
     * 
    **/
    delete<T extends BinKitchenOrderItemDeleteArgs>(
      args: SelectSubset<T, BinKitchenOrderItemDeleteArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Update one BinKitchenOrderItem.
     * @param {BinKitchenOrderItemUpdateArgs} args - Arguments to update one BinKitchenOrderItem.
     * @example
     * // Update one BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BinKitchenOrderItemUpdateArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpdateArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Delete zero or more BinKitchenOrderItems.
     * @param {BinKitchenOrderItemDeleteManyArgs} args - Arguments to filter BinKitchenOrderItems to delete.
     * @example
     * // Delete a few BinKitchenOrderItems
     * const { count } = await prisma.binKitchenOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BinKitchenOrderItemDeleteManyArgs>(
      args?: SelectSubset<T, BinKitchenOrderItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BinKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BinKitchenOrderItems
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BinKitchenOrderItemUpdateManyArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BinKitchenOrderItem.
     * @param {BinKitchenOrderItemUpsertArgs} args - Arguments to update or create a BinKitchenOrderItem.
     * @example
     * // Update or create a BinKitchenOrderItem
     * const binKitchenOrderItem = await prisma.binKitchenOrderItem.upsert({
     *   create: {
     *     // ... data to create a BinKitchenOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BinKitchenOrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends BinKitchenOrderItemUpsertArgs>(
      args: SelectSubset<T, BinKitchenOrderItemUpsertArgs>
    ): Prisma__BinKitchenOrderItemClient<BinKitchenOrderItemGetPayload<T>>

    /**
     * Count the number of BinKitchenOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemCountArgs} args - Arguments to filter BinKitchenOrderItems to count.
     * @example
     * // Count the number of BinKitchenOrderItems
     * const count = await prisma.binKitchenOrderItem.count({
     *   where: {
     *     // ... the filter for the BinKitchenOrderItems we want to count
     *   }
     * })
    **/
    count<T extends BinKitchenOrderItemCountArgs>(
      args?: Subset<T, BinKitchenOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinKitchenOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BinKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinKitchenOrderItemAggregateArgs>(args: Subset<T, BinKitchenOrderItemAggregateArgs>): Prisma.PrismaPromise<GetBinKitchenOrderItemAggregateType<T>>

    /**
     * Group by BinKitchenOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinKitchenOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinKitchenOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinKitchenOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: BinKitchenOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinKitchenOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinKitchenOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BinKitchenOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BinKitchenOrderItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    menu<T extends BinKitchenMenuArgs= {}>(args?: Subset<T, BinKitchenMenuArgs>): Prisma__BinKitchenMenuClient<BinKitchenMenuGetPayload<T> | Null>;

    order<T extends BinKitchenOrderArgs= {}>(args?: Subset<T, BinKitchenOrderArgs>): Prisma__BinKitchenOrderClient<BinKitchenOrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BinKitchenOrderItem base type for findUnique actions
   */
  export type BinKitchenOrderItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }

  /**
   * BinKitchenOrderItem findUnique
   */
  export interface BinKitchenOrderItemFindUniqueArgs extends BinKitchenOrderItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrderItem findUniqueOrThrow
   */
  export type BinKitchenOrderItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem base type for findFirst actions
   */
  export type BinKitchenOrderItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrderItems.
     */
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }

  /**
   * BinKitchenOrderItem findFirst
   */
  export interface BinKitchenOrderItemFindFirstArgs extends BinKitchenOrderItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BinKitchenOrderItem findFirstOrThrow
   */
  export type BinKitchenOrderItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItem to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BinKitchenOrderItems.
     */
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrderItem findMany
   */
  export type BinKitchenOrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter, which BinKitchenOrderItems to fetch.
     */
    where?: BinKitchenOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BinKitchenOrderItems to fetch.
     */
    orderBy?: Enumerable<BinKitchenOrderItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BinKitchenOrderItems.
     */
    cursor?: BinKitchenOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BinKitchenOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BinKitchenOrderItems.
     */
    skip?: number
    distinct?: Enumerable<BinKitchenOrderItemScalarFieldEnum>
  }


  /**
   * BinKitchenOrderItem create
   */
  export type BinKitchenOrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The data needed to create a BinKitchenOrderItem.
     */
    data: XOR<BinKitchenOrderItemCreateInput, BinKitchenOrderItemUncheckedCreateInput>
  }


  /**
   * BinKitchenOrderItem createMany
   */
  export type BinKitchenOrderItemCreateManyArgs = {
    /**
     * The data used to create many BinKitchenOrderItems.
     */
    data: Enumerable<BinKitchenOrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BinKitchenOrderItem update
   */
  export type BinKitchenOrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The data needed to update a BinKitchenOrderItem.
     */
    data: XOR<BinKitchenOrderItemUpdateInput, BinKitchenOrderItemUncheckedUpdateInput>
    /**
     * Choose, which BinKitchenOrderItem to update.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem updateMany
   */
  export type BinKitchenOrderItemUpdateManyArgs = {
    /**
     * The data used to update BinKitchenOrderItems.
     */
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which BinKitchenOrderItems to update
     */
    where?: BinKitchenOrderItemWhereInput
  }


  /**
   * BinKitchenOrderItem upsert
   */
  export type BinKitchenOrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * The filter to search for the BinKitchenOrderItem to update in case it exists.
     */
    where: BinKitchenOrderItemWhereUniqueInput
    /**
     * In case the BinKitchenOrderItem found by the `where` argument doesn't exist, create a new BinKitchenOrderItem with this data.
     */
    create: XOR<BinKitchenOrderItemCreateInput, BinKitchenOrderItemUncheckedCreateInput>
    /**
     * In case the BinKitchenOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinKitchenOrderItemUpdateInput, BinKitchenOrderItemUncheckedUpdateInput>
  }


  /**
   * BinKitchenOrderItem delete
   */
  export type BinKitchenOrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
    /**
     * Filter which BinKitchenOrderItem to delete.
     */
    where: BinKitchenOrderItemWhereUniqueInput
  }


  /**
   * BinKitchenOrderItem deleteMany
   */
  export type BinKitchenOrderItemDeleteManyArgs = {
    /**
     * Filter which BinKitchenOrderItems to delete
     */
    where?: BinKitchenOrderItemWhereInput
  }


  /**
   * BinKitchenOrderItem without action
   */
  export type BinKitchenOrderItemArgs = {
    /**
     * Select specific fields to fetch from the BinKitchenOrderItem
     */
    select?: BinKitchenOrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BinKitchenOrderItemInclude | null
  }



  /**
   * Model QuizCategory
   */


  export type AggregateQuizCategory = {
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  export type QuizCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuizCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuizCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuizCategorySumAggregateInputType = {
    id?: true
  }

  export type QuizCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizCategoryAggregateArgs = {
    /**
     * Filter which QuizCategory to aggregate.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizCategories
    **/
    _count?: true | QuizCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizCategoryMaxAggregateInputType
  }

  export type GetQuizCategoryAggregateType<T extends QuizCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizCategory[P]>
      : GetScalarType<T[P], AggregateQuizCategory[P]>
  }




  export type QuizCategoryGroupByArgs = {
    where?: QuizCategoryWhereInput
    orderBy?: Enumerable<QuizCategoryOrderByWithAggregationInput>
    by: QuizCategoryScalarFieldEnum[]
    having?: QuizCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCategoryCountAggregateInputType | true
    _avg?: QuizCategoryAvgAggregateInputType
    _sum?: QuizCategorySumAggregateInputType
    _min?: QuizCategoryMinAggregateInputType
    _max?: QuizCategoryMaxAggregateInputType
  }


  export type QuizCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuizCategoryCountAggregateOutputType | null
    _avg: QuizCategoryAvgAggregateOutputType | null
    _sum: QuizCategorySumAggregateOutputType | null
    _min: QuizCategoryMinAggregateOutputType | null
    _max: QuizCategoryMaxAggregateOutputType | null
  }

  type GetQuizCategoryGroupByPayload<T extends QuizCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuizCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuizCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | QuizCategory$questionsArgs
    rounds?: boolean | QuizCategory$roundsArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }


  export type QuizCategoryInclude = {
    questions?: boolean | QuizCategory$questionsArgs
    rounds?: boolean | QuizCategory$roundsArgs
    _count?: boolean | QuizCategoryCountOutputTypeArgs
  }

  export type QuizCategoryGetPayload<S extends boolean | null | undefined | QuizCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizCategory :
    S extends undefined ? never :
    S extends { include: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
    ? QuizCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questions' ? Array < QuizQuestionGetPayload<S['include'][P]>>  :
        P extends 'rounds' ? Array < QuizRoundGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizCategoryArgs | QuizCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questions' ? Array < QuizQuestionGetPayload<S['select'][P]>>  :
        P extends 'rounds' ? Array < QuizRoundGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizCategory ? QuizCategory[P] : never
  } 
      : QuizCategory


  type QuizCategoryCountArgs = 
    Omit<QuizCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuizCategoryCountAggregateInputType | true
    }

  export interface QuizCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizCategory that matches the filter.
     * @param {QuizCategoryFindUniqueArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find one QuizCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizCategoryFindUniqueOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindUniqueOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find the first QuizCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizCategory'> extends True ? Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>> : Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | null, null>

    /**
     * Find the first QuizCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindFirstOrThrowArgs} args - Arguments to find a QuizCategory
     * @example
     * // Get one QuizCategory
     * const quizCategory = await prisma.quizCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizCategoryFindFirstOrThrowArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Find zero or more QuizCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany()
     * 
     * // Get first 10 QuizCategories
     * const quizCategories = await prisma.quizCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizCategoryWithIdOnly = await prisma.quizCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizCategoryFindManyArgs>(
      args?: SelectSubset<T, QuizCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizCategoryGetPayload<T>>>

    /**
     * Create a QuizCategory.
     * @param {QuizCategoryCreateArgs} args - Arguments to create a QuizCategory.
     * @example
     * // Create one QuizCategory
     * const QuizCategory = await prisma.quizCategory.create({
     *   data: {
     *     // ... data to create a QuizCategory
     *   }
     * })
     * 
    **/
    create<T extends QuizCategoryCreateArgs>(
      args: SelectSubset<T, QuizCategoryCreateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Create many QuizCategories.
     *     @param {QuizCategoryCreateManyArgs} args - Arguments to create many QuizCategories.
     *     @example
     *     // Create many QuizCategories
     *     const quizCategory = await prisma.quizCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuizCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizCategory.
     * @param {QuizCategoryDeleteArgs} args - Arguments to delete one QuizCategory.
     * @example
     * // Delete one QuizCategory
     * const QuizCategory = await prisma.quizCategory.delete({
     *   where: {
     *     // ... filter to delete one QuizCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuizCategoryDeleteArgs>(
      args: SelectSubset<T, QuizCategoryDeleteArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Update one QuizCategory.
     * @param {QuizCategoryUpdateArgs} args - Arguments to update one QuizCategory.
     * @example
     * // Update one QuizCategory
     * const quizCategory = await prisma.quizCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizCategoryUpdateArgs>(
      args: SelectSubset<T, QuizCategoryUpdateArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Delete zero or more QuizCategories.
     * @param {QuizCategoryDeleteManyArgs} args - Arguments to filter QuizCategories to delete.
     * @example
     * // Delete a few QuizCategories
     * const { count } = await prisma.quizCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuizCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizCategories
     * const quizCategory = await prisma.quizCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuizCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizCategory.
     * @param {QuizCategoryUpsertArgs} args - Arguments to update or create a QuizCategory.
     * @example
     * // Update or create a QuizCategory
     * const quizCategory = await prisma.quizCategory.upsert({
     *   create: {
     *     // ... data to create a QuizCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuizCategoryUpsertArgs>(
      args: SelectSubset<T, QuizCategoryUpsertArgs>
    ): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T>>

    /**
     * Count the number of QuizCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryCountArgs} args - Arguments to filter QuizCategories to count.
     * @example
     * // Count the number of QuizCategories
     * const count = await prisma.quizCategory.count({
     *   where: {
     *     // ... the filter for the QuizCategories we want to count
     *   }
     * })
    **/
    count<T extends QuizCategoryCountArgs>(
      args?: Subset<T, QuizCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizCategoryAggregateArgs>(args: Subset<T, QuizCategoryAggregateArgs>): Prisma.PrismaPromise<GetQuizCategoryAggregateType<T>>

    /**
     * Group by QuizCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuizCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    questions<T extends QuizCategory$questionsArgs= {}>(args?: Subset<T, QuizCategory$questionsArgs>): Prisma.PrismaPromise<Array<QuizQuestionGetPayload<T>>| Null>;

    rounds<T extends QuizCategory$roundsArgs= {}>(args?: Subset<T, QuizCategory$roundsArgs>): Prisma.PrismaPromise<Array<QuizRoundGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizCategory base type for findUnique actions
   */
  export type QuizCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }

  /**
   * QuizCategory findUnique
   */
  export interface QuizCategoryFindUniqueArgs extends QuizCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findUniqueOrThrow
   */
  export type QuizCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory base type for findFirst actions
   */
  export type QuizCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }

  /**
   * QuizCategory findFirst
   */
  export interface QuizCategoryFindFirstArgs extends QuizCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizCategory findFirstOrThrow
   */
  export type QuizCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategory to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizCategories.
     */
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory findMany
   */
  export type QuizCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter, which QuizCategories to fetch.
     */
    where?: QuizCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizCategories to fetch.
     */
    orderBy?: Enumerable<QuizCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizCategories.
     */
    cursor?: QuizCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizCategories.
     */
    skip?: number
    distinct?: Enumerable<QuizCategoryScalarFieldEnum>
  }


  /**
   * QuizCategory create
   */
  export type QuizCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to create a QuizCategory.
     */
    data: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
  }


  /**
   * QuizCategory createMany
   */
  export type QuizCategoryCreateManyArgs = {
    /**
     * The data used to create many QuizCategories.
     */
    data: Enumerable<QuizCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizCategory update
   */
  export type QuizCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The data needed to update a QuizCategory.
     */
    data: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuizCategory to update.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory updateMany
   */
  export type QuizCategoryUpdateManyArgs = {
    /**
     * The data used to update QuizCategories.
     */
    data: XOR<QuizCategoryUpdateManyMutationInput, QuizCategoryUncheckedUpdateManyInput>
    /**
     * Filter which QuizCategories to update
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory upsert
   */
  export type QuizCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * The filter to search for the QuizCategory to update in case it exists.
     */
    where: QuizCategoryWhereUniqueInput
    /**
     * In case the QuizCategory found by the `where` argument doesn't exist, create a new QuizCategory with this data.
     */
    create: XOR<QuizCategoryCreateInput, QuizCategoryUncheckedCreateInput>
    /**
     * In case the QuizCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizCategoryUpdateInput, QuizCategoryUncheckedUpdateInput>
  }


  /**
   * QuizCategory delete
   */
  export type QuizCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
    /**
     * Filter which QuizCategory to delete.
     */
    where: QuizCategoryWhereUniqueInput
  }


  /**
   * QuizCategory deleteMany
   */
  export type QuizCategoryDeleteManyArgs = {
    /**
     * Filter which QuizCategories to delete
     */
    where?: QuizCategoryWhereInput
  }


  /**
   * QuizCategory.questions
   */
  export type QuizCategory$questionsArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    where?: QuizQuestionWhereInput
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizCategory.rounds
   */
  export type QuizCategory$roundsArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    where?: QuizRoundWhereInput
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    cursor?: QuizRoundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizCategory without action
   */
  export type QuizCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuizCategory
     */
    select?: QuizCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizCategoryInclude | null
  }



  /**
   * Model QuizQuestion
   */


  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    answerChoiceId: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    answerChoiceId: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: number | null
    questName: string | null
    categoryId: number | null
    answerChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: number | null
    questName: string | null
    categoryId: number | null
    answerChoiceId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    questName: number
    categoryId: number
    answerChoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    id?: true
    categoryId?: true
    answerChoiceId?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    id?: true
    categoryId?: true
    answerChoiceId?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    questName?: true
    categoryId?: true
    answerChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    questName?: true
    categoryId?: true
    answerChoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    questName?: true
    categoryId?: true
    answerChoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs = {
    where?: QuizQuestionWhereInput
    orderBy?: Enumerable<QuizQuestionOrderByWithAggregationInput>
    by: QuizQuestionScalarFieldEnum[]
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }


  export type QuizQuestionGroupByOutputType = {
    id: number
    questName: string
    categoryId: number
    answerChoiceId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect = {
    id?: boolean
    questName?: boolean
    category?: boolean | QuizCategoryArgs
    categoryId?: boolean
    answer?: boolean | QuizChoiceArgs
    answerChoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    choices?: boolean | QuizQuestion$choicesArgs
    roundQuestions?: boolean | QuizQuestion$roundQuestionsArgs
    _count?: boolean | QuizQuestionCountOutputTypeArgs
  }


  export type QuizQuestionInclude = {
    category?: boolean | QuizCategoryArgs
    answer?: boolean | QuizChoiceArgs
    choices?: boolean | QuizQuestion$choicesArgs
    roundQuestions?: boolean | QuizQuestion$roundQuestionsArgs
    _count?: boolean | QuizQuestionCountOutputTypeArgs
  }

  export type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizQuestion :
    S extends undefined ? never :
    S extends { include: any } & (QuizQuestionArgs | QuizQuestionFindManyArgs)
    ? QuizQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> :
        P extends 'answer' ? QuizChoiceGetPayload<S['include'][P]> :
        P extends 'choices' ? Array < QuizChoiceGetPayload<S['include'][P]>>  :
        P extends 'roundQuestions' ? Array < QuizRoundQuestionGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizQuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizQuestionArgs | QuizQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> :
        P extends 'answer' ? QuizChoiceGetPayload<S['select'][P]> :
        P extends 'choices' ? Array < QuizChoiceGetPayload<S['select'][P]>>  :
        P extends 'roundQuestions' ? Array < QuizRoundQuestionGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizQuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizQuestion ? QuizQuestion[P] : never
  } 
      : QuizQuestion


  type QuizQuestionCountArgs = 
    Omit<QuizQuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizQuestion'> extends True ? Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>> : Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | null, null>

    /**
     * Find one QuizQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizQuestion'> extends True ? Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>> : Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | null, null>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizQuestionFindManyArgs>(
      args?: SelectSubset<T, QuizQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizQuestionGetPayload<T>>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
    **/
    create<T extends QuizQuestionCreateArgs>(
      args: SelectSubset<T, QuizQuestionCreateArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Create many QuizQuestions.
     *     @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     *     @example
     *     // Create many QuizQuestions
     *     const quizQuestion = await prisma.quizQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizQuestionCreateManyArgs>(
      args?: SelectSubset<T, QuizQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
    **/
    delete<T extends QuizQuestionDeleteArgs>(
      args: SelectSubset<T, QuizQuestionDeleteArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizQuestionUpdateArgs>(
      args: SelectSubset<T, QuizQuestionUpdateArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizQuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuizQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizQuestionUpdateManyArgs>(
      args: SelectSubset<T, QuizQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends QuizQuestionUpsertArgs>(
      args: SelectSubset<T, QuizQuestionUpsertArgs>
    ): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T>>

    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    answer<T extends QuizChoiceArgs= {}>(args?: Subset<T, QuizChoiceArgs>): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | Null>;

    choices<T extends QuizQuestion$choicesArgs= {}>(args?: Subset<T, QuizQuestion$choicesArgs>): Prisma.PrismaPromise<Array<QuizChoiceGetPayload<T>>| Null>;

    roundQuestions<T extends QuizQuestion$roundQuestionsArgs= {}>(args?: Subset<T, QuizQuestion$roundQuestionsArgs>): Prisma.PrismaPromise<Array<QuizRoundQuestionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizQuestion base type for findUnique actions
   */
  export type QuizQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUnique
   */
  export interface QuizQuestionFindUniqueArgs extends QuizQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion base type for findFirst actions
   */
  export type QuizQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }

  /**
   * QuizQuestion findFirst
   */
  export interface QuizQuestionFindFirstArgs extends QuizQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: Enumerable<QuizQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: Enumerable<QuizQuestionScalarFieldEnum>
  }


  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }


  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: Enumerable<QuizQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
  }


  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }


  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }


  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
  }


  /**
   * QuizQuestion.choices
   */
  export type QuizQuestion$choicesArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    where?: QuizChoiceWhereInput
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    cursor?: QuizChoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizQuestion.roundQuestions
   */
  export type QuizQuestion$roundQuestionsArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    where?: QuizRoundQuestionWhereInput
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    cursor?: QuizRoundQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRoundQuestionScalarFieldEnum>
  }


  /**
   * QuizQuestion without action
   */
  export type QuizQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizQuestionInclude | null
  }



  /**
   * Model QuizChoice
   */


  export type AggregateQuizChoice = {
    _count: QuizChoiceCountAggregateOutputType | null
    _avg: QuizChoiceAvgAggregateOutputType | null
    _sum: QuizChoiceSumAggregateOutputType | null
    _min: QuizChoiceMinAggregateOutputType | null
    _max: QuizChoiceMaxAggregateOutputType | null
  }

  export type QuizChoiceAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizChoiceSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizChoiceMinAggregateOutputType = {
    id: number | null
    choiceName: string | null
    questionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizChoiceMaxAggregateOutputType = {
    id: number | null
    choiceName: string | null
    questionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizChoiceCountAggregateOutputType = {
    id: number
    choiceName: number
    questionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizChoiceAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizChoiceSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizChoiceMinAggregateInputType = {
    id?: true
    choiceName?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizChoiceMaxAggregateInputType = {
    id?: true
    choiceName?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizChoiceCountAggregateInputType = {
    id?: true
    choiceName?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizChoiceAggregateArgs = {
    /**
     * Filter which QuizChoice to aggregate.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizChoices
    **/
    _count?: true | QuizChoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizChoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizChoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizChoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizChoiceMaxAggregateInputType
  }

  export type GetQuizChoiceAggregateType<T extends QuizChoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizChoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizChoice[P]>
      : GetScalarType<T[P], AggregateQuizChoice[P]>
  }




  export type QuizChoiceGroupByArgs = {
    where?: QuizChoiceWhereInput
    orderBy?: Enumerable<QuizChoiceOrderByWithAggregationInput>
    by: QuizChoiceScalarFieldEnum[]
    having?: QuizChoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizChoiceCountAggregateInputType | true
    _avg?: QuizChoiceAvgAggregateInputType
    _sum?: QuizChoiceSumAggregateInputType
    _min?: QuizChoiceMinAggregateInputType
    _max?: QuizChoiceMaxAggregateInputType
  }


  export type QuizChoiceGroupByOutputType = {
    id: number
    choiceName: string
    questionId: number | null
    createdAt: Date
    updatedAt: Date
    _count: QuizChoiceCountAggregateOutputType | null
    _avg: QuizChoiceAvgAggregateOutputType | null
    _sum: QuizChoiceSumAggregateOutputType | null
    _min: QuizChoiceMinAggregateOutputType | null
    _max: QuizChoiceMaxAggregateOutputType | null
  }

  type GetQuizChoiceGroupByPayload<T extends QuizChoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizChoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizChoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizChoiceGroupByOutputType[P]>
            : GetScalarType<T[P], QuizChoiceGroupByOutputType[P]>
        }
      >
    >


  export type QuizChoiceSelect = {
    id?: boolean
    choiceName?: boolean
    questione?: boolean | QuizQuestionArgs
    questionId?: boolean
    questionAnswer?: boolean | QuizQuestionArgs
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type QuizChoiceInclude = {
    questione?: boolean | QuizQuestionArgs
    questionAnswer?: boolean | QuizQuestionArgs
  }

  export type QuizChoiceGetPayload<S extends boolean | null | undefined | QuizChoiceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizChoice :
    S extends undefined ? never :
    S extends { include: any } & (QuizChoiceArgs | QuizChoiceFindManyArgs)
    ? QuizChoice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questione' ? QuizQuestionGetPayload<S['include'][P]> | null :
        P extends 'questionAnswer' ? QuizQuestionGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuizChoiceArgs | QuizChoiceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questione' ? QuizQuestionGetPayload<S['select'][P]> | null :
        P extends 'questionAnswer' ? QuizQuestionGetPayload<S['select'][P]> | null :  P extends keyof QuizChoice ? QuizChoice[P] : never
  } 
      : QuizChoice


  type QuizChoiceCountArgs = 
    Omit<QuizChoiceFindManyArgs, 'select' | 'include'> & {
      select?: QuizChoiceCountAggregateInputType | true
    }

  export interface QuizChoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizChoice that matches the filter.
     * @param {QuizChoiceFindUniqueArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizChoiceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizChoiceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizChoice'> extends True ? Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>> : Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | null, null>

    /**
     * Find one QuizChoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizChoiceFindUniqueOrThrowArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizChoiceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizChoiceFindUniqueOrThrowArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Find the first QuizChoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindFirstArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizChoiceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizChoiceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizChoice'> extends True ? Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>> : Prisma__QuizChoiceClient<QuizChoiceGetPayload<T> | null, null>

    /**
     * Find the first QuizChoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindFirstOrThrowArgs} args - Arguments to find a QuizChoice
     * @example
     * // Get one QuizChoice
     * const quizChoice = await prisma.quizChoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizChoiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizChoiceFindFirstOrThrowArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Find zero or more QuizChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizChoices
     * const quizChoices = await prisma.quizChoice.findMany()
     * 
     * // Get first 10 QuizChoices
     * const quizChoices = await prisma.quizChoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizChoiceWithIdOnly = await prisma.quizChoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizChoiceFindManyArgs>(
      args?: SelectSubset<T, QuizChoiceFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizChoiceGetPayload<T>>>

    /**
     * Create a QuizChoice.
     * @param {QuizChoiceCreateArgs} args - Arguments to create a QuizChoice.
     * @example
     * // Create one QuizChoice
     * const QuizChoice = await prisma.quizChoice.create({
     *   data: {
     *     // ... data to create a QuizChoice
     *   }
     * })
     * 
    **/
    create<T extends QuizChoiceCreateArgs>(
      args: SelectSubset<T, QuizChoiceCreateArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Create many QuizChoices.
     *     @param {QuizChoiceCreateManyArgs} args - Arguments to create many QuizChoices.
     *     @example
     *     // Create many QuizChoices
     *     const quizChoice = await prisma.quizChoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizChoiceCreateManyArgs>(
      args?: SelectSubset<T, QuizChoiceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizChoice.
     * @param {QuizChoiceDeleteArgs} args - Arguments to delete one QuizChoice.
     * @example
     * // Delete one QuizChoice
     * const QuizChoice = await prisma.quizChoice.delete({
     *   where: {
     *     // ... filter to delete one QuizChoice
     *   }
     * })
     * 
    **/
    delete<T extends QuizChoiceDeleteArgs>(
      args: SelectSubset<T, QuizChoiceDeleteArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Update one QuizChoice.
     * @param {QuizChoiceUpdateArgs} args - Arguments to update one QuizChoice.
     * @example
     * // Update one QuizChoice
     * const quizChoice = await prisma.quizChoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizChoiceUpdateArgs>(
      args: SelectSubset<T, QuizChoiceUpdateArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Delete zero or more QuizChoices.
     * @param {QuizChoiceDeleteManyArgs} args - Arguments to filter QuizChoices to delete.
     * @example
     * // Delete a few QuizChoices
     * const { count } = await prisma.quizChoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizChoiceDeleteManyArgs>(
      args?: SelectSubset<T, QuizChoiceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizChoices
     * const quizChoice = await prisma.quizChoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizChoiceUpdateManyArgs>(
      args: SelectSubset<T, QuizChoiceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizChoice.
     * @param {QuizChoiceUpsertArgs} args - Arguments to update or create a QuizChoice.
     * @example
     * // Update or create a QuizChoice
     * const quizChoice = await prisma.quizChoice.upsert({
     *   create: {
     *     // ... data to create a QuizChoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizChoice we want to update
     *   }
     * })
    **/
    upsert<T extends QuizChoiceUpsertArgs>(
      args: SelectSubset<T, QuizChoiceUpsertArgs>
    ): Prisma__QuizChoiceClient<QuizChoiceGetPayload<T>>

    /**
     * Count the number of QuizChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceCountArgs} args - Arguments to filter QuizChoices to count.
     * @example
     * // Count the number of QuizChoices
     * const count = await prisma.quizChoice.count({
     *   where: {
     *     // ... the filter for the QuizChoices we want to count
     *   }
     * })
    **/
    count<T extends QuizChoiceCountArgs>(
      args?: Subset<T, QuizChoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizChoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizChoiceAggregateArgs>(args: Subset<T, QuizChoiceAggregateArgs>): Prisma.PrismaPromise<GetQuizChoiceAggregateType<T>>

    /**
     * Group by QuizChoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizChoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizChoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizChoiceGroupByArgs['orderBy'] }
        : { orderBy?: QuizChoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizChoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizChoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizChoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizChoiceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    questione<T extends QuizQuestionArgs= {}>(args?: Subset<T, QuizQuestionArgs>): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | Null>;

    questionAnswer<T extends QuizQuestionArgs= {}>(args?: Subset<T, QuizQuestionArgs>): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizChoice base type for findUnique actions
   */
  export type QuizChoiceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where: QuizChoiceWhereUniqueInput
  }

  /**
   * QuizChoice findUnique
   */
  export interface QuizChoiceFindUniqueArgs extends QuizChoiceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizChoice findUniqueOrThrow
   */
  export type QuizChoiceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice base type for findFirst actions
   */
  export type QuizChoiceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizChoices.
     */
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }

  /**
   * QuizChoice findFirst
   */
  export interface QuizChoiceFindFirstArgs extends QuizChoiceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizChoice findFirstOrThrow
   */
  export type QuizChoiceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoice to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizChoices.
     */
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizChoice findMany
   */
  export type QuizChoiceFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter, which QuizChoices to fetch.
     */
    where?: QuizChoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizChoices to fetch.
     */
    orderBy?: Enumerable<QuizChoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizChoices.
     */
    cursor?: QuizChoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizChoices.
     */
    skip?: number
    distinct?: Enumerable<QuizChoiceScalarFieldEnum>
  }


  /**
   * QuizChoice create
   */
  export type QuizChoiceCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The data needed to create a QuizChoice.
     */
    data: XOR<QuizChoiceCreateInput, QuizChoiceUncheckedCreateInput>
  }


  /**
   * QuizChoice createMany
   */
  export type QuizChoiceCreateManyArgs = {
    /**
     * The data used to create many QuizChoices.
     */
    data: Enumerable<QuizChoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizChoice update
   */
  export type QuizChoiceUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The data needed to update a QuizChoice.
     */
    data: XOR<QuizChoiceUpdateInput, QuizChoiceUncheckedUpdateInput>
    /**
     * Choose, which QuizChoice to update.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice updateMany
   */
  export type QuizChoiceUpdateManyArgs = {
    /**
     * The data used to update QuizChoices.
     */
    data: XOR<QuizChoiceUpdateManyMutationInput, QuizChoiceUncheckedUpdateManyInput>
    /**
     * Filter which QuizChoices to update
     */
    where?: QuizChoiceWhereInput
  }


  /**
   * QuizChoice upsert
   */
  export type QuizChoiceUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * The filter to search for the QuizChoice to update in case it exists.
     */
    where: QuizChoiceWhereUniqueInput
    /**
     * In case the QuizChoice found by the `where` argument doesn't exist, create a new QuizChoice with this data.
     */
    create: XOR<QuizChoiceCreateInput, QuizChoiceUncheckedCreateInput>
    /**
     * In case the QuizChoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizChoiceUpdateInput, QuizChoiceUncheckedUpdateInput>
  }


  /**
   * QuizChoice delete
   */
  export type QuizChoiceDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
    /**
     * Filter which QuizChoice to delete.
     */
    where: QuizChoiceWhereUniqueInput
  }


  /**
   * QuizChoice deleteMany
   */
  export type QuizChoiceDeleteManyArgs = {
    /**
     * Filter which QuizChoices to delete
     */
    where?: QuizChoiceWhereInput
  }


  /**
   * QuizChoice without action
   */
  export type QuizChoiceArgs = {
    /**
     * Select specific fields to fetch from the QuizChoice
     */
    select?: QuizChoiceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizChoiceInclude | null
  }



  /**
   * Model QuizRoundQuestion
   */


  export type AggregateQuizRoundQuestion = {
    _count: QuizRoundQuestionCountAggregateOutputType | null
    _avg: QuizRoundQuestionAvgAggregateOutputType | null
    _sum: QuizRoundQuestionSumAggregateOutputType | null
    _min: QuizRoundQuestionMinAggregateOutputType | null
    _max: QuizRoundQuestionMaxAggregateOutputType | null
  }

  export type QuizRoundQuestionAvgAggregateOutputType = {
    id: number | null
    userChoiceId: number | null
    questionId: number | null
    roundId: number | null
  }

  export type QuizRoundQuestionSumAggregateOutputType = {
    id: number | null
    userChoiceId: number | null
    questionId: number | null
    roundId: number | null
  }

  export type QuizRoundQuestionMinAggregateOutputType = {
    id: number | null
    userChoiceId: number | null
    questionId: number | null
    roundId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundQuestionMaxAggregateOutputType = {
    id: number | null
    userChoiceId: number | null
    questionId: number | null
    roundId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundQuestionCountAggregateOutputType = {
    id: number
    userChoiceId: number
    questionId: number
    roundId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizRoundQuestionAvgAggregateInputType = {
    id?: true
    userChoiceId?: true
    questionId?: true
    roundId?: true
  }

  export type QuizRoundQuestionSumAggregateInputType = {
    id?: true
    userChoiceId?: true
    questionId?: true
    roundId?: true
  }

  export type QuizRoundQuestionMinAggregateInputType = {
    id?: true
    userChoiceId?: true
    questionId?: true
    roundId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundQuestionMaxAggregateInputType = {
    id?: true
    userChoiceId?: true
    questionId?: true
    roundId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundQuestionCountAggregateInputType = {
    id?: true
    userChoiceId?: true
    questionId?: true
    roundId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizRoundQuestionAggregateArgs = {
    /**
     * Filter which QuizRoundQuestion to aggregate.
     */
    where?: QuizRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoundQuestions to fetch.
     */
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizRoundQuestions
    **/
    _count?: true | QuizRoundQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizRoundQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizRoundQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizRoundQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizRoundQuestionMaxAggregateInputType
  }

  export type GetQuizRoundQuestionAggregateType<T extends QuizRoundQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizRoundQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizRoundQuestion[P]>
      : GetScalarType<T[P], AggregateQuizRoundQuestion[P]>
  }




  export type QuizRoundQuestionGroupByArgs = {
    where?: QuizRoundQuestionWhereInput
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithAggregationInput>
    by: QuizRoundQuestionScalarFieldEnum[]
    having?: QuizRoundQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizRoundQuestionCountAggregateInputType | true
    _avg?: QuizRoundQuestionAvgAggregateInputType
    _sum?: QuizRoundQuestionSumAggregateInputType
    _min?: QuizRoundQuestionMinAggregateInputType
    _max?: QuizRoundQuestionMaxAggregateInputType
  }


  export type QuizRoundQuestionGroupByOutputType = {
    id: number
    userChoiceId: number
    questionId: number
    roundId: number
    createdAt: Date
    updatedAt: Date
    _count: QuizRoundQuestionCountAggregateOutputType | null
    _avg: QuizRoundQuestionAvgAggregateOutputType | null
    _sum: QuizRoundQuestionSumAggregateOutputType | null
    _min: QuizRoundQuestionMinAggregateOutputType | null
    _max: QuizRoundQuestionMaxAggregateOutputType | null
  }

  type GetQuizRoundQuestionGroupByPayload<T extends QuizRoundQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizRoundQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizRoundQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizRoundQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizRoundQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizRoundQuestionSelect = {
    id?: boolean
    userChoiceId?: boolean
    question?: boolean | QuizQuestionArgs
    questionId?: boolean
    round?: boolean | QuizRoundArgs
    roundId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type QuizRoundQuestionInclude = {
    question?: boolean | QuizQuestionArgs
    round?: boolean | QuizRoundArgs
  }

  export type QuizRoundQuestionGetPayload<S extends boolean | null | undefined | QuizRoundQuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRoundQuestion :
    S extends undefined ? never :
    S extends { include: any } & (QuizRoundQuestionArgs | QuizRoundQuestionFindManyArgs)
    ? QuizRoundQuestion  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? QuizQuestionGetPayload<S['include'][P]> :
        P extends 'round' ? QuizRoundGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizRoundQuestionArgs | QuizRoundQuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? QuizQuestionGetPayload<S['select'][P]> :
        P extends 'round' ? QuizRoundGetPayload<S['select'][P]> :  P extends keyof QuizRoundQuestion ? QuizRoundQuestion[P] : never
  } 
      : QuizRoundQuestion


  type QuizRoundQuestionCountArgs = 
    Omit<QuizRoundQuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuizRoundQuestionCountAggregateInputType | true
    }

  export interface QuizRoundQuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizRoundQuestion that matches the filter.
     * @param {QuizRoundQuestionFindUniqueArgs} args - Arguments to find a QuizRoundQuestion
     * @example
     * // Get one QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizRoundQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizRoundQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizRoundQuestion'> extends True ? Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>> : Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T> | null, null>

    /**
     * Find one QuizRoundQuestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizRoundQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizRoundQuestion
     * @example
     * // Get one QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizRoundQuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundQuestionFindUniqueOrThrowArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Find the first QuizRoundQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionFindFirstArgs} args - Arguments to find a QuizRoundQuestion
     * @example
     * // Get one QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizRoundQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizRoundQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizRoundQuestion'> extends True ? Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>> : Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T> | null, null>

    /**
     * Find the first QuizRoundQuestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizRoundQuestion
     * @example
     * // Get one QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizRoundQuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundQuestionFindFirstOrThrowArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Find zero or more QuizRoundQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizRoundQuestions
     * const quizRoundQuestions = await prisma.quizRoundQuestion.findMany()
     * 
     * // Get first 10 QuizRoundQuestions
     * const quizRoundQuestions = await prisma.quizRoundQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizRoundQuestionWithIdOnly = await prisma.quizRoundQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizRoundQuestionFindManyArgs>(
      args?: SelectSubset<T, QuizRoundQuestionFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizRoundQuestionGetPayload<T>>>

    /**
     * Create a QuizRoundQuestion.
     * @param {QuizRoundQuestionCreateArgs} args - Arguments to create a QuizRoundQuestion.
     * @example
     * // Create one QuizRoundQuestion
     * const QuizRoundQuestion = await prisma.quizRoundQuestion.create({
     *   data: {
     *     // ... data to create a QuizRoundQuestion
     *   }
     * })
     * 
    **/
    create<T extends QuizRoundQuestionCreateArgs>(
      args: SelectSubset<T, QuizRoundQuestionCreateArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Create many QuizRoundQuestions.
     *     @param {QuizRoundQuestionCreateManyArgs} args - Arguments to create many QuizRoundQuestions.
     *     @example
     *     // Create many QuizRoundQuestions
     *     const quizRoundQuestion = await prisma.quizRoundQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizRoundQuestionCreateManyArgs>(
      args?: SelectSubset<T, QuizRoundQuestionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizRoundQuestion.
     * @param {QuizRoundQuestionDeleteArgs} args - Arguments to delete one QuizRoundQuestion.
     * @example
     * // Delete one QuizRoundQuestion
     * const QuizRoundQuestion = await prisma.quizRoundQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizRoundQuestion
     *   }
     * })
     * 
    **/
    delete<T extends QuizRoundQuestionDeleteArgs>(
      args: SelectSubset<T, QuizRoundQuestionDeleteArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Update one QuizRoundQuestion.
     * @param {QuizRoundQuestionUpdateArgs} args - Arguments to update one QuizRoundQuestion.
     * @example
     * // Update one QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizRoundQuestionUpdateArgs>(
      args: SelectSubset<T, QuizRoundQuestionUpdateArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Delete zero or more QuizRoundQuestions.
     * @param {QuizRoundQuestionDeleteManyArgs} args - Arguments to filter QuizRoundQuestions to delete.
     * @example
     * // Delete a few QuizRoundQuestions
     * const { count } = await prisma.quizRoundQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizRoundQuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuizRoundQuestionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRoundQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizRoundQuestions
     * const quizRoundQuestion = await prisma.quizRoundQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizRoundQuestionUpdateManyArgs>(
      args: SelectSubset<T, QuizRoundQuestionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizRoundQuestion.
     * @param {QuizRoundQuestionUpsertArgs} args - Arguments to update or create a QuizRoundQuestion.
     * @example
     * // Update or create a QuizRoundQuestion
     * const quizRoundQuestion = await prisma.quizRoundQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizRoundQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizRoundQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends QuizRoundQuestionUpsertArgs>(
      args: SelectSubset<T, QuizRoundQuestionUpsertArgs>
    ): Prisma__QuizRoundQuestionClient<QuizRoundQuestionGetPayload<T>>

    /**
     * Count the number of QuizRoundQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionCountArgs} args - Arguments to filter QuizRoundQuestions to count.
     * @example
     * // Count the number of QuizRoundQuestions
     * const count = await prisma.quizRoundQuestion.count({
     *   where: {
     *     // ... the filter for the QuizRoundQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizRoundQuestionCountArgs>(
      args?: Subset<T, QuizRoundQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizRoundQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizRoundQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizRoundQuestionAggregateArgs>(args: Subset<T, QuizRoundQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizRoundQuestionAggregateType<T>>

    /**
     * Group by QuizRoundQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizRoundQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizRoundQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizRoundQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizRoundQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizRoundQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizRoundQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizRoundQuestionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends QuizQuestionArgs= {}>(args?: Subset<T, QuizQuestionArgs>): Prisma__QuizQuestionClient<QuizQuestionGetPayload<T> | Null>;

    round<T extends QuizRoundArgs= {}>(args?: Subset<T, QuizRoundArgs>): Prisma__QuizRoundClient<QuizRoundGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizRoundQuestion base type for findUnique actions
   */
  export type QuizRoundQuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter, which QuizRoundQuestion to fetch.
     */
    where: QuizRoundQuestionWhereUniqueInput
  }

  /**
   * QuizRoundQuestion findUnique
   */
  export interface QuizRoundQuestionFindUniqueArgs extends QuizRoundQuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRoundQuestion findUniqueOrThrow
   */
  export type QuizRoundQuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter, which QuizRoundQuestion to fetch.
     */
    where: QuizRoundQuestionWhereUniqueInput
  }


  /**
   * QuizRoundQuestion base type for findFirst actions
   */
  export type QuizRoundQuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter, which QuizRoundQuestion to fetch.
     */
    where?: QuizRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoundQuestions to fetch.
     */
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRoundQuestions.
     */
    cursor?: QuizRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRoundQuestions.
     */
    distinct?: Enumerable<QuizRoundQuestionScalarFieldEnum>
  }

  /**
   * QuizRoundQuestion findFirst
   */
  export interface QuizRoundQuestionFindFirstArgs extends QuizRoundQuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRoundQuestion findFirstOrThrow
   */
  export type QuizRoundQuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter, which QuizRoundQuestion to fetch.
     */
    where?: QuizRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoundQuestions to fetch.
     */
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRoundQuestions.
     */
    cursor?: QuizRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoundQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRoundQuestions.
     */
    distinct?: Enumerable<QuizRoundQuestionScalarFieldEnum>
  }


  /**
   * QuizRoundQuestion findMany
   */
  export type QuizRoundQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter, which QuizRoundQuestions to fetch.
     */
    where?: QuizRoundQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRoundQuestions to fetch.
     */
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizRoundQuestions.
     */
    cursor?: QuizRoundQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRoundQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRoundQuestions.
     */
    skip?: number
    distinct?: Enumerable<QuizRoundQuestionScalarFieldEnum>
  }


  /**
   * QuizRoundQuestion create
   */
  export type QuizRoundQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * The data needed to create a QuizRoundQuestion.
     */
    data: XOR<QuizRoundQuestionCreateInput, QuizRoundQuestionUncheckedCreateInput>
  }


  /**
   * QuizRoundQuestion createMany
   */
  export type QuizRoundQuestionCreateManyArgs = {
    /**
     * The data used to create many QuizRoundQuestions.
     */
    data: Enumerable<QuizRoundQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizRoundQuestion update
   */
  export type QuizRoundQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * The data needed to update a QuizRoundQuestion.
     */
    data: XOR<QuizRoundQuestionUpdateInput, QuizRoundQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizRoundQuestion to update.
     */
    where: QuizRoundQuestionWhereUniqueInput
  }


  /**
   * QuizRoundQuestion updateMany
   */
  export type QuizRoundQuestionUpdateManyArgs = {
    /**
     * The data used to update QuizRoundQuestions.
     */
    data: XOR<QuizRoundQuestionUpdateManyMutationInput, QuizRoundQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizRoundQuestions to update
     */
    where?: QuizRoundQuestionWhereInput
  }


  /**
   * QuizRoundQuestion upsert
   */
  export type QuizRoundQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * The filter to search for the QuizRoundQuestion to update in case it exists.
     */
    where: QuizRoundQuestionWhereUniqueInput
    /**
     * In case the QuizRoundQuestion found by the `where` argument doesn't exist, create a new QuizRoundQuestion with this data.
     */
    create: XOR<QuizRoundQuestionCreateInput, QuizRoundQuestionUncheckedCreateInput>
    /**
     * In case the QuizRoundQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizRoundQuestionUpdateInput, QuizRoundQuestionUncheckedUpdateInput>
  }


  /**
   * QuizRoundQuestion delete
   */
  export type QuizRoundQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    /**
     * Filter which QuizRoundQuestion to delete.
     */
    where: QuizRoundQuestionWhereUniqueInput
  }


  /**
   * QuizRoundQuestion deleteMany
   */
  export type QuizRoundQuestionDeleteManyArgs = {
    /**
     * Filter which QuizRoundQuestions to delete
     */
    where?: QuizRoundQuestionWhereInput
  }


  /**
   * QuizRoundQuestion without action
   */
  export type QuizRoundQuestionArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
  }



  /**
   * Model QuizRound
   */


  export type AggregateQuizRound = {
    _count: QuizRoundCountAggregateOutputType | null
    _avg: QuizRoundAvgAggregateOutputType | null
    _sum: QuizRoundSumAggregateOutputType | null
    _min: QuizRoundMinAggregateOutputType | null
    _max: QuizRoundMaxAggregateOutputType | null
  }

  export type QuizRoundAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    score: number | null
  }

  export type QuizRoundSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    score: number | null
  }

  export type QuizRoundMinAggregateOutputType = {
    id: number | null
    user: string | null
    categoryId: number | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundMaxAggregateOutputType = {
    id: number | null
    user: string | null
    categoryId: number | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizRoundCountAggregateOutputType = {
    id: number
    user: number
    categoryId: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizRoundAvgAggregateInputType = {
    id?: true
    categoryId?: true
    score?: true
  }

  export type QuizRoundSumAggregateInputType = {
    id?: true
    categoryId?: true
    score?: true
  }

  export type QuizRoundMinAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundMaxAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizRoundCountAggregateInputType = {
    id?: true
    user?: true
    categoryId?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizRoundAggregateArgs = {
    /**
     * Filter which QuizRound to aggregate.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizRounds
    **/
    _count?: true | QuizRoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizRoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizRoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizRoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizRoundMaxAggregateInputType
  }

  export type GetQuizRoundAggregateType<T extends QuizRoundAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizRound[P]>
      : GetScalarType<T[P], AggregateQuizRound[P]>
  }




  export type QuizRoundGroupByArgs = {
    where?: QuizRoundWhereInput
    orderBy?: Enumerable<QuizRoundOrderByWithAggregationInput>
    by: QuizRoundScalarFieldEnum[]
    having?: QuizRoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizRoundCountAggregateInputType | true
    _avg?: QuizRoundAvgAggregateInputType
    _sum?: QuizRoundSumAggregateInputType
    _min?: QuizRoundMinAggregateInputType
    _max?: QuizRoundMaxAggregateInputType
  }


  export type QuizRoundGroupByOutputType = {
    id: number
    user: string
    categoryId: number
    score: number
    createdAt: Date
    updatedAt: Date
    _count: QuizRoundCountAggregateOutputType | null
    _avg: QuizRoundAvgAggregateOutputType | null
    _sum: QuizRoundSumAggregateOutputType | null
    _min: QuizRoundMinAggregateOutputType | null
    _max: QuizRoundMaxAggregateOutputType | null
  }

  type GetQuizRoundGroupByPayload<T extends QuizRoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuizRoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizRoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizRoundGroupByOutputType[P]>
            : GetScalarType<T[P], QuizRoundGroupByOutputType[P]>
        }
      >
    >


  export type QuizRoundSelect = {
    id?: boolean
    user?: boolean
    category?: boolean | QuizCategoryArgs
    categoryId?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | QuizRound$questionsArgs
    _count?: boolean | QuizRoundCountOutputTypeArgs
  }


  export type QuizRoundInclude = {
    category?: boolean | QuizCategoryArgs
    questions?: boolean | QuizRound$questionsArgs
    _count?: boolean | QuizRoundCountOutputTypeArgs
  }

  export type QuizRoundGetPayload<S extends boolean | null | undefined | QuizRoundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuizRound :
    S extends undefined ? never :
    S extends { include: any } & (QuizRoundArgs | QuizRoundFindManyArgs)
    ? QuizRound  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['include'][P]> :
        P extends 'questions' ? Array < QuizRoundQuestionGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuizRoundCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuizRoundArgs | QuizRoundFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? QuizCategoryGetPayload<S['select'][P]> :
        P extends 'questions' ? Array < QuizRoundQuestionGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuizRoundCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof QuizRound ? QuizRound[P] : never
  } 
      : QuizRound


  type QuizRoundCountArgs = 
    Omit<QuizRoundFindManyArgs, 'select' | 'include'> & {
      select?: QuizRoundCountAggregateInputType | true
    }

  export interface QuizRoundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuizRound that matches the filter.
     * @param {QuizRoundFindUniqueArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuizRoundFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuizRoundFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuizRound'> extends True ? Prisma__QuizRoundClient<QuizRoundGetPayload<T>> : Prisma__QuizRoundClient<QuizRoundGetPayload<T> | null, null>

    /**
     * Find one QuizRound that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuizRoundFindUniqueOrThrowArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuizRoundFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundFindUniqueOrThrowArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Find the first QuizRound that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindFirstArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuizRoundFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuizRoundFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuizRound'> extends True ? Prisma__QuizRoundClient<QuizRoundGetPayload<T>> : Prisma__QuizRoundClient<QuizRoundGetPayload<T> | null, null>

    /**
     * Find the first QuizRound that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindFirstOrThrowArgs} args - Arguments to find a QuizRound
     * @example
     * // Get one QuizRound
     * const quizRound = await prisma.quizRound.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuizRoundFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuizRoundFindFirstOrThrowArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Find zero or more QuizRounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizRounds
     * const quizRounds = await prisma.quizRound.findMany()
     * 
     * // Get first 10 QuizRounds
     * const quizRounds = await prisma.quizRound.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizRoundWithIdOnly = await prisma.quizRound.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuizRoundFindManyArgs>(
      args?: SelectSubset<T, QuizRoundFindManyArgs>
    ): Prisma.PrismaPromise<Array<QuizRoundGetPayload<T>>>

    /**
     * Create a QuizRound.
     * @param {QuizRoundCreateArgs} args - Arguments to create a QuizRound.
     * @example
     * // Create one QuizRound
     * const QuizRound = await prisma.quizRound.create({
     *   data: {
     *     // ... data to create a QuizRound
     *   }
     * })
     * 
    **/
    create<T extends QuizRoundCreateArgs>(
      args: SelectSubset<T, QuizRoundCreateArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Create many QuizRounds.
     *     @param {QuizRoundCreateManyArgs} args - Arguments to create many QuizRounds.
     *     @example
     *     // Create many QuizRounds
     *     const quizRound = await prisma.quizRound.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuizRoundCreateManyArgs>(
      args?: SelectSubset<T, QuizRoundCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizRound.
     * @param {QuizRoundDeleteArgs} args - Arguments to delete one QuizRound.
     * @example
     * // Delete one QuizRound
     * const QuizRound = await prisma.quizRound.delete({
     *   where: {
     *     // ... filter to delete one QuizRound
     *   }
     * })
     * 
    **/
    delete<T extends QuizRoundDeleteArgs>(
      args: SelectSubset<T, QuizRoundDeleteArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Update one QuizRound.
     * @param {QuizRoundUpdateArgs} args - Arguments to update one QuizRound.
     * @example
     * // Update one QuizRound
     * const quizRound = await prisma.quizRound.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuizRoundUpdateArgs>(
      args: SelectSubset<T, QuizRoundUpdateArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Delete zero or more QuizRounds.
     * @param {QuizRoundDeleteManyArgs} args - Arguments to filter QuizRounds to delete.
     * @example
     * // Delete a few QuizRounds
     * const { count } = await prisma.quizRound.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuizRoundDeleteManyArgs>(
      args?: SelectSubset<T, QuizRoundDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizRounds
     * const quizRound = await prisma.quizRound.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuizRoundUpdateManyArgs>(
      args: SelectSubset<T, QuizRoundUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizRound.
     * @param {QuizRoundUpsertArgs} args - Arguments to update or create a QuizRound.
     * @example
     * // Update or create a QuizRound
     * const quizRound = await prisma.quizRound.upsert({
     *   create: {
     *     // ... data to create a QuizRound
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizRound we want to update
     *   }
     * })
    **/
    upsert<T extends QuizRoundUpsertArgs>(
      args: SelectSubset<T, QuizRoundUpsertArgs>
    ): Prisma__QuizRoundClient<QuizRoundGetPayload<T>>

    /**
     * Count the number of QuizRounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundCountArgs} args - Arguments to filter QuizRounds to count.
     * @example
     * // Count the number of QuizRounds
     * const count = await prisma.quizRound.count({
     *   where: {
     *     // ... the filter for the QuizRounds we want to count
     *   }
     * })
    **/
    count<T extends QuizRoundCountArgs>(
      args?: Subset<T, QuizRoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizRoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizRoundAggregateArgs>(args: Subset<T, QuizRoundAggregateArgs>): Prisma.PrismaPromise<GetQuizRoundAggregateType<T>>

    /**
     * Group by QuizRound.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizRoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizRoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizRoundGroupByArgs['orderBy'] }
        : { orderBy?: QuizRoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizRoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizRound.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuizRoundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends QuizCategoryArgs= {}>(args?: Subset<T, QuizCategoryArgs>): Prisma__QuizCategoryClient<QuizCategoryGetPayload<T> | Null>;

    questions<T extends QuizRound$questionsArgs= {}>(args?: Subset<T, QuizRound$questionsArgs>): Prisma.PrismaPromise<Array<QuizRoundQuestionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuizRound base type for findUnique actions
   */
  export type QuizRoundFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where: QuizRoundWhereUniqueInput
  }

  /**
   * QuizRound findUnique
   */
  export interface QuizRoundFindUniqueArgs extends QuizRoundFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRound findUniqueOrThrow
   */
  export type QuizRoundFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound base type for findFirst actions
   */
  export type QuizRoundFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRounds.
     */
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }

  /**
   * QuizRound findFirst
   */
  export interface QuizRoundFindFirstArgs extends QuizRoundFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuizRound findFirstOrThrow
   */
  export type QuizRoundFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRound to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizRounds.
     */
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizRound findMany
   */
  export type QuizRoundFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter, which QuizRounds to fetch.
     */
    where?: QuizRoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizRounds to fetch.
     */
    orderBy?: Enumerable<QuizRoundOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizRounds.
     */
    cursor?: QuizRoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizRounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizRounds.
     */
    skip?: number
    distinct?: Enumerable<QuizRoundScalarFieldEnum>
  }


  /**
   * QuizRound create
   */
  export type QuizRoundCreateArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The data needed to create a QuizRound.
     */
    data: XOR<QuizRoundCreateInput, QuizRoundUncheckedCreateInput>
  }


  /**
   * QuizRound createMany
   */
  export type QuizRoundCreateManyArgs = {
    /**
     * The data used to create many QuizRounds.
     */
    data: Enumerable<QuizRoundCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuizRound update
   */
  export type QuizRoundUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The data needed to update a QuizRound.
     */
    data: XOR<QuizRoundUpdateInput, QuizRoundUncheckedUpdateInput>
    /**
     * Choose, which QuizRound to update.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound updateMany
   */
  export type QuizRoundUpdateManyArgs = {
    /**
     * The data used to update QuizRounds.
     */
    data: XOR<QuizRoundUpdateManyMutationInput, QuizRoundUncheckedUpdateManyInput>
    /**
     * Filter which QuizRounds to update
     */
    where?: QuizRoundWhereInput
  }


  /**
   * QuizRound upsert
   */
  export type QuizRoundUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * The filter to search for the QuizRound to update in case it exists.
     */
    where: QuizRoundWhereUniqueInput
    /**
     * In case the QuizRound found by the `where` argument doesn't exist, create a new QuizRound with this data.
     */
    create: XOR<QuizRoundCreateInput, QuizRoundUncheckedCreateInput>
    /**
     * In case the QuizRound was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizRoundUpdateInput, QuizRoundUncheckedUpdateInput>
  }


  /**
   * QuizRound delete
   */
  export type QuizRoundDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
    /**
     * Filter which QuizRound to delete.
     */
    where: QuizRoundWhereUniqueInput
  }


  /**
   * QuizRound deleteMany
   */
  export type QuizRoundDeleteManyArgs = {
    /**
     * Filter which QuizRounds to delete
     */
    where?: QuizRoundWhereInput
  }


  /**
   * QuizRound.questions
   */
  export type QuizRound$questionsArgs = {
    /**
     * Select specific fields to fetch from the QuizRoundQuestion
     */
    select?: QuizRoundQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundQuestionInclude | null
    where?: QuizRoundQuestionWhereInput
    orderBy?: Enumerable<QuizRoundQuestionOrderByWithRelationInput>
    cursor?: QuizRoundQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuizRoundQuestionScalarFieldEnum>
  }


  /**
   * QuizRound without action
   */
  export type QuizRoundArgs = {
    /**
     * Select specific fields to fetch from the QuizRound
     */
    select?: QuizRoundSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuizRoundInclude | null
  }



  /**
   * Model FacebookUser
   */


  export type AggregateFacebookUser = {
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  export type FacebookUserAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookUserMinAggregateOutputType = {
    id: number | null
    username: string | null
    image: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    image: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserCountAggregateOutputType = {
    id: number
    username: number
    image: number
    coverImage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserAvgAggregateInputType = {
    id?: true
  }

  export type FacebookUserSumAggregateInputType = {
    id?: true
  }

  export type FacebookUserMinAggregateInputType = {
    id?: true
    username?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserMaxAggregateInputType = {
    id?: true
    username?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserCountAggregateInputType = {
    id?: true
    username?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserAggregateArgs = {
    /**
     * Filter which FacebookUser to aggregate.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUsers
    **/
    _count?: true | FacebookUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserMaxAggregateInputType
  }

  export type GetFacebookUserAggregateType<T extends FacebookUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUser[P]>
      : GetScalarType<T[P], AggregateFacebookUser[P]>
  }




  export type FacebookUserGroupByArgs = {
    where?: FacebookUserWhereInput
    orderBy?: Enumerable<FacebookUserOrderByWithAggregationInput>
    by: FacebookUserScalarFieldEnum[]
    having?: FacebookUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserCountAggregateInputType | true
    _avg?: FacebookUserAvgAggregateInputType
    _sum?: FacebookUserSumAggregateInputType
    _min?: FacebookUserMinAggregateInputType
    _max?: FacebookUserMaxAggregateInputType
  }


  export type FacebookUserGroupByOutputType = {
    id: number
    username: string
    image: string | null
    coverImage: string | null
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserCountAggregateOutputType | null
    _avg: FacebookUserAvgAggregateOutputType | null
    _sum: FacebookUserSumAggregateOutputType | null
    _min: FacebookUserMinAggregateOutputType | null
    _max: FacebookUserMaxAggregateOutputType | null
  }

  type GetFacebookUserGroupByPayload<T extends FacebookUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserSelect = {
    id?: boolean
    username?: boolean
    image?: boolean
    coverImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    from?: boolean | FacebookUser$fromArgs
    to?: boolean | FacebookUser$toArgs
    userInGroups?: boolean | FacebookUser$userInGroupsArgs
    posts?: boolean | FacebookUser$postsArgs
    directMessageFrom?: boolean | FacebookUser$directMessageFromArgs
    directMessageTo?: boolean | FacebookUser$directMessageToArgs
    commentPosts?: boolean | FacebookUser$commentPostsArgs
    likes?: boolean | FacebookUser$likesArgs
    postDestinations?: boolean | FacebookUser$postDestinationsArgs
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }


  export type FacebookUserInclude = {
    from?: boolean | FacebookUser$fromArgs
    to?: boolean | FacebookUser$toArgs
    userInGroups?: boolean | FacebookUser$userInGroupsArgs
    posts?: boolean | FacebookUser$postsArgs
    directMessageFrom?: boolean | FacebookUser$directMessageFromArgs
    directMessageTo?: boolean | FacebookUser$directMessageToArgs
    commentPosts?: boolean | FacebookUser$commentPostsArgs
    likes?: boolean | FacebookUser$likesArgs
    postDestinations?: boolean | FacebookUser$postDestinationsArgs
    _count?: boolean | FacebookUserCountOutputTypeArgs
  }

  export type FacebookUserGetPayload<S extends boolean | null | undefined | FacebookUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUser :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
    ? FacebookUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? Array < FacebookUserRelationshipGetPayload<S['include'][P]>>  :
        P extends 'to' ? Array < FacebookUserRelationshipGetPayload<S['include'][P]>>  :
        P extends 'userInGroups' ? Array < FacebookUserInGroupGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < FacebookPostGetPayload<S['include'][P]>>  :
        P extends 'directMessageFrom' ? Array < FacebookDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'directMessageTo' ? Array < FacebookDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['include'][P]>>  :
        P extends 'likes' ? Array < FacebookLikeGetPayload<S['include'][P]>>  :
        P extends 'postDestinations' ? Array < FacebookPostDestinationGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserArgs | FacebookUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? Array < FacebookUserRelationshipGetPayload<S['select'][P]>>  :
        P extends 'to' ? Array < FacebookUserRelationshipGetPayload<S['select'][P]>>  :
        P extends 'userInGroups' ? Array < FacebookUserInGroupGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < FacebookPostGetPayload<S['select'][P]>>  :
        P extends 'directMessageFrom' ? Array < FacebookDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'directMessageTo' ? Array < FacebookDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['select'][P]>>  :
        P extends 'likes' ? Array < FacebookLikeGetPayload<S['select'][P]>>  :
        P extends 'postDestinations' ? Array < FacebookPostDestinationGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookUser ? FacebookUser[P] : never
  } 
      : FacebookUser


  type FacebookUserCountArgs = 
    Omit<FacebookUserFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserCountAggregateInputType | true
    }

  export interface FacebookUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUser that matches the filter.
     * @param {FacebookUserFindUniqueArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find one FacebookUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserFindUniqueOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find the first FacebookUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUser'> extends True ? Prisma__FacebookUserClient<FacebookUserGetPayload<T>> : Prisma__FacebookUserClient<FacebookUserGetPayload<T> | null, null>

    /**
     * Find the first FacebookUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindFirstOrThrowArgs} args - Arguments to find a FacebookUser
     * @example
     * // Get one FacebookUser
     * const facebookUser = await prisma.facebookUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserFindFirstOrThrowArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Find zero or more FacebookUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany()
     * 
     * // Get first 10 FacebookUsers
     * const facebookUsers = await prisma.facebookUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserWithIdOnly = await prisma.facebookUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserFindManyArgs>(
      args?: SelectSubset<T, FacebookUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserGetPayload<T>>>

    /**
     * Create a FacebookUser.
     * @param {FacebookUserCreateArgs} args - Arguments to create a FacebookUser.
     * @example
     * // Create one FacebookUser
     * const FacebookUser = await prisma.facebookUser.create({
     *   data: {
     *     // ... data to create a FacebookUser
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserCreateArgs>(
      args: SelectSubset<T, FacebookUserCreateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Create many FacebookUsers.
     *     @param {FacebookUserCreateManyArgs} args - Arguments to create many FacebookUsers.
     *     @example
     *     // Create many FacebookUsers
     *     const facebookUser = await prisma.facebookUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUser.
     * @param {FacebookUserDeleteArgs} args - Arguments to delete one FacebookUser.
     * @example
     * // Delete one FacebookUser
     * const FacebookUser = await prisma.facebookUser.delete({
     *   where: {
     *     // ... filter to delete one FacebookUser
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserDeleteArgs>(
      args: SelectSubset<T, FacebookUserDeleteArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Update one FacebookUser.
     * @param {FacebookUserUpdateArgs} args - Arguments to update one FacebookUser.
     * @example
     * // Update one FacebookUser
     * const facebookUser = await prisma.facebookUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserUpdateArgs>(
      args: SelectSubset<T, FacebookUserUpdateArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Delete zero or more FacebookUsers.
     * @param {FacebookUserDeleteManyArgs} args - Arguments to filter FacebookUsers to delete.
     * @example
     * // Delete a few FacebookUsers
     * const { count } = await prisma.facebookUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUsers
     * const facebookUser = await prisma.facebookUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUser.
     * @param {FacebookUserUpsertArgs} args - Arguments to update or create a FacebookUser.
     * @example
     * // Update or create a FacebookUser
     * const facebookUser = await prisma.facebookUser.upsert({
     *   create: {
     *     // ... data to create a FacebookUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUser we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserUpsertArgs>(
      args: SelectSubset<T, FacebookUserUpsertArgs>
    ): Prisma__FacebookUserClient<FacebookUserGetPayload<T>>

    /**
     * Count the number of FacebookUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserCountArgs} args - Arguments to filter FacebookUsers to count.
     * @example
     * // Count the number of FacebookUsers
     * const count = await prisma.facebookUser.count({
     *   where: {
     *     // ... the filter for the FacebookUsers we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserCountArgs>(
      args?: Subset<T, FacebookUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserAggregateArgs>(args: Subset<T, FacebookUserAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserAggregateType<T>>

    /**
     * Group by FacebookUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends FacebookUser$fromArgs= {}>(args?: Subset<T, FacebookUser$fromArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationshipGetPayload<T>>| Null>;

    to<T extends FacebookUser$toArgs= {}>(args?: Subset<T, FacebookUser$toArgs>): Prisma.PrismaPromise<Array<FacebookUserRelationshipGetPayload<T>>| Null>;

    userInGroups<T extends FacebookUser$userInGroupsArgs= {}>(args?: Subset<T, FacebookUser$userInGroupsArgs>): Prisma.PrismaPromise<Array<FacebookUserInGroupGetPayload<T>>| Null>;

    posts<T extends FacebookUser$postsArgs= {}>(args?: Subset<T, FacebookUser$postsArgs>): Prisma.PrismaPromise<Array<FacebookPostGetPayload<T>>| Null>;

    directMessageFrom<T extends FacebookUser$directMessageFromArgs= {}>(args?: Subset<T, FacebookUser$directMessageFromArgs>): Prisma.PrismaPromise<Array<FacebookDirectMessageGetPayload<T>>| Null>;

    directMessageTo<T extends FacebookUser$directMessageToArgs= {}>(args?: Subset<T, FacebookUser$directMessageToArgs>): Prisma.PrismaPromise<Array<FacebookDirectMessageGetPayload<T>>| Null>;

    commentPosts<T extends FacebookUser$commentPostsArgs= {}>(args?: Subset<T, FacebookUser$commentPostsArgs>): Prisma.PrismaPromise<Array<FacebookCommentPostGetPayload<T>>| Null>;

    likes<T extends FacebookUser$likesArgs= {}>(args?: Subset<T, FacebookUser$likesArgs>): Prisma.PrismaPromise<Array<FacebookLikeGetPayload<T>>| Null>;

    postDestinations<T extends FacebookUser$postDestinationsArgs= {}>(args?: Subset<T, FacebookUser$postDestinationsArgs>): Prisma.PrismaPromise<Array<FacebookPostDestinationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUser base type for findUnique actions
   */
  export type FacebookUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }

  /**
   * FacebookUser findUnique
   */
  export interface FacebookUserFindUniqueArgs extends FacebookUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findUniqueOrThrow
   */
  export type FacebookUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser base type for findFirst actions
   */
  export type FacebookUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }

  /**
   * FacebookUser findFirst
   */
  export interface FacebookUserFindFirstArgs extends FacebookUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUser findFirstOrThrow
   */
  export type FacebookUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUser to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUsers.
     */
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser findMany
   */
  export type FacebookUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter, which FacebookUsers to fetch.
     */
    where?: FacebookUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUsers to fetch.
     */
    orderBy?: Enumerable<FacebookUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUsers.
     */
    cursor?: FacebookUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUsers.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserScalarFieldEnum>
  }


  /**
   * FacebookUser create
   */
  export type FacebookUserCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to create a FacebookUser.
     */
    data: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
  }


  /**
   * FacebookUser createMany
   */
  export type FacebookUserCreateManyArgs = {
    /**
     * The data used to create many FacebookUsers.
     */
    data: Enumerable<FacebookUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUser update
   */
  export type FacebookUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The data needed to update a FacebookUser.
     */
    data: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
    /**
     * Choose, which FacebookUser to update.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser updateMany
   */
  export type FacebookUserUpdateManyArgs = {
    /**
     * The data used to update FacebookUsers.
     */
    data: XOR<FacebookUserUpdateManyMutationInput, FacebookUserUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUsers to update
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser upsert
   */
  export type FacebookUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * The filter to search for the FacebookUser to update in case it exists.
     */
    where: FacebookUserWhereUniqueInput
    /**
     * In case the FacebookUser found by the `where` argument doesn't exist, create a new FacebookUser with this data.
     */
    create: XOR<FacebookUserCreateInput, FacebookUserUncheckedCreateInput>
    /**
     * In case the FacebookUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserUpdateInput, FacebookUserUncheckedUpdateInput>
  }


  /**
   * FacebookUser delete
   */
  export type FacebookUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
    /**
     * Filter which FacebookUser to delete.
     */
    where: FacebookUserWhereUniqueInput
  }


  /**
   * FacebookUser deleteMany
   */
  export type FacebookUserDeleteManyArgs = {
    /**
     * Filter which FacebookUsers to delete
     */
    where?: FacebookUserWhereInput
  }


  /**
   * FacebookUser.from
   */
  export type FacebookUser$fromArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    where?: FacebookUserRelationshipWhereInput
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    cursor?: FacebookUserRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationshipScalarFieldEnum>
  }


  /**
   * FacebookUser.to
   */
  export type FacebookUser$toArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    where?: FacebookUserRelationshipWhereInput
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    cursor?: FacebookUserRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserRelationshipScalarFieldEnum>
  }


  /**
   * FacebookUser.userInGroups
   */
  export type FacebookUser$userInGroupsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    where?: FacebookUserInGroupWhereInput
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    cursor?: FacebookUserInGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserInGroupScalarFieldEnum>
  }


  /**
   * FacebookUser.posts
   */
  export type FacebookUser$postsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    where?: FacebookPostWhereInput
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    cursor?: FacebookPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookUser.directMessageFrom
   */
  export type FacebookUser$directMessageFromArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    where?: FacebookDirectMessageWhereInput
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    cursor?: FacebookDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookDirectMessageScalarFieldEnum>
  }


  /**
   * FacebookUser.directMessageTo
   */
  export type FacebookUser$directMessageToArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    where?: FacebookDirectMessageWhereInput
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    cursor?: FacebookDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookDirectMessageScalarFieldEnum>
  }


  /**
   * FacebookUser.commentPosts
   */
  export type FacebookUser$commentPostsArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    where?: FacebookCommentPostWhereInput
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    cursor?: FacebookCommentPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookUser.likes
   */
  export type FacebookUser$likesArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    where?: FacebookLikeWhereInput
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    cursor?: FacebookLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookLikeScalarFieldEnum>
  }


  /**
   * FacebookUser.postDestinations
   */
  export type FacebookUser$postDestinationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    where?: FacebookPostDestinationWhereInput
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    cursor?: FacebookPostDestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }


  /**
   * FacebookUser without action
   */
  export type FacebookUserArgs = {
    /**
     * Select specific fields to fetch from the FacebookUser
     */
    select?: FacebookUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInclude | null
  }



  /**
   * Model FacebookUserRelationship
   */


  export type AggregateFacebookUserRelationship = {
    _count: FacebookUserRelationshipCountAggregateOutputType | null
    _avg: FacebookUserRelationshipAvgAggregateOutputType | null
    _sum: FacebookUserRelationshipSumAggregateOutputType | null
    _min: FacebookUserRelationshipMinAggregateOutputType | null
    _max: FacebookUserRelationshipMaxAggregateOutputType | null
  }

  export type FacebookUserRelationshipAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type FacebookUserRelationshipSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type FacebookUserRelationshipMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationshipMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserRelationshipCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserRelationshipAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type FacebookUserRelationshipSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type FacebookUserRelationshipMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationshipMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserRelationshipCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserRelationshipAggregateArgs = {
    /**
     * Filter which FacebookUserRelationship to aggregate.
     */
    where?: FacebookUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelationships to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUserRelationships
    **/
    _count?: true | FacebookUserRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserRelationshipMaxAggregateInputType
  }

  export type GetFacebookUserRelationshipAggregateType<T extends FacebookUserRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUserRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUserRelationship[P]>
      : GetScalarType<T[P], AggregateFacebookUserRelationship[P]>
  }




  export type FacebookUserRelationshipGroupByArgs = {
    where?: FacebookUserRelationshipWhereInput
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithAggregationInput>
    by: FacebookUserRelationshipScalarFieldEnum[]
    having?: FacebookUserRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserRelationshipCountAggregateInputType | true
    _avg?: FacebookUserRelationshipAvgAggregateInputType
    _sum?: FacebookUserRelationshipSumAggregateInputType
    _min?: FacebookUserRelationshipMinAggregateInputType
    _max?: FacebookUserRelationshipMaxAggregateInputType
  }


  export type FacebookUserRelationshipGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserRelationshipCountAggregateOutputType | null
    _avg: FacebookUserRelationshipAvgAggregateOutputType | null
    _sum: FacebookUserRelationshipSumAggregateOutputType | null
    _min: FacebookUserRelationshipMinAggregateOutputType | null
    _max: FacebookUserRelationshipMaxAggregateOutputType | null
  }

  type GetFacebookUserRelationshipGroupByPayload<T extends FacebookUserRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserRelationshipSelect = {
    id?: boolean
    from?: boolean | FacebookUserArgs
    to?: boolean | FacebookUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookUserRelationshipInclude = {
    from?: boolean | FacebookUserArgs
    to?: boolean | FacebookUserArgs
  }

  export type FacebookUserRelationshipGetPayload<S extends boolean | null | undefined | FacebookUserRelationshipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserRelationship :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserRelationshipArgs | FacebookUserRelationshipFindManyArgs)
    ? FacebookUserRelationship  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'to' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserRelationshipArgs | FacebookUserRelationshipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'to' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof FacebookUserRelationship ? FacebookUserRelationship[P] : never
  } 
      : FacebookUserRelationship


  type FacebookUserRelationshipCountArgs = 
    Omit<FacebookUserRelationshipFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserRelationshipCountAggregateInputType | true
    }

  export interface FacebookUserRelationshipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUserRelationship that matches the filter.
     * @param {FacebookUserRelationshipFindUniqueArgs} args - Arguments to find a FacebookUserRelationship
     * @example
     * // Get one FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserRelationshipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserRelationshipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUserRelationship'> extends True ? Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>> : Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T> | null, null>

    /**
     * Find one FacebookUserRelationship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserRelationshipFindUniqueOrThrowArgs} args - Arguments to find a FacebookUserRelationship
     * @example
     * // Get one FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserRelationshipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationshipFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Find the first FacebookUserRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipFindFirstArgs} args - Arguments to find a FacebookUserRelationship
     * @example
     * // Get one FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserRelationshipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserRelationshipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUserRelationship'> extends True ? Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>> : Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T> | null, null>

    /**
     * Find the first FacebookUserRelationship that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipFindFirstOrThrowArgs} args - Arguments to find a FacebookUserRelationship
     * @example
     * // Get one FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserRelationshipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserRelationshipFindFirstOrThrowArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Find zero or more FacebookUserRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUserRelationships
     * const facebookUserRelationships = await prisma.facebookUserRelationship.findMany()
     * 
     * // Get first 10 FacebookUserRelationships
     * const facebookUserRelationships = await prisma.facebookUserRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserRelationshipWithIdOnly = await prisma.facebookUserRelationship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserRelationshipFindManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationshipFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserRelationshipGetPayload<T>>>

    /**
     * Create a FacebookUserRelationship.
     * @param {FacebookUserRelationshipCreateArgs} args - Arguments to create a FacebookUserRelationship.
     * @example
     * // Create one FacebookUserRelationship
     * const FacebookUserRelationship = await prisma.facebookUserRelationship.create({
     *   data: {
     *     // ... data to create a FacebookUserRelationship
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserRelationshipCreateArgs>(
      args: SelectSubset<T, FacebookUserRelationshipCreateArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Create many FacebookUserRelationships.
     *     @param {FacebookUserRelationshipCreateManyArgs} args - Arguments to create many FacebookUserRelationships.
     *     @example
     *     // Create many FacebookUserRelationships
     *     const facebookUserRelationship = await prisma.facebookUserRelationship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserRelationshipCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationshipCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUserRelationship.
     * @param {FacebookUserRelationshipDeleteArgs} args - Arguments to delete one FacebookUserRelationship.
     * @example
     * // Delete one FacebookUserRelationship
     * const FacebookUserRelationship = await prisma.facebookUserRelationship.delete({
     *   where: {
     *     // ... filter to delete one FacebookUserRelationship
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserRelationshipDeleteArgs>(
      args: SelectSubset<T, FacebookUserRelationshipDeleteArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Update one FacebookUserRelationship.
     * @param {FacebookUserRelationshipUpdateArgs} args - Arguments to update one FacebookUserRelationship.
     * @example
     * // Update one FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserRelationshipUpdateArgs>(
      args: SelectSubset<T, FacebookUserRelationshipUpdateArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Delete zero or more FacebookUserRelationships.
     * @param {FacebookUserRelationshipDeleteManyArgs} args - Arguments to filter FacebookUserRelationships to delete.
     * @example
     * // Delete a few FacebookUserRelationships
     * const { count } = await prisma.facebookUserRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserRelationshipDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserRelationshipDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUserRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUserRelationships
     * const facebookUserRelationship = await prisma.facebookUserRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserRelationshipUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserRelationshipUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUserRelationship.
     * @param {FacebookUserRelationshipUpsertArgs} args - Arguments to update or create a FacebookUserRelationship.
     * @example
     * // Update or create a FacebookUserRelationship
     * const facebookUserRelationship = await prisma.facebookUserRelationship.upsert({
     *   create: {
     *     // ... data to create a FacebookUserRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUserRelationship we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserRelationshipUpsertArgs>(
      args: SelectSubset<T, FacebookUserRelationshipUpsertArgs>
    ): Prisma__FacebookUserRelationshipClient<FacebookUserRelationshipGetPayload<T>>

    /**
     * Count the number of FacebookUserRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipCountArgs} args - Arguments to filter FacebookUserRelationships to count.
     * @example
     * // Count the number of FacebookUserRelationships
     * const count = await prisma.facebookUserRelationship.count({
     *   where: {
     *     // ... the filter for the FacebookUserRelationships we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserRelationshipCountArgs>(
      args?: Subset<T, FacebookUserRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUserRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserRelationshipAggregateArgs>(args: Subset<T, FacebookUserRelationshipAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserRelationshipAggregateType<T>>

    /**
     * Group by FacebookUserRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUserRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserRelationshipClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    to<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUserRelationship base type for findUnique actions
   */
  export type FacebookUserRelationshipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter, which FacebookUserRelationship to fetch.
     */
    where: FacebookUserRelationshipWhereUniqueInput
  }

  /**
   * FacebookUserRelationship findUnique
   */
  export interface FacebookUserRelationshipFindUniqueArgs extends FacebookUserRelationshipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelationship findUniqueOrThrow
   */
  export type FacebookUserRelationshipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter, which FacebookUserRelationship to fetch.
     */
    where: FacebookUserRelationshipWhereUniqueInput
  }


  /**
   * FacebookUserRelationship base type for findFirst actions
   */
  export type FacebookUserRelationshipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter, which FacebookUserRelationship to fetch.
     */
    where?: FacebookUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelationships to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelationships.
     */
    cursor?: FacebookUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelationships.
     */
    distinct?: Enumerable<FacebookUserRelationshipScalarFieldEnum>
  }

  /**
   * FacebookUserRelationship findFirst
   */
  export interface FacebookUserRelationshipFindFirstArgs extends FacebookUserRelationshipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserRelationship findFirstOrThrow
   */
  export type FacebookUserRelationshipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter, which FacebookUserRelationship to fetch.
     */
    where?: FacebookUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelationships to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserRelationships.
     */
    cursor?: FacebookUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserRelationships.
     */
    distinct?: Enumerable<FacebookUserRelationshipScalarFieldEnum>
  }


  /**
   * FacebookUserRelationship findMany
   */
  export type FacebookUserRelationshipFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter, which FacebookUserRelationships to fetch.
     */
    where?: FacebookUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserRelationships to fetch.
     */
    orderBy?: Enumerable<FacebookUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUserRelationships.
     */
    cursor?: FacebookUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserRelationships.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserRelationshipScalarFieldEnum>
  }


  /**
   * FacebookUserRelationship create
   */
  export type FacebookUserRelationshipCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * The data needed to create a FacebookUserRelationship.
     */
    data: XOR<FacebookUserRelationshipCreateInput, FacebookUserRelationshipUncheckedCreateInput>
  }


  /**
   * FacebookUserRelationship createMany
   */
  export type FacebookUserRelationshipCreateManyArgs = {
    /**
     * The data used to create many FacebookUserRelationships.
     */
    data: Enumerable<FacebookUserRelationshipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUserRelationship update
   */
  export type FacebookUserRelationshipUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * The data needed to update a FacebookUserRelationship.
     */
    data: XOR<FacebookUserRelationshipUpdateInput, FacebookUserRelationshipUncheckedUpdateInput>
    /**
     * Choose, which FacebookUserRelationship to update.
     */
    where: FacebookUserRelationshipWhereUniqueInput
  }


  /**
   * FacebookUserRelationship updateMany
   */
  export type FacebookUserRelationshipUpdateManyArgs = {
    /**
     * The data used to update FacebookUserRelationships.
     */
    data: XOR<FacebookUserRelationshipUpdateManyMutationInput, FacebookUserRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUserRelationships to update
     */
    where?: FacebookUserRelationshipWhereInput
  }


  /**
   * FacebookUserRelationship upsert
   */
  export type FacebookUserRelationshipUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * The filter to search for the FacebookUserRelationship to update in case it exists.
     */
    where: FacebookUserRelationshipWhereUniqueInput
    /**
     * In case the FacebookUserRelationship found by the `where` argument doesn't exist, create a new FacebookUserRelationship with this data.
     */
    create: XOR<FacebookUserRelationshipCreateInput, FacebookUserRelationshipUncheckedCreateInput>
    /**
     * In case the FacebookUserRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserRelationshipUpdateInput, FacebookUserRelationshipUncheckedUpdateInput>
  }


  /**
   * FacebookUserRelationship delete
   */
  export type FacebookUserRelationshipDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
    /**
     * Filter which FacebookUserRelationship to delete.
     */
    where: FacebookUserRelationshipWhereUniqueInput
  }


  /**
   * FacebookUserRelationship deleteMany
   */
  export type FacebookUserRelationshipDeleteManyArgs = {
    /**
     * Filter which FacebookUserRelationships to delete
     */
    where?: FacebookUserRelationshipWhereInput
  }


  /**
   * FacebookUserRelationship without action
   */
  export type FacebookUserRelationshipArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserRelationship
     */
    select?: FacebookUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserRelationshipInclude | null
  }



  /**
   * Model FacebookDirectMessage
   */


  export type AggregateFacebookDirectMessage = {
    _count: FacebookDirectMessageCountAggregateOutputType | null
    _avg: FacebookDirectMessageAvgAggregateOutputType | null
    _sum: FacebookDirectMessageSumAggregateOutputType | null
    _min: FacebookDirectMessageMinAggregateOutputType | null
    _max: FacebookDirectMessageMaxAggregateOutputType | null
  }

  export type FacebookDirectMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type FacebookDirectMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type FacebookDirectMessageMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    message: string | null
    image: string | null
    readStatus: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookDirectMessageMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    message: string | null
    image: string | null
    readStatus: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookDirectMessageCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    message: number
    image: number
    readStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookDirectMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type FacebookDirectMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type FacebookDirectMessageMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    readStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookDirectMessageMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    readStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookDirectMessageCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    readStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookDirectMessageAggregateArgs = {
    /**
     * Filter which FacebookDirectMessage to aggregate.
     */
    where?: FacebookDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookDirectMessages to fetch.
     */
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookDirectMessages
    **/
    _count?: true | FacebookDirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookDirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookDirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookDirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookDirectMessageMaxAggregateInputType
  }

  export type GetFacebookDirectMessageAggregateType<T extends FacebookDirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookDirectMessage[P]>
      : GetScalarType<T[P], AggregateFacebookDirectMessage[P]>
  }




  export type FacebookDirectMessageGroupByArgs = {
    where?: FacebookDirectMessageWhereInput
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithAggregationInput>
    by: FacebookDirectMessageScalarFieldEnum[]
    having?: FacebookDirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookDirectMessageCountAggregateInputType | true
    _avg?: FacebookDirectMessageAvgAggregateInputType
    _sum?: FacebookDirectMessageSumAggregateInputType
    _min?: FacebookDirectMessageMinAggregateInputType
    _max?: FacebookDirectMessageMaxAggregateInputType
  }


  export type FacebookDirectMessageGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    message: string
    image: string | null
    readStatus: boolean
    createdAt: Date
    updatedAt: Date
    _count: FacebookDirectMessageCountAggregateOutputType | null
    _avg: FacebookDirectMessageAvgAggregateOutputType | null
    _sum: FacebookDirectMessageSumAggregateOutputType | null
    _min: FacebookDirectMessageMinAggregateOutputType | null
    _max: FacebookDirectMessageMaxAggregateOutputType | null
  }

  type GetFacebookDirectMessageGroupByPayload<T extends FacebookDirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookDirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookDirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookDirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookDirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type FacebookDirectMessageSelect = {
    id?: boolean
    from?: boolean | FacebookUserArgs
    to?: boolean | FacebookUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    message?: boolean
    image?: boolean
    readStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookDirectMessageInclude = {
    from?: boolean | FacebookUserArgs
    to?: boolean | FacebookUserArgs
  }

  export type FacebookDirectMessageGetPayload<S extends boolean | null | undefined | FacebookDirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookDirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (FacebookDirectMessageArgs | FacebookDirectMessageFindManyArgs)
    ? FacebookDirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'to' ? FacebookUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookDirectMessageArgs | FacebookDirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'to' ? FacebookUserGetPayload<S['select'][P]> :  P extends keyof FacebookDirectMessage ? FacebookDirectMessage[P] : never
  } 
      : FacebookDirectMessage


  type FacebookDirectMessageCountArgs = 
    Omit<FacebookDirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: FacebookDirectMessageCountAggregateInputType | true
    }

  export interface FacebookDirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookDirectMessage that matches the filter.
     * @param {FacebookDirectMessageFindUniqueArgs} args - Arguments to find a FacebookDirectMessage
     * @example
     * // Get one FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookDirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookDirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookDirectMessage'> extends True ? Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>> : Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T> | null, null>

    /**
     * Find one FacebookDirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookDirectMessageFindUniqueOrThrowArgs} args - Arguments to find a FacebookDirectMessage
     * @example
     * // Get one FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookDirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookDirectMessageFindUniqueOrThrowArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Find the first FacebookDirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageFindFirstArgs} args - Arguments to find a FacebookDirectMessage
     * @example
     * // Get one FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookDirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookDirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookDirectMessage'> extends True ? Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>> : Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T> | null, null>

    /**
     * Find the first FacebookDirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageFindFirstOrThrowArgs} args - Arguments to find a FacebookDirectMessage
     * @example
     * // Get one FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookDirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookDirectMessageFindFirstOrThrowArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Find zero or more FacebookDirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookDirectMessages
     * const facebookDirectMessages = await prisma.facebookDirectMessage.findMany()
     * 
     * // Get first 10 FacebookDirectMessages
     * const facebookDirectMessages = await prisma.facebookDirectMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookDirectMessageWithIdOnly = await prisma.facebookDirectMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookDirectMessageFindManyArgs>(
      args?: SelectSubset<T, FacebookDirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookDirectMessageGetPayload<T>>>

    /**
     * Create a FacebookDirectMessage.
     * @param {FacebookDirectMessageCreateArgs} args - Arguments to create a FacebookDirectMessage.
     * @example
     * // Create one FacebookDirectMessage
     * const FacebookDirectMessage = await prisma.facebookDirectMessage.create({
     *   data: {
     *     // ... data to create a FacebookDirectMessage
     *   }
     * })
     * 
    **/
    create<T extends FacebookDirectMessageCreateArgs>(
      args: SelectSubset<T, FacebookDirectMessageCreateArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Create many FacebookDirectMessages.
     *     @param {FacebookDirectMessageCreateManyArgs} args - Arguments to create many FacebookDirectMessages.
     *     @example
     *     // Create many FacebookDirectMessages
     *     const facebookDirectMessage = await prisma.facebookDirectMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookDirectMessageCreateManyArgs>(
      args?: SelectSubset<T, FacebookDirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookDirectMessage.
     * @param {FacebookDirectMessageDeleteArgs} args - Arguments to delete one FacebookDirectMessage.
     * @example
     * // Delete one FacebookDirectMessage
     * const FacebookDirectMessage = await prisma.facebookDirectMessage.delete({
     *   where: {
     *     // ... filter to delete one FacebookDirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends FacebookDirectMessageDeleteArgs>(
      args: SelectSubset<T, FacebookDirectMessageDeleteArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Update one FacebookDirectMessage.
     * @param {FacebookDirectMessageUpdateArgs} args - Arguments to update one FacebookDirectMessage.
     * @example
     * // Update one FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookDirectMessageUpdateArgs>(
      args: SelectSubset<T, FacebookDirectMessageUpdateArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Delete zero or more FacebookDirectMessages.
     * @param {FacebookDirectMessageDeleteManyArgs} args - Arguments to filter FacebookDirectMessages to delete.
     * @example
     * // Delete a few FacebookDirectMessages
     * const { count } = await prisma.facebookDirectMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookDirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, FacebookDirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookDirectMessages
     * const facebookDirectMessage = await prisma.facebookDirectMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookDirectMessageUpdateManyArgs>(
      args: SelectSubset<T, FacebookDirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookDirectMessage.
     * @param {FacebookDirectMessageUpsertArgs} args - Arguments to update or create a FacebookDirectMessage.
     * @example
     * // Update or create a FacebookDirectMessage
     * const facebookDirectMessage = await prisma.facebookDirectMessage.upsert({
     *   create: {
     *     // ... data to create a FacebookDirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookDirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookDirectMessageUpsertArgs>(
      args: SelectSubset<T, FacebookDirectMessageUpsertArgs>
    ): Prisma__FacebookDirectMessageClient<FacebookDirectMessageGetPayload<T>>

    /**
     * Count the number of FacebookDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageCountArgs} args - Arguments to filter FacebookDirectMessages to count.
     * @example
     * // Count the number of FacebookDirectMessages
     * const count = await prisma.facebookDirectMessage.count({
     *   where: {
     *     // ... the filter for the FacebookDirectMessages we want to count
     *   }
     * })
    **/
    count<T extends FacebookDirectMessageCountArgs>(
      args?: Subset<T, FacebookDirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookDirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookDirectMessageAggregateArgs>(args: Subset<T, FacebookDirectMessageAggregateArgs>): Prisma.PrismaPromise<GetFacebookDirectMessageAggregateType<T>>

    /**
     * Group by FacebookDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookDirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookDirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookDirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: FacebookDirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookDirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookDirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookDirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    to<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookDirectMessage base type for findUnique actions
   */
  export type FacebookDirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter, which FacebookDirectMessage to fetch.
     */
    where: FacebookDirectMessageWhereUniqueInput
  }

  /**
   * FacebookDirectMessage findUnique
   */
  export interface FacebookDirectMessageFindUniqueArgs extends FacebookDirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookDirectMessage findUniqueOrThrow
   */
  export type FacebookDirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter, which FacebookDirectMessage to fetch.
     */
    where: FacebookDirectMessageWhereUniqueInput
  }


  /**
   * FacebookDirectMessage base type for findFirst actions
   */
  export type FacebookDirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter, which FacebookDirectMessage to fetch.
     */
    where?: FacebookDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookDirectMessages to fetch.
     */
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookDirectMessages.
     */
    cursor?: FacebookDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookDirectMessages.
     */
    distinct?: Enumerable<FacebookDirectMessageScalarFieldEnum>
  }

  /**
   * FacebookDirectMessage findFirst
   */
  export interface FacebookDirectMessageFindFirstArgs extends FacebookDirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookDirectMessage findFirstOrThrow
   */
  export type FacebookDirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter, which FacebookDirectMessage to fetch.
     */
    where?: FacebookDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookDirectMessages to fetch.
     */
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookDirectMessages.
     */
    cursor?: FacebookDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookDirectMessages.
     */
    distinct?: Enumerable<FacebookDirectMessageScalarFieldEnum>
  }


  /**
   * FacebookDirectMessage findMany
   */
  export type FacebookDirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter, which FacebookDirectMessages to fetch.
     */
    where?: FacebookDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookDirectMessages to fetch.
     */
    orderBy?: Enumerable<FacebookDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookDirectMessages.
     */
    cursor?: FacebookDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookDirectMessages.
     */
    skip?: number
    distinct?: Enumerable<FacebookDirectMessageScalarFieldEnum>
  }


  /**
   * FacebookDirectMessage create
   */
  export type FacebookDirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * The data needed to create a FacebookDirectMessage.
     */
    data: XOR<FacebookDirectMessageCreateInput, FacebookDirectMessageUncheckedCreateInput>
  }


  /**
   * FacebookDirectMessage createMany
   */
  export type FacebookDirectMessageCreateManyArgs = {
    /**
     * The data used to create many FacebookDirectMessages.
     */
    data: Enumerable<FacebookDirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookDirectMessage update
   */
  export type FacebookDirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * The data needed to update a FacebookDirectMessage.
     */
    data: XOR<FacebookDirectMessageUpdateInput, FacebookDirectMessageUncheckedUpdateInput>
    /**
     * Choose, which FacebookDirectMessage to update.
     */
    where: FacebookDirectMessageWhereUniqueInput
  }


  /**
   * FacebookDirectMessage updateMany
   */
  export type FacebookDirectMessageUpdateManyArgs = {
    /**
     * The data used to update FacebookDirectMessages.
     */
    data: XOR<FacebookDirectMessageUpdateManyMutationInput, FacebookDirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which FacebookDirectMessages to update
     */
    where?: FacebookDirectMessageWhereInput
  }


  /**
   * FacebookDirectMessage upsert
   */
  export type FacebookDirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * The filter to search for the FacebookDirectMessage to update in case it exists.
     */
    where: FacebookDirectMessageWhereUniqueInput
    /**
     * In case the FacebookDirectMessage found by the `where` argument doesn't exist, create a new FacebookDirectMessage with this data.
     */
    create: XOR<FacebookDirectMessageCreateInput, FacebookDirectMessageUncheckedCreateInput>
    /**
     * In case the FacebookDirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookDirectMessageUpdateInput, FacebookDirectMessageUncheckedUpdateInput>
  }


  /**
   * FacebookDirectMessage delete
   */
  export type FacebookDirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
    /**
     * Filter which FacebookDirectMessage to delete.
     */
    where: FacebookDirectMessageWhereUniqueInput
  }


  /**
   * FacebookDirectMessage deleteMany
   */
  export type FacebookDirectMessageDeleteManyArgs = {
    /**
     * Filter which FacebookDirectMessages to delete
     */
    where?: FacebookDirectMessageWhereInput
  }


  /**
   * FacebookDirectMessage without action
   */
  export type FacebookDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the FacebookDirectMessage
     */
    select?: FacebookDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookDirectMessageInclude | null
  }



  /**
   * Model FacebookLocation
   */


  export type AggregateFacebookLocation = {
    _count: FacebookLocationCountAggregateOutputType | null
    _avg: FacebookLocationAvgAggregateOutputType | null
    _sum: FacebookLocationSumAggregateOutputType | null
    _min: FacebookLocationMinAggregateOutputType | null
    _max: FacebookLocationMaxAggregateOutputType | null
  }

  export type FacebookLocationAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookLocationSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookLocationMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookLocationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookLocationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookLocationAvgAggregateInputType = {
    id?: true
  }

  export type FacebookLocationSumAggregateInputType = {
    id?: true
  }

  export type FacebookLocationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookLocationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookLocationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookLocationAggregateArgs = {
    /**
     * Filter which FacebookLocation to aggregate.
     */
    where?: FacebookLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLocations to fetch.
     */
    orderBy?: Enumerable<FacebookLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookLocations
    **/
    _count?: true | FacebookLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookLocationMaxAggregateInputType
  }

  export type GetFacebookLocationAggregateType<T extends FacebookLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookLocation[P]>
      : GetScalarType<T[P], AggregateFacebookLocation[P]>
  }




  export type FacebookLocationGroupByArgs = {
    where?: FacebookLocationWhereInput
    orderBy?: Enumerable<FacebookLocationOrderByWithAggregationInput>
    by: FacebookLocationScalarFieldEnum[]
    having?: FacebookLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookLocationCountAggregateInputType | true
    _avg?: FacebookLocationAvgAggregateInputType
    _sum?: FacebookLocationSumAggregateInputType
    _min?: FacebookLocationMinAggregateInputType
    _max?: FacebookLocationMaxAggregateInputType
  }


  export type FacebookLocationGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookLocationCountAggregateOutputType | null
    _avg: FacebookLocationAvgAggregateOutputType | null
    _sum: FacebookLocationSumAggregateOutputType | null
    _min: FacebookLocationMinAggregateOutputType | null
    _max: FacebookLocationMaxAggregateOutputType | null
  }

  type GetFacebookLocationGroupByPayload<T extends FacebookLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookLocationGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookLocationGroupByOutputType[P]>
        }
      >
    >


  export type FacebookLocationSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | FacebookLocation$postsArgs
    _count?: boolean | FacebookLocationCountOutputTypeArgs
  }


  export type FacebookLocationInclude = {
    posts?: boolean | FacebookLocation$postsArgs
    _count?: boolean | FacebookLocationCountOutputTypeArgs
  }

  export type FacebookLocationGetPayload<S extends boolean | null | undefined | FacebookLocationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookLocation :
    S extends undefined ? never :
    S extends { include: any } & (FacebookLocationArgs | FacebookLocationFindManyArgs)
    ? FacebookLocation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < FacebookPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookLocationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookLocationArgs | FacebookLocationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < FacebookPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookLocationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookLocation ? FacebookLocation[P] : never
  } 
      : FacebookLocation


  type FacebookLocationCountArgs = 
    Omit<FacebookLocationFindManyArgs, 'select' | 'include'> & {
      select?: FacebookLocationCountAggregateInputType | true
    }

  export interface FacebookLocationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookLocation that matches the filter.
     * @param {FacebookLocationFindUniqueArgs} args - Arguments to find a FacebookLocation
     * @example
     * // Get one FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookLocationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookLocationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookLocation'> extends True ? Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>> : Prisma__FacebookLocationClient<FacebookLocationGetPayload<T> | null, null>

    /**
     * Find one FacebookLocation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookLocationFindUniqueOrThrowArgs} args - Arguments to find a FacebookLocation
     * @example
     * // Get one FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookLocationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookLocationFindUniqueOrThrowArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Find the first FacebookLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationFindFirstArgs} args - Arguments to find a FacebookLocation
     * @example
     * // Get one FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookLocationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookLocationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookLocation'> extends True ? Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>> : Prisma__FacebookLocationClient<FacebookLocationGetPayload<T> | null, null>

    /**
     * Find the first FacebookLocation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationFindFirstOrThrowArgs} args - Arguments to find a FacebookLocation
     * @example
     * // Get one FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookLocationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookLocationFindFirstOrThrowArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Find zero or more FacebookLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookLocations
     * const facebookLocations = await prisma.facebookLocation.findMany()
     * 
     * // Get first 10 FacebookLocations
     * const facebookLocations = await prisma.facebookLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookLocationWithIdOnly = await prisma.facebookLocation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookLocationFindManyArgs>(
      args?: SelectSubset<T, FacebookLocationFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookLocationGetPayload<T>>>

    /**
     * Create a FacebookLocation.
     * @param {FacebookLocationCreateArgs} args - Arguments to create a FacebookLocation.
     * @example
     * // Create one FacebookLocation
     * const FacebookLocation = await prisma.facebookLocation.create({
     *   data: {
     *     // ... data to create a FacebookLocation
     *   }
     * })
     * 
    **/
    create<T extends FacebookLocationCreateArgs>(
      args: SelectSubset<T, FacebookLocationCreateArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Create many FacebookLocations.
     *     @param {FacebookLocationCreateManyArgs} args - Arguments to create many FacebookLocations.
     *     @example
     *     // Create many FacebookLocations
     *     const facebookLocation = await prisma.facebookLocation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookLocationCreateManyArgs>(
      args?: SelectSubset<T, FacebookLocationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookLocation.
     * @param {FacebookLocationDeleteArgs} args - Arguments to delete one FacebookLocation.
     * @example
     * // Delete one FacebookLocation
     * const FacebookLocation = await prisma.facebookLocation.delete({
     *   where: {
     *     // ... filter to delete one FacebookLocation
     *   }
     * })
     * 
    **/
    delete<T extends FacebookLocationDeleteArgs>(
      args: SelectSubset<T, FacebookLocationDeleteArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Update one FacebookLocation.
     * @param {FacebookLocationUpdateArgs} args - Arguments to update one FacebookLocation.
     * @example
     * // Update one FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookLocationUpdateArgs>(
      args: SelectSubset<T, FacebookLocationUpdateArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Delete zero or more FacebookLocations.
     * @param {FacebookLocationDeleteManyArgs} args - Arguments to filter FacebookLocations to delete.
     * @example
     * // Delete a few FacebookLocations
     * const { count } = await prisma.facebookLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookLocationDeleteManyArgs>(
      args?: SelectSubset<T, FacebookLocationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookLocations
     * const facebookLocation = await prisma.facebookLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookLocationUpdateManyArgs>(
      args: SelectSubset<T, FacebookLocationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookLocation.
     * @param {FacebookLocationUpsertArgs} args - Arguments to update or create a FacebookLocation.
     * @example
     * // Update or create a FacebookLocation
     * const facebookLocation = await prisma.facebookLocation.upsert({
     *   create: {
     *     // ... data to create a FacebookLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookLocation we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookLocationUpsertArgs>(
      args: SelectSubset<T, FacebookLocationUpsertArgs>
    ): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T>>

    /**
     * Count the number of FacebookLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationCountArgs} args - Arguments to filter FacebookLocations to count.
     * @example
     * // Count the number of FacebookLocations
     * const count = await prisma.facebookLocation.count({
     *   where: {
     *     // ... the filter for the FacebookLocations we want to count
     *   }
     * })
    **/
    count<T extends FacebookLocationCountArgs>(
      args?: Subset<T, FacebookLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookLocationAggregateArgs>(args: Subset<T, FacebookLocationAggregateArgs>): Prisma.PrismaPromise<GetFacebookLocationAggregateType<T>>

    /**
     * Group by FacebookLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookLocationGroupByArgs['orderBy'] }
        : { orderBy?: FacebookLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookLocationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends FacebookLocation$postsArgs= {}>(args?: Subset<T, FacebookLocation$postsArgs>): Prisma.PrismaPromise<Array<FacebookPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookLocation base type for findUnique actions
   */
  export type FacebookLocationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter, which FacebookLocation to fetch.
     */
    where: FacebookLocationWhereUniqueInput
  }

  /**
   * FacebookLocation findUnique
   */
  export interface FacebookLocationFindUniqueArgs extends FacebookLocationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookLocation findUniqueOrThrow
   */
  export type FacebookLocationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter, which FacebookLocation to fetch.
     */
    where: FacebookLocationWhereUniqueInput
  }


  /**
   * FacebookLocation base type for findFirst actions
   */
  export type FacebookLocationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter, which FacebookLocation to fetch.
     */
    where?: FacebookLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLocations to fetch.
     */
    orderBy?: Enumerable<FacebookLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookLocations.
     */
    cursor?: FacebookLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookLocations.
     */
    distinct?: Enumerable<FacebookLocationScalarFieldEnum>
  }

  /**
   * FacebookLocation findFirst
   */
  export interface FacebookLocationFindFirstArgs extends FacebookLocationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookLocation findFirstOrThrow
   */
  export type FacebookLocationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter, which FacebookLocation to fetch.
     */
    where?: FacebookLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLocations to fetch.
     */
    orderBy?: Enumerable<FacebookLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookLocations.
     */
    cursor?: FacebookLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookLocations.
     */
    distinct?: Enumerable<FacebookLocationScalarFieldEnum>
  }


  /**
   * FacebookLocation findMany
   */
  export type FacebookLocationFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter, which FacebookLocations to fetch.
     */
    where?: FacebookLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLocations to fetch.
     */
    orderBy?: Enumerable<FacebookLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookLocations.
     */
    cursor?: FacebookLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLocations.
     */
    skip?: number
    distinct?: Enumerable<FacebookLocationScalarFieldEnum>
  }


  /**
   * FacebookLocation create
   */
  export type FacebookLocationCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * The data needed to create a FacebookLocation.
     */
    data: XOR<FacebookLocationCreateInput, FacebookLocationUncheckedCreateInput>
  }


  /**
   * FacebookLocation createMany
   */
  export type FacebookLocationCreateManyArgs = {
    /**
     * The data used to create many FacebookLocations.
     */
    data: Enumerable<FacebookLocationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookLocation update
   */
  export type FacebookLocationUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * The data needed to update a FacebookLocation.
     */
    data: XOR<FacebookLocationUpdateInput, FacebookLocationUncheckedUpdateInput>
    /**
     * Choose, which FacebookLocation to update.
     */
    where: FacebookLocationWhereUniqueInput
  }


  /**
   * FacebookLocation updateMany
   */
  export type FacebookLocationUpdateManyArgs = {
    /**
     * The data used to update FacebookLocations.
     */
    data: XOR<FacebookLocationUpdateManyMutationInput, FacebookLocationUncheckedUpdateManyInput>
    /**
     * Filter which FacebookLocations to update
     */
    where?: FacebookLocationWhereInput
  }


  /**
   * FacebookLocation upsert
   */
  export type FacebookLocationUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * The filter to search for the FacebookLocation to update in case it exists.
     */
    where: FacebookLocationWhereUniqueInput
    /**
     * In case the FacebookLocation found by the `where` argument doesn't exist, create a new FacebookLocation with this data.
     */
    create: XOR<FacebookLocationCreateInput, FacebookLocationUncheckedCreateInput>
    /**
     * In case the FacebookLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookLocationUpdateInput, FacebookLocationUncheckedUpdateInput>
  }


  /**
   * FacebookLocation delete
   */
  export type FacebookLocationDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
    /**
     * Filter which FacebookLocation to delete.
     */
    where: FacebookLocationWhereUniqueInput
  }


  /**
   * FacebookLocation deleteMany
   */
  export type FacebookLocationDeleteManyArgs = {
    /**
     * Filter which FacebookLocations to delete
     */
    where?: FacebookLocationWhereInput
  }


  /**
   * FacebookLocation.posts
   */
  export type FacebookLocation$postsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    where?: FacebookPostWhereInput
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    cursor?: FacebookPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookLocation without action
   */
  export type FacebookLocationArgs = {
    /**
     * Select specific fields to fetch from the FacebookLocation
     */
    select?: FacebookLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLocationInclude | null
  }



  /**
   * Model FacebookHashtag
   */


  export type AggregateFacebookHashtag = {
    _count: FacebookHashtagCountAggregateOutputType | null
    _avg: FacebookHashtagAvgAggregateOutputType | null
    _sum: FacebookHashtagSumAggregateOutputType | null
    _min: FacebookHashtagMinAggregateOutputType | null
    _max: FacebookHashtagMaxAggregateOutputType | null
  }

  export type FacebookHashtagAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashtagSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookHashtagMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashtagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookHashtagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookHashtagAvgAggregateInputType = {
    id?: true
  }

  export type FacebookHashtagSumAggregateInputType = {
    id?: true
  }

  export type FacebookHashtagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashtagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookHashtagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookHashtagAggregateArgs = {
    /**
     * Filter which FacebookHashtag to aggregate.
     */
    where?: FacebookHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashtags to fetch.
     */
    orderBy?: Enumerable<FacebookHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookHashtags
    **/
    _count?: true | FacebookHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookHashtagMaxAggregateInputType
  }

  export type GetFacebookHashtagAggregateType<T extends FacebookHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookHashtag[P]>
      : GetScalarType<T[P], AggregateFacebookHashtag[P]>
  }




  export type FacebookHashtagGroupByArgs = {
    where?: FacebookHashtagWhereInput
    orderBy?: Enumerable<FacebookHashtagOrderByWithAggregationInput>
    by: FacebookHashtagScalarFieldEnum[]
    having?: FacebookHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookHashtagCountAggregateInputType | true
    _avg?: FacebookHashtagAvgAggregateInputType
    _sum?: FacebookHashtagSumAggregateInputType
    _min?: FacebookHashtagMinAggregateInputType
    _max?: FacebookHashtagMaxAggregateInputType
  }


  export type FacebookHashtagGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookHashtagCountAggregateOutputType | null
    _avg: FacebookHashtagAvgAggregateOutputType | null
    _sum: FacebookHashtagSumAggregateOutputType | null
    _min: FacebookHashtagMinAggregateOutputType | null
    _max: FacebookHashtagMaxAggregateOutputType | null
  }

  type GetFacebookHashtagGroupByPayload<T extends FacebookHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookHashtagGroupByOutputType[P]>
        }
      >
    >


  export type FacebookHashtagSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | FacebookHashtag$postsArgs
    _count?: boolean | FacebookHashtagCountOutputTypeArgs
  }


  export type FacebookHashtagInclude = {
    posts?: boolean | FacebookHashtag$postsArgs
    _count?: boolean | FacebookHashtagCountOutputTypeArgs
  }

  export type FacebookHashtagGetPayload<S extends boolean | null | undefined | FacebookHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookHashtag :
    S extends undefined ? never :
    S extends { include: any } & (FacebookHashtagArgs | FacebookHashtagFindManyArgs)
    ? FacebookHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < FacebookPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookHashtagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookHashtagArgs | FacebookHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < FacebookPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookHashtagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookHashtag ? FacebookHashtag[P] : never
  } 
      : FacebookHashtag


  type FacebookHashtagCountArgs = 
    Omit<FacebookHashtagFindManyArgs, 'select' | 'include'> & {
      select?: FacebookHashtagCountAggregateInputType | true
    }

  export interface FacebookHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookHashtag that matches the filter.
     * @param {FacebookHashtagFindUniqueArgs} args - Arguments to find a FacebookHashtag
     * @example
     * // Get one FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookHashtag'> extends True ? Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>> : Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T> | null, null>

    /**
     * Find one FacebookHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookHashtagFindUniqueOrThrowArgs} args - Arguments to find a FacebookHashtag
     * @example
     * // Get one FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashtagFindUniqueOrThrowArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Find the first FacebookHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagFindFirstArgs} args - Arguments to find a FacebookHashtag
     * @example
     * // Get one FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookHashtag'> extends True ? Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>> : Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T> | null, null>

    /**
     * Find the first FacebookHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagFindFirstOrThrowArgs} args - Arguments to find a FacebookHashtag
     * @example
     * // Get one FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookHashtagFindFirstOrThrowArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Find zero or more FacebookHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookHashtags
     * const facebookHashtags = await prisma.facebookHashtag.findMany()
     * 
     * // Get first 10 FacebookHashtags
     * const facebookHashtags = await prisma.facebookHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookHashtagWithIdOnly = await prisma.facebookHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookHashtagFindManyArgs>(
      args?: SelectSubset<T, FacebookHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookHashtagGetPayload<T>>>

    /**
     * Create a FacebookHashtag.
     * @param {FacebookHashtagCreateArgs} args - Arguments to create a FacebookHashtag.
     * @example
     * // Create one FacebookHashtag
     * const FacebookHashtag = await prisma.facebookHashtag.create({
     *   data: {
     *     // ... data to create a FacebookHashtag
     *   }
     * })
     * 
    **/
    create<T extends FacebookHashtagCreateArgs>(
      args: SelectSubset<T, FacebookHashtagCreateArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Create many FacebookHashtags.
     *     @param {FacebookHashtagCreateManyArgs} args - Arguments to create many FacebookHashtags.
     *     @example
     *     // Create many FacebookHashtags
     *     const facebookHashtag = await prisma.facebookHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookHashtagCreateManyArgs>(
      args?: SelectSubset<T, FacebookHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookHashtag.
     * @param {FacebookHashtagDeleteArgs} args - Arguments to delete one FacebookHashtag.
     * @example
     * // Delete one FacebookHashtag
     * const FacebookHashtag = await prisma.facebookHashtag.delete({
     *   where: {
     *     // ... filter to delete one FacebookHashtag
     *   }
     * })
     * 
    **/
    delete<T extends FacebookHashtagDeleteArgs>(
      args: SelectSubset<T, FacebookHashtagDeleteArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Update one FacebookHashtag.
     * @param {FacebookHashtagUpdateArgs} args - Arguments to update one FacebookHashtag.
     * @example
     * // Update one FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookHashtagUpdateArgs>(
      args: SelectSubset<T, FacebookHashtagUpdateArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Delete zero or more FacebookHashtags.
     * @param {FacebookHashtagDeleteManyArgs} args - Arguments to filter FacebookHashtags to delete.
     * @example
     * // Delete a few FacebookHashtags
     * const { count } = await prisma.facebookHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookHashtagDeleteManyArgs>(
      args?: SelectSubset<T, FacebookHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookHashtags
     * const facebookHashtag = await prisma.facebookHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookHashtagUpdateManyArgs>(
      args: SelectSubset<T, FacebookHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookHashtag.
     * @param {FacebookHashtagUpsertArgs} args - Arguments to update or create a FacebookHashtag.
     * @example
     * // Update or create a FacebookHashtag
     * const facebookHashtag = await prisma.facebookHashtag.upsert({
     *   create: {
     *     // ... data to create a FacebookHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookHashtagUpsertArgs>(
      args: SelectSubset<T, FacebookHashtagUpsertArgs>
    ): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T>>

    /**
     * Count the number of FacebookHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagCountArgs} args - Arguments to filter FacebookHashtags to count.
     * @example
     * // Count the number of FacebookHashtags
     * const count = await prisma.facebookHashtag.count({
     *   where: {
     *     // ... the filter for the FacebookHashtags we want to count
     *   }
     * })
    **/
    count<T extends FacebookHashtagCountArgs>(
      args?: Subset<T, FacebookHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookHashtagAggregateArgs>(args: Subset<T, FacebookHashtagAggregateArgs>): Prisma.PrismaPromise<GetFacebookHashtagAggregateType<T>>

    /**
     * Group by FacebookHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookHashtagGroupByArgs['orderBy'] }
        : { orderBy?: FacebookHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends FacebookHashtag$postsArgs= {}>(args?: Subset<T, FacebookHashtag$postsArgs>): Prisma.PrismaPromise<Array<FacebookPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookHashtag base type for findUnique actions
   */
  export type FacebookHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter, which FacebookHashtag to fetch.
     */
    where: FacebookHashtagWhereUniqueInput
  }

  /**
   * FacebookHashtag findUnique
   */
  export interface FacebookHashtagFindUniqueArgs extends FacebookHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashtag findUniqueOrThrow
   */
  export type FacebookHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter, which FacebookHashtag to fetch.
     */
    where: FacebookHashtagWhereUniqueInput
  }


  /**
   * FacebookHashtag base type for findFirst actions
   */
  export type FacebookHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter, which FacebookHashtag to fetch.
     */
    where?: FacebookHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashtags to fetch.
     */
    orderBy?: Enumerable<FacebookHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashtags.
     */
    cursor?: FacebookHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashtags.
     */
    distinct?: Enumerable<FacebookHashtagScalarFieldEnum>
  }

  /**
   * FacebookHashtag findFirst
   */
  export interface FacebookHashtagFindFirstArgs extends FacebookHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookHashtag findFirstOrThrow
   */
  export type FacebookHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter, which FacebookHashtag to fetch.
     */
    where?: FacebookHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashtags to fetch.
     */
    orderBy?: Enumerable<FacebookHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookHashtags.
     */
    cursor?: FacebookHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookHashtags.
     */
    distinct?: Enumerable<FacebookHashtagScalarFieldEnum>
  }


  /**
   * FacebookHashtag findMany
   */
  export type FacebookHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter, which FacebookHashtags to fetch.
     */
    where?: FacebookHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookHashtags to fetch.
     */
    orderBy?: Enumerable<FacebookHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookHashtags.
     */
    cursor?: FacebookHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookHashtags.
     */
    skip?: number
    distinct?: Enumerable<FacebookHashtagScalarFieldEnum>
  }


  /**
   * FacebookHashtag create
   */
  export type FacebookHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * The data needed to create a FacebookHashtag.
     */
    data: XOR<FacebookHashtagCreateInput, FacebookHashtagUncheckedCreateInput>
  }


  /**
   * FacebookHashtag createMany
   */
  export type FacebookHashtagCreateManyArgs = {
    /**
     * The data used to create many FacebookHashtags.
     */
    data: Enumerable<FacebookHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookHashtag update
   */
  export type FacebookHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * The data needed to update a FacebookHashtag.
     */
    data: XOR<FacebookHashtagUpdateInput, FacebookHashtagUncheckedUpdateInput>
    /**
     * Choose, which FacebookHashtag to update.
     */
    where: FacebookHashtagWhereUniqueInput
  }


  /**
   * FacebookHashtag updateMany
   */
  export type FacebookHashtagUpdateManyArgs = {
    /**
     * The data used to update FacebookHashtags.
     */
    data: XOR<FacebookHashtagUpdateManyMutationInput, FacebookHashtagUncheckedUpdateManyInput>
    /**
     * Filter which FacebookHashtags to update
     */
    where?: FacebookHashtagWhereInput
  }


  /**
   * FacebookHashtag upsert
   */
  export type FacebookHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * The filter to search for the FacebookHashtag to update in case it exists.
     */
    where: FacebookHashtagWhereUniqueInput
    /**
     * In case the FacebookHashtag found by the `where` argument doesn't exist, create a new FacebookHashtag with this data.
     */
    create: XOR<FacebookHashtagCreateInput, FacebookHashtagUncheckedCreateInput>
    /**
     * In case the FacebookHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookHashtagUpdateInput, FacebookHashtagUncheckedUpdateInput>
  }


  /**
   * FacebookHashtag delete
   */
  export type FacebookHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
    /**
     * Filter which FacebookHashtag to delete.
     */
    where: FacebookHashtagWhereUniqueInput
  }


  /**
   * FacebookHashtag deleteMany
   */
  export type FacebookHashtagDeleteManyArgs = {
    /**
     * Filter which FacebookHashtags to delete
     */
    where?: FacebookHashtagWhereInput
  }


  /**
   * FacebookHashtag.posts
   */
  export type FacebookHashtag$postsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    where?: FacebookPostWhereInput
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    cursor?: FacebookPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookHashtag without action
   */
  export type FacebookHashtagArgs = {
    /**
     * Select specific fields to fetch from the FacebookHashtag
     */
    select?: FacebookHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookHashtagInclude | null
  }



  /**
   * Model FacebookLike
   */


  export type AggregateFacebookLike = {
    _count: FacebookLikeCountAggregateOutputType | null
    _avg: FacebookLikeAvgAggregateOutputType | null
    _sum: FacebookLikeSumAggregateOutputType | null
    _min: FacebookLikeMinAggregateOutputType | null
    _max: FacebookLikeMaxAggregateOutputType | null
  }

  export type FacebookLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type FacebookLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type FacebookLikeMinAggregateOutputType = {
    id: number | null
    type: FacebookLikeTypeEnum | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookLikeMaxAggregateOutputType = {
    id: number | null
    type: FacebookLikeTypeEnum | null
    userId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookLikeCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type FacebookLikeSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type FacebookLikeMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookLikeMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookLikeCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookLikeAggregateArgs = {
    /**
     * Filter which FacebookLike to aggregate.
     */
    where?: FacebookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLikes to fetch.
     */
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookLikes
    **/
    _count?: true | FacebookLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookLikeMaxAggregateInputType
  }

  export type GetFacebookLikeAggregateType<T extends FacebookLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookLike[P]>
      : GetScalarType<T[P], AggregateFacebookLike[P]>
  }




  export type FacebookLikeGroupByArgs = {
    where?: FacebookLikeWhereInput
    orderBy?: Enumerable<FacebookLikeOrderByWithAggregationInput>
    by: FacebookLikeScalarFieldEnum[]
    having?: FacebookLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookLikeCountAggregateInputType | true
    _avg?: FacebookLikeAvgAggregateInputType
    _sum?: FacebookLikeSumAggregateInputType
    _min?: FacebookLikeMinAggregateInputType
    _max?: FacebookLikeMaxAggregateInputType
  }


  export type FacebookLikeGroupByOutputType = {
    id: number
    type: FacebookLikeTypeEnum
    userId: number
    postId: number | null
    createdAt: Date
    updatedAt: Date
    _count: FacebookLikeCountAggregateOutputType | null
    _avg: FacebookLikeAvgAggregateOutputType | null
    _sum: FacebookLikeSumAggregateOutputType | null
    _min: FacebookLikeMinAggregateOutputType | null
    _max: FacebookLikeMaxAggregateOutputType | null
  }

  type GetFacebookLikeGroupByPayload<T extends FacebookLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookLikeGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookLikeGroupByOutputType[P]>
        }
      >
    >


  export type FacebookLikeSelect = {
    id?: boolean
    type?: boolean
    user?: boolean | FacebookUserArgs
    userId?: boolean
    posts?: boolean | FacebookPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookLikeInclude = {
    user?: boolean | FacebookUserArgs
    posts?: boolean | FacebookPostArgs
  }

  export type FacebookLikeGetPayload<S extends boolean | null | undefined | FacebookLikeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookLike :
    S extends undefined ? never :
    S extends { include: any } & (FacebookLikeArgs | FacebookLikeFindManyArgs)
    ? FacebookLike  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'posts' ? FacebookPostGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (FacebookLikeArgs | FacebookLikeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'posts' ? FacebookPostGetPayload<S['select'][P]> | null :  P extends keyof FacebookLike ? FacebookLike[P] : never
  } 
      : FacebookLike


  type FacebookLikeCountArgs = 
    Omit<FacebookLikeFindManyArgs, 'select' | 'include'> & {
      select?: FacebookLikeCountAggregateInputType | true
    }

  export interface FacebookLikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookLike that matches the filter.
     * @param {FacebookLikeFindUniqueArgs} args - Arguments to find a FacebookLike
     * @example
     * // Get one FacebookLike
     * const facebookLike = await prisma.facebookLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookLike'> extends True ? Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>> : Prisma__FacebookLikeClient<FacebookLikeGetPayload<T> | null, null>

    /**
     * Find one FacebookLike that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookLikeFindUniqueOrThrowArgs} args - Arguments to find a FacebookLike
     * @example
     * // Get one FacebookLike
     * const facebookLike = await prisma.facebookLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookLikeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookLikeFindUniqueOrThrowArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Find the first FacebookLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeFindFirstArgs} args - Arguments to find a FacebookLike
     * @example
     * // Get one FacebookLike
     * const facebookLike = await prisma.facebookLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookLike'> extends True ? Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>> : Prisma__FacebookLikeClient<FacebookLikeGetPayload<T> | null, null>

    /**
     * Find the first FacebookLike that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeFindFirstOrThrowArgs} args - Arguments to find a FacebookLike
     * @example
     * // Get one FacebookLike
     * const facebookLike = await prisma.facebookLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookLikeFindFirstOrThrowArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Find zero or more FacebookLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookLikes
     * const facebookLikes = await prisma.facebookLike.findMany()
     * 
     * // Get first 10 FacebookLikes
     * const facebookLikes = await prisma.facebookLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookLikeWithIdOnly = await prisma.facebookLike.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookLikeFindManyArgs>(
      args?: SelectSubset<T, FacebookLikeFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookLikeGetPayload<T>>>

    /**
     * Create a FacebookLike.
     * @param {FacebookLikeCreateArgs} args - Arguments to create a FacebookLike.
     * @example
     * // Create one FacebookLike
     * const FacebookLike = await prisma.facebookLike.create({
     *   data: {
     *     // ... data to create a FacebookLike
     *   }
     * })
     * 
    **/
    create<T extends FacebookLikeCreateArgs>(
      args: SelectSubset<T, FacebookLikeCreateArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Create many FacebookLikes.
     *     @param {FacebookLikeCreateManyArgs} args - Arguments to create many FacebookLikes.
     *     @example
     *     // Create many FacebookLikes
     *     const facebookLike = await prisma.facebookLike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookLikeCreateManyArgs>(
      args?: SelectSubset<T, FacebookLikeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookLike.
     * @param {FacebookLikeDeleteArgs} args - Arguments to delete one FacebookLike.
     * @example
     * // Delete one FacebookLike
     * const FacebookLike = await prisma.facebookLike.delete({
     *   where: {
     *     // ... filter to delete one FacebookLike
     *   }
     * })
     * 
    **/
    delete<T extends FacebookLikeDeleteArgs>(
      args: SelectSubset<T, FacebookLikeDeleteArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Update one FacebookLike.
     * @param {FacebookLikeUpdateArgs} args - Arguments to update one FacebookLike.
     * @example
     * // Update one FacebookLike
     * const facebookLike = await prisma.facebookLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookLikeUpdateArgs>(
      args: SelectSubset<T, FacebookLikeUpdateArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Delete zero or more FacebookLikes.
     * @param {FacebookLikeDeleteManyArgs} args - Arguments to filter FacebookLikes to delete.
     * @example
     * // Delete a few FacebookLikes
     * const { count } = await prisma.facebookLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookLikeDeleteManyArgs>(
      args?: SelectSubset<T, FacebookLikeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookLikes
     * const facebookLike = await prisma.facebookLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookLikeUpdateManyArgs>(
      args: SelectSubset<T, FacebookLikeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookLike.
     * @param {FacebookLikeUpsertArgs} args - Arguments to update or create a FacebookLike.
     * @example
     * // Update or create a FacebookLike
     * const facebookLike = await prisma.facebookLike.upsert({
     *   create: {
     *     // ... data to create a FacebookLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookLike we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookLikeUpsertArgs>(
      args: SelectSubset<T, FacebookLikeUpsertArgs>
    ): Prisma__FacebookLikeClient<FacebookLikeGetPayload<T>>

    /**
     * Count the number of FacebookLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeCountArgs} args - Arguments to filter FacebookLikes to count.
     * @example
     * // Count the number of FacebookLikes
     * const count = await prisma.facebookLike.count({
     *   where: {
     *     // ... the filter for the FacebookLikes we want to count
     *   }
     * })
    **/
    count<T extends FacebookLikeCountArgs>(
      args?: Subset<T, FacebookLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookLikeAggregateArgs>(args: Subset<T, FacebookLikeAggregateArgs>): Prisma.PrismaPromise<GetFacebookLikeAggregateType<T>>

    /**
     * Group by FacebookLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookLikeGroupByArgs['orderBy'] }
        : { orderBy?: FacebookLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookLikeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    posts<T extends FacebookPostArgs= {}>(args?: Subset<T, FacebookPostArgs>): Prisma__FacebookPostClient<FacebookPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookLike base type for findUnique actions
   */
  export type FacebookLikeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter, which FacebookLike to fetch.
     */
    where: FacebookLikeWhereUniqueInput
  }

  /**
   * FacebookLike findUnique
   */
  export interface FacebookLikeFindUniqueArgs extends FacebookLikeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookLike findUniqueOrThrow
   */
  export type FacebookLikeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter, which FacebookLike to fetch.
     */
    where: FacebookLikeWhereUniqueInput
  }


  /**
   * FacebookLike base type for findFirst actions
   */
  export type FacebookLikeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter, which FacebookLike to fetch.
     */
    where?: FacebookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLikes to fetch.
     */
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookLikes.
     */
    cursor?: FacebookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookLikes.
     */
    distinct?: Enumerable<FacebookLikeScalarFieldEnum>
  }

  /**
   * FacebookLike findFirst
   */
  export interface FacebookLikeFindFirstArgs extends FacebookLikeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookLike findFirstOrThrow
   */
  export type FacebookLikeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter, which FacebookLike to fetch.
     */
    where?: FacebookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLikes to fetch.
     */
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookLikes.
     */
    cursor?: FacebookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookLikes.
     */
    distinct?: Enumerable<FacebookLikeScalarFieldEnum>
  }


  /**
   * FacebookLike findMany
   */
  export type FacebookLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter, which FacebookLikes to fetch.
     */
    where?: FacebookLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookLikes to fetch.
     */
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookLikes.
     */
    cursor?: FacebookLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookLikes.
     */
    skip?: number
    distinct?: Enumerable<FacebookLikeScalarFieldEnum>
  }


  /**
   * FacebookLike create
   */
  export type FacebookLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * The data needed to create a FacebookLike.
     */
    data: XOR<FacebookLikeCreateInput, FacebookLikeUncheckedCreateInput>
  }


  /**
   * FacebookLike createMany
   */
  export type FacebookLikeCreateManyArgs = {
    /**
     * The data used to create many FacebookLikes.
     */
    data: Enumerable<FacebookLikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookLike update
   */
  export type FacebookLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * The data needed to update a FacebookLike.
     */
    data: XOR<FacebookLikeUpdateInput, FacebookLikeUncheckedUpdateInput>
    /**
     * Choose, which FacebookLike to update.
     */
    where: FacebookLikeWhereUniqueInput
  }


  /**
   * FacebookLike updateMany
   */
  export type FacebookLikeUpdateManyArgs = {
    /**
     * The data used to update FacebookLikes.
     */
    data: XOR<FacebookLikeUpdateManyMutationInput, FacebookLikeUncheckedUpdateManyInput>
    /**
     * Filter which FacebookLikes to update
     */
    where?: FacebookLikeWhereInput
  }


  /**
   * FacebookLike upsert
   */
  export type FacebookLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * The filter to search for the FacebookLike to update in case it exists.
     */
    where: FacebookLikeWhereUniqueInput
    /**
     * In case the FacebookLike found by the `where` argument doesn't exist, create a new FacebookLike with this data.
     */
    create: XOR<FacebookLikeCreateInput, FacebookLikeUncheckedCreateInput>
    /**
     * In case the FacebookLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookLikeUpdateInput, FacebookLikeUncheckedUpdateInput>
  }


  /**
   * FacebookLike delete
   */
  export type FacebookLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    /**
     * Filter which FacebookLike to delete.
     */
    where: FacebookLikeWhereUniqueInput
  }


  /**
   * FacebookLike deleteMany
   */
  export type FacebookLikeDeleteManyArgs = {
    /**
     * Filter which FacebookLikes to delete
     */
    where?: FacebookLikeWhereInput
  }


  /**
   * FacebookLike without action
   */
  export type FacebookLikeArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
  }



  /**
   * Model FacebookShareType
   */


  export type AggregateFacebookShareType = {
    _count: FacebookShareTypeCountAggregateOutputType | null
    _avg: FacebookShareTypeAvgAggregateOutputType | null
    _sum: FacebookShareTypeSumAggregateOutputType | null
    _min: FacebookShareTypeMinAggregateOutputType | null
    _max: FacebookShareTypeMaxAggregateOutputType | null
  }

  export type FacebookShareTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookShareTypeSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookShareTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookShareTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookShareTypeCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookShareTypeAvgAggregateInputType = {
    id?: true
  }

  export type FacebookShareTypeSumAggregateInputType = {
    id?: true
  }

  export type FacebookShareTypeMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookShareTypeMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookShareTypeCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookShareTypeAggregateArgs = {
    /**
     * Filter which FacebookShareType to aggregate.
     */
    where?: FacebookShareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookShareTypes to fetch.
     */
    orderBy?: Enumerable<FacebookShareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookShareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookShareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookShareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookShareTypes
    **/
    _count?: true | FacebookShareTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookShareTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookShareTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookShareTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookShareTypeMaxAggregateInputType
  }

  export type GetFacebookShareTypeAggregateType<T extends FacebookShareTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookShareType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookShareType[P]>
      : GetScalarType<T[P], AggregateFacebookShareType[P]>
  }




  export type FacebookShareTypeGroupByArgs = {
    where?: FacebookShareTypeWhereInput
    orderBy?: Enumerable<FacebookShareTypeOrderByWithAggregationInput>
    by: FacebookShareTypeScalarFieldEnum[]
    having?: FacebookShareTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookShareTypeCountAggregateInputType | true
    _avg?: FacebookShareTypeAvgAggregateInputType
    _sum?: FacebookShareTypeSumAggregateInputType
    _min?: FacebookShareTypeMinAggregateInputType
    _max?: FacebookShareTypeMaxAggregateInputType
  }


  export type FacebookShareTypeGroupByOutputType = {
    id: number
    type: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookShareTypeCountAggregateOutputType | null
    _avg: FacebookShareTypeAvgAggregateOutputType | null
    _sum: FacebookShareTypeSumAggregateOutputType | null
    _min: FacebookShareTypeMinAggregateOutputType | null
    _max: FacebookShareTypeMaxAggregateOutputType | null
  }

  type GetFacebookShareTypeGroupByPayload<T extends FacebookShareTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookShareTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookShareTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookShareTypeGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookShareTypeGroupByOutputType[P]>
        }
      >
    >


  export type FacebookShareTypeSelect = {
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commentPosts?: boolean | FacebookShareType$commentPostsArgs
    posts?: boolean | FacebookShareType$postsArgs
    _count?: boolean | FacebookShareTypeCountOutputTypeArgs
  }


  export type FacebookShareTypeInclude = {
    commentPosts?: boolean | FacebookShareType$commentPostsArgs
    posts?: boolean | FacebookShareType$postsArgs
    _count?: boolean | FacebookShareTypeCountOutputTypeArgs
  }

  export type FacebookShareTypeGetPayload<S extends boolean | null | undefined | FacebookShareTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookShareType :
    S extends undefined ? never :
    S extends { include: any } & (FacebookShareTypeArgs | FacebookShareTypeFindManyArgs)
    ? FacebookShareType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['include'][P]>>  :
        P extends 'posts' ? Array < FacebookPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookShareTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookShareTypeArgs | FacebookShareTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['select'][P]>>  :
        P extends 'posts' ? Array < FacebookPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookShareTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookShareType ? FacebookShareType[P] : never
  } 
      : FacebookShareType


  type FacebookShareTypeCountArgs = 
    Omit<FacebookShareTypeFindManyArgs, 'select' | 'include'> & {
      select?: FacebookShareTypeCountAggregateInputType | true
    }

  export interface FacebookShareTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookShareType that matches the filter.
     * @param {FacebookShareTypeFindUniqueArgs} args - Arguments to find a FacebookShareType
     * @example
     * // Get one FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookShareTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookShareTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookShareType'> extends True ? Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>> : Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T> | null, null>

    /**
     * Find one FacebookShareType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookShareTypeFindUniqueOrThrowArgs} args - Arguments to find a FacebookShareType
     * @example
     * // Get one FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookShareTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookShareTypeFindUniqueOrThrowArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Find the first FacebookShareType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeFindFirstArgs} args - Arguments to find a FacebookShareType
     * @example
     * // Get one FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookShareTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookShareTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookShareType'> extends True ? Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>> : Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T> | null, null>

    /**
     * Find the first FacebookShareType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeFindFirstOrThrowArgs} args - Arguments to find a FacebookShareType
     * @example
     * // Get one FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookShareTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookShareTypeFindFirstOrThrowArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Find zero or more FacebookShareTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookShareTypes
     * const facebookShareTypes = await prisma.facebookShareType.findMany()
     * 
     * // Get first 10 FacebookShareTypes
     * const facebookShareTypes = await prisma.facebookShareType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookShareTypeWithIdOnly = await prisma.facebookShareType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookShareTypeFindManyArgs>(
      args?: SelectSubset<T, FacebookShareTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookShareTypeGetPayload<T>>>

    /**
     * Create a FacebookShareType.
     * @param {FacebookShareTypeCreateArgs} args - Arguments to create a FacebookShareType.
     * @example
     * // Create one FacebookShareType
     * const FacebookShareType = await prisma.facebookShareType.create({
     *   data: {
     *     // ... data to create a FacebookShareType
     *   }
     * })
     * 
    **/
    create<T extends FacebookShareTypeCreateArgs>(
      args: SelectSubset<T, FacebookShareTypeCreateArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Create many FacebookShareTypes.
     *     @param {FacebookShareTypeCreateManyArgs} args - Arguments to create many FacebookShareTypes.
     *     @example
     *     // Create many FacebookShareTypes
     *     const facebookShareType = await prisma.facebookShareType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookShareTypeCreateManyArgs>(
      args?: SelectSubset<T, FacebookShareTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookShareType.
     * @param {FacebookShareTypeDeleteArgs} args - Arguments to delete one FacebookShareType.
     * @example
     * // Delete one FacebookShareType
     * const FacebookShareType = await prisma.facebookShareType.delete({
     *   where: {
     *     // ... filter to delete one FacebookShareType
     *   }
     * })
     * 
    **/
    delete<T extends FacebookShareTypeDeleteArgs>(
      args: SelectSubset<T, FacebookShareTypeDeleteArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Update one FacebookShareType.
     * @param {FacebookShareTypeUpdateArgs} args - Arguments to update one FacebookShareType.
     * @example
     * // Update one FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookShareTypeUpdateArgs>(
      args: SelectSubset<T, FacebookShareTypeUpdateArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Delete zero or more FacebookShareTypes.
     * @param {FacebookShareTypeDeleteManyArgs} args - Arguments to filter FacebookShareTypes to delete.
     * @example
     * // Delete a few FacebookShareTypes
     * const { count } = await prisma.facebookShareType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookShareTypeDeleteManyArgs>(
      args?: SelectSubset<T, FacebookShareTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookShareTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookShareTypes
     * const facebookShareType = await prisma.facebookShareType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookShareTypeUpdateManyArgs>(
      args: SelectSubset<T, FacebookShareTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookShareType.
     * @param {FacebookShareTypeUpsertArgs} args - Arguments to update or create a FacebookShareType.
     * @example
     * // Update or create a FacebookShareType
     * const facebookShareType = await prisma.facebookShareType.upsert({
     *   create: {
     *     // ... data to create a FacebookShareType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookShareType we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookShareTypeUpsertArgs>(
      args: SelectSubset<T, FacebookShareTypeUpsertArgs>
    ): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T>>

    /**
     * Count the number of FacebookShareTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeCountArgs} args - Arguments to filter FacebookShareTypes to count.
     * @example
     * // Count the number of FacebookShareTypes
     * const count = await prisma.facebookShareType.count({
     *   where: {
     *     // ... the filter for the FacebookShareTypes we want to count
     *   }
     * })
    **/
    count<T extends FacebookShareTypeCountArgs>(
      args?: Subset<T, FacebookShareTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookShareTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookShareType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookShareTypeAggregateArgs>(args: Subset<T, FacebookShareTypeAggregateArgs>): Prisma.PrismaPromise<GetFacebookShareTypeAggregateType<T>>

    /**
     * Group by FacebookShareType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookShareTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookShareTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookShareTypeGroupByArgs['orderBy'] }
        : { orderBy?: FacebookShareTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookShareTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookShareTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookShareType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookShareTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commentPosts<T extends FacebookShareType$commentPostsArgs= {}>(args?: Subset<T, FacebookShareType$commentPostsArgs>): Prisma.PrismaPromise<Array<FacebookCommentPostGetPayload<T>>| Null>;

    posts<T extends FacebookShareType$postsArgs= {}>(args?: Subset<T, FacebookShareType$postsArgs>): Prisma.PrismaPromise<Array<FacebookPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookShareType base type for findUnique actions
   */
  export type FacebookShareTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter, which FacebookShareType to fetch.
     */
    where: FacebookShareTypeWhereUniqueInput
  }

  /**
   * FacebookShareType findUnique
   */
  export interface FacebookShareTypeFindUniqueArgs extends FacebookShareTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookShareType findUniqueOrThrow
   */
  export type FacebookShareTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter, which FacebookShareType to fetch.
     */
    where: FacebookShareTypeWhereUniqueInput
  }


  /**
   * FacebookShareType base type for findFirst actions
   */
  export type FacebookShareTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter, which FacebookShareType to fetch.
     */
    where?: FacebookShareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookShareTypes to fetch.
     */
    orderBy?: Enumerable<FacebookShareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookShareTypes.
     */
    cursor?: FacebookShareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookShareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookShareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookShareTypes.
     */
    distinct?: Enumerable<FacebookShareTypeScalarFieldEnum>
  }

  /**
   * FacebookShareType findFirst
   */
  export interface FacebookShareTypeFindFirstArgs extends FacebookShareTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookShareType findFirstOrThrow
   */
  export type FacebookShareTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter, which FacebookShareType to fetch.
     */
    where?: FacebookShareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookShareTypes to fetch.
     */
    orderBy?: Enumerable<FacebookShareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookShareTypes.
     */
    cursor?: FacebookShareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookShareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookShareTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookShareTypes.
     */
    distinct?: Enumerable<FacebookShareTypeScalarFieldEnum>
  }


  /**
   * FacebookShareType findMany
   */
  export type FacebookShareTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter, which FacebookShareTypes to fetch.
     */
    where?: FacebookShareTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookShareTypes to fetch.
     */
    orderBy?: Enumerable<FacebookShareTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookShareTypes.
     */
    cursor?: FacebookShareTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookShareTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookShareTypes.
     */
    skip?: number
    distinct?: Enumerable<FacebookShareTypeScalarFieldEnum>
  }


  /**
   * FacebookShareType create
   */
  export type FacebookShareTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * The data needed to create a FacebookShareType.
     */
    data: XOR<FacebookShareTypeCreateInput, FacebookShareTypeUncheckedCreateInput>
  }


  /**
   * FacebookShareType createMany
   */
  export type FacebookShareTypeCreateManyArgs = {
    /**
     * The data used to create many FacebookShareTypes.
     */
    data: Enumerable<FacebookShareTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookShareType update
   */
  export type FacebookShareTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * The data needed to update a FacebookShareType.
     */
    data: XOR<FacebookShareTypeUpdateInput, FacebookShareTypeUncheckedUpdateInput>
    /**
     * Choose, which FacebookShareType to update.
     */
    where: FacebookShareTypeWhereUniqueInput
  }


  /**
   * FacebookShareType updateMany
   */
  export type FacebookShareTypeUpdateManyArgs = {
    /**
     * The data used to update FacebookShareTypes.
     */
    data: XOR<FacebookShareTypeUpdateManyMutationInput, FacebookShareTypeUncheckedUpdateManyInput>
    /**
     * Filter which FacebookShareTypes to update
     */
    where?: FacebookShareTypeWhereInput
  }


  /**
   * FacebookShareType upsert
   */
  export type FacebookShareTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * The filter to search for the FacebookShareType to update in case it exists.
     */
    where: FacebookShareTypeWhereUniqueInput
    /**
     * In case the FacebookShareType found by the `where` argument doesn't exist, create a new FacebookShareType with this data.
     */
    create: XOR<FacebookShareTypeCreateInput, FacebookShareTypeUncheckedCreateInput>
    /**
     * In case the FacebookShareType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookShareTypeUpdateInput, FacebookShareTypeUncheckedUpdateInput>
  }


  /**
   * FacebookShareType delete
   */
  export type FacebookShareTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
    /**
     * Filter which FacebookShareType to delete.
     */
    where: FacebookShareTypeWhereUniqueInput
  }


  /**
   * FacebookShareType deleteMany
   */
  export type FacebookShareTypeDeleteManyArgs = {
    /**
     * Filter which FacebookShareTypes to delete
     */
    where?: FacebookShareTypeWhereInput
  }


  /**
   * FacebookShareType.commentPosts
   */
  export type FacebookShareType$commentPostsArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    where?: FacebookCommentPostWhereInput
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    cursor?: FacebookCommentPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookShareType.posts
   */
  export type FacebookShareType$postsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    where?: FacebookPostWhereInput
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    cursor?: FacebookPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookShareType without action
   */
  export type FacebookShareTypeArgs = {
    /**
     * Select specific fields to fetch from the FacebookShareType
     */
    select?: FacebookShareTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookShareTypeInclude | null
  }



  /**
   * Model FacebookGroup
   */


  export type AggregateFacebookGroup = {
    _count: FacebookGroupCountAggregateOutputType | null
    _avg: FacebookGroupAvgAggregateOutputType | null
    _sum: FacebookGroupSumAggregateOutputType | null
    _min: FacebookGroupMinAggregateOutputType | null
    _max: FacebookGroupMaxAggregateOutputType | null
  }

  export type FacebookGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type FacebookGroupSumAggregateOutputType = {
    id: number | null
  }

  export type FacebookGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookGroupCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookGroupAvgAggregateInputType = {
    id?: true
  }

  export type FacebookGroupSumAggregateInputType = {
    id?: true
  }

  export type FacebookGroupMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookGroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookGroupCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookGroupAggregateArgs = {
    /**
     * Filter which FacebookGroup to aggregate.
     */
    where?: FacebookGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookGroups to fetch.
     */
    orderBy?: Enumerable<FacebookGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookGroups
    **/
    _count?: true | FacebookGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookGroupMaxAggregateInputType
  }

  export type GetFacebookGroupAggregateType<T extends FacebookGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookGroup[P]>
      : GetScalarType<T[P], AggregateFacebookGroup[P]>
  }




  export type FacebookGroupGroupByArgs = {
    where?: FacebookGroupWhereInput
    orderBy?: Enumerable<FacebookGroupOrderByWithAggregationInput>
    by: FacebookGroupScalarFieldEnum[]
    having?: FacebookGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookGroupCountAggregateInputType | true
    _avg?: FacebookGroupAvgAggregateInputType
    _sum?: FacebookGroupSumAggregateInputType
    _min?: FacebookGroupMinAggregateInputType
    _max?: FacebookGroupMaxAggregateInputType
  }


  export type FacebookGroupGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FacebookGroupCountAggregateOutputType | null
    _avg: FacebookGroupAvgAggregateOutputType | null
    _sum: FacebookGroupSumAggregateOutputType | null
    _min: FacebookGroupMinAggregateOutputType | null
    _max: FacebookGroupMaxAggregateOutputType | null
  }

  type GetFacebookGroupGroupByPayload<T extends FacebookGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookGroupGroupByOutputType[P]>
        }
      >
    >


  export type FacebookGroupSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userInGroups?: boolean | FacebookGroup$userInGroupsArgs
    postDestinations?: boolean | FacebookGroup$postDestinationsArgs
    _count?: boolean | FacebookGroupCountOutputTypeArgs
  }


  export type FacebookGroupInclude = {
    userInGroups?: boolean | FacebookGroup$userInGroupsArgs
    postDestinations?: boolean | FacebookGroup$postDestinationsArgs
    _count?: boolean | FacebookGroupCountOutputTypeArgs
  }

  export type FacebookGroupGetPayload<S extends boolean | null | undefined | FacebookGroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookGroup :
    S extends undefined ? never :
    S extends { include: any } & (FacebookGroupArgs | FacebookGroupFindManyArgs)
    ? FacebookGroup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userInGroups' ? Array < FacebookUserInGroupGetPayload<S['include'][P]>>  :
        P extends 'postDestinations' ? Array < FacebookPostDestinationGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookGroupCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookGroupArgs | FacebookGroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userInGroups' ? Array < FacebookUserInGroupGetPayload<S['select'][P]>>  :
        P extends 'postDestinations' ? Array < FacebookPostDestinationGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookGroupCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookGroup ? FacebookGroup[P] : never
  } 
      : FacebookGroup


  type FacebookGroupCountArgs = 
    Omit<FacebookGroupFindManyArgs, 'select' | 'include'> & {
      select?: FacebookGroupCountAggregateInputType | true
    }

  export interface FacebookGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookGroup that matches the filter.
     * @param {FacebookGroupFindUniqueArgs} args - Arguments to find a FacebookGroup
     * @example
     * // Get one FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookGroup'> extends True ? Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>> : Prisma__FacebookGroupClient<FacebookGroupGetPayload<T> | null, null>

    /**
     * Find one FacebookGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookGroupFindUniqueOrThrowArgs} args - Arguments to find a FacebookGroup
     * @example
     * // Get one FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookGroupFindUniqueOrThrowArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Find the first FacebookGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupFindFirstArgs} args - Arguments to find a FacebookGroup
     * @example
     * // Get one FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookGroup'> extends True ? Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>> : Prisma__FacebookGroupClient<FacebookGroupGetPayload<T> | null, null>

    /**
     * Find the first FacebookGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupFindFirstOrThrowArgs} args - Arguments to find a FacebookGroup
     * @example
     * // Get one FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookGroupFindFirstOrThrowArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Find zero or more FacebookGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookGroups
     * const facebookGroups = await prisma.facebookGroup.findMany()
     * 
     * // Get first 10 FacebookGroups
     * const facebookGroups = await prisma.facebookGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookGroupWithIdOnly = await prisma.facebookGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookGroupFindManyArgs>(
      args?: SelectSubset<T, FacebookGroupFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookGroupGetPayload<T>>>

    /**
     * Create a FacebookGroup.
     * @param {FacebookGroupCreateArgs} args - Arguments to create a FacebookGroup.
     * @example
     * // Create one FacebookGroup
     * const FacebookGroup = await prisma.facebookGroup.create({
     *   data: {
     *     // ... data to create a FacebookGroup
     *   }
     * })
     * 
    **/
    create<T extends FacebookGroupCreateArgs>(
      args: SelectSubset<T, FacebookGroupCreateArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Create many FacebookGroups.
     *     @param {FacebookGroupCreateManyArgs} args - Arguments to create many FacebookGroups.
     *     @example
     *     // Create many FacebookGroups
     *     const facebookGroup = await prisma.facebookGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookGroupCreateManyArgs>(
      args?: SelectSubset<T, FacebookGroupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookGroup.
     * @param {FacebookGroupDeleteArgs} args - Arguments to delete one FacebookGroup.
     * @example
     * // Delete one FacebookGroup
     * const FacebookGroup = await prisma.facebookGroup.delete({
     *   where: {
     *     // ... filter to delete one FacebookGroup
     *   }
     * })
     * 
    **/
    delete<T extends FacebookGroupDeleteArgs>(
      args: SelectSubset<T, FacebookGroupDeleteArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Update one FacebookGroup.
     * @param {FacebookGroupUpdateArgs} args - Arguments to update one FacebookGroup.
     * @example
     * // Update one FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookGroupUpdateArgs>(
      args: SelectSubset<T, FacebookGroupUpdateArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Delete zero or more FacebookGroups.
     * @param {FacebookGroupDeleteManyArgs} args - Arguments to filter FacebookGroups to delete.
     * @example
     * // Delete a few FacebookGroups
     * const { count } = await prisma.facebookGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookGroupDeleteManyArgs>(
      args?: SelectSubset<T, FacebookGroupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookGroups
     * const facebookGroup = await prisma.facebookGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookGroupUpdateManyArgs>(
      args: SelectSubset<T, FacebookGroupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookGroup.
     * @param {FacebookGroupUpsertArgs} args - Arguments to update or create a FacebookGroup.
     * @example
     * // Update or create a FacebookGroup
     * const facebookGroup = await prisma.facebookGroup.upsert({
     *   create: {
     *     // ... data to create a FacebookGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookGroup we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookGroupUpsertArgs>(
      args: SelectSubset<T, FacebookGroupUpsertArgs>
    ): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T>>

    /**
     * Count the number of FacebookGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupCountArgs} args - Arguments to filter FacebookGroups to count.
     * @example
     * // Count the number of FacebookGroups
     * const count = await prisma.facebookGroup.count({
     *   where: {
     *     // ... the filter for the FacebookGroups we want to count
     *   }
     * })
    **/
    count<T extends FacebookGroupCountArgs>(
      args?: Subset<T, FacebookGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookGroupAggregateArgs>(args: Subset<T, FacebookGroupAggregateArgs>): Prisma.PrismaPromise<GetFacebookGroupAggregateType<T>>

    /**
     * Group by FacebookGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookGroupGroupByArgs['orderBy'] }
        : { orderBy?: FacebookGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookGroupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userInGroups<T extends FacebookGroup$userInGroupsArgs= {}>(args?: Subset<T, FacebookGroup$userInGroupsArgs>): Prisma.PrismaPromise<Array<FacebookUserInGroupGetPayload<T>>| Null>;

    postDestinations<T extends FacebookGroup$postDestinationsArgs= {}>(args?: Subset<T, FacebookGroup$postDestinationsArgs>): Prisma.PrismaPromise<Array<FacebookPostDestinationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookGroup base type for findUnique actions
   */
  export type FacebookGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter, which FacebookGroup to fetch.
     */
    where: FacebookGroupWhereUniqueInput
  }

  /**
   * FacebookGroup findUnique
   */
  export interface FacebookGroupFindUniqueArgs extends FacebookGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookGroup findUniqueOrThrow
   */
  export type FacebookGroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter, which FacebookGroup to fetch.
     */
    where: FacebookGroupWhereUniqueInput
  }


  /**
   * FacebookGroup base type for findFirst actions
   */
  export type FacebookGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter, which FacebookGroup to fetch.
     */
    where?: FacebookGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookGroups to fetch.
     */
    orderBy?: Enumerable<FacebookGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookGroups.
     */
    cursor?: FacebookGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookGroups.
     */
    distinct?: Enumerable<FacebookGroupScalarFieldEnum>
  }

  /**
   * FacebookGroup findFirst
   */
  export interface FacebookGroupFindFirstArgs extends FacebookGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookGroup findFirstOrThrow
   */
  export type FacebookGroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter, which FacebookGroup to fetch.
     */
    where?: FacebookGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookGroups to fetch.
     */
    orderBy?: Enumerable<FacebookGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookGroups.
     */
    cursor?: FacebookGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookGroups.
     */
    distinct?: Enumerable<FacebookGroupScalarFieldEnum>
  }


  /**
   * FacebookGroup findMany
   */
  export type FacebookGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter, which FacebookGroups to fetch.
     */
    where?: FacebookGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookGroups to fetch.
     */
    orderBy?: Enumerable<FacebookGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookGroups.
     */
    cursor?: FacebookGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookGroups.
     */
    skip?: number
    distinct?: Enumerable<FacebookGroupScalarFieldEnum>
  }


  /**
   * FacebookGroup create
   */
  export type FacebookGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * The data needed to create a FacebookGroup.
     */
    data: XOR<FacebookGroupCreateInput, FacebookGroupUncheckedCreateInput>
  }


  /**
   * FacebookGroup createMany
   */
  export type FacebookGroupCreateManyArgs = {
    /**
     * The data used to create many FacebookGroups.
     */
    data: Enumerable<FacebookGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookGroup update
   */
  export type FacebookGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * The data needed to update a FacebookGroup.
     */
    data: XOR<FacebookGroupUpdateInput, FacebookGroupUncheckedUpdateInput>
    /**
     * Choose, which FacebookGroup to update.
     */
    where: FacebookGroupWhereUniqueInput
  }


  /**
   * FacebookGroup updateMany
   */
  export type FacebookGroupUpdateManyArgs = {
    /**
     * The data used to update FacebookGroups.
     */
    data: XOR<FacebookGroupUpdateManyMutationInput, FacebookGroupUncheckedUpdateManyInput>
    /**
     * Filter which FacebookGroups to update
     */
    where?: FacebookGroupWhereInput
  }


  /**
   * FacebookGroup upsert
   */
  export type FacebookGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * The filter to search for the FacebookGroup to update in case it exists.
     */
    where: FacebookGroupWhereUniqueInput
    /**
     * In case the FacebookGroup found by the `where` argument doesn't exist, create a new FacebookGroup with this data.
     */
    create: XOR<FacebookGroupCreateInput, FacebookGroupUncheckedCreateInput>
    /**
     * In case the FacebookGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookGroupUpdateInput, FacebookGroupUncheckedUpdateInput>
  }


  /**
   * FacebookGroup delete
   */
  export type FacebookGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
    /**
     * Filter which FacebookGroup to delete.
     */
    where: FacebookGroupWhereUniqueInput
  }


  /**
   * FacebookGroup deleteMany
   */
  export type FacebookGroupDeleteManyArgs = {
    /**
     * Filter which FacebookGroups to delete
     */
    where?: FacebookGroupWhereInput
  }


  /**
   * FacebookGroup.userInGroups
   */
  export type FacebookGroup$userInGroupsArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    where?: FacebookUserInGroupWhereInput
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    cursor?: FacebookUserInGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookUserInGroupScalarFieldEnum>
  }


  /**
   * FacebookGroup.postDestinations
   */
  export type FacebookGroup$postDestinationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    where?: FacebookPostDestinationWhereInput
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    cursor?: FacebookPostDestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }


  /**
   * FacebookGroup without action
   */
  export type FacebookGroupArgs = {
    /**
     * Select specific fields to fetch from the FacebookGroup
     */
    select?: FacebookGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookGroupInclude | null
  }



  /**
   * Model FacebookUserInGroup
   */


  export type AggregateFacebookUserInGroup = {
    _count: FacebookUserInGroupCountAggregateOutputType | null
    _avg: FacebookUserInGroupAvgAggregateOutputType | null
    _sum: FacebookUserInGroupSumAggregateOutputType | null
    _min: FacebookUserInGroupMinAggregateOutputType | null
    _max: FacebookUserInGroupMaxAggregateOutputType | null
  }

  export type FacebookUserInGroupAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type FacebookUserInGroupSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type FacebookUserInGroupMinAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserInGroupMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookUserInGroupCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookUserInGroupAvgAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type FacebookUserInGroupSumAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type FacebookUserInGroupMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserInGroupMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookUserInGroupCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookUserInGroupAggregateArgs = {
    /**
     * Filter which FacebookUserInGroup to aggregate.
     */
    where?: FacebookUserInGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserInGroups to fetch.
     */
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookUserInGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserInGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserInGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookUserInGroups
    **/
    _count?: true | FacebookUserInGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookUserInGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookUserInGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookUserInGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookUserInGroupMaxAggregateInputType
  }

  export type GetFacebookUserInGroupAggregateType<T extends FacebookUserInGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookUserInGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookUserInGroup[P]>
      : GetScalarType<T[P], AggregateFacebookUserInGroup[P]>
  }




  export type FacebookUserInGroupGroupByArgs = {
    where?: FacebookUserInGroupWhereInput
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithAggregationInput>
    by: FacebookUserInGroupScalarFieldEnum[]
    having?: FacebookUserInGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookUserInGroupCountAggregateInputType | true
    _avg?: FacebookUserInGroupAvgAggregateInputType
    _sum?: FacebookUserInGroupSumAggregateInputType
    _min?: FacebookUserInGroupMinAggregateInputType
    _max?: FacebookUserInGroupMaxAggregateInputType
  }


  export type FacebookUserInGroupGroupByOutputType = {
    id: number
    userId: number
    groupId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookUserInGroupCountAggregateOutputType | null
    _avg: FacebookUserInGroupAvgAggregateOutputType | null
    _sum: FacebookUserInGroupSumAggregateOutputType | null
    _min: FacebookUserInGroupMinAggregateOutputType | null
    _max: FacebookUserInGroupMaxAggregateOutputType | null
  }

  type GetFacebookUserInGroupGroupByPayload<T extends FacebookUserInGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookUserInGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookUserInGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookUserInGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookUserInGroupGroupByOutputType[P]>
        }
      >
    >


  export type FacebookUserInGroupSelect = {
    id?: boolean
    user?: boolean | FacebookUserArgs
    userId?: boolean
    group?: boolean | FacebookGroupArgs
    groupId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookUserInGroupInclude = {
    user?: boolean | FacebookUserArgs
    group?: boolean | FacebookGroupArgs
  }

  export type FacebookUserInGroupGetPayload<S extends boolean | null | undefined | FacebookUserInGroupArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookUserInGroup :
    S extends undefined ? never :
    S extends { include: any } & (FacebookUserInGroupArgs | FacebookUserInGroupFindManyArgs)
    ? FacebookUserInGroup  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'group' ? FacebookGroupGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookUserInGroupArgs | FacebookUserInGroupFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'group' ? FacebookGroupGetPayload<S['select'][P]> :  P extends keyof FacebookUserInGroup ? FacebookUserInGroup[P] : never
  } 
      : FacebookUserInGroup


  type FacebookUserInGroupCountArgs = 
    Omit<FacebookUserInGroupFindManyArgs, 'select' | 'include'> & {
      select?: FacebookUserInGroupCountAggregateInputType | true
    }

  export interface FacebookUserInGroupDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookUserInGroup that matches the filter.
     * @param {FacebookUserInGroupFindUniqueArgs} args - Arguments to find a FacebookUserInGroup
     * @example
     * // Get one FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookUserInGroupFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookUserInGroupFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookUserInGroup'> extends True ? Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>> : Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T> | null, null>

    /**
     * Find one FacebookUserInGroup that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookUserInGroupFindUniqueOrThrowArgs} args - Arguments to find a FacebookUserInGroup
     * @example
     * // Get one FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookUserInGroupFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserInGroupFindUniqueOrThrowArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Find the first FacebookUserInGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupFindFirstArgs} args - Arguments to find a FacebookUserInGroup
     * @example
     * // Get one FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookUserInGroupFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookUserInGroupFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookUserInGroup'> extends True ? Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>> : Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T> | null, null>

    /**
     * Find the first FacebookUserInGroup that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupFindFirstOrThrowArgs} args - Arguments to find a FacebookUserInGroup
     * @example
     * // Get one FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookUserInGroupFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookUserInGroupFindFirstOrThrowArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Find zero or more FacebookUserInGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookUserInGroups
     * const facebookUserInGroups = await prisma.facebookUserInGroup.findMany()
     * 
     * // Get first 10 FacebookUserInGroups
     * const facebookUserInGroups = await prisma.facebookUserInGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookUserInGroupWithIdOnly = await prisma.facebookUserInGroup.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookUserInGroupFindManyArgs>(
      args?: SelectSubset<T, FacebookUserInGroupFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookUserInGroupGetPayload<T>>>

    /**
     * Create a FacebookUserInGroup.
     * @param {FacebookUserInGroupCreateArgs} args - Arguments to create a FacebookUserInGroup.
     * @example
     * // Create one FacebookUserInGroup
     * const FacebookUserInGroup = await prisma.facebookUserInGroup.create({
     *   data: {
     *     // ... data to create a FacebookUserInGroup
     *   }
     * })
     * 
    **/
    create<T extends FacebookUserInGroupCreateArgs>(
      args: SelectSubset<T, FacebookUserInGroupCreateArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Create many FacebookUserInGroups.
     *     @param {FacebookUserInGroupCreateManyArgs} args - Arguments to create many FacebookUserInGroups.
     *     @example
     *     // Create many FacebookUserInGroups
     *     const facebookUserInGroup = await prisma.facebookUserInGroup.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookUserInGroupCreateManyArgs>(
      args?: SelectSubset<T, FacebookUserInGroupCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookUserInGroup.
     * @param {FacebookUserInGroupDeleteArgs} args - Arguments to delete one FacebookUserInGroup.
     * @example
     * // Delete one FacebookUserInGroup
     * const FacebookUserInGroup = await prisma.facebookUserInGroup.delete({
     *   where: {
     *     // ... filter to delete one FacebookUserInGroup
     *   }
     * })
     * 
    **/
    delete<T extends FacebookUserInGroupDeleteArgs>(
      args: SelectSubset<T, FacebookUserInGroupDeleteArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Update one FacebookUserInGroup.
     * @param {FacebookUserInGroupUpdateArgs} args - Arguments to update one FacebookUserInGroup.
     * @example
     * // Update one FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookUserInGroupUpdateArgs>(
      args: SelectSubset<T, FacebookUserInGroupUpdateArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Delete zero or more FacebookUserInGroups.
     * @param {FacebookUserInGroupDeleteManyArgs} args - Arguments to filter FacebookUserInGroups to delete.
     * @example
     * // Delete a few FacebookUserInGroups
     * const { count } = await prisma.facebookUserInGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookUserInGroupDeleteManyArgs>(
      args?: SelectSubset<T, FacebookUserInGroupDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookUserInGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookUserInGroups
     * const facebookUserInGroup = await prisma.facebookUserInGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookUserInGroupUpdateManyArgs>(
      args: SelectSubset<T, FacebookUserInGroupUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookUserInGroup.
     * @param {FacebookUserInGroupUpsertArgs} args - Arguments to update or create a FacebookUserInGroup.
     * @example
     * // Update or create a FacebookUserInGroup
     * const facebookUserInGroup = await prisma.facebookUserInGroup.upsert({
     *   create: {
     *     // ... data to create a FacebookUserInGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookUserInGroup we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookUserInGroupUpsertArgs>(
      args: SelectSubset<T, FacebookUserInGroupUpsertArgs>
    ): Prisma__FacebookUserInGroupClient<FacebookUserInGroupGetPayload<T>>

    /**
     * Count the number of FacebookUserInGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupCountArgs} args - Arguments to filter FacebookUserInGroups to count.
     * @example
     * // Count the number of FacebookUserInGroups
     * const count = await prisma.facebookUserInGroup.count({
     *   where: {
     *     // ... the filter for the FacebookUserInGroups we want to count
     *   }
     * })
    **/
    count<T extends FacebookUserInGroupCountArgs>(
      args?: Subset<T, FacebookUserInGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookUserInGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookUserInGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookUserInGroupAggregateArgs>(args: Subset<T, FacebookUserInGroupAggregateArgs>): Prisma.PrismaPromise<GetFacebookUserInGroupAggregateType<T>>

    /**
     * Group by FacebookUserInGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookUserInGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookUserInGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookUserInGroupGroupByArgs['orderBy'] }
        : { orderBy?: FacebookUserInGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookUserInGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookUserInGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookUserInGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookUserInGroupClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    group<T extends FacebookGroupArgs= {}>(args?: Subset<T, FacebookGroupArgs>): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookUserInGroup base type for findUnique actions
   */
  export type FacebookUserInGroupFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter, which FacebookUserInGroup to fetch.
     */
    where: FacebookUserInGroupWhereUniqueInput
  }

  /**
   * FacebookUserInGroup findUnique
   */
  export interface FacebookUserInGroupFindUniqueArgs extends FacebookUserInGroupFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserInGroup findUniqueOrThrow
   */
  export type FacebookUserInGroupFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter, which FacebookUserInGroup to fetch.
     */
    where: FacebookUserInGroupWhereUniqueInput
  }


  /**
   * FacebookUserInGroup base type for findFirst actions
   */
  export type FacebookUserInGroupFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter, which FacebookUserInGroup to fetch.
     */
    where?: FacebookUserInGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserInGroups to fetch.
     */
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserInGroups.
     */
    cursor?: FacebookUserInGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserInGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserInGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserInGroups.
     */
    distinct?: Enumerable<FacebookUserInGroupScalarFieldEnum>
  }

  /**
   * FacebookUserInGroup findFirst
   */
  export interface FacebookUserInGroupFindFirstArgs extends FacebookUserInGroupFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookUserInGroup findFirstOrThrow
   */
  export type FacebookUserInGroupFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter, which FacebookUserInGroup to fetch.
     */
    where?: FacebookUserInGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserInGroups to fetch.
     */
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookUserInGroups.
     */
    cursor?: FacebookUserInGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserInGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserInGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookUserInGroups.
     */
    distinct?: Enumerable<FacebookUserInGroupScalarFieldEnum>
  }


  /**
   * FacebookUserInGroup findMany
   */
  export type FacebookUserInGroupFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter, which FacebookUserInGroups to fetch.
     */
    where?: FacebookUserInGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookUserInGroups to fetch.
     */
    orderBy?: Enumerable<FacebookUserInGroupOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookUserInGroups.
     */
    cursor?: FacebookUserInGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookUserInGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookUserInGroups.
     */
    skip?: number
    distinct?: Enumerable<FacebookUserInGroupScalarFieldEnum>
  }


  /**
   * FacebookUserInGroup create
   */
  export type FacebookUserInGroupCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * The data needed to create a FacebookUserInGroup.
     */
    data: XOR<FacebookUserInGroupCreateInput, FacebookUserInGroupUncheckedCreateInput>
  }


  /**
   * FacebookUserInGroup createMany
   */
  export type FacebookUserInGroupCreateManyArgs = {
    /**
     * The data used to create many FacebookUserInGroups.
     */
    data: Enumerable<FacebookUserInGroupCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookUserInGroup update
   */
  export type FacebookUserInGroupUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * The data needed to update a FacebookUserInGroup.
     */
    data: XOR<FacebookUserInGroupUpdateInput, FacebookUserInGroupUncheckedUpdateInput>
    /**
     * Choose, which FacebookUserInGroup to update.
     */
    where: FacebookUserInGroupWhereUniqueInput
  }


  /**
   * FacebookUserInGroup updateMany
   */
  export type FacebookUserInGroupUpdateManyArgs = {
    /**
     * The data used to update FacebookUserInGroups.
     */
    data: XOR<FacebookUserInGroupUpdateManyMutationInput, FacebookUserInGroupUncheckedUpdateManyInput>
    /**
     * Filter which FacebookUserInGroups to update
     */
    where?: FacebookUserInGroupWhereInput
  }


  /**
   * FacebookUserInGroup upsert
   */
  export type FacebookUserInGroupUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * The filter to search for the FacebookUserInGroup to update in case it exists.
     */
    where: FacebookUserInGroupWhereUniqueInput
    /**
     * In case the FacebookUserInGroup found by the `where` argument doesn't exist, create a new FacebookUserInGroup with this data.
     */
    create: XOR<FacebookUserInGroupCreateInput, FacebookUserInGroupUncheckedCreateInput>
    /**
     * In case the FacebookUserInGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookUserInGroupUpdateInput, FacebookUserInGroupUncheckedUpdateInput>
  }


  /**
   * FacebookUserInGroup delete
   */
  export type FacebookUserInGroupDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
    /**
     * Filter which FacebookUserInGroup to delete.
     */
    where: FacebookUserInGroupWhereUniqueInput
  }


  /**
   * FacebookUserInGroup deleteMany
   */
  export type FacebookUserInGroupDeleteManyArgs = {
    /**
     * Filter which FacebookUserInGroups to delete
     */
    where?: FacebookUserInGroupWhereInput
  }


  /**
   * FacebookUserInGroup without action
   */
  export type FacebookUserInGroupArgs = {
    /**
     * Select specific fields to fetch from the FacebookUserInGroup
     */
    select?: FacebookUserInGroupSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookUserInGroupInclude | null
  }



  /**
   * Model FacebookPostDestination
   */


  export type AggregateFacebookPostDestination = {
    _count: FacebookPostDestinationCountAggregateOutputType | null
    _avg: FacebookPostDestinationAvgAggregateOutputType | null
    _sum: FacebookPostDestinationSumAggregateOutputType | null
    _min: FacebookPostDestinationMinAggregateOutputType | null
    _max: FacebookPostDestinationMaxAggregateOutputType | null
  }

  export type FacebookPostDestinationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    postId: number | null
  }

  export type FacebookPostDestinationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
    postId: number | null
  }

  export type FacebookPostDestinationMinAggregateOutputType = {
    id: number | null
    type: string | null
    userId: number | null
    groupId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPostDestinationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    userId: number | null
    groupId: number | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPostDestinationCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    groupId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookPostDestinationAvgAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    postId?: true
  }

  export type FacebookPostDestinationSumAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    postId?: true
  }

  export type FacebookPostDestinationMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    groupId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPostDestinationMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    groupId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPostDestinationCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    groupId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookPostDestinationAggregateArgs = {
    /**
     * Filter which FacebookPostDestination to aggregate.
     */
    where?: FacebookPostDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPostDestinations to fetch.
     */
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookPostDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPostDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPostDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookPostDestinations
    **/
    _count?: true | FacebookPostDestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookPostDestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookPostDestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookPostDestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookPostDestinationMaxAggregateInputType
  }

  export type GetFacebookPostDestinationAggregateType<T extends FacebookPostDestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookPostDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookPostDestination[P]>
      : GetScalarType<T[P], AggregateFacebookPostDestination[P]>
  }




  export type FacebookPostDestinationGroupByArgs = {
    where?: FacebookPostDestinationWhereInput
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithAggregationInput>
    by: FacebookPostDestinationScalarFieldEnum[]
    having?: FacebookPostDestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookPostDestinationCountAggregateInputType | true
    _avg?: FacebookPostDestinationAvgAggregateInputType
    _sum?: FacebookPostDestinationSumAggregateInputType
    _min?: FacebookPostDestinationMinAggregateInputType
    _max?: FacebookPostDestinationMaxAggregateInputType
  }


  export type FacebookPostDestinationGroupByOutputType = {
    id: number
    type: string
    userId: number
    groupId: number
    postId: number | null
    createdAt: Date
    updatedAt: Date
    _count: FacebookPostDestinationCountAggregateOutputType | null
    _avg: FacebookPostDestinationAvgAggregateOutputType | null
    _sum: FacebookPostDestinationSumAggregateOutputType | null
    _min: FacebookPostDestinationMinAggregateOutputType | null
    _max: FacebookPostDestinationMaxAggregateOutputType | null
  }

  type GetFacebookPostDestinationGroupByPayload<T extends FacebookPostDestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookPostDestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookPostDestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookPostDestinationGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookPostDestinationGroupByOutputType[P]>
        }
      >
    >


  export type FacebookPostDestinationSelect = {
    id?: boolean
    type?: boolean
    userWall?: boolean | FacebookUserArgs
    group?: boolean | FacebookGroupArgs
    userId?: boolean
    groupId?: boolean
    post?: boolean | FacebookPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type FacebookPostDestinationInclude = {
    userWall?: boolean | FacebookUserArgs
    group?: boolean | FacebookGroupArgs
    post?: boolean | FacebookPostArgs
  }

  export type FacebookPostDestinationGetPayload<S extends boolean | null | undefined | FacebookPostDestinationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookPostDestination :
    S extends undefined ? never :
    S extends { include: any } & (FacebookPostDestinationArgs | FacebookPostDestinationFindManyArgs)
    ? FacebookPostDestination  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userWall' ? FacebookUserGetPayload<S['include'][P]> | null :
        P extends 'group' ? FacebookGroupGetPayload<S['include'][P]> | null :
        P extends 'post' ? FacebookPostGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (FacebookPostDestinationArgs | FacebookPostDestinationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userWall' ? FacebookUserGetPayload<S['select'][P]> | null :
        P extends 'group' ? FacebookGroupGetPayload<S['select'][P]> | null :
        P extends 'post' ? FacebookPostGetPayload<S['select'][P]> | null :  P extends keyof FacebookPostDestination ? FacebookPostDestination[P] : never
  } 
      : FacebookPostDestination


  type FacebookPostDestinationCountArgs = 
    Omit<FacebookPostDestinationFindManyArgs, 'select' | 'include'> & {
      select?: FacebookPostDestinationCountAggregateInputType | true
    }

  export interface FacebookPostDestinationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookPostDestination that matches the filter.
     * @param {FacebookPostDestinationFindUniqueArgs} args - Arguments to find a FacebookPostDestination
     * @example
     * // Get one FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookPostDestinationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookPostDestinationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookPostDestination'> extends True ? Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>> : Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T> | null, null>

    /**
     * Find one FacebookPostDestination that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookPostDestinationFindUniqueOrThrowArgs} args - Arguments to find a FacebookPostDestination
     * @example
     * // Get one FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookPostDestinationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookPostDestinationFindUniqueOrThrowArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Find the first FacebookPostDestination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationFindFirstArgs} args - Arguments to find a FacebookPostDestination
     * @example
     * // Get one FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookPostDestinationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookPostDestinationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookPostDestination'> extends True ? Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>> : Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T> | null, null>

    /**
     * Find the first FacebookPostDestination that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationFindFirstOrThrowArgs} args - Arguments to find a FacebookPostDestination
     * @example
     * // Get one FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookPostDestinationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookPostDestinationFindFirstOrThrowArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Find zero or more FacebookPostDestinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookPostDestinations
     * const facebookPostDestinations = await prisma.facebookPostDestination.findMany()
     * 
     * // Get first 10 FacebookPostDestinations
     * const facebookPostDestinations = await prisma.facebookPostDestination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookPostDestinationWithIdOnly = await prisma.facebookPostDestination.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookPostDestinationFindManyArgs>(
      args?: SelectSubset<T, FacebookPostDestinationFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookPostDestinationGetPayload<T>>>

    /**
     * Create a FacebookPostDestination.
     * @param {FacebookPostDestinationCreateArgs} args - Arguments to create a FacebookPostDestination.
     * @example
     * // Create one FacebookPostDestination
     * const FacebookPostDestination = await prisma.facebookPostDestination.create({
     *   data: {
     *     // ... data to create a FacebookPostDestination
     *   }
     * })
     * 
    **/
    create<T extends FacebookPostDestinationCreateArgs>(
      args: SelectSubset<T, FacebookPostDestinationCreateArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Create many FacebookPostDestinations.
     *     @param {FacebookPostDestinationCreateManyArgs} args - Arguments to create many FacebookPostDestinations.
     *     @example
     *     // Create many FacebookPostDestinations
     *     const facebookPostDestination = await prisma.facebookPostDestination.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookPostDestinationCreateManyArgs>(
      args?: SelectSubset<T, FacebookPostDestinationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookPostDestination.
     * @param {FacebookPostDestinationDeleteArgs} args - Arguments to delete one FacebookPostDestination.
     * @example
     * // Delete one FacebookPostDestination
     * const FacebookPostDestination = await prisma.facebookPostDestination.delete({
     *   where: {
     *     // ... filter to delete one FacebookPostDestination
     *   }
     * })
     * 
    **/
    delete<T extends FacebookPostDestinationDeleteArgs>(
      args: SelectSubset<T, FacebookPostDestinationDeleteArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Update one FacebookPostDestination.
     * @param {FacebookPostDestinationUpdateArgs} args - Arguments to update one FacebookPostDestination.
     * @example
     * // Update one FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookPostDestinationUpdateArgs>(
      args: SelectSubset<T, FacebookPostDestinationUpdateArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Delete zero or more FacebookPostDestinations.
     * @param {FacebookPostDestinationDeleteManyArgs} args - Arguments to filter FacebookPostDestinations to delete.
     * @example
     * // Delete a few FacebookPostDestinations
     * const { count } = await prisma.facebookPostDestination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookPostDestinationDeleteManyArgs>(
      args?: SelectSubset<T, FacebookPostDestinationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPostDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookPostDestinations
     * const facebookPostDestination = await prisma.facebookPostDestination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookPostDestinationUpdateManyArgs>(
      args: SelectSubset<T, FacebookPostDestinationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookPostDestination.
     * @param {FacebookPostDestinationUpsertArgs} args - Arguments to update or create a FacebookPostDestination.
     * @example
     * // Update or create a FacebookPostDestination
     * const facebookPostDestination = await prisma.facebookPostDestination.upsert({
     *   create: {
     *     // ... data to create a FacebookPostDestination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookPostDestination we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookPostDestinationUpsertArgs>(
      args: SelectSubset<T, FacebookPostDestinationUpsertArgs>
    ): Prisma__FacebookPostDestinationClient<FacebookPostDestinationGetPayload<T>>

    /**
     * Count the number of FacebookPostDestinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationCountArgs} args - Arguments to filter FacebookPostDestinations to count.
     * @example
     * // Count the number of FacebookPostDestinations
     * const count = await prisma.facebookPostDestination.count({
     *   where: {
     *     // ... the filter for the FacebookPostDestinations we want to count
     *   }
     * })
    **/
    count<T extends FacebookPostDestinationCountArgs>(
      args?: Subset<T, FacebookPostDestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookPostDestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookPostDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookPostDestinationAggregateArgs>(args: Subset<T, FacebookPostDestinationAggregateArgs>): Prisma.PrismaPromise<GetFacebookPostDestinationAggregateType<T>>

    /**
     * Group by FacebookPostDestination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostDestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookPostDestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookPostDestinationGroupByArgs['orderBy'] }
        : { orderBy?: FacebookPostDestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookPostDestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookPostDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookPostDestination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookPostDestinationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userWall<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    group<T extends FacebookGroupArgs= {}>(args?: Subset<T, FacebookGroupArgs>): Prisma__FacebookGroupClient<FacebookGroupGetPayload<T> | Null>;

    post<T extends FacebookPostArgs= {}>(args?: Subset<T, FacebookPostArgs>): Prisma__FacebookPostClient<FacebookPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookPostDestination base type for findUnique actions
   */
  export type FacebookPostDestinationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter, which FacebookPostDestination to fetch.
     */
    where: FacebookPostDestinationWhereUniqueInput
  }

  /**
   * FacebookPostDestination findUnique
   */
  export interface FacebookPostDestinationFindUniqueArgs extends FacebookPostDestinationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookPostDestination findUniqueOrThrow
   */
  export type FacebookPostDestinationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter, which FacebookPostDestination to fetch.
     */
    where: FacebookPostDestinationWhereUniqueInput
  }


  /**
   * FacebookPostDestination base type for findFirst actions
   */
  export type FacebookPostDestinationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter, which FacebookPostDestination to fetch.
     */
    where?: FacebookPostDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPostDestinations to fetch.
     */
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPostDestinations.
     */
    cursor?: FacebookPostDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPostDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPostDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPostDestinations.
     */
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }

  /**
   * FacebookPostDestination findFirst
   */
  export interface FacebookPostDestinationFindFirstArgs extends FacebookPostDestinationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookPostDestination findFirstOrThrow
   */
  export type FacebookPostDestinationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter, which FacebookPostDestination to fetch.
     */
    where?: FacebookPostDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPostDestinations to fetch.
     */
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPostDestinations.
     */
    cursor?: FacebookPostDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPostDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPostDestinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPostDestinations.
     */
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }


  /**
   * FacebookPostDestination findMany
   */
  export type FacebookPostDestinationFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter, which FacebookPostDestinations to fetch.
     */
    where?: FacebookPostDestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPostDestinations to fetch.
     */
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookPostDestinations.
     */
    cursor?: FacebookPostDestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPostDestinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPostDestinations.
     */
    skip?: number
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }


  /**
   * FacebookPostDestination create
   */
  export type FacebookPostDestinationCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * The data needed to create a FacebookPostDestination.
     */
    data: XOR<FacebookPostDestinationCreateInput, FacebookPostDestinationUncheckedCreateInput>
  }


  /**
   * FacebookPostDestination createMany
   */
  export type FacebookPostDestinationCreateManyArgs = {
    /**
     * The data used to create many FacebookPostDestinations.
     */
    data: Enumerable<FacebookPostDestinationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookPostDestination update
   */
  export type FacebookPostDestinationUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * The data needed to update a FacebookPostDestination.
     */
    data: XOR<FacebookPostDestinationUpdateInput, FacebookPostDestinationUncheckedUpdateInput>
    /**
     * Choose, which FacebookPostDestination to update.
     */
    where: FacebookPostDestinationWhereUniqueInput
  }


  /**
   * FacebookPostDestination updateMany
   */
  export type FacebookPostDestinationUpdateManyArgs = {
    /**
     * The data used to update FacebookPostDestinations.
     */
    data: XOR<FacebookPostDestinationUpdateManyMutationInput, FacebookPostDestinationUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPostDestinations to update
     */
    where?: FacebookPostDestinationWhereInput
  }


  /**
   * FacebookPostDestination upsert
   */
  export type FacebookPostDestinationUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * The filter to search for the FacebookPostDestination to update in case it exists.
     */
    where: FacebookPostDestinationWhereUniqueInput
    /**
     * In case the FacebookPostDestination found by the `where` argument doesn't exist, create a new FacebookPostDestination with this data.
     */
    create: XOR<FacebookPostDestinationCreateInput, FacebookPostDestinationUncheckedCreateInput>
    /**
     * In case the FacebookPostDestination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookPostDestinationUpdateInput, FacebookPostDestinationUncheckedUpdateInput>
  }


  /**
   * FacebookPostDestination delete
   */
  export type FacebookPostDestinationDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    /**
     * Filter which FacebookPostDestination to delete.
     */
    where: FacebookPostDestinationWhereUniqueInput
  }


  /**
   * FacebookPostDestination deleteMany
   */
  export type FacebookPostDestinationDeleteManyArgs = {
    /**
     * Filter which FacebookPostDestinations to delete
     */
    where?: FacebookPostDestinationWhereInput
  }


  /**
   * FacebookPostDestination without action
   */
  export type FacebookPostDestinationArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
  }



  /**
   * Model FacebookPost
   */


  export type AggregateFacebookPost = {
    _count: FacebookPostCountAggregateOutputType | null
    _avg: FacebookPostAvgAggregateOutputType | null
    _sum: FacebookPostSumAggregateOutputType | null
    _min: FacebookPostMinAggregateOutputType | null
    _max: FacebookPostMaxAggregateOutputType | null
  }

  export type FacebookPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    locationId: number | null
    hashtagId: number | null
    shareToId: number | null
  }

  export type FacebookPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    locationId: number | null
    hashtagId: number | null
    shareToId: number | null
  }

  export type FacebookPostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    locationId: number | null
    hashtagId: number | null
    shareToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    locationId: number | null
    hashtagId: number | null
    shareToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookPostCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    image: number
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookPostAvgAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    hashtagId?: true
    shareToId?: true
  }

  export type FacebookPostSumAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    hashtagId?: true
    shareToId?: true
  }

  export type FacebookPostMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    locationId?: true
    hashtagId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPostMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    locationId?: true
    hashtagId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookPostCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    locationId?: true
    hashtagId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookPostAggregateArgs = {
    /**
     * Filter which FacebookPost to aggregate.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookPosts
    **/
    _count?: true | FacebookPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookPostMaxAggregateInputType
  }

  export type GetFacebookPostAggregateType<T extends FacebookPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookPost[P]>
      : GetScalarType<T[P], AggregateFacebookPost[P]>
  }




  export type FacebookPostGroupByArgs = {
    where?: FacebookPostWhereInput
    orderBy?: Enumerable<FacebookPostOrderByWithAggregationInput>
    by: FacebookPostScalarFieldEnum[]
    having?: FacebookPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookPostCountAggregateInputType | true
    _avg?: FacebookPostAvgAggregateInputType
    _sum?: FacebookPostSumAggregateInputType
    _min?: FacebookPostMinAggregateInputType
    _max?: FacebookPostMaxAggregateInputType
  }


  export type FacebookPostGroupByOutputType = {
    id: number
    userId: number
    message: string | null
    image: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookPostCountAggregateOutputType | null
    _avg: FacebookPostAvgAggregateOutputType | null
    _sum: FacebookPostSumAggregateOutputType | null
    _min: FacebookPostMinAggregateOutputType | null
    _max: FacebookPostMaxAggregateOutputType | null
  }

  type GetFacebookPostGroupByPayload<T extends FacebookPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookPostGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookPostGroupByOutputType[P]>
        }
      >
    >


  export type FacebookPostSelect = {
    id?: boolean
    user?: boolean | FacebookUserArgs
    userId?: boolean
    message?: boolean
    image?: boolean
    location?: boolean | FacebookLocationArgs
    locationId?: boolean
    hashtag?: boolean | FacebookHashtagArgs
    hashtagId?: boolean
    share?: boolean | FacebookShareTypeArgs
    shareToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    likes?: boolean | FacebookPost$likesArgs
    commentPosts?: boolean | FacebookPost$commentPostsArgs
    postDestionations?: boolean | FacebookPost$postDestionationsArgs
    _count?: boolean | FacebookPostCountOutputTypeArgs
  }


  export type FacebookPostInclude = {
    user?: boolean | FacebookUserArgs
    location?: boolean | FacebookLocationArgs
    hashtag?: boolean | FacebookHashtagArgs
    share?: boolean | FacebookShareTypeArgs
    likes?: boolean | FacebookPost$likesArgs
    commentPosts?: boolean | FacebookPost$commentPostsArgs
    postDestionations?: boolean | FacebookPost$postDestionationsArgs
    _count?: boolean | FacebookPostCountOutputTypeArgs
  }

  export type FacebookPostGetPayload<S extends boolean | null | undefined | FacebookPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookPost :
    S extends undefined ? never :
    S extends { include: any } & (FacebookPostArgs | FacebookPostFindManyArgs)
    ? FacebookPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'location' ? FacebookLocationGetPayload<S['include'][P]> :
        P extends 'hashtag' ? FacebookHashtagGetPayload<S['include'][P]> | null :
        P extends 'share' ? FacebookShareTypeGetPayload<S['include'][P]> | null :
        P extends 'likes' ? Array < FacebookLikeGetPayload<S['include'][P]>>  :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['include'][P]>>  :
        P extends 'postDestionations' ? Array < FacebookPostDestinationGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookPostArgs | FacebookPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'location' ? FacebookLocationGetPayload<S['select'][P]> :
        P extends 'hashtag' ? FacebookHashtagGetPayload<S['select'][P]> | null :
        P extends 'share' ? FacebookShareTypeGetPayload<S['select'][P]> | null :
        P extends 'likes' ? Array < FacebookLikeGetPayload<S['select'][P]>>  :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['select'][P]>>  :
        P extends 'postDestionations' ? Array < FacebookPostDestinationGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookPost ? FacebookPost[P] : never
  } 
      : FacebookPost


  type FacebookPostCountArgs = 
    Omit<FacebookPostFindManyArgs, 'select' | 'include'> & {
      select?: FacebookPostCountAggregateInputType | true
    }

  export interface FacebookPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookPost that matches the filter.
     * @param {FacebookPostFindUniqueArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookPost'> extends True ? Prisma__FacebookPostClient<FacebookPostGetPayload<T>> : Prisma__FacebookPostClient<FacebookPostGetPayload<T> | null, null>

    /**
     * Find one FacebookPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookPostFindUniqueOrThrowArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookPostFindUniqueOrThrowArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Find the first FacebookPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindFirstArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookPost'> extends True ? Prisma__FacebookPostClient<FacebookPostGetPayload<T>> : Prisma__FacebookPostClient<FacebookPostGetPayload<T> | null, null>

    /**
     * Find the first FacebookPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindFirstOrThrowArgs} args - Arguments to find a FacebookPost
     * @example
     * // Get one FacebookPost
     * const facebookPost = await prisma.facebookPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookPostFindFirstOrThrowArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Find zero or more FacebookPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookPosts
     * const facebookPosts = await prisma.facebookPost.findMany()
     * 
     * // Get first 10 FacebookPosts
     * const facebookPosts = await prisma.facebookPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookPostWithIdOnly = await prisma.facebookPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookPostFindManyArgs>(
      args?: SelectSubset<T, FacebookPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookPostGetPayload<T>>>

    /**
     * Create a FacebookPost.
     * @param {FacebookPostCreateArgs} args - Arguments to create a FacebookPost.
     * @example
     * // Create one FacebookPost
     * const FacebookPost = await prisma.facebookPost.create({
     *   data: {
     *     // ... data to create a FacebookPost
     *   }
     * })
     * 
    **/
    create<T extends FacebookPostCreateArgs>(
      args: SelectSubset<T, FacebookPostCreateArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Create many FacebookPosts.
     *     @param {FacebookPostCreateManyArgs} args - Arguments to create many FacebookPosts.
     *     @example
     *     // Create many FacebookPosts
     *     const facebookPost = await prisma.facebookPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookPostCreateManyArgs>(
      args?: SelectSubset<T, FacebookPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookPost.
     * @param {FacebookPostDeleteArgs} args - Arguments to delete one FacebookPost.
     * @example
     * // Delete one FacebookPost
     * const FacebookPost = await prisma.facebookPost.delete({
     *   where: {
     *     // ... filter to delete one FacebookPost
     *   }
     * })
     * 
    **/
    delete<T extends FacebookPostDeleteArgs>(
      args: SelectSubset<T, FacebookPostDeleteArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Update one FacebookPost.
     * @param {FacebookPostUpdateArgs} args - Arguments to update one FacebookPost.
     * @example
     * // Update one FacebookPost
     * const facebookPost = await prisma.facebookPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookPostUpdateArgs>(
      args: SelectSubset<T, FacebookPostUpdateArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Delete zero or more FacebookPosts.
     * @param {FacebookPostDeleteManyArgs} args - Arguments to filter FacebookPosts to delete.
     * @example
     * // Delete a few FacebookPosts
     * const { count } = await prisma.facebookPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookPostDeleteManyArgs>(
      args?: SelectSubset<T, FacebookPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookPosts
     * const facebookPost = await prisma.facebookPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookPostUpdateManyArgs>(
      args: SelectSubset<T, FacebookPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookPost.
     * @param {FacebookPostUpsertArgs} args - Arguments to update or create a FacebookPost.
     * @example
     * // Update or create a FacebookPost
     * const facebookPost = await prisma.facebookPost.upsert({
     *   create: {
     *     // ... data to create a FacebookPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookPost we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookPostUpsertArgs>(
      args: SelectSubset<T, FacebookPostUpsertArgs>
    ): Prisma__FacebookPostClient<FacebookPostGetPayload<T>>

    /**
     * Count the number of FacebookPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostCountArgs} args - Arguments to filter FacebookPosts to count.
     * @example
     * // Count the number of FacebookPosts
     * const count = await prisma.facebookPost.count({
     *   where: {
     *     // ... the filter for the FacebookPosts we want to count
     *   }
     * })
    **/
    count<T extends FacebookPostCountArgs>(
      args?: Subset<T, FacebookPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookPostAggregateArgs>(args: Subset<T, FacebookPostAggregateArgs>): Prisma.PrismaPromise<GetFacebookPostAggregateType<T>>

    /**
     * Group by FacebookPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookPostGroupByArgs['orderBy'] }
        : { orderBy?: FacebookPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    location<T extends FacebookLocationArgs= {}>(args?: Subset<T, FacebookLocationArgs>): Prisma__FacebookLocationClient<FacebookLocationGetPayload<T> | Null>;

    hashtag<T extends FacebookHashtagArgs= {}>(args?: Subset<T, FacebookHashtagArgs>): Prisma__FacebookHashtagClient<FacebookHashtagGetPayload<T> | Null>;

    share<T extends FacebookShareTypeArgs= {}>(args?: Subset<T, FacebookShareTypeArgs>): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T> | Null>;

    likes<T extends FacebookPost$likesArgs= {}>(args?: Subset<T, FacebookPost$likesArgs>): Prisma.PrismaPromise<Array<FacebookLikeGetPayload<T>>| Null>;

    commentPosts<T extends FacebookPost$commentPostsArgs= {}>(args?: Subset<T, FacebookPost$commentPostsArgs>): Prisma.PrismaPromise<Array<FacebookCommentPostGetPayload<T>>| Null>;

    postDestionations<T extends FacebookPost$postDestionationsArgs= {}>(args?: Subset<T, FacebookPost$postDestionationsArgs>): Prisma.PrismaPromise<Array<FacebookPostDestinationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookPost base type for findUnique actions
   */
  export type FacebookPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where: FacebookPostWhereUniqueInput
  }

  /**
   * FacebookPost findUnique
   */
  export interface FacebookPostFindUniqueArgs extends FacebookPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookPost findUniqueOrThrow
   */
  export type FacebookPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where: FacebookPostWhereUniqueInput
  }


  /**
   * FacebookPost base type for findFirst actions
   */
  export type FacebookPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPosts.
     */
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }

  /**
   * FacebookPost findFirst
   */
  export interface FacebookPostFindFirstArgs extends FacebookPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookPost findFirstOrThrow
   */
  export type FacebookPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter, which FacebookPost to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookPosts.
     */
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookPost findMany
   */
  export type FacebookPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter, which FacebookPosts to fetch.
     */
    where?: FacebookPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookPosts to fetch.
     */
    orderBy?: Enumerable<FacebookPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookPosts.
     */
    cursor?: FacebookPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookPosts.
     */
    skip?: number
    distinct?: Enumerable<FacebookPostScalarFieldEnum>
  }


  /**
   * FacebookPost create
   */
  export type FacebookPostCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * The data needed to create a FacebookPost.
     */
    data: XOR<FacebookPostCreateInput, FacebookPostUncheckedCreateInput>
  }


  /**
   * FacebookPost createMany
   */
  export type FacebookPostCreateManyArgs = {
    /**
     * The data used to create many FacebookPosts.
     */
    data: Enumerable<FacebookPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookPost update
   */
  export type FacebookPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * The data needed to update a FacebookPost.
     */
    data: XOR<FacebookPostUpdateInput, FacebookPostUncheckedUpdateInput>
    /**
     * Choose, which FacebookPost to update.
     */
    where: FacebookPostWhereUniqueInput
  }


  /**
   * FacebookPost updateMany
   */
  export type FacebookPostUpdateManyArgs = {
    /**
     * The data used to update FacebookPosts.
     */
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyInput>
    /**
     * Filter which FacebookPosts to update
     */
    where?: FacebookPostWhereInput
  }


  /**
   * FacebookPost upsert
   */
  export type FacebookPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * The filter to search for the FacebookPost to update in case it exists.
     */
    where: FacebookPostWhereUniqueInput
    /**
     * In case the FacebookPost found by the `where` argument doesn't exist, create a new FacebookPost with this data.
     */
    create: XOR<FacebookPostCreateInput, FacebookPostUncheckedCreateInput>
    /**
     * In case the FacebookPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookPostUpdateInput, FacebookPostUncheckedUpdateInput>
  }


  /**
   * FacebookPost delete
   */
  export type FacebookPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
    /**
     * Filter which FacebookPost to delete.
     */
    where: FacebookPostWhereUniqueInput
  }


  /**
   * FacebookPost deleteMany
   */
  export type FacebookPostDeleteManyArgs = {
    /**
     * Filter which FacebookPosts to delete
     */
    where?: FacebookPostWhereInput
  }


  /**
   * FacebookPost.likes
   */
  export type FacebookPost$likesArgs = {
    /**
     * Select specific fields to fetch from the FacebookLike
     */
    select?: FacebookLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookLikeInclude | null
    where?: FacebookLikeWhereInput
    orderBy?: Enumerable<FacebookLikeOrderByWithRelationInput>
    cursor?: FacebookLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookLikeScalarFieldEnum>
  }


  /**
   * FacebookPost.commentPosts
   */
  export type FacebookPost$commentPostsArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    where?: FacebookCommentPostWhereInput
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    cursor?: FacebookCommentPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookPost.postDestionations
   */
  export type FacebookPost$postDestionationsArgs = {
    /**
     * Select specific fields to fetch from the FacebookPostDestination
     */
    select?: FacebookPostDestinationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostDestinationInclude | null
    where?: FacebookPostDestinationWhereInput
    orderBy?: Enumerable<FacebookPostDestinationOrderByWithRelationInput>
    cursor?: FacebookPostDestinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookPostDestinationScalarFieldEnum>
  }


  /**
   * FacebookPost without action
   */
  export type FacebookPostArgs = {
    /**
     * Select specific fields to fetch from the FacebookPost
     */
    select?: FacebookPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookPostInclude | null
  }



  /**
   * Model FacebookCommentPost
   */


  export type AggregateFacebookCommentPost = {
    _count: FacebookCommentPostCountAggregateOutputType | null
    _avg: FacebookCommentPostAvgAggregateOutputType | null
    _sum: FacebookCommentPostSumAggregateOutputType | null
    _min: FacebookCommentPostMinAggregateOutputType | null
    _max: FacebookCommentPostMaxAggregateOutputType | null
  }

  export type FacebookCommentPostAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    commentToId: number | null
    shareToId: number | null
  }

  export type FacebookCommentPostSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    commentToId: number | null
    shareToId: number | null
  }

  export type FacebookCommentPostMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    message: string | null
    image: string | null
    commentToId: number | null
    shareToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookCommentPostMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    message: string | null
    image: string | null
    commentToId: number | null
    shareToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacebookCommentPostCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    message: number
    image: number
    commentToId: number
    shareToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacebookCommentPostAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    commentToId?: true
    shareToId?: true
  }

  export type FacebookCommentPostSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    commentToId?: true
    shareToId?: true
  }

  export type FacebookCommentPostMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    message?: true
    image?: true
    commentToId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookCommentPostMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    message?: true
    image?: true
    commentToId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacebookCommentPostCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    message?: true
    image?: true
    commentToId?: true
    shareToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacebookCommentPostAggregateArgs = {
    /**
     * Filter which FacebookCommentPost to aggregate.
     */
    where?: FacebookCommentPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCommentPosts to fetch.
     */
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacebookCommentPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCommentPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCommentPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacebookCommentPosts
    **/
    _count?: true | FacebookCommentPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacebookCommentPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacebookCommentPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacebookCommentPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacebookCommentPostMaxAggregateInputType
  }

  export type GetFacebookCommentPostAggregateType<T extends FacebookCommentPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFacebookCommentPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacebookCommentPost[P]>
      : GetScalarType<T[P], AggregateFacebookCommentPost[P]>
  }




  export type FacebookCommentPostGroupByArgs = {
    where?: FacebookCommentPostWhereInput
    orderBy?: Enumerable<FacebookCommentPostOrderByWithAggregationInput>
    by: FacebookCommentPostScalarFieldEnum[]
    having?: FacebookCommentPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacebookCommentPostCountAggregateInputType | true
    _avg?: FacebookCommentPostAvgAggregateInputType
    _sum?: FacebookCommentPostSumAggregateInputType
    _min?: FacebookCommentPostMinAggregateInputType
    _max?: FacebookCommentPostMaxAggregateInputType
  }


  export type FacebookCommentPostGroupByOutputType = {
    id: number
    postId: number
    userId: number
    message: string | null
    image: string | null
    commentToId: number | null
    shareToId: number
    createdAt: Date
    updatedAt: Date
    _count: FacebookCommentPostCountAggregateOutputType | null
    _avg: FacebookCommentPostAvgAggregateOutputType | null
    _sum: FacebookCommentPostSumAggregateOutputType | null
    _min: FacebookCommentPostMinAggregateOutputType | null
    _max: FacebookCommentPostMaxAggregateOutputType | null
  }

  type GetFacebookCommentPostGroupByPayload<T extends FacebookCommentPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FacebookCommentPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacebookCommentPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacebookCommentPostGroupByOutputType[P]>
            : GetScalarType<T[P], FacebookCommentPostGroupByOutputType[P]>
        }
      >
    >


  export type FacebookCommentPostSelect = {
    id?: boolean
    post?: boolean | FacebookPostArgs
    postId?: boolean
    user?: boolean | FacebookUserArgs
    userId?: boolean
    message?: boolean
    image?: boolean
    commentTo?: boolean | FacebookCommentPostArgs
    commentToId?: boolean
    share?: boolean | FacebookShareTypeArgs
    shareToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commentPosts?: boolean | FacebookCommentPost$commentPostsArgs
    _count?: boolean | FacebookCommentPostCountOutputTypeArgs
  }


  export type FacebookCommentPostInclude = {
    post?: boolean | FacebookPostArgs
    user?: boolean | FacebookUserArgs
    commentTo?: boolean | FacebookCommentPostArgs
    share?: boolean | FacebookShareTypeArgs
    commentPosts?: boolean | FacebookCommentPost$commentPostsArgs
    _count?: boolean | FacebookCommentPostCountOutputTypeArgs
  }

  export type FacebookCommentPostGetPayload<S extends boolean | null | undefined | FacebookCommentPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FacebookCommentPost :
    S extends undefined ? never :
    S extends { include: any } & (FacebookCommentPostArgs | FacebookCommentPostFindManyArgs)
    ? FacebookCommentPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? FacebookPostGetPayload<S['include'][P]> :
        P extends 'user' ? FacebookUserGetPayload<S['include'][P]> :
        P extends 'commentTo' ? FacebookCommentPostGetPayload<S['include'][P]> | null :
        P extends 'share' ? FacebookShareTypeGetPayload<S['include'][P]> :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? FacebookCommentPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FacebookCommentPostArgs | FacebookCommentPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? FacebookPostGetPayload<S['select'][P]> :
        P extends 'user' ? FacebookUserGetPayload<S['select'][P]> :
        P extends 'commentTo' ? FacebookCommentPostGetPayload<S['select'][P]> | null :
        P extends 'share' ? FacebookShareTypeGetPayload<S['select'][P]> :
        P extends 'commentPosts' ? Array < FacebookCommentPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? FacebookCommentPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FacebookCommentPost ? FacebookCommentPost[P] : never
  } 
      : FacebookCommentPost


  type FacebookCommentPostCountArgs = 
    Omit<FacebookCommentPostFindManyArgs, 'select' | 'include'> & {
      select?: FacebookCommentPostCountAggregateInputType | true
    }

  export interface FacebookCommentPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FacebookCommentPost that matches the filter.
     * @param {FacebookCommentPostFindUniqueArgs} args - Arguments to find a FacebookCommentPost
     * @example
     * // Get one FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacebookCommentPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FacebookCommentPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FacebookCommentPost'> extends True ? Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>> : Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T> | null, null>

    /**
     * Find one FacebookCommentPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacebookCommentPostFindUniqueOrThrowArgs} args - Arguments to find a FacebookCommentPost
     * @example
     * // Get one FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacebookCommentPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FacebookCommentPostFindUniqueOrThrowArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Find the first FacebookCommentPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostFindFirstArgs} args - Arguments to find a FacebookCommentPost
     * @example
     * // Get one FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacebookCommentPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FacebookCommentPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FacebookCommentPost'> extends True ? Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>> : Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T> | null, null>

    /**
     * Find the first FacebookCommentPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostFindFirstOrThrowArgs} args - Arguments to find a FacebookCommentPost
     * @example
     * // Get one FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacebookCommentPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacebookCommentPostFindFirstOrThrowArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Find zero or more FacebookCommentPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacebookCommentPosts
     * const facebookCommentPosts = await prisma.facebookCommentPost.findMany()
     * 
     * // Get first 10 FacebookCommentPosts
     * const facebookCommentPosts = await prisma.facebookCommentPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facebookCommentPostWithIdOnly = await prisma.facebookCommentPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacebookCommentPostFindManyArgs>(
      args?: SelectSubset<T, FacebookCommentPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<FacebookCommentPostGetPayload<T>>>

    /**
     * Create a FacebookCommentPost.
     * @param {FacebookCommentPostCreateArgs} args - Arguments to create a FacebookCommentPost.
     * @example
     * // Create one FacebookCommentPost
     * const FacebookCommentPost = await prisma.facebookCommentPost.create({
     *   data: {
     *     // ... data to create a FacebookCommentPost
     *   }
     * })
     * 
    **/
    create<T extends FacebookCommentPostCreateArgs>(
      args: SelectSubset<T, FacebookCommentPostCreateArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Create many FacebookCommentPosts.
     *     @param {FacebookCommentPostCreateManyArgs} args - Arguments to create many FacebookCommentPosts.
     *     @example
     *     // Create many FacebookCommentPosts
     *     const facebookCommentPost = await prisma.facebookCommentPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacebookCommentPostCreateManyArgs>(
      args?: SelectSubset<T, FacebookCommentPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FacebookCommentPost.
     * @param {FacebookCommentPostDeleteArgs} args - Arguments to delete one FacebookCommentPost.
     * @example
     * // Delete one FacebookCommentPost
     * const FacebookCommentPost = await prisma.facebookCommentPost.delete({
     *   where: {
     *     // ... filter to delete one FacebookCommentPost
     *   }
     * })
     * 
    **/
    delete<T extends FacebookCommentPostDeleteArgs>(
      args: SelectSubset<T, FacebookCommentPostDeleteArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Update one FacebookCommentPost.
     * @param {FacebookCommentPostUpdateArgs} args - Arguments to update one FacebookCommentPost.
     * @example
     * // Update one FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacebookCommentPostUpdateArgs>(
      args: SelectSubset<T, FacebookCommentPostUpdateArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Delete zero or more FacebookCommentPosts.
     * @param {FacebookCommentPostDeleteManyArgs} args - Arguments to filter FacebookCommentPosts to delete.
     * @example
     * // Delete a few FacebookCommentPosts
     * const { count } = await prisma.facebookCommentPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacebookCommentPostDeleteManyArgs>(
      args?: SelectSubset<T, FacebookCommentPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacebookCommentPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacebookCommentPosts
     * const facebookCommentPost = await prisma.facebookCommentPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacebookCommentPostUpdateManyArgs>(
      args: SelectSubset<T, FacebookCommentPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacebookCommentPost.
     * @param {FacebookCommentPostUpsertArgs} args - Arguments to update or create a FacebookCommentPost.
     * @example
     * // Update or create a FacebookCommentPost
     * const facebookCommentPost = await prisma.facebookCommentPost.upsert({
     *   create: {
     *     // ... data to create a FacebookCommentPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacebookCommentPost we want to update
     *   }
     * })
    **/
    upsert<T extends FacebookCommentPostUpsertArgs>(
      args: SelectSubset<T, FacebookCommentPostUpsertArgs>
    ): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T>>

    /**
     * Count the number of FacebookCommentPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostCountArgs} args - Arguments to filter FacebookCommentPosts to count.
     * @example
     * // Count the number of FacebookCommentPosts
     * const count = await prisma.facebookCommentPost.count({
     *   where: {
     *     // ... the filter for the FacebookCommentPosts we want to count
     *   }
     * })
    **/
    count<T extends FacebookCommentPostCountArgs>(
      args?: Subset<T, FacebookCommentPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacebookCommentPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacebookCommentPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacebookCommentPostAggregateArgs>(args: Subset<T, FacebookCommentPostAggregateArgs>): Prisma.PrismaPromise<GetFacebookCommentPostAggregateType<T>>

    /**
     * Group by FacebookCommentPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacebookCommentPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacebookCommentPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacebookCommentPostGroupByArgs['orderBy'] }
        : { orderBy?: FacebookCommentPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacebookCommentPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacebookCommentPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FacebookCommentPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FacebookCommentPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends FacebookPostArgs= {}>(args?: Subset<T, FacebookPostArgs>): Prisma__FacebookPostClient<FacebookPostGetPayload<T> | Null>;

    user<T extends FacebookUserArgs= {}>(args?: Subset<T, FacebookUserArgs>): Prisma__FacebookUserClient<FacebookUserGetPayload<T> | Null>;

    commentTo<T extends FacebookCommentPostArgs= {}>(args?: Subset<T, FacebookCommentPostArgs>): Prisma__FacebookCommentPostClient<FacebookCommentPostGetPayload<T> | Null>;

    share<T extends FacebookShareTypeArgs= {}>(args?: Subset<T, FacebookShareTypeArgs>): Prisma__FacebookShareTypeClient<FacebookShareTypeGetPayload<T> | Null>;

    commentPosts<T extends FacebookCommentPost$commentPostsArgs= {}>(args?: Subset<T, FacebookCommentPost$commentPostsArgs>): Prisma.PrismaPromise<Array<FacebookCommentPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FacebookCommentPost base type for findUnique actions
   */
  export type FacebookCommentPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter, which FacebookCommentPost to fetch.
     */
    where: FacebookCommentPostWhereUniqueInput
  }

  /**
   * FacebookCommentPost findUnique
   */
  export interface FacebookCommentPostFindUniqueArgs extends FacebookCommentPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookCommentPost findUniqueOrThrow
   */
  export type FacebookCommentPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter, which FacebookCommentPost to fetch.
     */
    where: FacebookCommentPostWhereUniqueInput
  }


  /**
   * FacebookCommentPost base type for findFirst actions
   */
  export type FacebookCommentPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter, which FacebookCommentPost to fetch.
     */
    where?: FacebookCommentPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCommentPosts to fetch.
     */
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookCommentPosts.
     */
    cursor?: FacebookCommentPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCommentPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCommentPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookCommentPosts.
     */
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }

  /**
   * FacebookCommentPost findFirst
   */
  export interface FacebookCommentPostFindFirstArgs extends FacebookCommentPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FacebookCommentPost findFirstOrThrow
   */
  export type FacebookCommentPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter, which FacebookCommentPost to fetch.
     */
    where?: FacebookCommentPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCommentPosts to fetch.
     */
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacebookCommentPosts.
     */
    cursor?: FacebookCommentPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCommentPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCommentPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacebookCommentPosts.
     */
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookCommentPost findMany
   */
  export type FacebookCommentPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter, which FacebookCommentPosts to fetch.
     */
    where?: FacebookCommentPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacebookCommentPosts to fetch.
     */
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacebookCommentPosts.
     */
    cursor?: FacebookCommentPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacebookCommentPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacebookCommentPosts.
     */
    skip?: number
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookCommentPost create
   */
  export type FacebookCommentPostCreateArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * The data needed to create a FacebookCommentPost.
     */
    data: XOR<FacebookCommentPostCreateInput, FacebookCommentPostUncheckedCreateInput>
  }


  /**
   * FacebookCommentPost createMany
   */
  export type FacebookCommentPostCreateManyArgs = {
    /**
     * The data used to create many FacebookCommentPosts.
     */
    data: Enumerable<FacebookCommentPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FacebookCommentPost update
   */
  export type FacebookCommentPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * The data needed to update a FacebookCommentPost.
     */
    data: XOR<FacebookCommentPostUpdateInput, FacebookCommentPostUncheckedUpdateInput>
    /**
     * Choose, which FacebookCommentPost to update.
     */
    where: FacebookCommentPostWhereUniqueInput
  }


  /**
   * FacebookCommentPost updateMany
   */
  export type FacebookCommentPostUpdateManyArgs = {
    /**
     * The data used to update FacebookCommentPosts.
     */
    data: XOR<FacebookCommentPostUpdateManyMutationInput, FacebookCommentPostUncheckedUpdateManyInput>
    /**
     * Filter which FacebookCommentPosts to update
     */
    where?: FacebookCommentPostWhereInput
  }


  /**
   * FacebookCommentPost upsert
   */
  export type FacebookCommentPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * The filter to search for the FacebookCommentPost to update in case it exists.
     */
    where: FacebookCommentPostWhereUniqueInput
    /**
     * In case the FacebookCommentPost found by the `where` argument doesn't exist, create a new FacebookCommentPost with this data.
     */
    create: XOR<FacebookCommentPostCreateInput, FacebookCommentPostUncheckedCreateInput>
    /**
     * In case the FacebookCommentPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacebookCommentPostUpdateInput, FacebookCommentPostUncheckedUpdateInput>
  }


  /**
   * FacebookCommentPost delete
   */
  export type FacebookCommentPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    /**
     * Filter which FacebookCommentPost to delete.
     */
    where: FacebookCommentPostWhereUniqueInput
  }


  /**
   * FacebookCommentPost deleteMany
   */
  export type FacebookCommentPostDeleteManyArgs = {
    /**
     * Filter which FacebookCommentPosts to delete
     */
    where?: FacebookCommentPostWhereInput
  }


  /**
   * FacebookCommentPost.commentPosts
   */
  export type FacebookCommentPost$commentPostsArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
    where?: FacebookCommentPostWhereInput
    orderBy?: Enumerable<FacebookCommentPostOrderByWithRelationInput>
    cursor?: FacebookCommentPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FacebookCommentPostScalarFieldEnum>
  }


  /**
   * FacebookCommentPost without action
   */
  export type FacebookCommentPostArgs = {
    /**
     * Select specific fields to fetch from the FacebookCommentPost
     */
    select?: FacebookCommentPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacebookCommentPostInclude | null
  }



  /**
   * Model TwitterUser
   */


  export type AggregateTwitterUser = {
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  export type TwitterUserAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterUserMinAggregateOutputType = {
    id: number | null
    username: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserCountAggregateOutputType = {
    id: number
    username: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterUserAvgAggregateInputType = {
    id?: true
  }

  export type TwitterUserSumAggregateInputType = {
    id?: true
  }

  export type TwitterUserMinAggregateInputType = {
    id?: true
    username?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserMaxAggregateInputType = {
    id?: true
    username?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserCountAggregateInputType = {
    id?: true
    username?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterUserAggregateArgs = {
    /**
     * Filter which TwitterUser to aggregate.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUsers
    **/
    _count?: true | TwitterUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterUserMaxAggregateInputType
  }

  export type GetTwitterUserAggregateType<T extends TwitterUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUser[P]>
      : GetScalarType<T[P], AggregateTwitterUser[P]>
  }




  export type TwitterUserGroupByArgs = {
    where?: TwitterUserWhereInput
    orderBy?: Enumerable<TwitterUserOrderByWithAggregationInput>
    by: TwitterUserScalarFieldEnum[]
    having?: TwitterUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterUserCountAggregateInputType | true
    _avg?: TwitterUserAvgAggregateInputType
    _sum?: TwitterUserSumAggregateInputType
    _min?: TwitterUserMinAggregateInputType
    _max?: TwitterUserMaxAggregateInputType
  }


  export type TwitterUserGroupByOutputType = {
    id: number
    username: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwitterUserCountAggregateOutputType | null
    _avg: TwitterUserAvgAggregateOutputType | null
    _sum: TwitterUserSumAggregateOutputType | null
    _min: TwitterUserMinAggregateOutputType | null
    _max: TwitterUserMaxAggregateOutputType | null
  }

  type GetTwitterUserGroupByPayload<T extends TwitterUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterUserGroupByOutputType[P]>
        }
      >
    >


  export type TwitterUserSelect = {
    id?: boolean
    username?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | TwitterUser$postsArgs
    followings?: boolean | TwitterUser$followingsArgs
    followers?: boolean | TwitterUser$followersArgs
    replyPosts?: boolean | TwitterUser$replyPostsArgs
    directMessageFrom?: boolean | TwitterUser$directMessageFromArgs
    directMessageTo?: boolean | TwitterUser$directMessageToArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }


  export type TwitterUserInclude = {
    posts?: boolean | TwitterUser$postsArgs
    followings?: boolean | TwitterUser$followingsArgs
    followers?: boolean | TwitterUser$followersArgs
    replyPosts?: boolean | TwitterUser$replyPostsArgs
    directMessageFrom?: boolean | TwitterUser$directMessageFromArgs
    directMessageTo?: boolean | TwitterUser$directMessageToArgs
    _count?: boolean | TwitterUserCountOutputTypeArgs
  }

  export type TwitterUserGetPayload<S extends boolean | null | undefined | TwitterUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUser :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
    ? TwitterUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'posts' ? Array < TwitterPostGetPayload<S['include'][P]>>  :
        P extends 'followings' ? Array < TwitterUserRelationshipGetPayload<S['include'][P]>>  :
        P extends 'followers' ? Array < TwitterUserRelationshipGetPayload<S['include'][P]>>  :
        P extends 'replyPosts' ? Array < TwitterReplyPostGetPayload<S['include'][P]>>  :
        P extends 'directMessageFrom' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends 'directMessageTo' ? Array < TwitterDirectMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterUserArgs | TwitterUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'posts' ? Array < TwitterPostGetPayload<S['select'][P]>>  :
        P extends 'followings' ? Array < TwitterUserRelationshipGetPayload<S['select'][P]>>  :
        P extends 'followers' ? Array < TwitterUserRelationshipGetPayload<S['select'][P]>>  :
        P extends 'replyPosts' ? Array < TwitterReplyPostGetPayload<S['select'][P]>>  :
        P extends 'directMessageFrom' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends 'directMessageTo' ? Array < TwitterDirectMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterUser ? TwitterUser[P] : never
  } 
      : TwitterUser


  type TwitterUserCountArgs = 
    Omit<TwitterUserFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserCountAggregateInputType | true
    }

  export interface TwitterUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterUser that matches the filter.
     * @param {TwitterUserFindUniqueArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find one TwitterUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterUserFindUniqueOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindUniqueOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find the first TwitterUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUser'> extends True ? Prisma__TwitterUserClient<TwitterUserGetPayload<T>> : Prisma__TwitterUserClient<TwitterUserGetPayload<T> | null, null>

    /**
     * Find the first TwitterUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindFirstOrThrowArgs} args - Arguments to find a TwitterUser
     * @example
     * // Get one TwitterUser
     * const twitterUser = await prisma.twitterUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserFindFirstOrThrowArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Find zero or more TwitterUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany()
     * 
     * // Get first 10 TwitterUsers
     * const twitterUsers = await prisma.twitterUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserWithIdOnly = await prisma.twitterUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserFindManyArgs>(
      args?: SelectSubset<T, TwitterUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterUserGetPayload<T>>>

    /**
     * Create a TwitterUser.
     * @param {TwitterUserCreateArgs} args - Arguments to create a TwitterUser.
     * @example
     * // Create one TwitterUser
     * const TwitterUser = await prisma.twitterUser.create({
     *   data: {
     *     // ... data to create a TwitterUser
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserCreateArgs>(
      args: SelectSubset<T, TwitterUserCreateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Create many TwitterUsers.
     *     @param {TwitterUserCreateManyArgs} args - Arguments to create many TwitterUsers.
     *     @example
     *     // Create many TwitterUsers
     *     const twitterUser = await prisma.twitterUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterUserCreateManyArgs>(
      args?: SelectSubset<T, TwitterUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterUser.
     * @param {TwitterUserDeleteArgs} args - Arguments to delete one TwitterUser.
     * @example
     * // Delete one TwitterUser
     * const TwitterUser = await prisma.twitterUser.delete({
     *   where: {
     *     // ... filter to delete one TwitterUser
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserDeleteArgs>(
      args: SelectSubset<T, TwitterUserDeleteArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Update one TwitterUser.
     * @param {TwitterUserUpdateArgs} args - Arguments to update one TwitterUser.
     * @example
     * // Update one TwitterUser
     * const twitterUser = await prisma.twitterUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserUpdateArgs>(
      args: SelectSubset<T, TwitterUserUpdateArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Delete zero or more TwitterUsers.
     * @param {TwitterUserDeleteManyArgs} args - Arguments to filter TwitterUsers to delete.
     * @example
     * // Delete a few TwitterUsers
     * const { count } = await prisma.twitterUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUsers
     * const twitterUser = await prisma.twitterUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterUser.
     * @param {TwitterUserUpsertArgs} args - Arguments to update or create a TwitterUser.
     * @example
     * // Update or create a TwitterUser
     * const twitterUser = await prisma.twitterUser.upsert({
     *   create: {
     *     // ... data to create a TwitterUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUser we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserUpsertArgs>(
      args: SelectSubset<T, TwitterUserUpsertArgs>
    ): Prisma__TwitterUserClient<TwitterUserGetPayload<T>>

    /**
     * Count the number of TwitterUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserCountArgs} args - Arguments to filter TwitterUsers to count.
     * @example
     * // Count the number of TwitterUsers
     * const count = await prisma.twitterUser.count({
     *   where: {
     *     // ... the filter for the TwitterUsers we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserCountArgs>(
      args?: Subset<T, TwitterUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserAggregateArgs>(args: Subset<T, TwitterUserAggregateArgs>): Prisma.PrismaPromise<GetTwitterUserAggregateType<T>>

    /**
     * Group by TwitterUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterUserGroupByArgs['orderBy'] }
        : { orderBy?: TwitterUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    posts<T extends TwitterUser$postsArgs= {}>(args?: Subset<T, TwitterUser$postsArgs>): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>| Null>;

    followings<T extends TwitterUser$followingsArgs= {}>(args?: Subset<T, TwitterUser$followingsArgs>): Prisma.PrismaPromise<Array<TwitterUserRelationshipGetPayload<T>>| Null>;

    followers<T extends TwitterUser$followersArgs= {}>(args?: Subset<T, TwitterUser$followersArgs>): Prisma.PrismaPromise<Array<TwitterUserRelationshipGetPayload<T>>| Null>;

    replyPosts<T extends TwitterUser$replyPostsArgs= {}>(args?: Subset<T, TwitterUser$replyPostsArgs>): Prisma.PrismaPromise<Array<TwitterReplyPostGetPayload<T>>| Null>;

    directMessageFrom<T extends TwitterUser$directMessageFromArgs= {}>(args?: Subset<T, TwitterUser$directMessageFromArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    directMessageTo<T extends TwitterUser$directMessageToArgs= {}>(args?: Subset<T, TwitterUser$directMessageToArgs>): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterUser base type for findUnique actions
   */
  export type TwitterUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }

  /**
   * TwitterUser findUnique
   */
  export interface TwitterUserFindUniqueArgs extends TwitterUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findUniqueOrThrow
   */
  export type TwitterUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser base type for findFirst actions
   */
  export type TwitterUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }

  /**
   * TwitterUser findFirst
   */
  export interface TwitterUserFindFirstArgs extends TwitterUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUser findFirstOrThrow
   */
  export type TwitterUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUser to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUsers.
     */
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser findMany
   */
  export type TwitterUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter, which TwitterUsers to fetch.
     */
    where?: TwitterUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUsers to fetch.
     */
    orderBy?: Enumerable<TwitterUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUsers.
     */
    cursor?: TwitterUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUsers.
     */
    skip?: number
    distinct?: Enumerable<TwitterUserScalarFieldEnum>
  }


  /**
   * TwitterUser create
   */
  export type TwitterUserCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to create a TwitterUser.
     */
    data: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
  }


  /**
   * TwitterUser createMany
   */
  export type TwitterUserCreateManyArgs = {
    /**
     * The data used to create many TwitterUsers.
     */
    data: Enumerable<TwitterUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterUser update
   */
  export type TwitterUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The data needed to update a TwitterUser.
     */
    data: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
    /**
     * Choose, which TwitterUser to update.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser updateMany
   */
  export type TwitterUserUpdateManyArgs = {
    /**
     * The data used to update TwitterUsers.
     */
    data: XOR<TwitterUserUpdateManyMutationInput, TwitterUserUncheckedUpdateManyInput>
    /**
     * Filter which TwitterUsers to update
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser upsert
   */
  export type TwitterUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * The filter to search for the TwitterUser to update in case it exists.
     */
    where: TwitterUserWhereUniqueInput
    /**
     * In case the TwitterUser found by the `where` argument doesn't exist, create a new TwitterUser with this data.
     */
    create: XOR<TwitterUserCreateInput, TwitterUserUncheckedCreateInput>
    /**
     * In case the TwitterUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterUserUpdateInput, TwitterUserUncheckedUpdateInput>
  }


  /**
   * TwitterUser delete
   */
  export type TwitterUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
    /**
     * Filter which TwitterUser to delete.
     */
    where: TwitterUserWhereUniqueInput
  }


  /**
   * TwitterUser deleteMany
   */
  export type TwitterUserDeleteManyArgs = {
    /**
     * Filter which TwitterUsers to delete
     */
    where?: TwitterUserWhereInput
  }


  /**
   * TwitterUser.posts
   */
  export type TwitterUser$postsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    cursor?: TwitterPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterUser.followings
   */
  export type TwitterUser$followingsArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    where?: TwitterUserRelationshipWhereInput
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    cursor?: TwitterUserRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterUserRelationshipScalarFieldEnum>
  }


  /**
   * TwitterUser.followers
   */
  export type TwitterUser$followersArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    where?: TwitterUserRelationshipWhereInput
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    cursor?: TwitterUserRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterUserRelationshipScalarFieldEnum>
  }


  /**
   * TwitterUser.replyPosts
   */
  export type TwitterUser$replyPostsArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    where?: TwitterReplyPostWhereInput
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    cursor?: TwitterReplyPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterReplyPostScalarFieldEnum>
  }


  /**
   * TwitterUser.directMessageFrom
   */
  export type TwitterUser$directMessageFromArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser.directMessageTo
   */
  export type TwitterUser$directMessageToArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    cursor?: TwitterDirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterUser without action
   */
  export type TwitterUserArgs = {
    /**
     * Select specific fields to fetch from the TwitterUser
     */
    select?: TwitterUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserInclude | null
  }



  /**
   * Model TwitterPost
   */


  export type AggregateTwitterPost = {
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  export type TwitterPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwitterPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TwitterPostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterPostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwitterPostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TwitterPostMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterPostAggregateArgs = {
    /**
     * Filter which TwitterPost to aggregate.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPosts
    **/
    _count?: true | TwitterPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostMaxAggregateInputType
  }

  export type GetTwitterPostAggregateType<T extends TwitterPostAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPost[P]>
      : GetScalarType<T[P], AggregateTwitterPost[P]>
  }




  export type TwitterPostGroupByArgs = {
    where?: TwitterPostWhereInput
    orderBy?: Enumerable<TwitterPostOrderByWithAggregationInput>
    by: TwitterPostScalarFieldEnum[]
    having?: TwitterPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostCountAggregateInputType | true
    _avg?: TwitterPostAvgAggregateInputType
    _sum?: TwitterPostSumAggregateInputType
    _min?: TwitterPostMinAggregateInputType
    _max?: TwitterPostMaxAggregateInputType
  }


  export type TwitterPostGroupByOutputType = {
    id: number
    userId: number
    message: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwitterPostCountAggregateOutputType | null
    _avg: TwitterPostAvgAggregateOutputType | null
    _sum: TwitterPostSumAggregateOutputType | null
    _min: TwitterPostMinAggregateOutputType | null
    _max: TwitterPostMaxAggregateOutputType | null
  }

  type GetTwitterPostGroupByPayload<T extends TwitterPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostSelect = {
    id?: boolean
    user?: boolean | TwitterUserArgs
    userId?: boolean
    message?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postAndHashtags?: boolean | TwitterPost$postAndHashtagsArgs
    replyPosts?: boolean | TwitterPost$replyPostsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }


  export type TwitterPostInclude = {
    user?: boolean | TwitterUserArgs
    postAndHashtags?: boolean | TwitterPost$postAndHashtagsArgs
    replyPosts?: boolean | TwitterPost$replyPostsArgs
    _count?: boolean | TwitterPostCountOutputTypeArgs
  }

  export type TwitterPostGetPayload<S extends boolean | null | undefined | TwitterPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPost :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
    ? TwitterPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'postAndHashtags' ? Array < TwitterPostAndHashtagGetPayload<S['include'][P]>>  :
        P extends 'replyPosts' ? Array < TwitterReplyPostGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostArgs | TwitterPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'postAndHashtags' ? Array < TwitterPostAndHashtagGetPayload<S['select'][P]>>  :
        P extends 'replyPosts' ? Array < TwitterReplyPostGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterPost ? TwitterPost[P] : never
  } 
      : TwitterPost


  type TwitterPostCountArgs = 
    Omit<TwitterPostFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostCountAggregateInputType | true
    }

  export interface TwitterPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPost that matches the filter.
     * @param {TwitterPostFindUniqueArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find one TwitterPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostFindUniqueOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find the first TwitterPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPost'> extends True ? Prisma__TwitterPostClient<TwitterPostGetPayload<T>> : Prisma__TwitterPostClient<TwitterPostGetPayload<T> | null, null>

    /**
     * Find the first TwitterPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindFirstOrThrowArgs} args - Arguments to find a TwitterPost
     * @example
     * // Get one TwitterPost
     * const twitterPost = await prisma.twitterPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostFindFirstOrThrowArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Find zero or more TwitterPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany()
     * 
     * // Get first 10 TwitterPosts
     * const twitterPosts = await prisma.twitterPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostWithIdOnly = await prisma.twitterPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostFindManyArgs>(
      args?: SelectSubset<T, TwitterPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostGetPayload<T>>>

    /**
     * Create a TwitterPost.
     * @param {TwitterPostCreateArgs} args - Arguments to create a TwitterPost.
     * @example
     * // Create one TwitterPost
     * const TwitterPost = await prisma.twitterPost.create({
     *   data: {
     *     // ... data to create a TwitterPost
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostCreateArgs>(
      args: SelectSubset<T, TwitterPostCreateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Create many TwitterPosts.
     *     @param {TwitterPostCreateManyArgs} args - Arguments to create many TwitterPosts.
     *     @example
     *     // Create many TwitterPosts
     *     const twitterPost = await prisma.twitterPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPost.
     * @param {TwitterPostDeleteArgs} args - Arguments to delete one TwitterPost.
     * @example
     * // Delete one TwitterPost
     * const TwitterPost = await prisma.twitterPost.delete({
     *   where: {
     *     // ... filter to delete one TwitterPost
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostDeleteArgs>(
      args: SelectSubset<T, TwitterPostDeleteArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Update one TwitterPost.
     * @param {TwitterPostUpdateArgs} args - Arguments to update one TwitterPost.
     * @example
     * // Update one TwitterPost
     * const twitterPost = await prisma.twitterPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostUpdateArgs>(
      args: SelectSubset<T, TwitterPostUpdateArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Delete zero or more TwitterPosts.
     * @param {TwitterPostDeleteManyArgs} args - Arguments to filter TwitterPosts to delete.
     * @example
     * // Delete a few TwitterPosts
     * const { count } = await prisma.twitterPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPosts
     * const twitterPost = await prisma.twitterPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPost.
     * @param {TwitterPostUpsertArgs} args - Arguments to update or create a TwitterPost.
     * @example
     * // Update or create a TwitterPost
     * const twitterPost = await prisma.twitterPost.upsert({
     *   create: {
     *     // ... data to create a TwitterPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPost we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostUpsertArgs>(
      args: SelectSubset<T, TwitterPostUpsertArgs>
    ): Prisma__TwitterPostClient<TwitterPostGetPayload<T>>

    /**
     * Count the number of TwitterPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostCountArgs} args - Arguments to filter TwitterPosts to count.
     * @example
     * // Count the number of TwitterPosts
     * const count = await prisma.twitterPost.count({
     *   where: {
     *     // ... the filter for the TwitterPosts we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostCountArgs>(
      args?: Subset<T, TwitterPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostAggregateArgs>(args: Subset<T, TwitterPostAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostAggregateType<T>>

    /**
     * Group by TwitterPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    postAndHashtags<T extends TwitterPost$postAndHashtagsArgs= {}>(args?: Subset<T, TwitterPost$postAndHashtagsArgs>): Prisma.PrismaPromise<Array<TwitterPostAndHashtagGetPayload<T>>| Null>;

    replyPosts<T extends TwitterPost$replyPostsArgs= {}>(args?: Subset<T, TwitterPost$replyPostsArgs>): Prisma.PrismaPromise<Array<TwitterReplyPostGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPost base type for findUnique actions
   */
  export type TwitterPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }

  /**
   * TwitterPost findUnique
   */
  export interface TwitterPostFindUniqueArgs extends TwitterPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findUniqueOrThrow
   */
  export type TwitterPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost base type for findFirst actions
   */
  export type TwitterPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }

  /**
   * TwitterPost findFirst
   */
  export interface TwitterPostFindFirstArgs extends TwitterPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPost findFirstOrThrow
   */
  export type TwitterPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPost to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPosts.
     */
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost findMany
   */
  export type TwitterPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter, which TwitterPosts to fetch.
     */
    where?: TwitterPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPosts to fetch.
     */
    orderBy?: Enumerable<TwitterPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPosts.
     */
    cursor?: TwitterPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPosts.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostScalarFieldEnum>
  }


  /**
   * TwitterPost create
   */
  export type TwitterPostCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to create a TwitterPost.
     */
    data: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
  }


  /**
   * TwitterPost createMany
   */
  export type TwitterPostCreateManyArgs = {
    /**
     * The data used to create many TwitterPosts.
     */
    data: Enumerable<TwitterPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPost update
   */
  export type TwitterPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The data needed to update a TwitterPost.
     */
    data: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
    /**
     * Choose, which TwitterPost to update.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost updateMany
   */
  export type TwitterPostUpdateManyArgs = {
    /**
     * The data used to update TwitterPosts.
     */
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPosts to update
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost upsert
   */
  export type TwitterPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * The filter to search for the TwitterPost to update in case it exists.
     */
    where: TwitterPostWhereUniqueInput
    /**
     * In case the TwitterPost found by the `where` argument doesn't exist, create a new TwitterPost with this data.
     */
    create: XOR<TwitterPostCreateInput, TwitterPostUncheckedCreateInput>
    /**
     * In case the TwitterPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostUpdateInput, TwitterPostUncheckedUpdateInput>
  }


  /**
   * TwitterPost delete
   */
  export type TwitterPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
    /**
     * Filter which TwitterPost to delete.
     */
    where: TwitterPostWhereUniqueInput
  }


  /**
   * TwitterPost deleteMany
   */
  export type TwitterPostDeleteManyArgs = {
    /**
     * Filter which TwitterPosts to delete
     */
    where?: TwitterPostWhereInput
  }


  /**
   * TwitterPost.postAndHashtags
   */
  export type TwitterPost$postAndHashtagsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    where?: TwitterPostAndHashtagWhereInput
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostAndHashtagScalarFieldEnum>
  }


  /**
   * TwitterPost.replyPosts
   */
  export type TwitterPost$replyPostsArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    where?: TwitterReplyPostWhereInput
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    cursor?: TwitterReplyPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterReplyPostScalarFieldEnum>
  }


  /**
   * TwitterPost without action
   */
  export type TwitterPostArgs = {
    /**
     * Select specific fields to fetch from the TwitterPost
     */
    select?: TwitterPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostInclude | null
  }



  /**
   * Model TwitterUserRelationship
   */


  export type AggregateTwitterUserRelationship = {
    _count: TwitterUserRelationshipCountAggregateOutputType | null
    _avg: TwitterUserRelationshipAvgAggregateOutputType | null
    _sum: TwitterUserRelationshipSumAggregateOutputType | null
    _min: TwitterUserRelationshipMinAggregateOutputType | null
    _max: TwitterUserRelationshipMaxAggregateOutputType | null
  }

  export type TwitterUserRelationshipAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationshipSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterUserRelationshipMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserRelationshipMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterUserRelationshipCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterUserRelationshipAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationshipSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterUserRelationshipMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserRelationshipMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterUserRelationshipCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterUserRelationshipAggregateArgs = {
    /**
     * Filter which TwitterUserRelationship to aggregate.
     */
    where?: TwitterUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelationships to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterUserRelationships
    **/
    _count?: true | TwitterUserRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterUserRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterUserRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterUserRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterUserRelationshipMaxAggregateInputType
  }

  export type GetTwitterUserRelationshipAggregateType<T extends TwitterUserRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterUserRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterUserRelationship[P]>
      : GetScalarType<T[P], AggregateTwitterUserRelationship[P]>
  }




  export type TwitterUserRelationshipGroupByArgs = {
    where?: TwitterUserRelationshipWhereInput
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithAggregationInput>
    by: TwitterUserRelationshipScalarFieldEnum[]
    having?: TwitterUserRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterUserRelationshipCountAggregateInputType | true
    _avg?: TwitterUserRelationshipAvgAggregateInputType
    _sum?: TwitterUserRelationshipSumAggregateInputType
    _min?: TwitterUserRelationshipMinAggregateInputType
    _max?: TwitterUserRelationshipMaxAggregateInputType
  }


  export type TwitterUserRelationshipGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterUserRelationshipCountAggregateOutputType | null
    _avg: TwitterUserRelationshipAvgAggregateOutputType | null
    _sum: TwitterUserRelationshipSumAggregateOutputType | null
    _min: TwitterUserRelationshipMinAggregateOutputType | null
    _max: TwitterUserRelationshipMaxAggregateOutputType | null
  }

  type GetTwitterUserRelationshipGroupByPayload<T extends TwitterUserRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterUserRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterUserRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterUserRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterUserRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type TwitterUserRelationshipSelect = {
    id?: boolean
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterUserRelationshipInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterUserRelationshipGetPayload<S extends boolean | null | undefined | TwitterUserRelationshipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterUserRelationship :
    S extends undefined ? never :
    S extends { include: any } & (TwitterUserRelationshipArgs | TwitterUserRelationshipFindManyArgs)
    ? TwitterUserRelationship  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterUserRelationshipArgs | TwitterUserRelationshipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterUserRelationship ? TwitterUserRelationship[P] : never
  } 
      : TwitterUserRelationship


  type TwitterUserRelationshipCountArgs = 
    Omit<TwitterUserRelationshipFindManyArgs, 'select' | 'include'> & {
      select?: TwitterUserRelationshipCountAggregateInputType | true
    }

  export interface TwitterUserRelationshipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterUserRelationship that matches the filter.
     * @param {TwitterUserRelationshipFindUniqueArgs} args - Arguments to find a TwitterUserRelationship
     * @example
     * // Get one TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterUserRelationshipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterUserRelationshipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterUserRelationship'> extends True ? Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>> : Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T> | null, null>

    /**
     * Find one TwitterUserRelationship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterUserRelationshipFindUniqueOrThrowArgs} args - Arguments to find a TwitterUserRelationship
     * @example
     * // Get one TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterUserRelationshipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserRelationshipFindUniqueOrThrowArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Find the first TwitterUserRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipFindFirstArgs} args - Arguments to find a TwitterUserRelationship
     * @example
     * // Get one TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterUserRelationshipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterUserRelationshipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterUserRelationship'> extends True ? Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>> : Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T> | null, null>

    /**
     * Find the first TwitterUserRelationship that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipFindFirstOrThrowArgs} args - Arguments to find a TwitterUserRelationship
     * @example
     * // Get one TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterUserRelationshipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterUserRelationshipFindFirstOrThrowArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Find zero or more TwitterUserRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterUserRelationships
     * const twitterUserRelationships = await prisma.twitterUserRelationship.findMany()
     * 
     * // Get first 10 TwitterUserRelationships
     * const twitterUserRelationships = await prisma.twitterUserRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterUserRelationshipWithIdOnly = await prisma.twitterUserRelationship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterUserRelationshipFindManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationshipFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterUserRelationshipGetPayload<T>>>

    /**
     * Create a TwitterUserRelationship.
     * @param {TwitterUserRelationshipCreateArgs} args - Arguments to create a TwitterUserRelationship.
     * @example
     * // Create one TwitterUserRelationship
     * const TwitterUserRelationship = await prisma.twitterUserRelationship.create({
     *   data: {
     *     // ... data to create a TwitterUserRelationship
     *   }
     * })
     * 
    **/
    create<T extends TwitterUserRelationshipCreateArgs>(
      args: SelectSubset<T, TwitterUserRelationshipCreateArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Create many TwitterUserRelationships.
     *     @param {TwitterUserRelationshipCreateManyArgs} args - Arguments to create many TwitterUserRelationships.
     *     @example
     *     // Create many TwitterUserRelationships
     *     const twitterUserRelationship = await prisma.twitterUserRelationship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterUserRelationshipCreateManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationshipCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterUserRelationship.
     * @param {TwitterUserRelationshipDeleteArgs} args - Arguments to delete one TwitterUserRelationship.
     * @example
     * // Delete one TwitterUserRelationship
     * const TwitterUserRelationship = await prisma.twitterUserRelationship.delete({
     *   where: {
     *     // ... filter to delete one TwitterUserRelationship
     *   }
     * })
     * 
    **/
    delete<T extends TwitterUserRelationshipDeleteArgs>(
      args: SelectSubset<T, TwitterUserRelationshipDeleteArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Update one TwitterUserRelationship.
     * @param {TwitterUserRelationshipUpdateArgs} args - Arguments to update one TwitterUserRelationship.
     * @example
     * // Update one TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterUserRelationshipUpdateArgs>(
      args: SelectSubset<T, TwitterUserRelationshipUpdateArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Delete zero or more TwitterUserRelationships.
     * @param {TwitterUserRelationshipDeleteManyArgs} args - Arguments to filter TwitterUserRelationships to delete.
     * @example
     * // Delete a few TwitterUserRelationships
     * const { count } = await prisma.twitterUserRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterUserRelationshipDeleteManyArgs>(
      args?: SelectSubset<T, TwitterUserRelationshipDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterUserRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterUserRelationships
     * const twitterUserRelationship = await prisma.twitterUserRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterUserRelationshipUpdateManyArgs>(
      args: SelectSubset<T, TwitterUserRelationshipUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterUserRelationship.
     * @param {TwitterUserRelationshipUpsertArgs} args - Arguments to update or create a TwitterUserRelationship.
     * @example
     * // Update or create a TwitterUserRelationship
     * const twitterUserRelationship = await prisma.twitterUserRelationship.upsert({
     *   create: {
     *     // ... data to create a TwitterUserRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterUserRelationship we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterUserRelationshipUpsertArgs>(
      args: SelectSubset<T, TwitterUserRelationshipUpsertArgs>
    ): Prisma__TwitterUserRelationshipClient<TwitterUserRelationshipGetPayload<T>>

    /**
     * Count the number of TwitterUserRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipCountArgs} args - Arguments to filter TwitterUserRelationships to count.
     * @example
     * // Count the number of TwitterUserRelationships
     * const count = await prisma.twitterUserRelationship.count({
     *   where: {
     *     // ... the filter for the TwitterUserRelationships we want to count
     *   }
     * })
    **/
    count<T extends TwitterUserRelationshipCountArgs>(
      args?: Subset<T, TwitterUserRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterUserRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterUserRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterUserRelationshipAggregateArgs>(args: Subset<T, TwitterUserRelationshipAggregateArgs>): Prisma.PrismaPromise<GetTwitterUserRelationshipAggregateType<T>>

    /**
     * Group by TwitterUserRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterUserRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterUserRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterUserRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: TwitterUserRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterUserRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterUserRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterUserRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterUserRelationshipClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterUserRelationship base type for findUnique actions
   */
  export type TwitterUserRelationshipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter, which TwitterUserRelationship to fetch.
     */
    where: TwitterUserRelationshipWhereUniqueInput
  }

  /**
   * TwitterUserRelationship findUnique
   */
  export interface TwitterUserRelationshipFindUniqueArgs extends TwitterUserRelationshipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUserRelationship findUniqueOrThrow
   */
  export type TwitterUserRelationshipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter, which TwitterUserRelationship to fetch.
     */
    where: TwitterUserRelationshipWhereUniqueInput
  }


  /**
   * TwitterUserRelationship base type for findFirst actions
   */
  export type TwitterUserRelationshipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter, which TwitterUserRelationship to fetch.
     */
    where?: TwitterUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelationships to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUserRelationships.
     */
    cursor?: TwitterUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUserRelationships.
     */
    distinct?: Enumerable<TwitterUserRelationshipScalarFieldEnum>
  }

  /**
   * TwitterUserRelationship findFirst
   */
  export interface TwitterUserRelationshipFindFirstArgs extends TwitterUserRelationshipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterUserRelationship findFirstOrThrow
   */
  export type TwitterUserRelationshipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter, which TwitterUserRelationship to fetch.
     */
    where?: TwitterUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelationships to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterUserRelationships.
     */
    cursor?: TwitterUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterUserRelationships.
     */
    distinct?: Enumerable<TwitterUserRelationshipScalarFieldEnum>
  }


  /**
   * TwitterUserRelationship findMany
   */
  export type TwitterUserRelationshipFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter, which TwitterUserRelationships to fetch.
     */
    where?: TwitterUserRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterUserRelationships to fetch.
     */
    orderBy?: Enumerable<TwitterUserRelationshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterUserRelationships.
     */
    cursor?: TwitterUserRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterUserRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterUserRelationships.
     */
    skip?: number
    distinct?: Enumerable<TwitterUserRelationshipScalarFieldEnum>
  }


  /**
   * TwitterUserRelationship create
   */
  export type TwitterUserRelationshipCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * The data needed to create a TwitterUserRelationship.
     */
    data: XOR<TwitterUserRelationshipCreateInput, TwitterUserRelationshipUncheckedCreateInput>
  }


  /**
   * TwitterUserRelationship createMany
   */
  export type TwitterUserRelationshipCreateManyArgs = {
    /**
     * The data used to create many TwitterUserRelationships.
     */
    data: Enumerable<TwitterUserRelationshipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterUserRelationship update
   */
  export type TwitterUserRelationshipUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * The data needed to update a TwitterUserRelationship.
     */
    data: XOR<TwitterUserRelationshipUpdateInput, TwitterUserRelationshipUncheckedUpdateInput>
    /**
     * Choose, which TwitterUserRelationship to update.
     */
    where: TwitterUserRelationshipWhereUniqueInput
  }


  /**
   * TwitterUserRelationship updateMany
   */
  export type TwitterUserRelationshipUpdateManyArgs = {
    /**
     * The data used to update TwitterUserRelationships.
     */
    data: XOR<TwitterUserRelationshipUpdateManyMutationInput, TwitterUserRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which TwitterUserRelationships to update
     */
    where?: TwitterUserRelationshipWhereInput
  }


  /**
   * TwitterUserRelationship upsert
   */
  export type TwitterUserRelationshipUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * The filter to search for the TwitterUserRelationship to update in case it exists.
     */
    where: TwitterUserRelationshipWhereUniqueInput
    /**
     * In case the TwitterUserRelationship found by the `where` argument doesn't exist, create a new TwitterUserRelationship with this data.
     */
    create: XOR<TwitterUserRelationshipCreateInput, TwitterUserRelationshipUncheckedCreateInput>
    /**
     * In case the TwitterUserRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterUserRelationshipUpdateInput, TwitterUserRelationshipUncheckedUpdateInput>
  }


  /**
   * TwitterUserRelationship delete
   */
  export type TwitterUserRelationshipDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
    /**
     * Filter which TwitterUserRelationship to delete.
     */
    where: TwitterUserRelationshipWhereUniqueInput
  }


  /**
   * TwitterUserRelationship deleteMany
   */
  export type TwitterUserRelationshipDeleteManyArgs = {
    /**
     * Filter which TwitterUserRelationships to delete
     */
    where?: TwitterUserRelationshipWhereInput
  }


  /**
   * TwitterUserRelationship without action
   */
  export type TwitterUserRelationshipArgs = {
    /**
     * Select specific fields to fetch from the TwitterUserRelationship
     */
    select?: TwitterUserRelationshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterUserRelationshipInclude | null
  }



  /**
   * Model TwitterHashtag
   */


  export type AggregateTwitterHashtag = {
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  export type TwitterHashtagAvgAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagSumAggregateOutputType = {
    id: number | null
  }

  export type TwitterHashtagMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterHashtagCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterHashtagAvgAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagSumAggregateInputType = {
    id?: true
  }

  export type TwitterHashtagMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterHashtagCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterHashtagAggregateArgs = {
    /**
     * Filter which TwitterHashtag to aggregate.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterHashtags
    **/
    _count?: true | TwitterHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterHashtagMaxAggregateInputType
  }

  export type GetTwitterHashtagAggregateType<T extends TwitterHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterHashtag[P]>
  }




  export type TwitterHashtagGroupByArgs = {
    where?: TwitterHashtagWhereInput
    orderBy?: Enumerable<TwitterHashtagOrderByWithAggregationInput>
    by: TwitterHashtagScalarFieldEnum[]
    having?: TwitterHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterHashtagCountAggregateInputType | true
    _avg?: TwitterHashtagAvgAggregateInputType
    _sum?: TwitterHashtagSumAggregateInputType
    _min?: TwitterHashtagMinAggregateInputType
    _max?: TwitterHashtagMaxAggregateInputType
  }


  export type TwitterHashtagGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TwitterHashtagCountAggregateOutputType | null
    _avg: TwitterHashtagAvgAggregateOutputType | null
    _sum: TwitterHashtagSumAggregateOutputType | null
    _min: TwitterHashtagMinAggregateOutputType | null
    _max: TwitterHashtagMaxAggregateOutputType | null
  }

  type GetTwitterHashtagGroupByPayload<T extends TwitterHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterHashtagSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postAndHashtags?: boolean | TwitterHashtag$postAndHashtagsArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }


  export type TwitterHashtagInclude = {
    postAndHashtags?: boolean | TwitterHashtag$postAndHashtagsArgs
    _count?: boolean | TwitterHashtagCountOutputTypeArgs
  }

  export type TwitterHashtagGetPayload<S extends boolean | null | undefined | TwitterHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
    ? TwitterHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'postAndHashtags' ? Array < TwitterPostAndHashtagGetPayload<S['include'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterHashtagArgs | TwitterHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'postAndHashtags' ? Array < TwitterPostAndHashtagGetPayload<S['select'][P]>>  :
        P extends '_count' ? TwitterHashtagCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TwitterHashtag ? TwitterHashtag[P] : never
  } 
      : TwitterHashtag


  type TwitterHashtagCountArgs = 
    Omit<TwitterHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterHashtagCountAggregateInputType | true
    }

  export interface TwitterHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterHashtag that matches the filter.
     * @param {TwitterHashtagFindUniqueArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find the first TwitterHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterHashtag'> extends True ? Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>> : Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterHashtag
     * @example
     * // Get one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany()
     * 
     * // Get first 10 TwitterHashtags
     * const twitterHashtags = await prisma.twitterHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterHashtagWithIdOnly = await prisma.twitterHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterHashtagGetPayload<T>>>

    /**
     * Create a TwitterHashtag.
     * @param {TwitterHashtagCreateArgs} args - Arguments to create a TwitterHashtag.
     * @example
     * // Create one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.create({
     *   data: {
     *     // ... data to create a TwitterHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterHashtagCreateArgs>(
      args: SelectSubset<T, TwitterHashtagCreateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Create many TwitterHashtags.
     *     @param {TwitterHashtagCreateManyArgs} args - Arguments to create many TwitterHashtags.
     *     @example
     *     // Create many TwitterHashtags
     *     const twitterHashtag = await prisma.twitterHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterHashtag.
     * @param {TwitterHashtagDeleteArgs} args - Arguments to delete one TwitterHashtag.
     * @example
     * // Delete one TwitterHashtag
     * const TwitterHashtag = await prisma.twitterHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterHashtagDeleteArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Update one TwitterHashtag.
     * @param {TwitterHashtagUpdateArgs} args - Arguments to update one TwitterHashtag.
     * @example
     * // Update one TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterHashtags.
     * @param {TwitterHashtagDeleteManyArgs} args - Arguments to filter TwitterHashtags to delete.
     * @example
     * // Delete a few TwitterHashtags
     * const { count } = await prisma.twitterHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterHashtags
     * const twitterHashtag = await prisma.twitterHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterHashtag.
     * @param {TwitterHashtagUpsertArgs} args - Arguments to update or create a TwitterHashtag.
     * @example
     * // Update or create a TwitterHashtag
     * const twitterHashtag = await prisma.twitterHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterHashtagUpsertArgs>
    ): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T>>

    /**
     * Count the number of TwitterHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagCountArgs} args - Arguments to filter TwitterHashtags to count.
     * @example
     * // Count the number of TwitterHashtags
     * const count = await prisma.twitterHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterHashtagCountArgs>(
      args?: Subset<T, TwitterHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterHashtagAggregateArgs>(args: Subset<T, TwitterHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterHashtagAggregateType<T>>

    /**
     * Group by TwitterHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    postAndHashtags<T extends TwitterHashtag$postAndHashtagsArgs= {}>(args?: Subset<T, TwitterHashtag$postAndHashtagsArgs>): Prisma.PrismaPromise<Array<TwitterPostAndHashtagGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterHashtag base type for findUnique actions
   */
  export type TwitterHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }

  /**
   * TwitterHashtag findUnique
   */
  export interface TwitterHashtagFindUniqueArgs extends TwitterHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findUniqueOrThrow
   */
  export type TwitterHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag base type for findFirst actions
   */
  export type TwitterHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }

  /**
   * TwitterHashtag findFirst
   */
  export interface TwitterHashtagFindFirstArgs extends TwitterHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterHashtag findFirstOrThrow
   */
  export type TwitterHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtag to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterHashtags.
     */
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag findMany
   */
  export type TwitterHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter, which TwitterHashtags to fetch.
     */
    where?: TwitterHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterHashtags.
     */
    cursor?: TwitterHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag create
   */
  export type TwitterHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to create a TwitterHashtag.
     */
    data: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
  }


  /**
   * TwitterHashtag createMany
   */
  export type TwitterHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterHashtags.
     */
    data: Enumerable<TwitterHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterHashtag update
   */
  export type TwitterHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The data needed to update a TwitterHashtag.
     */
    data: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterHashtag to update.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag updateMany
   */
  export type TwitterHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterHashtags.
     */
    data: XOR<TwitterHashtagUpdateManyMutationInput, TwitterHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterHashtags to update
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag upsert
   */
  export type TwitterHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * The filter to search for the TwitterHashtag to update in case it exists.
     */
    where: TwitterHashtagWhereUniqueInput
    /**
     * In case the TwitterHashtag found by the `where` argument doesn't exist, create a new TwitterHashtag with this data.
     */
    create: XOR<TwitterHashtagCreateInput, TwitterHashtagUncheckedCreateInput>
    /**
     * In case the TwitterHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterHashtagUpdateInput, TwitterHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterHashtag delete
   */
  export type TwitterHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
    /**
     * Filter which TwitterHashtag to delete.
     */
    where: TwitterHashtagWhereUniqueInput
  }


  /**
   * TwitterHashtag deleteMany
   */
  export type TwitterHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterHashtags to delete
     */
    where?: TwitterHashtagWhereInput
  }


  /**
   * TwitterHashtag.postAndHashtags
   */
  export type TwitterHashtag$postAndHashtagsArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    where?: TwitterPostAndHashtagWhereInput
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TwitterPostAndHashtagScalarFieldEnum>
  }


  /**
   * TwitterHashtag without action
   */
  export type TwitterHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterHashtag
     */
    select?: TwitterHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterHashtagInclude | null
  }



  /**
   * Model TwitterPostAndHashtag
   */


  export type AggregateTwitterPostAndHashtag = {
    _count: TwitterPostAndHashtagCountAggregateOutputType | null
    _avg: TwitterPostAndHashtagAvgAggregateOutputType | null
    _sum: TwitterPostAndHashtagSumAggregateOutputType | null
    _min: TwitterPostAndHashtagMinAggregateOutputType | null
    _max: TwitterPostAndHashtagMaxAggregateOutputType | null
  }

  export type TwitterPostAndHashtagAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostAndHashtagSumAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
  }

  export type TwitterPostAndHashtagMinAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostAndHashtagMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    hashtagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterPostAndHashtagCountAggregateOutputType = {
    id: number
    postId: number
    hashtagId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterPostAndHashtagAvgAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostAndHashtagSumAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
  }

  export type TwitterPostAndHashtagMinAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostAndHashtagMaxAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterPostAndHashtagCountAggregateInputType = {
    id?: true
    postId?: true
    hashtagId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterPostAndHashtagAggregateArgs = {
    /**
     * Filter which TwitterPostAndHashtag to aggregate.
     */
    where?: TwitterPostAndHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostAndHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostAndHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostAndHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterPostAndHashtags
    **/
    _count?: true | TwitterPostAndHashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterPostAndHashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterPostAndHashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterPostAndHashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterPostAndHashtagMaxAggregateInputType
  }

  export type GetTwitterPostAndHashtagAggregateType<T extends TwitterPostAndHashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterPostAndHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterPostAndHashtag[P]>
      : GetScalarType<T[P], AggregateTwitterPostAndHashtag[P]>
  }




  export type TwitterPostAndHashtagGroupByArgs = {
    where?: TwitterPostAndHashtagWhereInput
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithAggregationInput>
    by: TwitterPostAndHashtagScalarFieldEnum[]
    having?: TwitterPostAndHashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterPostAndHashtagCountAggregateInputType | true
    _avg?: TwitterPostAndHashtagAvgAggregateInputType
    _sum?: TwitterPostAndHashtagSumAggregateInputType
    _min?: TwitterPostAndHashtagMinAggregateInputType
    _max?: TwitterPostAndHashtagMaxAggregateInputType
  }


  export type TwitterPostAndHashtagGroupByOutputType = {
    id: number
    postId: number
    hashtagId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterPostAndHashtagCountAggregateOutputType | null
    _avg: TwitterPostAndHashtagAvgAggregateOutputType | null
    _sum: TwitterPostAndHashtagSumAggregateOutputType | null
    _min: TwitterPostAndHashtagMinAggregateOutputType | null
    _max: TwitterPostAndHashtagMaxAggregateOutputType | null
  }

  type GetTwitterPostAndHashtagGroupByPayload<T extends TwitterPostAndHashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterPostAndHashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterPostAndHashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterPostAndHashtagGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterPostAndHashtagGroupByOutputType[P]>
        }
      >
    >


  export type TwitterPostAndHashtagSelect = {
    id?: boolean
    post?: boolean | TwitterPostArgs
    postId?: boolean
    hashtag?: boolean | TwitterHashtagArgs
    hashtagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterPostAndHashtagInclude = {
    post?: boolean | TwitterPostArgs
    hashtag?: boolean | TwitterHashtagArgs
  }

  export type TwitterPostAndHashtagGetPayload<S extends boolean | null | undefined | TwitterPostAndHashtagArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterPostAndHashtag :
    S extends undefined ? never :
    S extends { include: any } & (TwitterPostAndHashtagArgs | TwitterPostAndHashtagFindManyArgs)
    ? TwitterPostAndHashtag  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterPostAndHashtagArgs | TwitterPostAndHashtagFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :
        P extends 'hashtag' ? TwitterHashtagGetPayload<S['select'][P]> :  P extends keyof TwitterPostAndHashtag ? TwitterPostAndHashtag[P] : never
  } 
      : TwitterPostAndHashtag


  type TwitterPostAndHashtagCountArgs = 
    Omit<TwitterPostAndHashtagFindManyArgs, 'select' | 'include'> & {
      select?: TwitterPostAndHashtagCountAggregateInputType | true
    }

  export interface TwitterPostAndHashtagDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterPostAndHashtag that matches the filter.
     * @param {TwitterPostAndHashtagFindUniqueArgs} args - Arguments to find a TwitterPostAndHashtag
     * @example
     * // Get one TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterPostAndHashtagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterPostAndHashtagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterPostAndHashtag'> extends True ? Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>> : Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T> | null, null>

    /**
     * Find one TwitterPostAndHashtag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterPostAndHashtagFindUniqueOrThrowArgs} args - Arguments to find a TwitterPostAndHashtag
     * @example
     * // Get one TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterPostAndHashtagFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostAndHashtagFindUniqueOrThrowArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Find the first TwitterPostAndHashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagFindFirstArgs} args - Arguments to find a TwitterPostAndHashtag
     * @example
     * // Get one TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterPostAndHashtagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterPostAndHashtagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterPostAndHashtag'> extends True ? Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>> : Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T> | null, null>

    /**
     * Find the first TwitterPostAndHashtag that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagFindFirstOrThrowArgs} args - Arguments to find a TwitterPostAndHashtag
     * @example
     * // Get one TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterPostAndHashtagFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterPostAndHashtagFindFirstOrThrowArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Find zero or more TwitterPostAndHashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterPostAndHashtags
     * const twitterPostAndHashtags = await prisma.twitterPostAndHashtag.findMany()
     * 
     * // Get first 10 TwitterPostAndHashtags
     * const twitterPostAndHashtags = await prisma.twitterPostAndHashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterPostAndHashtagWithIdOnly = await prisma.twitterPostAndHashtag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterPostAndHashtagFindManyArgs>(
      args?: SelectSubset<T, TwitterPostAndHashtagFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterPostAndHashtagGetPayload<T>>>

    /**
     * Create a TwitterPostAndHashtag.
     * @param {TwitterPostAndHashtagCreateArgs} args - Arguments to create a TwitterPostAndHashtag.
     * @example
     * // Create one TwitterPostAndHashtag
     * const TwitterPostAndHashtag = await prisma.twitterPostAndHashtag.create({
     *   data: {
     *     // ... data to create a TwitterPostAndHashtag
     *   }
     * })
     * 
    **/
    create<T extends TwitterPostAndHashtagCreateArgs>(
      args: SelectSubset<T, TwitterPostAndHashtagCreateArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Create many TwitterPostAndHashtags.
     *     @param {TwitterPostAndHashtagCreateManyArgs} args - Arguments to create many TwitterPostAndHashtags.
     *     @example
     *     // Create many TwitterPostAndHashtags
     *     const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterPostAndHashtagCreateManyArgs>(
      args?: SelectSubset<T, TwitterPostAndHashtagCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterPostAndHashtag.
     * @param {TwitterPostAndHashtagDeleteArgs} args - Arguments to delete one TwitterPostAndHashtag.
     * @example
     * // Delete one TwitterPostAndHashtag
     * const TwitterPostAndHashtag = await prisma.twitterPostAndHashtag.delete({
     *   where: {
     *     // ... filter to delete one TwitterPostAndHashtag
     *   }
     * })
     * 
    **/
    delete<T extends TwitterPostAndHashtagDeleteArgs>(
      args: SelectSubset<T, TwitterPostAndHashtagDeleteArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Update one TwitterPostAndHashtag.
     * @param {TwitterPostAndHashtagUpdateArgs} args - Arguments to update one TwitterPostAndHashtag.
     * @example
     * // Update one TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterPostAndHashtagUpdateArgs>(
      args: SelectSubset<T, TwitterPostAndHashtagUpdateArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Delete zero or more TwitterPostAndHashtags.
     * @param {TwitterPostAndHashtagDeleteManyArgs} args - Arguments to filter TwitterPostAndHashtags to delete.
     * @example
     * // Delete a few TwitterPostAndHashtags
     * const { count } = await prisma.twitterPostAndHashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterPostAndHashtagDeleteManyArgs>(
      args?: SelectSubset<T, TwitterPostAndHashtagDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterPostAndHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterPostAndHashtags
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterPostAndHashtagUpdateManyArgs>(
      args: SelectSubset<T, TwitterPostAndHashtagUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterPostAndHashtag.
     * @param {TwitterPostAndHashtagUpsertArgs} args - Arguments to update or create a TwitterPostAndHashtag.
     * @example
     * // Update or create a TwitterPostAndHashtag
     * const twitterPostAndHashtag = await prisma.twitterPostAndHashtag.upsert({
     *   create: {
     *     // ... data to create a TwitterPostAndHashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterPostAndHashtag we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterPostAndHashtagUpsertArgs>(
      args: SelectSubset<T, TwitterPostAndHashtagUpsertArgs>
    ): Prisma__TwitterPostAndHashtagClient<TwitterPostAndHashtagGetPayload<T>>

    /**
     * Count the number of TwitterPostAndHashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagCountArgs} args - Arguments to filter TwitterPostAndHashtags to count.
     * @example
     * // Count the number of TwitterPostAndHashtags
     * const count = await prisma.twitterPostAndHashtag.count({
     *   where: {
     *     // ... the filter for the TwitterPostAndHashtags we want to count
     *   }
     * })
    **/
    count<T extends TwitterPostAndHashtagCountArgs>(
      args?: Subset<T, TwitterPostAndHashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterPostAndHashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterPostAndHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterPostAndHashtagAggregateArgs>(args: Subset<T, TwitterPostAndHashtagAggregateArgs>): Prisma.PrismaPromise<GetTwitterPostAndHashtagAggregateType<T>>

    /**
     * Group by TwitterPostAndHashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterPostAndHashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterPostAndHashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterPostAndHashtagGroupByArgs['orderBy'] }
        : { orderBy?: TwitterPostAndHashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterPostAndHashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterPostAndHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterPostAndHashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterPostAndHashtagClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    hashtag<T extends TwitterHashtagArgs= {}>(args?: Subset<T, TwitterHashtagArgs>): Prisma__TwitterHashtagClient<TwitterHashtagGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterPostAndHashtag base type for findUnique actions
   */
  export type TwitterPostAndHashtagFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter, which TwitterPostAndHashtag to fetch.
     */
    where: TwitterPostAndHashtagWhereUniqueInput
  }

  /**
   * TwitterPostAndHashtag findUnique
   */
  export interface TwitterPostAndHashtagFindUniqueArgs extends TwitterPostAndHashtagFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostAndHashtag findUniqueOrThrow
   */
  export type TwitterPostAndHashtagFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter, which TwitterPostAndHashtag to fetch.
     */
    where: TwitterPostAndHashtagWhereUniqueInput
  }


  /**
   * TwitterPostAndHashtag base type for findFirst actions
   */
  export type TwitterPostAndHashtagFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter, which TwitterPostAndHashtag to fetch.
     */
    where?: TwitterPostAndHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostAndHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostAndHashtags.
     */
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostAndHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostAndHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostAndHashtags.
     */
    distinct?: Enumerable<TwitterPostAndHashtagScalarFieldEnum>
  }

  /**
   * TwitterPostAndHashtag findFirst
   */
  export interface TwitterPostAndHashtagFindFirstArgs extends TwitterPostAndHashtagFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterPostAndHashtag findFirstOrThrow
   */
  export type TwitterPostAndHashtagFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter, which TwitterPostAndHashtag to fetch.
     */
    where?: TwitterPostAndHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostAndHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterPostAndHashtags.
     */
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostAndHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostAndHashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterPostAndHashtags.
     */
    distinct?: Enumerable<TwitterPostAndHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostAndHashtag findMany
   */
  export type TwitterPostAndHashtagFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter, which TwitterPostAndHashtags to fetch.
     */
    where?: TwitterPostAndHashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterPostAndHashtags to fetch.
     */
    orderBy?: Enumerable<TwitterPostAndHashtagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterPostAndHashtags.
     */
    cursor?: TwitterPostAndHashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterPostAndHashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterPostAndHashtags.
     */
    skip?: number
    distinct?: Enumerable<TwitterPostAndHashtagScalarFieldEnum>
  }


  /**
   * TwitterPostAndHashtag create
   */
  export type TwitterPostAndHashtagCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * The data needed to create a TwitterPostAndHashtag.
     */
    data: XOR<TwitterPostAndHashtagCreateInput, TwitterPostAndHashtagUncheckedCreateInput>
  }


  /**
   * TwitterPostAndHashtag createMany
   */
  export type TwitterPostAndHashtagCreateManyArgs = {
    /**
     * The data used to create many TwitterPostAndHashtags.
     */
    data: Enumerable<TwitterPostAndHashtagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterPostAndHashtag update
   */
  export type TwitterPostAndHashtagUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * The data needed to update a TwitterPostAndHashtag.
     */
    data: XOR<TwitterPostAndHashtagUpdateInput, TwitterPostAndHashtagUncheckedUpdateInput>
    /**
     * Choose, which TwitterPostAndHashtag to update.
     */
    where: TwitterPostAndHashtagWhereUniqueInput
  }


  /**
   * TwitterPostAndHashtag updateMany
   */
  export type TwitterPostAndHashtagUpdateManyArgs = {
    /**
     * The data used to update TwitterPostAndHashtags.
     */
    data: XOR<TwitterPostAndHashtagUpdateManyMutationInput, TwitterPostAndHashtagUncheckedUpdateManyInput>
    /**
     * Filter which TwitterPostAndHashtags to update
     */
    where?: TwitterPostAndHashtagWhereInput
  }


  /**
   * TwitterPostAndHashtag upsert
   */
  export type TwitterPostAndHashtagUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * The filter to search for the TwitterPostAndHashtag to update in case it exists.
     */
    where: TwitterPostAndHashtagWhereUniqueInput
    /**
     * In case the TwitterPostAndHashtag found by the `where` argument doesn't exist, create a new TwitterPostAndHashtag with this data.
     */
    create: XOR<TwitterPostAndHashtagCreateInput, TwitterPostAndHashtagUncheckedCreateInput>
    /**
     * In case the TwitterPostAndHashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterPostAndHashtagUpdateInput, TwitterPostAndHashtagUncheckedUpdateInput>
  }


  /**
   * TwitterPostAndHashtag delete
   */
  export type TwitterPostAndHashtagDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
    /**
     * Filter which TwitterPostAndHashtag to delete.
     */
    where: TwitterPostAndHashtagWhereUniqueInput
  }


  /**
   * TwitterPostAndHashtag deleteMany
   */
  export type TwitterPostAndHashtagDeleteManyArgs = {
    /**
     * Filter which TwitterPostAndHashtags to delete
     */
    where?: TwitterPostAndHashtagWhereInput
  }


  /**
   * TwitterPostAndHashtag without action
   */
  export type TwitterPostAndHashtagArgs = {
    /**
     * Select specific fields to fetch from the TwitterPostAndHashtag
     */
    select?: TwitterPostAndHashtagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterPostAndHashtagInclude | null
  }



  /**
   * Model TwitterReplyPost
   */


  export type AggregateTwitterReplyPost = {
    _count: TwitterReplyPostCountAggregateOutputType | null
    _avg: TwitterReplyPostAvgAggregateOutputType | null
    _sum: TwitterReplyPostSumAggregateOutputType | null
    _min: TwitterReplyPostMinAggregateOutputType | null
    _max: TwitterReplyPostMaxAggregateOutputType | null
  }

  export type TwitterReplyPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type TwitterReplyPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type TwitterReplyPostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterReplyPostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    image: string | null
    postId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterReplyPostCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    image: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterReplyPostAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type TwitterReplyPostSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type TwitterReplyPostMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterReplyPostMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterReplyPostCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    image?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterReplyPostAggregateArgs = {
    /**
     * Filter which TwitterReplyPost to aggregate.
     */
    where?: TwitterReplyPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterReplyPosts to fetch.
     */
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterReplyPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterReplyPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterReplyPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterReplyPosts
    **/
    _count?: true | TwitterReplyPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterReplyPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterReplyPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterReplyPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterReplyPostMaxAggregateInputType
  }

  export type GetTwitterReplyPostAggregateType<T extends TwitterReplyPostAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterReplyPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterReplyPost[P]>
      : GetScalarType<T[P], AggregateTwitterReplyPost[P]>
  }




  export type TwitterReplyPostGroupByArgs = {
    where?: TwitterReplyPostWhereInput
    orderBy?: Enumerable<TwitterReplyPostOrderByWithAggregationInput>
    by: TwitterReplyPostScalarFieldEnum[]
    having?: TwitterReplyPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterReplyPostCountAggregateInputType | true
    _avg?: TwitterReplyPostAvgAggregateInputType
    _sum?: TwitterReplyPostSumAggregateInputType
    _min?: TwitterReplyPostMinAggregateInputType
    _max?: TwitterReplyPostMaxAggregateInputType
  }


  export type TwitterReplyPostGroupByOutputType = {
    id: number
    userId: number
    message: string
    image: string | null
    postId: number
    createdAt: Date
    updatedAt: Date
    _count: TwitterReplyPostCountAggregateOutputType | null
    _avg: TwitterReplyPostAvgAggregateOutputType | null
    _sum: TwitterReplyPostSumAggregateOutputType | null
    _min: TwitterReplyPostMinAggregateOutputType | null
    _max: TwitterReplyPostMaxAggregateOutputType | null
  }

  type GetTwitterReplyPostGroupByPayload<T extends TwitterReplyPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterReplyPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterReplyPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterReplyPostGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterReplyPostGroupByOutputType[P]>
        }
      >
    >


  export type TwitterReplyPostSelect = {
    id?: boolean
    user?: boolean | TwitterUserArgs
    userId?: boolean
    message?: boolean
    image?: boolean
    post?: boolean | TwitterPostArgs
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterReplyPostInclude = {
    user?: boolean | TwitterUserArgs
    post?: boolean | TwitterPostArgs
  }

  export type TwitterReplyPostGetPayload<S extends boolean | null | undefined | TwitterReplyPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterReplyPost :
    S extends undefined ? never :
    S extends { include: any } & (TwitterReplyPostArgs | TwitterReplyPostFindManyArgs)
    ? TwitterReplyPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'post' ? TwitterPostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterReplyPostArgs | TwitterReplyPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'post' ? TwitterPostGetPayload<S['select'][P]> :  P extends keyof TwitterReplyPost ? TwitterReplyPost[P] : never
  } 
      : TwitterReplyPost


  type TwitterReplyPostCountArgs = 
    Omit<TwitterReplyPostFindManyArgs, 'select' | 'include'> & {
      select?: TwitterReplyPostCountAggregateInputType | true
    }

  export interface TwitterReplyPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterReplyPost that matches the filter.
     * @param {TwitterReplyPostFindUniqueArgs} args - Arguments to find a TwitterReplyPost
     * @example
     * // Get one TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterReplyPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterReplyPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterReplyPost'> extends True ? Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>> : Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T> | null, null>

    /**
     * Find one TwitterReplyPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterReplyPostFindUniqueOrThrowArgs} args - Arguments to find a TwitterReplyPost
     * @example
     * // Get one TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterReplyPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterReplyPostFindUniqueOrThrowArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Find the first TwitterReplyPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostFindFirstArgs} args - Arguments to find a TwitterReplyPost
     * @example
     * // Get one TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterReplyPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterReplyPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterReplyPost'> extends True ? Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>> : Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T> | null, null>

    /**
     * Find the first TwitterReplyPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostFindFirstOrThrowArgs} args - Arguments to find a TwitterReplyPost
     * @example
     * // Get one TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterReplyPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterReplyPostFindFirstOrThrowArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Find zero or more TwitterReplyPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterReplyPosts
     * const twitterReplyPosts = await prisma.twitterReplyPost.findMany()
     * 
     * // Get first 10 TwitterReplyPosts
     * const twitterReplyPosts = await prisma.twitterReplyPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterReplyPostWithIdOnly = await prisma.twitterReplyPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterReplyPostFindManyArgs>(
      args?: SelectSubset<T, TwitterReplyPostFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterReplyPostGetPayload<T>>>

    /**
     * Create a TwitterReplyPost.
     * @param {TwitterReplyPostCreateArgs} args - Arguments to create a TwitterReplyPost.
     * @example
     * // Create one TwitterReplyPost
     * const TwitterReplyPost = await prisma.twitterReplyPost.create({
     *   data: {
     *     // ... data to create a TwitterReplyPost
     *   }
     * })
     * 
    **/
    create<T extends TwitterReplyPostCreateArgs>(
      args: SelectSubset<T, TwitterReplyPostCreateArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Create many TwitterReplyPosts.
     *     @param {TwitterReplyPostCreateManyArgs} args - Arguments to create many TwitterReplyPosts.
     *     @example
     *     // Create many TwitterReplyPosts
     *     const twitterReplyPost = await prisma.twitterReplyPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterReplyPostCreateManyArgs>(
      args?: SelectSubset<T, TwitterReplyPostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterReplyPost.
     * @param {TwitterReplyPostDeleteArgs} args - Arguments to delete one TwitterReplyPost.
     * @example
     * // Delete one TwitterReplyPost
     * const TwitterReplyPost = await prisma.twitterReplyPost.delete({
     *   where: {
     *     // ... filter to delete one TwitterReplyPost
     *   }
     * })
     * 
    **/
    delete<T extends TwitterReplyPostDeleteArgs>(
      args: SelectSubset<T, TwitterReplyPostDeleteArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Update one TwitterReplyPost.
     * @param {TwitterReplyPostUpdateArgs} args - Arguments to update one TwitterReplyPost.
     * @example
     * // Update one TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterReplyPostUpdateArgs>(
      args: SelectSubset<T, TwitterReplyPostUpdateArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Delete zero or more TwitterReplyPosts.
     * @param {TwitterReplyPostDeleteManyArgs} args - Arguments to filter TwitterReplyPosts to delete.
     * @example
     * // Delete a few TwitterReplyPosts
     * const { count } = await prisma.twitterReplyPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterReplyPostDeleteManyArgs>(
      args?: SelectSubset<T, TwitterReplyPostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterReplyPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterReplyPosts
     * const twitterReplyPost = await prisma.twitterReplyPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterReplyPostUpdateManyArgs>(
      args: SelectSubset<T, TwitterReplyPostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterReplyPost.
     * @param {TwitterReplyPostUpsertArgs} args - Arguments to update or create a TwitterReplyPost.
     * @example
     * // Update or create a TwitterReplyPost
     * const twitterReplyPost = await prisma.twitterReplyPost.upsert({
     *   create: {
     *     // ... data to create a TwitterReplyPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterReplyPost we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterReplyPostUpsertArgs>(
      args: SelectSubset<T, TwitterReplyPostUpsertArgs>
    ): Prisma__TwitterReplyPostClient<TwitterReplyPostGetPayload<T>>

    /**
     * Count the number of TwitterReplyPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostCountArgs} args - Arguments to filter TwitterReplyPosts to count.
     * @example
     * // Count the number of TwitterReplyPosts
     * const count = await prisma.twitterReplyPost.count({
     *   where: {
     *     // ... the filter for the TwitterReplyPosts we want to count
     *   }
     * })
    **/
    count<T extends TwitterReplyPostCountArgs>(
      args?: Subset<T, TwitterReplyPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterReplyPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterReplyPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterReplyPostAggregateArgs>(args: Subset<T, TwitterReplyPostAggregateArgs>): Prisma.PrismaPromise<GetTwitterReplyPostAggregateType<T>>

    /**
     * Group by TwitterReplyPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterReplyPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterReplyPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterReplyPostGroupByArgs['orderBy'] }
        : { orderBy?: TwitterReplyPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterReplyPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterReplyPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterReplyPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterReplyPostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    post<T extends TwitterPostArgs= {}>(args?: Subset<T, TwitterPostArgs>): Prisma__TwitterPostClient<TwitterPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterReplyPost base type for findUnique actions
   */
  export type TwitterReplyPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter, which TwitterReplyPost to fetch.
     */
    where: TwitterReplyPostWhereUniqueInput
  }

  /**
   * TwitterReplyPost findUnique
   */
  export interface TwitterReplyPostFindUniqueArgs extends TwitterReplyPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterReplyPost findUniqueOrThrow
   */
  export type TwitterReplyPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter, which TwitterReplyPost to fetch.
     */
    where: TwitterReplyPostWhereUniqueInput
  }


  /**
   * TwitterReplyPost base type for findFirst actions
   */
  export type TwitterReplyPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter, which TwitterReplyPost to fetch.
     */
    where?: TwitterReplyPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterReplyPosts to fetch.
     */
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterReplyPosts.
     */
    cursor?: TwitterReplyPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterReplyPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterReplyPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterReplyPosts.
     */
    distinct?: Enumerable<TwitterReplyPostScalarFieldEnum>
  }

  /**
   * TwitterReplyPost findFirst
   */
  export interface TwitterReplyPostFindFirstArgs extends TwitterReplyPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterReplyPost findFirstOrThrow
   */
  export type TwitterReplyPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter, which TwitterReplyPost to fetch.
     */
    where?: TwitterReplyPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterReplyPosts to fetch.
     */
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterReplyPosts.
     */
    cursor?: TwitterReplyPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterReplyPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterReplyPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterReplyPosts.
     */
    distinct?: Enumerable<TwitterReplyPostScalarFieldEnum>
  }


  /**
   * TwitterReplyPost findMany
   */
  export type TwitterReplyPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter, which TwitterReplyPosts to fetch.
     */
    where?: TwitterReplyPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterReplyPosts to fetch.
     */
    orderBy?: Enumerable<TwitterReplyPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterReplyPosts.
     */
    cursor?: TwitterReplyPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterReplyPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterReplyPosts.
     */
    skip?: number
    distinct?: Enumerable<TwitterReplyPostScalarFieldEnum>
  }


  /**
   * TwitterReplyPost create
   */
  export type TwitterReplyPostCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * The data needed to create a TwitterReplyPost.
     */
    data: XOR<TwitterReplyPostCreateInput, TwitterReplyPostUncheckedCreateInput>
  }


  /**
   * TwitterReplyPost createMany
   */
  export type TwitterReplyPostCreateManyArgs = {
    /**
     * The data used to create many TwitterReplyPosts.
     */
    data: Enumerable<TwitterReplyPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterReplyPost update
   */
  export type TwitterReplyPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * The data needed to update a TwitterReplyPost.
     */
    data: XOR<TwitterReplyPostUpdateInput, TwitterReplyPostUncheckedUpdateInput>
    /**
     * Choose, which TwitterReplyPost to update.
     */
    where: TwitterReplyPostWhereUniqueInput
  }


  /**
   * TwitterReplyPost updateMany
   */
  export type TwitterReplyPostUpdateManyArgs = {
    /**
     * The data used to update TwitterReplyPosts.
     */
    data: XOR<TwitterReplyPostUpdateManyMutationInput, TwitterReplyPostUncheckedUpdateManyInput>
    /**
     * Filter which TwitterReplyPosts to update
     */
    where?: TwitterReplyPostWhereInput
  }


  /**
   * TwitterReplyPost upsert
   */
  export type TwitterReplyPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * The filter to search for the TwitterReplyPost to update in case it exists.
     */
    where: TwitterReplyPostWhereUniqueInput
    /**
     * In case the TwitterReplyPost found by the `where` argument doesn't exist, create a new TwitterReplyPost with this data.
     */
    create: XOR<TwitterReplyPostCreateInput, TwitterReplyPostUncheckedCreateInput>
    /**
     * In case the TwitterReplyPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterReplyPostUpdateInput, TwitterReplyPostUncheckedUpdateInput>
  }


  /**
   * TwitterReplyPost delete
   */
  export type TwitterReplyPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
    /**
     * Filter which TwitterReplyPost to delete.
     */
    where: TwitterReplyPostWhereUniqueInput
  }


  /**
   * TwitterReplyPost deleteMany
   */
  export type TwitterReplyPostDeleteManyArgs = {
    /**
     * Filter which TwitterReplyPosts to delete
     */
    where?: TwitterReplyPostWhereInput
  }


  /**
   * TwitterReplyPost without action
   */
  export type TwitterReplyPostArgs = {
    /**
     * Select specific fields to fetch from the TwitterReplyPost
     */
    select?: TwitterReplyPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterReplyPostInclude | null
  }



  /**
   * Model TwitterDirectMessage
   */


  export type AggregateTwitterDirectMessage = {
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  export type TwitterDirectMessageAvgAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterDirectMessageSumAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
  }

  export type TwitterDirectMessageMinAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterDirectMessageMaxAggregateOutputType = {
    id: number | null
    fromUserId: number | null
    toUserId: number | null
    message: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwitterDirectMessageCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    message: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwitterDirectMessageAvgAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterDirectMessageSumAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
  }

  export type TwitterDirectMessageMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterDirectMessageMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwitterDirectMessageCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    message?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwitterDirectMessageAggregateArgs = {
    /**
     * Filter which TwitterDirectMessage to aggregate.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterDirectMessages
    **/
    _count?: true | TwitterDirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterDirectMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterDirectMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterDirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterDirectMessageMaxAggregateInputType
  }

  export type GetTwitterDirectMessageAggregateType<T extends TwitterDirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
      : GetScalarType<T[P], AggregateTwitterDirectMessage[P]>
  }




  export type TwitterDirectMessageGroupByArgs = {
    where?: TwitterDirectMessageWhereInput
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithAggregationInput>
    by: TwitterDirectMessageScalarFieldEnum[]
    having?: TwitterDirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterDirectMessageCountAggregateInputType | true
    _avg?: TwitterDirectMessageAvgAggregateInputType
    _sum?: TwitterDirectMessageSumAggregateInputType
    _min?: TwitterDirectMessageMinAggregateInputType
    _max?: TwitterDirectMessageMaxAggregateInputType
  }


  export type TwitterDirectMessageGroupByOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    message: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwitterDirectMessageCountAggregateOutputType | null
    _avg: TwitterDirectMessageAvgAggregateOutputType | null
    _sum: TwitterDirectMessageSumAggregateOutputType | null
    _min: TwitterDirectMessageMinAggregateOutputType | null
    _max: TwitterDirectMessageMaxAggregateOutputType | null
  }

  type GetTwitterDirectMessageGroupByPayload<T extends TwitterDirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwitterDirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterDirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterDirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type TwitterDirectMessageSelect = {
    id?: boolean
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
    fromUserId?: boolean
    toUserId?: boolean
    message?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TwitterDirectMessageInclude = {
    from?: boolean | TwitterUserArgs
    to?: boolean | TwitterUserArgs
  }

  export type TwitterDirectMessageGetPayload<S extends boolean | null | undefined | TwitterDirectMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TwitterDirectMessage :
    S extends undefined ? never :
    S extends { include: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
    ? TwitterDirectMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? TwitterUserGetPayload<S['include'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TwitterDirectMessageArgs | TwitterDirectMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? TwitterUserGetPayload<S['select'][P]> :
        P extends 'to' ? TwitterUserGetPayload<S['select'][P]> :  P extends keyof TwitterDirectMessage ? TwitterDirectMessage[P] : never
  } 
      : TwitterDirectMessage


  type TwitterDirectMessageCountArgs = 
    Omit<TwitterDirectMessageFindManyArgs, 'select' | 'include'> & {
      select?: TwitterDirectMessageCountAggregateInputType | true
    }

  export interface TwitterDirectMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TwitterDirectMessage that matches the filter.
     * @param {TwitterDirectMessageFindUniqueArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwitterDirectMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwitterDirectMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find one TwitterDirectMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwitterDirectMessageFindUniqueOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwitterDirectMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindUniqueOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find the first TwitterDirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwitterDirectMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwitterDirectMessage'> extends True ? Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>> : Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T> | null, null>

    /**
     * Find the first TwitterDirectMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindFirstOrThrowArgs} args - Arguments to find a TwitterDirectMessage
     * @example
     * // Get one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwitterDirectMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindFirstOrThrowArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Find zero or more TwitterDirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany()
     * 
     * // Get first 10 TwitterDirectMessages
     * const twitterDirectMessages = await prisma.twitterDirectMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterDirectMessageWithIdOnly = await prisma.twitterDirectMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwitterDirectMessageFindManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<TwitterDirectMessageGetPayload<T>>>

    /**
     * Create a TwitterDirectMessage.
     * @param {TwitterDirectMessageCreateArgs} args - Arguments to create a TwitterDirectMessage.
     * @example
     * // Create one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.create({
     *   data: {
     *     // ... data to create a TwitterDirectMessage
     *   }
     * })
     * 
    **/
    create<T extends TwitterDirectMessageCreateArgs>(
      args: SelectSubset<T, TwitterDirectMessageCreateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Create many TwitterDirectMessages.
     *     @param {TwitterDirectMessageCreateManyArgs} args - Arguments to create many TwitterDirectMessages.
     *     @example
     *     // Create many TwitterDirectMessages
     *     const twitterDirectMessage = await prisma.twitterDirectMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwitterDirectMessageCreateManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwitterDirectMessage.
     * @param {TwitterDirectMessageDeleteArgs} args - Arguments to delete one TwitterDirectMessage.
     * @example
     * // Delete one TwitterDirectMessage
     * const TwitterDirectMessage = await prisma.twitterDirectMessage.delete({
     *   where: {
     *     // ... filter to delete one TwitterDirectMessage
     *   }
     * })
     * 
    **/
    delete<T extends TwitterDirectMessageDeleteArgs>(
      args: SelectSubset<T, TwitterDirectMessageDeleteArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpdateArgs} args - Arguments to update one TwitterDirectMessage.
     * @example
     * // Update one TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwitterDirectMessageUpdateArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Delete zero or more TwitterDirectMessages.
     * @param {TwitterDirectMessageDeleteManyArgs} args - Arguments to filter TwitterDirectMessages to delete.
     * @example
     * // Delete a few TwitterDirectMessages
     * const { count } = await prisma.twitterDirectMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwitterDirectMessageDeleteManyArgs>(
      args?: SelectSubset<T, TwitterDirectMessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterDirectMessages
     * const twitterDirectMessage = await prisma.twitterDirectMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwitterDirectMessageUpdateManyArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwitterDirectMessage.
     * @param {TwitterDirectMessageUpsertArgs} args - Arguments to update or create a TwitterDirectMessage.
     * @example
     * // Update or create a TwitterDirectMessage
     * const twitterDirectMessage = await prisma.twitterDirectMessage.upsert({
     *   create: {
     *     // ... data to create a TwitterDirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterDirectMessage we want to update
     *   }
     * })
    **/
    upsert<T extends TwitterDirectMessageUpsertArgs>(
      args: SelectSubset<T, TwitterDirectMessageUpsertArgs>
    ): Prisma__TwitterDirectMessageClient<TwitterDirectMessageGetPayload<T>>

    /**
     * Count the number of TwitterDirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageCountArgs} args - Arguments to filter TwitterDirectMessages to count.
     * @example
     * // Count the number of TwitterDirectMessages
     * const count = await prisma.twitterDirectMessage.count({
     *   where: {
     *     // ... the filter for the TwitterDirectMessages we want to count
     *   }
     * })
    **/
    count<T extends TwitterDirectMessageCountArgs>(
      args?: Subset<T, TwitterDirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterDirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterDirectMessageAggregateArgs>(args: Subset<T, TwitterDirectMessageAggregateArgs>): Prisma.PrismaPromise<GetTwitterDirectMessageAggregateType<T>>

    /**
     * Group by TwitterDirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterDirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterDirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterDirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: TwitterDirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterDirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterDirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwitterDirectMessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    to<T extends TwitterUserArgs= {}>(args?: Subset<T, TwitterUserArgs>): Prisma__TwitterUserClient<TwitterUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwitterDirectMessage base type for findUnique actions
   */
  export type TwitterDirectMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }

  /**
   * TwitterDirectMessage findUnique
   */
  export interface TwitterDirectMessageFindUniqueArgs extends TwitterDirectMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findUniqueOrThrow
   */
  export type TwitterDirectMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage base type for findFirst actions
   */
  export type TwitterDirectMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }

  /**
   * TwitterDirectMessage findFirst
   */
  export interface TwitterDirectMessageFindFirstArgs extends TwitterDirectMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwitterDirectMessage findFirstOrThrow
   */
  export type TwitterDirectMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessage to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterDirectMessages.
     */
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage findMany
   */
  export type TwitterDirectMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter, which TwitterDirectMessages to fetch.
     */
    where?: TwitterDirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterDirectMessages to fetch.
     */
    orderBy?: Enumerable<TwitterDirectMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterDirectMessages.
     */
    cursor?: TwitterDirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterDirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterDirectMessages.
     */
    skip?: number
    distinct?: Enumerable<TwitterDirectMessageScalarFieldEnum>
  }


  /**
   * TwitterDirectMessage create
   */
  export type TwitterDirectMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to create a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
  }


  /**
   * TwitterDirectMessage createMany
   */
  export type TwitterDirectMessageCreateManyArgs = {
    /**
     * The data used to create many TwitterDirectMessages.
     */
    data: Enumerable<TwitterDirectMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwitterDirectMessage update
   */
  export type TwitterDirectMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The data needed to update a TwitterDirectMessage.
     */
    data: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
    /**
     * Choose, which TwitterDirectMessage to update.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage updateMany
   */
  export type TwitterDirectMessageUpdateManyArgs = {
    /**
     * The data used to update TwitterDirectMessages.
     */
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which TwitterDirectMessages to update
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage upsert
   */
  export type TwitterDirectMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * The filter to search for the TwitterDirectMessage to update in case it exists.
     */
    where: TwitterDirectMessageWhereUniqueInput
    /**
     * In case the TwitterDirectMessage found by the `where` argument doesn't exist, create a new TwitterDirectMessage with this data.
     */
    create: XOR<TwitterDirectMessageCreateInput, TwitterDirectMessageUncheckedCreateInput>
    /**
     * In case the TwitterDirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterDirectMessageUpdateInput, TwitterDirectMessageUncheckedUpdateInput>
  }


  /**
   * TwitterDirectMessage delete
   */
  export type TwitterDirectMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
    /**
     * Filter which TwitterDirectMessage to delete.
     */
    where: TwitterDirectMessageWhereUniqueInput
  }


  /**
   * TwitterDirectMessage deleteMany
   */
  export type TwitterDirectMessageDeleteManyArgs = {
    /**
     * Filter which TwitterDirectMessages to delete
     */
    where?: TwitterDirectMessageWhereInput
  }


  /**
   * TwitterDirectMessage without action
   */
  export type TwitterDirectMessageArgs = {
    /**
     * Select specific fields to fetch from the TwitterDirectMessage
     */
    select?: TwitterDirectMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwitterDirectMessageInclude | null
  }



  /**
   * Model YoutubeUser
   */


  export type AggregateYoutubeUser = {
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  export type YoutubeUserAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeUserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeUserAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeUserSumAggregateInputType = {
    id?: true
  }

  export type YoutubeUserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeUserAggregateArgs = {
    /**
     * Filter which YoutubeUser to aggregate.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUsers
    **/
    _count?: true | YoutubeUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserMaxAggregateInputType
  }

  export type GetYoutubeUserAggregateType<T extends YoutubeUserAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUser[P]>
      : GetScalarType<T[P], AggregateYoutubeUser[P]>
  }




  export type YoutubeUserGroupByArgs = {
    where?: YoutubeUserWhereInput
    orderBy?: Enumerable<YoutubeUserOrderByWithAggregationInput>
    by: YoutubeUserScalarFieldEnum[]
    having?: YoutubeUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserCountAggregateInputType | true
    _avg?: YoutubeUserAvgAggregateInputType
    _sum?: YoutubeUserSumAggregateInputType
    _min?: YoutubeUserMinAggregateInputType
    _max?: YoutubeUserMaxAggregateInputType
  }


  export type YoutubeUserGroupByOutputType = {
    id: number
    username: string
    email: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: YoutubeUserCountAggregateOutputType | null
    _avg: YoutubeUserAvgAggregateOutputType | null
    _sum: YoutubeUserSumAggregateOutputType | null
    _min: YoutubeUserMinAggregateOutputType | null
    _max: YoutubeUserMaxAggregateOutputType | null
  }

  type GetYoutubeUserGroupByPayload<T extends YoutubeUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserSelect = {
    id?: boolean
    username?: boolean
    email?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userToChannels?: boolean | YoutubeUser$userToChannelsArgs
    subscribers?: boolean | YoutubeUser$subscribersArgs
    reactions?: boolean | YoutubeUser$reactionsArgs
    comments?: boolean | YoutubeUser$commentsArgs
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }


  export type YoutubeUserInclude = {
    userToChannels?: boolean | YoutubeUser$userToChannelsArgs
    subscribers?: boolean | YoutubeUser$subscribersArgs
    reactions?: boolean | YoutubeUser$reactionsArgs
    comments?: boolean | YoutubeUser$commentsArgs
    _count?: boolean | YoutubeUserCountOutputTypeArgs
  }

  export type YoutubeUserGetPayload<S extends boolean | null | undefined | YoutubeUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUser :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
    ? YoutubeUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends 'subscribers' ? Array < YoutubeSubscriberGetPayload<S['include'][P]>>  :
        P extends 'reactions' ? Array < YoutubeReactionGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < YoutubeCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserArgs | YoutubeUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends 'subscribers' ? Array < YoutubeSubscriberGetPayload<S['select'][P]>>  :
        P extends 'reactions' ? Array < YoutubeReactionGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < YoutubeCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeUser ? YoutubeUser[P] : never
  } 
      : YoutubeUser


  type YoutubeUserCountArgs = 
    Omit<YoutubeUserFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserCountAggregateInputType | true
    }

  export interface YoutubeUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUser that matches the filter.
     * @param {YoutubeUserFindUniqueArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find one YoutubeUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find the first YoutubeUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUser'> extends True ? Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>> : Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindFirstOrThrowArgs} args - Arguments to find a YoutubeUser
     * @example
     * // Get one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Find zero or more YoutubeUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany()
     * 
     * // Get first 10 YoutubeUsers
     * const youtubeUsers = await prisma.youtubeUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeUserWithIdOnly = await prisma.youtubeUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeUserFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserGetPayload<T>>>

    /**
     * Create a YoutubeUser.
     * @param {YoutubeUserCreateArgs} args - Arguments to create a YoutubeUser.
     * @example
     * // Create one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.create({
     *   data: {
     *     // ... data to create a YoutubeUser
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserCreateArgs>(
      args: SelectSubset<T, YoutubeUserCreateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Create many YoutubeUsers.
     *     @param {YoutubeUserCreateManyArgs} args - Arguments to create many YoutubeUsers.
     *     @example
     *     // Create many YoutubeUsers
     *     const youtubeUser = await prisma.youtubeUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUser.
     * @param {YoutubeUserDeleteArgs} args - Arguments to delete one YoutubeUser.
     * @example
     * // Delete one YoutubeUser
     * const YoutubeUser = await prisma.youtubeUser.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUser
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserDeleteArgs>(
      args: SelectSubset<T, YoutubeUserDeleteArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Update one YoutubeUser.
     * @param {YoutubeUserUpdateArgs} args - Arguments to update one YoutubeUser.
     * @example
     * // Update one YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserUpdateArgs>(
      args: SelectSubset<T, YoutubeUserUpdateArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Delete zero or more YoutubeUsers.
     * @param {YoutubeUserDeleteManyArgs} args - Arguments to filter YoutubeUsers to delete.
     * @example
     * // Delete a few YoutubeUsers
     * const { count } = await prisma.youtubeUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUsers
     * const youtubeUser = await prisma.youtubeUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUser.
     * @param {YoutubeUserUpsertArgs} args - Arguments to update or create a YoutubeUser.
     * @example
     * // Update or create a YoutubeUser
     * const youtubeUser = await prisma.youtubeUser.upsert({
     *   create: {
     *     // ... data to create a YoutubeUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUser we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserUpsertArgs>(
      args: SelectSubset<T, YoutubeUserUpsertArgs>
    ): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T>>

    /**
     * Count the number of YoutubeUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserCountArgs} args - Arguments to filter YoutubeUsers to count.
     * @example
     * // Count the number of YoutubeUsers
     * const count = await prisma.youtubeUser.count({
     *   where: {
     *     // ... the filter for the YoutubeUsers we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserCountArgs>(
      args?: Subset<T, YoutubeUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserAggregateArgs>(args: Subset<T, YoutubeUserAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserAggregateType<T>>

    /**
     * Group by YoutubeUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannels<T extends YoutubeUser$userToChannelsArgs= {}>(args?: Subset<T, YoutubeUser$userToChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    subscribers<T extends YoutubeUser$subscribersArgs= {}>(args?: Subset<T, YoutubeUser$subscribersArgs>): Prisma.PrismaPromise<Array<YoutubeSubscriberGetPayload<T>>| Null>;

    reactions<T extends YoutubeUser$reactionsArgs= {}>(args?: Subset<T, YoutubeUser$reactionsArgs>): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>| Null>;

    comments<T extends YoutubeUser$commentsArgs= {}>(args?: Subset<T, YoutubeUser$commentsArgs>): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUser base type for findUnique actions
   */
  export type YoutubeUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }

  /**
   * YoutubeUser findUnique
   */
  export interface YoutubeUserFindUniqueArgs extends YoutubeUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findUniqueOrThrow
   */
  export type YoutubeUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser base type for findFirst actions
   */
  export type YoutubeUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }

  /**
   * YoutubeUser findFirst
   */
  export interface YoutubeUserFindFirstArgs extends YoutubeUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUser findFirstOrThrow
   */
  export type YoutubeUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUser to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUsers.
     */
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser findMany
   */
  export type YoutubeUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter, which YoutubeUsers to fetch.
     */
    where?: YoutubeUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUsers to fetch.
     */
    orderBy?: Enumerable<YoutubeUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUsers.
     */
    cursor?: YoutubeUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUsers.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserScalarFieldEnum>
  }


  /**
   * YoutubeUser create
   */
  export type YoutubeUserCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to create a YoutubeUser.
     */
    data: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
  }


  /**
   * YoutubeUser createMany
   */
  export type YoutubeUserCreateManyArgs = {
    /**
     * The data used to create many YoutubeUsers.
     */
    data: Enumerable<YoutubeUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUser update
   */
  export type YoutubeUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The data needed to update a YoutubeUser.
     */
    data: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUser to update.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser updateMany
   */
  export type YoutubeUserUpdateManyArgs = {
    /**
     * The data used to update YoutubeUsers.
     */
    data: XOR<YoutubeUserUpdateManyMutationInput, YoutubeUserUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUsers to update
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser upsert
   */
  export type YoutubeUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * The filter to search for the YoutubeUser to update in case it exists.
     */
    where: YoutubeUserWhereUniqueInput
    /**
     * In case the YoutubeUser found by the `where` argument doesn't exist, create a new YoutubeUser with this data.
     */
    create: XOR<YoutubeUserCreateInput, YoutubeUserUncheckedCreateInput>
    /**
     * In case the YoutubeUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserUpdateInput, YoutubeUserUncheckedUpdateInput>
  }


  /**
   * YoutubeUser delete
   */
  export type YoutubeUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
    /**
     * Filter which YoutubeUser to delete.
     */
    where: YoutubeUserWhereUniqueInput
  }


  /**
   * YoutubeUser deleteMany
   */
  export type YoutubeUserDeleteManyArgs = {
    /**
     * Filter which YoutubeUsers to delete
     */
    where?: YoutubeUserWhereInput
  }


  /**
   * YoutubeUser.userToChannels
   */
  export type YoutubeUser$userToChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUser.subscribers
   */
  export type YoutubeUser$subscribersArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    where?: YoutubeSubscriberWhereInput
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    cursor?: YoutubeSubscriberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeSubscriberScalarFieldEnum>
  }


  /**
   * YoutubeUser.reactions
   */
  export type YoutubeUser$reactionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    cursor?: YoutubeReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeUser.comments
   */
  export type YoutubeUser$commentsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    cursor?: YoutubeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeUser without action
   */
  export type YoutubeUserArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUser
     */
    select?: YoutubeUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserInclude | null
  }



  /**
   * Model YoutubeRole
   */


  export type AggregateYoutubeRole = {
    _count: YoutubeRoleCountAggregateOutputType | null
    _avg: YoutubeRoleAvgAggregateOutputType | null
    _sum: YoutubeRoleSumAggregateOutputType | null
    _min: YoutubeRoleMinAggregateOutputType | null
    _max: YoutubeRoleMaxAggregateOutputType | null
  }

  export type YoutubeRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeRoleSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeRoleMinAggregateOutputType = {
    id: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeRoleMaxAggregateOutputType = {
    id: number | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeRoleCountAggregateOutputType = {
    id: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeRoleAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeRoleSumAggregateInputType = {
    id?: true
  }

  export type YoutubeRoleMinAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeRoleMaxAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeRoleCountAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeRoleAggregateArgs = {
    /**
     * Filter which YoutubeRole to aggregate.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeRoles
    **/
    _count?: true | YoutubeRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeRoleMaxAggregateInputType
  }

  export type GetYoutubeRoleAggregateType<T extends YoutubeRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeRole[P]>
      : GetScalarType<T[P], AggregateYoutubeRole[P]>
  }




  export type YoutubeRoleGroupByArgs = {
    where?: YoutubeRoleWhereInput
    orderBy?: Enumerable<YoutubeRoleOrderByWithAggregationInput>
    by: YoutubeRoleScalarFieldEnum[]
    having?: YoutubeRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeRoleCountAggregateInputType | true
    _avg?: YoutubeRoleAvgAggregateInputType
    _sum?: YoutubeRoleSumAggregateInputType
    _min?: YoutubeRoleMinAggregateInputType
    _max?: YoutubeRoleMaxAggregateInputType
  }


  export type YoutubeRoleGroupByOutputType = {
    id: number
    role: string
    createdAt: Date
    updatedAt: Date
    _count: YoutubeRoleCountAggregateOutputType | null
    _avg: YoutubeRoleAvgAggregateOutputType | null
    _sum: YoutubeRoleSumAggregateOutputType | null
    _min: YoutubeRoleMinAggregateOutputType | null
    _max: YoutubeRoleMaxAggregateOutputType | null
  }

  type GetYoutubeRoleGroupByPayload<T extends YoutubeRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeRoleGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeRoleGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeRoleSelect = {
    id?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userToChannels?: boolean | YoutubeRole$userToChannelsArgs
    _count?: boolean | YoutubeRoleCountOutputTypeArgs
  }


  export type YoutubeRoleInclude = {
    userToChannels?: boolean | YoutubeRole$userToChannelsArgs
    _count?: boolean | YoutubeRoleCountOutputTypeArgs
  }

  export type YoutubeRoleGetPayload<S extends boolean | null | undefined | YoutubeRoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeRole :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeRoleArgs | YoutubeRoleFindManyArgs)
    ? YoutubeRole  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeRoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeRoleArgs | YoutubeRoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeRoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeRole ? YoutubeRole[P] : never
  } 
      : YoutubeRole


  type YoutubeRoleCountArgs = 
    Omit<YoutubeRoleFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeRoleCountAggregateInputType | true
    }

  export interface YoutubeRoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeRole that matches the filter.
     * @param {YoutubeRoleFindUniqueArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeRole'> extends True ? Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>> : Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | null, null>

    /**
     * Find one YoutubeRole that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeRoleFindUniqueOrThrowArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeRoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeRoleFindUniqueOrThrowArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Find the first YoutubeRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindFirstArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeRole'> extends True ? Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>> : Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | null, null>

    /**
     * Find the first YoutubeRole that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindFirstOrThrowArgs} args - Arguments to find a YoutubeRole
     * @example
     * // Get one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeRoleFindFirstOrThrowArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Find zero or more YoutubeRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeRoles
     * const youtubeRoles = await prisma.youtubeRole.findMany()
     * 
     * // Get first 10 YoutubeRoles
     * const youtubeRoles = await prisma.youtubeRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeRoleWithIdOnly = await prisma.youtubeRole.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeRoleFindManyArgs>(
      args?: SelectSubset<T, YoutubeRoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeRoleGetPayload<T>>>

    /**
     * Create a YoutubeRole.
     * @param {YoutubeRoleCreateArgs} args - Arguments to create a YoutubeRole.
     * @example
     * // Create one YoutubeRole
     * const YoutubeRole = await prisma.youtubeRole.create({
     *   data: {
     *     // ... data to create a YoutubeRole
     *   }
     * })
     * 
    **/
    create<T extends YoutubeRoleCreateArgs>(
      args: SelectSubset<T, YoutubeRoleCreateArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Create many YoutubeRoles.
     *     @param {YoutubeRoleCreateManyArgs} args - Arguments to create many YoutubeRoles.
     *     @example
     *     // Create many YoutubeRoles
     *     const youtubeRole = await prisma.youtubeRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeRoleCreateManyArgs>(
      args?: SelectSubset<T, YoutubeRoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeRole.
     * @param {YoutubeRoleDeleteArgs} args - Arguments to delete one YoutubeRole.
     * @example
     * // Delete one YoutubeRole
     * const YoutubeRole = await prisma.youtubeRole.delete({
     *   where: {
     *     // ... filter to delete one YoutubeRole
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeRoleDeleteArgs>(
      args: SelectSubset<T, YoutubeRoleDeleteArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Update one YoutubeRole.
     * @param {YoutubeRoleUpdateArgs} args - Arguments to update one YoutubeRole.
     * @example
     * // Update one YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeRoleUpdateArgs>(
      args: SelectSubset<T, YoutubeRoleUpdateArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Delete zero or more YoutubeRoles.
     * @param {YoutubeRoleDeleteManyArgs} args - Arguments to filter YoutubeRoles to delete.
     * @example
     * // Delete a few YoutubeRoles
     * const { count } = await prisma.youtubeRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeRoleDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeRoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeRoles
     * const youtubeRole = await prisma.youtubeRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeRoleUpdateManyArgs>(
      args: SelectSubset<T, YoutubeRoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeRole.
     * @param {YoutubeRoleUpsertArgs} args - Arguments to update or create a YoutubeRole.
     * @example
     * // Update or create a YoutubeRole
     * const youtubeRole = await prisma.youtubeRole.upsert({
     *   create: {
     *     // ... data to create a YoutubeRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeRole we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeRoleUpsertArgs>(
      args: SelectSubset<T, YoutubeRoleUpsertArgs>
    ): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T>>

    /**
     * Count the number of YoutubeRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleCountArgs} args - Arguments to filter YoutubeRoles to count.
     * @example
     * // Count the number of YoutubeRoles
     * const count = await prisma.youtubeRole.count({
     *   where: {
     *     // ... the filter for the YoutubeRoles we want to count
     *   }
     * })
    **/
    count<T extends YoutubeRoleCountArgs>(
      args?: Subset<T, YoutubeRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeRoleAggregateArgs>(args: Subset<T, YoutubeRoleAggregateArgs>): Prisma.PrismaPromise<GetYoutubeRoleAggregateType<T>>

    /**
     * Group by YoutubeRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeRoleGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeRoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannels<T extends YoutubeRole$userToChannelsArgs= {}>(args?: Subset<T, YoutubeRole$userToChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeRole base type for findUnique actions
   */
  export type YoutubeRoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where: YoutubeRoleWhereUniqueInput
  }

  /**
   * YoutubeRole findUnique
   */
  export interface YoutubeRoleFindUniqueArgs extends YoutubeRoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeRole findUniqueOrThrow
   */
  export type YoutubeRoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole base type for findFirst actions
   */
  export type YoutubeRoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeRoles.
     */
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }

  /**
   * YoutubeRole findFirst
   */
  export interface YoutubeRoleFindFirstArgs extends YoutubeRoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeRole findFirstOrThrow
   */
  export type YoutubeRoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRole to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeRoles.
     */
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }


  /**
   * YoutubeRole findMany
   */
  export type YoutubeRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter, which YoutubeRoles to fetch.
     */
    where?: YoutubeRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeRoles to fetch.
     */
    orderBy?: Enumerable<YoutubeRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeRoles.
     */
    cursor?: YoutubeRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeRoles.
     */
    skip?: number
    distinct?: Enumerable<YoutubeRoleScalarFieldEnum>
  }


  /**
   * YoutubeRole create
   */
  export type YoutubeRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The data needed to create a YoutubeRole.
     */
    data: XOR<YoutubeRoleCreateInput, YoutubeRoleUncheckedCreateInput>
  }


  /**
   * YoutubeRole createMany
   */
  export type YoutubeRoleCreateManyArgs = {
    /**
     * The data used to create many YoutubeRoles.
     */
    data: Enumerable<YoutubeRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeRole update
   */
  export type YoutubeRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The data needed to update a YoutubeRole.
     */
    data: XOR<YoutubeRoleUpdateInput, YoutubeRoleUncheckedUpdateInput>
    /**
     * Choose, which YoutubeRole to update.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole updateMany
   */
  export type YoutubeRoleUpdateManyArgs = {
    /**
     * The data used to update YoutubeRoles.
     */
    data: XOR<YoutubeRoleUpdateManyMutationInput, YoutubeRoleUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeRoles to update
     */
    where?: YoutubeRoleWhereInput
  }


  /**
   * YoutubeRole upsert
   */
  export type YoutubeRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * The filter to search for the YoutubeRole to update in case it exists.
     */
    where: YoutubeRoleWhereUniqueInput
    /**
     * In case the YoutubeRole found by the `where` argument doesn't exist, create a new YoutubeRole with this data.
     */
    create: XOR<YoutubeRoleCreateInput, YoutubeRoleUncheckedCreateInput>
    /**
     * In case the YoutubeRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeRoleUpdateInput, YoutubeRoleUncheckedUpdateInput>
  }


  /**
   * YoutubeRole delete
   */
  export type YoutubeRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
    /**
     * Filter which YoutubeRole to delete.
     */
    where: YoutubeRoleWhereUniqueInput
  }


  /**
   * YoutubeRole deleteMany
   */
  export type YoutubeRoleDeleteManyArgs = {
    /**
     * Filter which YoutubeRoles to delete
     */
    where?: YoutubeRoleWhereInput
  }


  /**
   * YoutubeRole.userToChannels
   */
  export type YoutubeRole$userToChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeRole without action
   */
  export type YoutubeRoleArgs = {
    /**
     * Select specific fields to fetch from the YoutubeRole
     */
    select?: YoutubeRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeRoleInclude | null
  }



  /**
   * Model YoutubeChannel
   */


  export type AggregateYoutubeChannel = {
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  export type YoutubeChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelSumAggregateOutputType = {
    id: number | null
  }

  export type YoutubeChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    descriptions: string | null
    image: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    descriptions: string | null
    image: string | null
    coverImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeChannelCountAggregateOutputType = {
    id: number
    name: number
    descriptions: number
    image: number
    coverImage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeChannelAvgAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelSumAggregateInputType = {
    id?: true
  }

  export type YoutubeChannelMinAggregateInputType = {
    id?: true
    name?: true
    descriptions?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeChannelMaxAggregateInputType = {
    id?: true
    name?: true
    descriptions?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeChannelCountAggregateInputType = {
    id?: true
    name?: true
    descriptions?: true
    image?: true
    coverImage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeChannelAggregateArgs = {
    /**
     * Filter which YoutubeChannel to aggregate.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeChannels
    **/
    _count?: true | YoutubeChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeChannelMaxAggregateInputType
  }

  export type GetYoutubeChannelAggregateType<T extends YoutubeChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeChannel[P]>
  }




  export type YoutubeChannelGroupByArgs = {
    where?: YoutubeChannelWhereInput
    orderBy?: Enumerable<YoutubeChannelOrderByWithAggregationInput>
    by: YoutubeChannelScalarFieldEnum[]
    having?: YoutubeChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeChannelCountAggregateInputType | true
    _avg?: YoutubeChannelAvgAggregateInputType
    _sum?: YoutubeChannelSumAggregateInputType
    _min?: YoutubeChannelMinAggregateInputType
    _max?: YoutubeChannelMaxAggregateInputType
  }


  export type YoutubeChannelGroupByOutputType = {
    id: number
    name: string
    descriptions: string
    image: string | null
    coverImage: string | null
    createdAt: Date
    updatedAt: Date
    _count: YoutubeChannelCountAggregateOutputType | null
    _avg: YoutubeChannelAvgAggregateOutputType | null
    _sum: YoutubeChannelSumAggregateOutputType | null
    _min: YoutubeChannelMinAggregateOutputType | null
    _max: YoutubeChannelMaxAggregateOutputType | null
  }

  type GetYoutubeChannelGroupByPayload<T extends YoutubeChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeChannelSelect = {
    id?: boolean
    name?: boolean
    descriptions?: boolean
    image?: boolean
    coverImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userToChannels?: boolean | YoutubeChannel$userToChannelsArgs
    videos?: boolean | YoutubeChannel$videosArgs
    subscribers?: boolean | YoutubeChannel$subscribersArgs
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }


  export type YoutubeChannelInclude = {
    userToChannels?: boolean | YoutubeChannel$userToChannelsArgs
    videos?: boolean | YoutubeChannel$videosArgs
    subscribers?: boolean | YoutubeChannel$subscribersArgs
    _count?: boolean | YoutubeChannelCountOutputTypeArgs
  }

  export type YoutubeChannelGetPayload<S extends boolean | null | undefined | YoutubeChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
    ? YoutubeChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['include'][P]>>  :
        P extends 'videos' ? Array < YoutubeVideoGetPayload<S['include'][P]>>  :
        P extends 'subscribers' ? Array < YoutubeSubscriberGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeChannelArgs | YoutubeChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userToChannels' ? Array < YoutubeUserToChannelGetPayload<S['select'][P]>>  :
        P extends 'videos' ? Array < YoutubeVideoGetPayload<S['select'][P]>>  :
        P extends 'subscribers' ? Array < YoutubeSubscriberGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeChannelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeChannel ? YoutubeChannel[P] : never
  } 
      : YoutubeChannel


  type YoutubeChannelCountArgs = 
    Omit<YoutubeChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeChannelCountAggregateInputType | true
    }

  export interface YoutubeChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeChannel that matches the filter.
     * @param {YoutubeChannelFindUniqueArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find the first YoutubeChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeChannel'> extends True ? Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>> : Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeChannel
     * @example
     * // Get one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany()
     * 
     * // Get first 10 YoutubeChannels
     * const youtubeChannels = await prisma.youtubeChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeChannelWithIdOnly = await prisma.youtubeChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeChannelGetPayload<T>>>

    /**
     * Create a YoutubeChannel.
     * @param {YoutubeChannelCreateArgs} args - Arguments to create a YoutubeChannel.
     * @example
     * // Create one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.create({
     *   data: {
     *     // ... data to create a YoutubeChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeChannelCreateArgs>(
      args: SelectSubset<T, YoutubeChannelCreateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Create many YoutubeChannels.
     *     @param {YoutubeChannelCreateManyArgs} args - Arguments to create many YoutubeChannels.
     *     @example
     *     // Create many YoutubeChannels
     *     const youtubeChannel = await prisma.youtubeChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeChannel.
     * @param {YoutubeChannelDeleteArgs} args - Arguments to delete one YoutubeChannel.
     * @example
     * // Delete one YoutubeChannel
     * const YoutubeChannel = await prisma.youtubeChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeChannelDeleteArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Update one YoutubeChannel.
     * @param {YoutubeChannelUpdateArgs} args - Arguments to update one YoutubeChannel.
     * @example
     * // Update one YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeChannels.
     * @param {YoutubeChannelDeleteManyArgs} args - Arguments to filter YoutubeChannels to delete.
     * @example
     * // Delete a few YoutubeChannels
     * const { count } = await prisma.youtubeChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeChannels
     * const youtubeChannel = await prisma.youtubeChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeChannel.
     * @param {YoutubeChannelUpsertArgs} args - Arguments to update or create a YoutubeChannel.
     * @example
     * // Update or create a YoutubeChannel
     * const youtubeChannel = await prisma.youtubeChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeChannelUpsertArgs>
    ): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T>>

    /**
     * Count the number of YoutubeChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelCountArgs} args - Arguments to filter YoutubeChannels to count.
     * @example
     * // Count the number of YoutubeChannels
     * const count = await prisma.youtubeChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeChannelCountArgs>(
      args?: Subset<T, YoutubeChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeChannelAggregateArgs>(args: Subset<T, YoutubeChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeChannelAggregateType<T>>

    /**
     * Group by YoutubeChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userToChannels<T extends YoutubeChannel$userToChannelsArgs= {}>(args?: Subset<T, YoutubeChannel$userToChannelsArgs>): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>| Null>;

    videos<T extends YoutubeChannel$videosArgs= {}>(args?: Subset<T, YoutubeChannel$videosArgs>): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>| Null>;

    subscribers<T extends YoutubeChannel$subscribersArgs= {}>(args?: Subset<T, YoutubeChannel$subscribersArgs>): Prisma.PrismaPromise<Array<YoutubeSubscriberGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeChannel base type for findUnique actions
   */
  export type YoutubeChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }

  /**
   * YoutubeChannel findUnique
   */
  export interface YoutubeChannelFindUniqueArgs extends YoutubeChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findUniqueOrThrow
   */
  export type YoutubeChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel base type for findFirst actions
   */
  export type YoutubeChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }

  /**
   * YoutubeChannel findFirst
   */
  export interface YoutubeChannelFindFirstArgs extends YoutubeChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeChannel findFirstOrThrow
   */
  export type YoutubeChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannel to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeChannels.
     */
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel findMany
   */
  export type YoutubeChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter, which YoutubeChannels to fetch.
     */
    where?: YoutubeChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeChannels.
     */
    cursor?: YoutubeChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel create
   */
  export type YoutubeChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to create a YoutubeChannel.
     */
    data: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
  }


  /**
   * YoutubeChannel createMany
   */
  export type YoutubeChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeChannels.
     */
    data: Enumerable<YoutubeChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeChannel update
   */
  export type YoutubeChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The data needed to update a YoutubeChannel.
     */
    data: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeChannel to update.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel updateMany
   */
  export type YoutubeChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeChannels.
     */
    data: XOR<YoutubeChannelUpdateManyMutationInput, YoutubeChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeChannels to update
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel upsert
   */
  export type YoutubeChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * The filter to search for the YoutubeChannel to update in case it exists.
     */
    where: YoutubeChannelWhereUniqueInput
    /**
     * In case the YoutubeChannel found by the `where` argument doesn't exist, create a new YoutubeChannel with this data.
     */
    create: XOR<YoutubeChannelCreateInput, YoutubeChannelUncheckedCreateInput>
    /**
     * In case the YoutubeChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeChannelUpdateInput, YoutubeChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeChannel delete
   */
  export type YoutubeChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
    /**
     * Filter which YoutubeChannel to delete.
     */
    where: YoutubeChannelWhereUniqueInput
  }


  /**
   * YoutubeChannel deleteMany
   */
  export type YoutubeChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeChannels to delete
     */
    where?: YoutubeChannelWhereInput
  }


  /**
   * YoutubeChannel.userToChannels
   */
  export type YoutubeChannel$userToChannelsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    cursor?: YoutubeUserToChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeChannel.videos
   */
  export type YoutubeChannel$videosArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    cursor?: YoutubeVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeChannel.subscribers
   */
  export type YoutubeChannel$subscribersArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    where?: YoutubeSubscriberWhereInput
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    cursor?: YoutubeSubscriberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeSubscriberScalarFieldEnum>
  }


  /**
   * YoutubeChannel without action
   */
  export type YoutubeChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeChannel
     */
    select?: YoutubeChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeChannelInclude | null
  }



  /**
   * Model YoutubeUserToChannel
   */


  export type AggregateYoutubeUserToChannel = {
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  export type YoutubeUserToChannelAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    channelId: number | null
  }

  export type YoutubeUserToChannelSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    channelId: number | null
  }

  export type YoutubeUserToChannelMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserToChannelMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    channelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeUserToChannelCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    channelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeUserToChannelAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    channelId?: true
  }

  export type YoutubeUserToChannelSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    channelId?: true
  }

  export type YoutubeUserToChannelMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserToChannelMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeUserToChannelCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    channelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeUserToChannelAggregateArgs = {
    /**
     * Filter which YoutubeUserToChannel to aggregate.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeUserToChannels
    **/
    _count?: true | YoutubeUserToChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeUserToChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeUserToChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }

  export type GetYoutubeUserToChannelAggregateType<T extends YoutubeUserToChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeUserToChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
      : GetScalarType<T[P], AggregateYoutubeUserToChannel[P]>
  }




  export type YoutubeUserToChannelGroupByArgs = {
    where?: YoutubeUserToChannelWhereInput
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithAggregationInput>
    by: YoutubeUserToChannelScalarFieldEnum[]
    having?: YoutubeUserToChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeUserToChannelCountAggregateInputType | true
    _avg?: YoutubeUserToChannelAvgAggregateInputType
    _sum?: YoutubeUserToChannelSumAggregateInputType
    _min?: YoutubeUserToChannelMinAggregateInputType
    _max?: YoutubeUserToChannelMaxAggregateInputType
  }


  export type YoutubeUserToChannelGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    channelId: number
    createdAt: Date
    updatedAt: Date
    _count: YoutubeUserToChannelCountAggregateOutputType | null
    _avg: YoutubeUserToChannelAvgAggregateOutputType | null
    _sum: YoutubeUserToChannelSumAggregateOutputType | null
    _min: YoutubeUserToChannelMinAggregateOutputType | null
    _max: YoutubeUserToChannelMaxAggregateOutputType | null
  }

  type GetYoutubeUserToChannelGroupByPayload<T extends YoutubeUserToChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeUserToChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeUserToChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeUserToChannelGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeUserToChannelSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    role?: boolean | YoutubeRoleArgs
    channel?: boolean | YoutubeChannelArgs
    userId?: boolean
    roleId?: boolean
    channelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YoutubeUserToChannelInclude = {
    user?: boolean | YoutubeUserArgs
    role?: boolean | YoutubeRoleArgs
    channel?: boolean | YoutubeChannelArgs
  }

  export type YoutubeUserToChannelGetPayload<S extends boolean | null | undefined | YoutubeUserToChannelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeUserToChannel :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
    ? YoutubeUserToChannel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'role' ? YoutubeRoleGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeUserToChannelArgs | YoutubeUserToChannelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'role' ? YoutubeRoleGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :  P extends keyof YoutubeUserToChannel ? YoutubeUserToChannel[P] : never
  } 
      : YoutubeUserToChannel


  type YoutubeUserToChannelCountArgs = 
    Omit<YoutubeUserToChannelFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeUserToChannelCountAggregateInputType | true
    }

  export interface YoutubeUserToChannelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeUserToChannel that matches the filter.
     * @param {YoutubeUserToChannelFindUniqueArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeUserToChannelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeUserToChannelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find one YoutubeUserToChannel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeUserToChannelFindUniqueOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeUserToChannelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindUniqueOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find the first YoutubeUserToChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeUserToChannelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeUserToChannel'> extends True ? Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>> : Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T> | null, null>

    /**
     * Find the first YoutubeUserToChannel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindFirstOrThrowArgs} args - Arguments to find a YoutubeUserToChannel
     * @example
     * // Get one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeUserToChannelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindFirstOrThrowArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Find zero or more YoutubeUserToChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany()
     * 
     * // Get first 10 YoutubeUserToChannels
     * const youtubeUserToChannels = await prisma.youtubeUserToChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeUserToChannelWithIdOnly = await prisma.youtubeUserToChannel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeUserToChannelFindManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeUserToChannelGetPayload<T>>>

    /**
     * Create a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelCreateArgs} args - Arguments to create a YoutubeUserToChannel.
     * @example
     * // Create one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.create({
     *   data: {
     *     // ... data to create a YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    create<T extends YoutubeUserToChannelCreateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelCreateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Create many YoutubeUserToChannels.
     *     @param {YoutubeUserToChannelCreateManyArgs} args - Arguments to create many YoutubeUserToChannels.
     *     @example
     *     // Create many YoutubeUserToChannels
     *     const youtubeUserToChannel = await prisma.youtubeUserToChannel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeUserToChannelCreateManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeUserToChannel.
     * @param {YoutubeUserToChannelDeleteArgs} args - Arguments to delete one YoutubeUserToChannel.
     * @example
     * // Delete one YoutubeUserToChannel
     * const YoutubeUserToChannel = await prisma.youtubeUserToChannel.delete({
     *   where: {
     *     // ... filter to delete one YoutubeUserToChannel
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeUserToChannelDeleteArgs>(
      args: SelectSubset<T, YoutubeUserToChannelDeleteArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpdateArgs} args - Arguments to update one YoutubeUserToChannel.
     * @example
     * // Update one YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeUserToChannelUpdateArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Delete zero or more YoutubeUserToChannels.
     * @param {YoutubeUserToChannelDeleteManyArgs} args - Arguments to filter YoutubeUserToChannels to delete.
     * @example
     * // Delete a few YoutubeUserToChannels
     * const { count } = await prisma.youtubeUserToChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeUserToChannelDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeUserToChannelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeUserToChannels
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeUserToChannelUpdateManyArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeUserToChannel.
     * @param {YoutubeUserToChannelUpsertArgs} args - Arguments to update or create a YoutubeUserToChannel.
     * @example
     * // Update or create a YoutubeUserToChannel
     * const youtubeUserToChannel = await prisma.youtubeUserToChannel.upsert({
     *   create: {
     *     // ... data to create a YoutubeUserToChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeUserToChannel we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeUserToChannelUpsertArgs>(
      args: SelectSubset<T, YoutubeUserToChannelUpsertArgs>
    ): Prisma__YoutubeUserToChannelClient<YoutubeUserToChannelGetPayload<T>>

    /**
     * Count the number of YoutubeUserToChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelCountArgs} args - Arguments to filter YoutubeUserToChannels to count.
     * @example
     * // Count the number of YoutubeUserToChannels
     * const count = await prisma.youtubeUserToChannel.count({
     *   where: {
     *     // ... the filter for the YoutubeUserToChannels we want to count
     *   }
     * })
    **/
    count<T extends YoutubeUserToChannelCountArgs>(
      args?: Subset<T, YoutubeUserToChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeUserToChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeUserToChannelAggregateArgs>(args: Subset<T, YoutubeUserToChannelAggregateArgs>): Prisma.PrismaPromise<GetYoutubeUserToChannelAggregateType<T>>

    /**
     * Group by YoutubeUserToChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeUserToChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeUserToChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeUserToChannelGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeUserToChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeUserToChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeUserToChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeUserToChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeUserToChannelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    role<T extends YoutubeRoleArgs= {}>(args?: Subset<T, YoutubeRoleArgs>): Prisma__YoutubeRoleClient<YoutubeRoleGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeUserToChannel base type for findUnique actions
   */
  export type YoutubeUserToChannelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }

  /**
   * YoutubeUserToChannel findUnique
   */
  export interface YoutubeUserToChannelFindUniqueArgs extends YoutubeUserToChannelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findUniqueOrThrow
   */
  export type YoutubeUserToChannelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel base type for findFirst actions
   */
  export type YoutubeUserToChannelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }

  /**
   * YoutubeUserToChannel findFirst
   */
  export interface YoutubeUserToChannelFindFirstArgs extends YoutubeUserToChannelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeUserToChannel findFirstOrThrow
   */
  export type YoutubeUserToChannelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannel to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeUserToChannels.
     */
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel findMany
   */
  export type YoutubeUserToChannelFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter, which YoutubeUserToChannels to fetch.
     */
    where?: YoutubeUserToChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeUserToChannels to fetch.
     */
    orderBy?: Enumerable<YoutubeUserToChannelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeUserToChannels.
     */
    cursor?: YoutubeUserToChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeUserToChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeUserToChannels.
     */
    skip?: number
    distinct?: Enumerable<YoutubeUserToChannelScalarFieldEnum>
  }


  /**
   * YoutubeUserToChannel create
   */
  export type YoutubeUserToChannelCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to create a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
  }


  /**
   * YoutubeUserToChannel createMany
   */
  export type YoutubeUserToChannelCreateManyArgs = {
    /**
     * The data used to create many YoutubeUserToChannels.
     */
    data: Enumerable<YoutubeUserToChannelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeUserToChannel update
   */
  export type YoutubeUserToChannelUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The data needed to update a YoutubeUserToChannel.
     */
    data: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
    /**
     * Choose, which YoutubeUserToChannel to update.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel updateMany
   */
  export type YoutubeUserToChannelUpdateManyArgs = {
    /**
     * The data used to update YoutubeUserToChannels.
     */
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeUserToChannels to update
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel upsert
   */
  export type YoutubeUserToChannelUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * The filter to search for the YoutubeUserToChannel to update in case it exists.
     */
    where: YoutubeUserToChannelWhereUniqueInput
    /**
     * In case the YoutubeUserToChannel found by the `where` argument doesn't exist, create a new YoutubeUserToChannel with this data.
     */
    create: XOR<YoutubeUserToChannelCreateInput, YoutubeUserToChannelUncheckedCreateInput>
    /**
     * In case the YoutubeUserToChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeUserToChannelUpdateInput, YoutubeUserToChannelUncheckedUpdateInput>
  }


  /**
   * YoutubeUserToChannel delete
   */
  export type YoutubeUserToChannelDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
    /**
     * Filter which YoutubeUserToChannel to delete.
     */
    where: YoutubeUserToChannelWhereUniqueInput
  }


  /**
   * YoutubeUserToChannel deleteMany
   */
  export type YoutubeUserToChannelDeleteManyArgs = {
    /**
     * Filter which YoutubeUserToChannels to delete
     */
    where?: YoutubeUserToChannelWhereInput
  }


  /**
   * YoutubeUserToChannel without action
   */
  export type YoutubeUserToChannelArgs = {
    /**
     * Select specific fields to fetch from the YoutubeUserToChannel
     */
    select?: YoutubeUserToChannelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeUserToChannelInclude | null
  }



  /**
   * Model YoutubeVideo
   */


  export type AggregateYoutubeVideo = {
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  export type YoutubeVideoAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type YoutubeVideoSumAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type YoutubeVideoMinAggregateOutputType = {
    id: number | null
    channelId: number | null
    name: string | null
    urlFile: string | null
    coverImage: string | null
    descriptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeVideoMaxAggregateOutputType = {
    id: number | null
    channelId: number | null
    name: string | null
    urlFile: string | null
    coverImage: string | null
    descriptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeVideoCountAggregateOutputType = {
    id: number
    channelId: number
    name: number
    urlFile: number
    coverImage: number
    descriptions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeVideoAvgAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type YoutubeVideoSumAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type YoutubeVideoMinAggregateInputType = {
    id?: true
    channelId?: true
    name?: true
    urlFile?: true
    coverImage?: true
    descriptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeVideoMaxAggregateInputType = {
    id?: true
    channelId?: true
    name?: true
    urlFile?: true
    coverImage?: true
    descriptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeVideoCountAggregateInputType = {
    id?: true
    channelId?: true
    name?: true
    urlFile?: true
    coverImage?: true
    descriptions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeVideoAggregateArgs = {
    /**
     * Filter which YoutubeVideo to aggregate.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeVideos
    **/
    _count?: true | YoutubeVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeVideoMaxAggregateInputType
  }

  export type GetYoutubeVideoAggregateType<T extends YoutubeVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeVideo[P]>
      : GetScalarType<T[P], AggregateYoutubeVideo[P]>
  }




  export type YoutubeVideoGroupByArgs = {
    where?: YoutubeVideoWhereInput
    orderBy?: Enumerable<YoutubeVideoOrderByWithAggregationInput>
    by: YoutubeVideoScalarFieldEnum[]
    having?: YoutubeVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeVideoCountAggregateInputType | true
    _avg?: YoutubeVideoAvgAggregateInputType
    _sum?: YoutubeVideoSumAggregateInputType
    _min?: YoutubeVideoMinAggregateInputType
    _max?: YoutubeVideoMaxAggregateInputType
  }


  export type YoutubeVideoGroupByOutputType = {
    id: number
    channelId: number
    name: string
    urlFile: string
    coverImage: string | null
    descriptions: string | null
    createdAt: Date
    updatedAt: Date
    _count: YoutubeVideoCountAggregateOutputType | null
    _avg: YoutubeVideoAvgAggregateOutputType | null
    _sum: YoutubeVideoSumAggregateOutputType | null
    _min: YoutubeVideoMinAggregateOutputType | null
    _max: YoutubeVideoMaxAggregateOutputType | null
  }

  type GetYoutubeVideoGroupByPayload<T extends YoutubeVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeVideoGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeVideoSelect = {
    id?: boolean
    channel?: boolean | YoutubeChannelArgs
    channelId?: boolean
    name?: boolean
    urlFile?: boolean
    coverImage?: boolean
    descriptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | YoutubeVideo$commentsArgs
    reactions?: boolean | YoutubeVideo$reactionsArgs
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }


  export type YoutubeVideoInclude = {
    channel?: boolean | YoutubeChannelArgs
    comments?: boolean | YoutubeVideo$commentsArgs
    reactions?: boolean | YoutubeVideo$reactionsArgs
    _count?: boolean | YoutubeVideoCountOutputTypeArgs
  }

  export type YoutubeVideoGetPayload<S extends boolean | null | undefined | YoutubeVideoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeVideo :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
    ? YoutubeVideo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :
        P extends 'comments' ? Array < YoutubeCommentGetPayload<S['include'][P]>>  :
        P extends 'reactions' ? Array < YoutubeReactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeVideoArgs | YoutubeVideoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :
        P extends 'comments' ? Array < YoutubeCommentGetPayload<S['select'][P]>>  :
        P extends 'reactions' ? Array < YoutubeReactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeVideoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeVideo ? YoutubeVideo[P] : never
  } 
      : YoutubeVideo


  type YoutubeVideoCountArgs = 
    Omit<YoutubeVideoFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeVideoCountAggregateInputType | true
    }

  export interface YoutubeVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeVideo that matches the filter.
     * @param {YoutubeVideoFindUniqueArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeVideoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeVideoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find one YoutubeVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeVideoFindUniqueOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeVideoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindUniqueOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find the first YoutubeVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeVideoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeVideoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeVideo'> extends True ? Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>> : Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | null, null>

    /**
     * Find the first YoutubeVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindFirstOrThrowArgs} args - Arguments to find a YoutubeVideo
     * @example
     * // Get one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeVideoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeVideoFindFirstOrThrowArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Find zero or more YoutubeVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany()
     * 
     * // Get first 10 YoutubeVideos
     * const youtubeVideos = await prisma.youtubeVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeVideoWithIdOnly = await prisma.youtubeVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeVideoFindManyArgs>(
      args?: SelectSubset<T, YoutubeVideoFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeVideoGetPayload<T>>>

    /**
     * Create a YoutubeVideo.
     * @param {YoutubeVideoCreateArgs} args - Arguments to create a YoutubeVideo.
     * @example
     * // Create one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.create({
     *   data: {
     *     // ... data to create a YoutubeVideo
     *   }
     * })
     * 
    **/
    create<T extends YoutubeVideoCreateArgs>(
      args: SelectSubset<T, YoutubeVideoCreateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Create many YoutubeVideos.
     *     @param {YoutubeVideoCreateManyArgs} args - Arguments to create many YoutubeVideos.
     *     @example
     *     // Create many YoutubeVideos
     *     const youtubeVideo = await prisma.youtubeVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeVideoCreateManyArgs>(
      args?: SelectSubset<T, YoutubeVideoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeVideo.
     * @param {YoutubeVideoDeleteArgs} args - Arguments to delete one YoutubeVideo.
     * @example
     * // Delete one YoutubeVideo
     * const YoutubeVideo = await prisma.youtubeVideo.delete({
     *   where: {
     *     // ... filter to delete one YoutubeVideo
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeVideoDeleteArgs>(
      args: SelectSubset<T, YoutubeVideoDeleteArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Update one YoutubeVideo.
     * @param {YoutubeVideoUpdateArgs} args - Arguments to update one YoutubeVideo.
     * @example
     * // Update one YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeVideoUpdateArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Delete zero or more YoutubeVideos.
     * @param {YoutubeVideoDeleteManyArgs} args - Arguments to filter YoutubeVideos to delete.
     * @example
     * // Delete a few YoutubeVideos
     * const { count } = await prisma.youtubeVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeVideoDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeVideoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeVideos
     * const youtubeVideo = await prisma.youtubeVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeVideoUpdateManyArgs>(
      args: SelectSubset<T, YoutubeVideoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeVideo.
     * @param {YoutubeVideoUpsertArgs} args - Arguments to update or create a YoutubeVideo.
     * @example
     * // Update or create a YoutubeVideo
     * const youtubeVideo = await prisma.youtubeVideo.upsert({
     *   create: {
     *     // ... data to create a YoutubeVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeVideo we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeVideoUpsertArgs>(
      args: SelectSubset<T, YoutubeVideoUpsertArgs>
    ): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T>>

    /**
     * Count the number of YoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoCountArgs} args - Arguments to filter YoutubeVideos to count.
     * @example
     * // Count the number of YoutubeVideos
     * const count = await prisma.youtubeVideo.count({
     *   where: {
     *     // ... the filter for the YoutubeVideos we want to count
     *   }
     * })
    **/
    count<T extends YoutubeVideoCountArgs>(
      args?: Subset<T, YoutubeVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeVideoAggregateArgs>(args: Subset<T, YoutubeVideoAggregateArgs>): Prisma.PrismaPromise<GetYoutubeVideoAggregateType<T>>

    /**
     * Group by YoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeVideoGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeVideoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    comments<T extends YoutubeVideo$commentsArgs= {}>(args?: Subset<T, YoutubeVideo$commentsArgs>): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>| Null>;

    reactions<T extends YoutubeVideo$reactionsArgs= {}>(args?: Subset<T, YoutubeVideo$reactionsArgs>): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeVideo base type for findUnique actions
   */
  export type YoutubeVideoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }

  /**
   * YoutubeVideo findUnique
   */
  export interface YoutubeVideoFindUniqueArgs extends YoutubeVideoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findUniqueOrThrow
   */
  export type YoutubeVideoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo base type for findFirst actions
   */
  export type YoutubeVideoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }

  /**
   * YoutubeVideo findFirst
   */
  export interface YoutubeVideoFindFirstArgs extends YoutubeVideoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeVideo findFirstOrThrow
   */
  export type YoutubeVideoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideo to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeVideos.
     */
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo findMany
   */
  export type YoutubeVideoFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter, which YoutubeVideos to fetch.
     */
    where?: YoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeVideos to fetch.
     */
    orderBy?: Enumerable<YoutubeVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeVideos.
     */
    cursor?: YoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeVideos.
     */
    skip?: number
    distinct?: Enumerable<YoutubeVideoScalarFieldEnum>
  }


  /**
   * YoutubeVideo create
   */
  export type YoutubeVideoCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to create a YoutubeVideo.
     */
    data: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
  }


  /**
   * YoutubeVideo createMany
   */
  export type YoutubeVideoCreateManyArgs = {
    /**
     * The data used to create many YoutubeVideos.
     */
    data: Enumerable<YoutubeVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeVideo update
   */
  export type YoutubeVideoUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The data needed to update a YoutubeVideo.
     */
    data: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
    /**
     * Choose, which YoutubeVideo to update.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo updateMany
   */
  export type YoutubeVideoUpdateManyArgs = {
    /**
     * The data used to update YoutubeVideos.
     */
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeVideos to update
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo upsert
   */
  export type YoutubeVideoUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * The filter to search for the YoutubeVideo to update in case it exists.
     */
    where: YoutubeVideoWhereUniqueInput
    /**
     * In case the YoutubeVideo found by the `where` argument doesn't exist, create a new YoutubeVideo with this data.
     */
    create: XOR<YoutubeVideoCreateInput, YoutubeVideoUncheckedCreateInput>
    /**
     * In case the YoutubeVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeVideoUpdateInput, YoutubeVideoUncheckedUpdateInput>
  }


  /**
   * YoutubeVideo delete
   */
  export type YoutubeVideoDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
    /**
     * Filter which YoutubeVideo to delete.
     */
    where: YoutubeVideoWhereUniqueInput
  }


  /**
   * YoutubeVideo deleteMany
   */
  export type YoutubeVideoDeleteManyArgs = {
    /**
     * Filter which YoutubeVideos to delete
     */
    where?: YoutubeVideoWhereInput
  }


  /**
   * YoutubeVideo.comments
   */
  export type YoutubeVideo$commentsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    cursor?: YoutubeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeVideo.reactions
   */
  export type YoutubeVideo$reactionsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    cursor?: YoutubeReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeVideo without action
   */
  export type YoutubeVideoArgs = {
    /**
     * Select specific fields to fetch from the YoutubeVideo
     */
    select?: YoutubeVideoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeVideoInclude | null
  }



  /**
   * Model YoutubeSubscriber
   */


  export type AggregateYoutubeSubscriber = {
    _count: YoutubeSubscriberCountAggregateOutputType | null
    _avg: YoutubeSubscriberAvgAggregateOutputType | null
    _sum: YoutubeSubscriberSumAggregateOutputType | null
    _min: YoutubeSubscriberMinAggregateOutputType | null
    _max: YoutubeSubscriberMaxAggregateOutputType | null
  }

  export type YoutubeSubscriberAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type YoutubeSubscriberSumAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
  }

  export type YoutubeSubscriberMinAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    membership: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeSubscriberMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    channelId: number | null
    membership: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeSubscriberCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    membership: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeSubscriberAvgAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type YoutubeSubscriberSumAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
  }

  export type YoutubeSubscriberMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeSubscriberMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeSubscriberCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    membership?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeSubscriberAggregateArgs = {
    /**
     * Filter which YoutubeSubscriber to aggregate.
     */
    where?: YoutubeSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscribers to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeSubscribers
    **/
    _count?: true | YoutubeSubscriberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeSubscriberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeSubscriberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeSubscriberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeSubscriberMaxAggregateInputType
  }

  export type GetYoutubeSubscriberAggregateType<T extends YoutubeSubscriberAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeSubscriber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeSubscriber[P]>
      : GetScalarType<T[P], AggregateYoutubeSubscriber[P]>
  }




  export type YoutubeSubscriberGroupByArgs = {
    where?: YoutubeSubscriberWhereInput
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithAggregationInput>
    by: YoutubeSubscriberScalarFieldEnum[]
    having?: YoutubeSubscriberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeSubscriberCountAggregateInputType | true
    _avg?: YoutubeSubscriberAvgAggregateInputType
    _sum?: YoutubeSubscriberSumAggregateInputType
    _min?: YoutubeSubscriberMinAggregateInputType
    _max?: YoutubeSubscriberMaxAggregateInputType
  }


  export type YoutubeSubscriberGroupByOutputType = {
    id: number
    userId: number
    channelId: number
    membership: boolean
    createdAt: Date
    updatedAt: Date
    _count: YoutubeSubscriberCountAggregateOutputType | null
    _avg: YoutubeSubscriberAvgAggregateOutputType | null
    _sum: YoutubeSubscriberSumAggregateOutputType | null
    _min: YoutubeSubscriberMinAggregateOutputType | null
    _max: YoutubeSubscriberMaxAggregateOutputType | null
  }

  type GetYoutubeSubscriberGroupByPayload<T extends YoutubeSubscriberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeSubscriberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeSubscriberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeSubscriberGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeSubscriberGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeSubscriberSelect = {
    id?: boolean
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
    userId?: boolean
    channelId?: boolean
    membership?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YoutubeSubscriberInclude = {
    user?: boolean | YoutubeUserArgs
    channel?: boolean | YoutubeChannelArgs
  }

  export type YoutubeSubscriberGetPayload<S extends boolean | null | undefined | YoutubeSubscriberArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeSubscriber :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeSubscriberArgs | YoutubeSubscriberFindManyArgs)
    ? YoutubeSubscriber  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeSubscriberArgs | YoutubeSubscriberFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'channel' ? YoutubeChannelGetPayload<S['select'][P]> :  P extends keyof YoutubeSubscriber ? YoutubeSubscriber[P] : never
  } 
      : YoutubeSubscriber


  type YoutubeSubscriberCountArgs = 
    Omit<YoutubeSubscriberFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeSubscriberCountAggregateInputType | true
    }

  export interface YoutubeSubscriberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeSubscriber that matches the filter.
     * @param {YoutubeSubscriberFindUniqueArgs} args - Arguments to find a YoutubeSubscriber
     * @example
     * // Get one YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeSubscriberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeSubscriberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeSubscriber'> extends True ? Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>> : Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T> | null, null>

    /**
     * Find one YoutubeSubscriber that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeSubscriberFindUniqueOrThrowArgs} args - Arguments to find a YoutubeSubscriber
     * @example
     * // Get one YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeSubscriberFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeSubscriberFindUniqueOrThrowArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Find the first YoutubeSubscriber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberFindFirstArgs} args - Arguments to find a YoutubeSubscriber
     * @example
     * // Get one YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeSubscriberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeSubscriberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeSubscriber'> extends True ? Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>> : Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T> | null, null>

    /**
     * Find the first YoutubeSubscriber that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberFindFirstOrThrowArgs} args - Arguments to find a YoutubeSubscriber
     * @example
     * // Get one YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeSubscriberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeSubscriberFindFirstOrThrowArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Find zero or more YoutubeSubscribers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeSubscribers
     * const youtubeSubscribers = await prisma.youtubeSubscriber.findMany()
     * 
     * // Get first 10 YoutubeSubscribers
     * const youtubeSubscribers = await prisma.youtubeSubscriber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeSubscriberWithIdOnly = await prisma.youtubeSubscriber.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeSubscriberFindManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriberFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeSubscriberGetPayload<T>>>

    /**
     * Create a YoutubeSubscriber.
     * @param {YoutubeSubscriberCreateArgs} args - Arguments to create a YoutubeSubscriber.
     * @example
     * // Create one YoutubeSubscriber
     * const YoutubeSubscriber = await prisma.youtubeSubscriber.create({
     *   data: {
     *     // ... data to create a YoutubeSubscriber
     *   }
     * })
     * 
    **/
    create<T extends YoutubeSubscriberCreateArgs>(
      args: SelectSubset<T, YoutubeSubscriberCreateArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Create many YoutubeSubscribers.
     *     @param {YoutubeSubscriberCreateManyArgs} args - Arguments to create many YoutubeSubscribers.
     *     @example
     *     // Create many YoutubeSubscribers
     *     const youtubeSubscriber = await prisma.youtubeSubscriber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeSubscriberCreateManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriberCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeSubscriber.
     * @param {YoutubeSubscriberDeleteArgs} args - Arguments to delete one YoutubeSubscriber.
     * @example
     * // Delete one YoutubeSubscriber
     * const YoutubeSubscriber = await prisma.youtubeSubscriber.delete({
     *   where: {
     *     // ... filter to delete one YoutubeSubscriber
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeSubscriberDeleteArgs>(
      args: SelectSubset<T, YoutubeSubscriberDeleteArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Update one YoutubeSubscriber.
     * @param {YoutubeSubscriberUpdateArgs} args - Arguments to update one YoutubeSubscriber.
     * @example
     * // Update one YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeSubscriberUpdateArgs>(
      args: SelectSubset<T, YoutubeSubscriberUpdateArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Delete zero or more YoutubeSubscribers.
     * @param {YoutubeSubscriberDeleteManyArgs} args - Arguments to filter YoutubeSubscribers to delete.
     * @example
     * // Delete a few YoutubeSubscribers
     * const { count } = await prisma.youtubeSubscriber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeSubscriberDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeSubscriberDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeSubscribers
     * const youtubeSubscriber = await prisma.youtubeSubscriber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeSubscriberUpdateManyArgs>(
      args: SelectSubset<T, YoutubeSubscriberUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeSubscriber.
     * @param {YoutubeSubscriberUpsertArgs} args - Arguments to update or create a YoutubeSubscriber.
     * @example
     * // Update or create a YoutubeSubscriber
     * const youtubeSubscriber = await prisma.youtubeSubscriber.upsert({
     *   create: {
     *     // ... data to create a YoutubeSubscriber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeSubscriber we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeSubscriberUpsertArgs>(
      args: SelectSubset<T, YoutubeSubscriberUpsertArgs>
    ): Prisma__YoutubeSubscriberClient<YoutubeSubscriberGetPayload<T>>

    /**
     * Count the number of YoutubeSubscribers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberCountArgs} args - Arguments to filter YoutubeSubscribers to count.
     * @example
     * // Count the number of YoutubeSubscribers
     * const count = await prisma.youtubeSubscriber.count({
     *   where: {
     *     // ... the filter for the YoutubeSubscribers we want to count
     *   }
     * })
    **/
    count<T extends YoutubeSubscriberCountArgs>(
      args?: Subset<T, YoutubeSubscriberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeSubscriberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeSubscriberAggregateArgs>(args: Subset<T, YoutubeSubscriberAggregateArgs>): Prisma.PrismaPromise<GetYoutubeSubscriberAggregateType<T>>

    /**
     * Group by YoutubeSubscriber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeSubscriberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeSubscriberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeSubscriberGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeSubscriberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeSubscriberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeSubscriberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeSubscriber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeSubscriberClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    channel<T extends YoutubeChannelArgs= {}>(args?: Subset<T, YoutubeChannelArgs>): Prisma__YoutubeChannelClient<YoutubeChannelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeSubscriber base type for findUnique actions
   */
  export type YoutubeSubscriberFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter, which YoutubeSubscriber to fetch.
     */
    where: YoutubeSubscriberWhereUniqueInput
  }

  /**
   * YoutubeSubscriber findUnique
   */
  export interface YoutubeSubscriberFindUniqueArgs extends YoutubeSubscriberFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeSubscriber findUniqueOrThrow
   */
  export type YoutubeSubscriberFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter, which YoutubeSubscriber to fetch.
     */
    where: YoutubeSubscriberWhereUniqueInput
  }


  /**
   * YoutubeSubscriber base type for findFirst actions
   */
  export type YoutubeSubscriberFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter, which YoutubeSubscriber to fetch.
     */
    where?: YoutubeSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscribers to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeSubscribers.
     */
    cursor?: YoutubeSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeSubscribers.
     */
    distinct?: Enumerable<YoutubeSubscriberScalarFieldEnum>
  }

  /**
   * YoutubeSubscriber findFirst
   */
  export interface YoutubeSubscriberFindFirstArgs extends YoutubeSubscriberFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeSubscriber findFirstOrThrow
   */
  export type YoutubeSubscriberFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter, which YoutubeSubscriber to fetch.
     */
    where?: YoutubeSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscribers to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeSubscribers.
     */
    cursor?: YoutubeSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscribers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeSubscribers.
     */
    distinct?: Enumerable<YoutubeSubscriberScalarFieldEnum>
  }


  /**
   * YoutubeSubscriber findMany
   */
  export type YoutubeSubscriberFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter, which YoutubeSubscribers to fetch.
     */
    where?: YoutubeSubscriberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeSubscribers to fetch.
     */
    orderBy?: Enumerable<YoutubeSubscriberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeSubscribers.
     */
    cursor?: YoutubeSubscriberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeSubscribers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeSubscribers.
     */
    skip?: number
    distinct?: Enumerable<YoutubeSubscriberScalarFieldEnum>
  }


  /**
   * YoutubeSubscriber create
   */
  export type YoutubeSubscriberCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * The data needed to create a YoutubeSubscriber.
     */
    data: XOR<YoutubeSubscriberCreateInput, YoutubeSubscriberUncheckedCreateInput>
  }


  /**
   * YoutubeSubscriber createMany
   */
  export type YoutubeSubscriberCreateManyArgs = {
    /**
     * The data used to create many YoutubeSubscribers.
     */
    data: Enumerable<YoutubeSubscriberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeSubscriber update
   */
  export type YoutubeSubscriberUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * The data needed to update a YoutubeSubscriber.
     */
    data: XOR<YoutubeSubscriberUpdateInput, YoutubeSubscriberUncheckedUpdateInput>
    /**
     * Choose, which YoutubeSubscriber to update.
     */
    where: YoutubeSubscriberWhereUniqueInput
  }


  /**
   * YoutubeSubscriber updateMany
   */
  export type YoutubeSubscriberUpdateManyArgs = {
    /**
     * The data used to update YoutubeSubscribers.
     */
    data: XOR<YoutubeSubscriberUpdateManyMutationInput, YoutubeSubscriberUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeSubscribers to update
     */
    where?: YoutubeSubscriberWhereInput
  }


  /**
   * YoutubeSubscriber upsert
   */
  export type YoutubeSubscriberUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * The filter to search for the YoutubeSubscriber to update in case it exists.
     */
    where: YoutubeSubscriberWhereUniqueInput
    /**
     * In case the YoutubeSubscriber found by the `where` argument doesn't exist, create a new YoutubeSubscriber with this data.
     */
    create: XOR<YoutubeSubscriberCreateInput, YoutubeSubscriberUncheckedCreateInput>
    /**
     * In case the YoutubeSubscriber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeSubscriberUpdateInput, YoutubeSubscriberUncheckedUpdateInput>
  }


  /**
   * YoutubeSubscriber delete
   */
  export type YoutubeSubscriberDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
    /**
     * Filter which YoutubeSubscriber to delete.
     */
    where: YoutubeSubscriberWhereUniqueInput
  }


  /**
   * YoutubeSubscriber deleteMany
   */
  export type YoutubeSubscriberDeleteManyArgs = {
    /**
     * Filter which YoutubeSubscribers to delete
     */
    where?: YoutubeSubscriberWhereInput
  }


  /**
   * YoutubeSubscriber without action
   */
  export type YoutubeSubscriberArgs = {
    /**
     * Select specific fields to fetch from the YoutubeSubscriber
     */
    select?: YoutubeSubscriberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeSubscriberInclude | null
  }



  /**
   * Model YoutubeReaction
   */


  export type AggregateYoutubeReaction = {
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  export type YoutubeReactionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type YoutubeReactionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    videoId: number | null
  }

  export type YoutubeReactionMinAggregateOutputType = {
    id: number | null
    type: ReactionEnum | null
    userId: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeReactionMaxAggregateOutputType = {
    id: number | null
    type: ReactionEnum | null
    userId: number | null
    videoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeReactionCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    videoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeReactionAvgAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type YoutubeReactionSumAggregateInputType = {
    id?: true
    userId?: true
    videoId?: true
  }

  export type YoutubeReactionMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeReactionMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeReactionCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeReactionAggregateArgs = {
    /**
     * Filter which YoutubeReaction to aggregate.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeReactions
    **/
    _count?: true | YoutubeReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeReactionMaxAggregateInputType
  }

  export type GetYoutubeReactionAggregateType<T extends YoutubeReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeReaction[P]>
      : GetScalarType<T[P], AggregateYoutubeReaction[P]>
  }




  export type YoutubeReactionGroupByArgs = {
    where?: YoutubeReactionWhereInput
    orderBy?: Enumerable<YoutubeReactionOrderByWithAggregationInput>
    by: YoutubeReactionScalarFieldEnum[]
    having?: YoutubeReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeReactionCountAggregateInputType | true
    _avg?: YoutubeReactionAvgAggregateInputType
    _sum?: YoutubeReactionSumAggregateInputType
    _min?: YoutubeReactionMinAggregateInputType
    _max?: YoutubeReactionMaxAggregateInputType
  }


  export type YoutubeReactionGroupByOutputType = {
    id: number
    type: ReactionEnum
    userId: number
    videoId: number
    createdAt: Date
    updatedAt: Date
    _count: YoutubeReactionCountAggregateOutputType | null
    _avg: YoutubeReactionAvgAggregateOutputType | null
    _sum: YoutubeReactionSumAggregateOutputType | null
    _min: YoutubeReactionMinAggregateOutputType | null
    _max: YoutubeReactionMaxAggregateOutputType | null
  }

  type GetYoutubeReactionGroupByPayload<T extends YoutubeReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeReactionGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeReactionSelect = {
    id?: boolean
    type?: boolean
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
    userId?: boolean
    videoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type YoutubeReactionInclude = {
    user?: boolean | YoutubeUserArgs
    video?: boolean | YoutubeVideoArgs
  }

  export type YoutubeReactionGetPayload<S extends boolean | null | undefined | YoutubeReactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeReaction :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
    ? YoutubeReaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeReactionArgs | YoutubeReactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'video' ? YoutubeVideoGetPayload<S['select'][P]> :  P extends keyof YoutubeReaction ? YoutubeReaction[P] : never
  } 
      : YoutubeReaction


  type YoutubeReactionCountArgs = 
    Omit<YoutubeReactionFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeReactionCountAggregateInputType | true
    }

  export interface YoutubeReactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeReaction that matches the filter.
     * @param {YoutubeReactionFindUniqueArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeReactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeReactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find one YoutubeReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeReactionFindUniqueOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeReactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindUniqueOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find the first YoutubeReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeReactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeReactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeReaction'> extends True ? Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>> : Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T> | null, null>

    /**
     * Find the first YoutubeReaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindFirstOrThrowArgs} args - Arguments to find a YoutubeReaction
     * @example
     * // Get one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeReactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeReactionFindFirstOrThrowArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Find zero or more YoutubeReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany()
     * 
     * // Get first 10 YoutubeReactions
     * const youtubeReactions = await prisma.youtubeReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeReactionWithIdOnly = await prisma.youtubeReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeReactionFindManyArgs>(
      args?: SelectSubset<T, YoutubeReactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeReactionGetPayload<T>>>

    /**
     * Create a YoutubeReaction.
     * @param {YoutubeReactionCreateArgs} args - Arguments to create a YoutubeReaction.
     * @example
     * // Create one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.create({
     *   data: {
     *     // ... data to create a YoutubeReaction
     *   }
     * })
     * 
    **/
    create<T extends YoutubeReactionCreateArgs>(
      args: SelectSubset<T, YoutubeReactionCreateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Create many YoutubeReactions.
     *     @param {YoutubeReactionCreateManyArgs} args - Arguments to create many YoutubeReactions.
     *     @example
     *     // Create many YoutubeReactions
     *     const youtubeReaction = await prisma.youtubeReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeReactionCreateManyArgs>(
      args?: SelectSubset<T, YoutubeReactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeReaction.
     * @param {YoutubeReactionDeleteArgs} args - Arguments to delete one YoutubeReaction.
     * @example
     * // Delete one YoutubeReaction
     * const YoutubeReaction = await prisma.youtubeReaction.delete({
     *   where: {
     *     // ... filter to delete one YoutubeReaction
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeReactionDeleteArgs>(
      args: SelectSubset<T, YoutubeReactionDeleteArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Update one YoutubeReaction.
     * @param {YoutubeReactionUpdateArgs} args - Arguments to update one YoutubeReaction.
     * @example
     * // Update one YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeReactionUpdateArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Delete zero or more YoutubeReactions.
     * @param {YoutubeReactionDeleteManyArgs} args - Arguments to filter YoutubeReactions to delete.
     * @example
     * // Delete a few YoutubeReactions
     * const { count } = await prisma.youtubeReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeReactionDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeReactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeReactions
     * const youtubeReaction = await prisma.youtubeReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeReactionUpdateManyArgs>(
      args: SelectSubset<T, YoutubeReactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeReaction.
     * @param {YoutubeReactionUpsertArgs} args - Arguments to update or create a YoutubeReaction.
     * @example
     * // Update or create a YoutubeReaction
     * const youtubeReaction = await prisma.youtubeReaction.upsert({
     *   create: {
     *     // ... data to create a YoutubeReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeReaction we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeReactionUpsertArgs>(
      args: SelectSubset<T, YoutubeReactionUpsertArgs>
    ): Prisma__YoutubeReactionClient<YoutubeReactionGetPayload<T>>

    /**
     * Count the number of YoutubeReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionCountArgs} args - Arguments to filter YoutubeReactions to count.
     * @example
     * // Count the number of YoutubeReactions
     * const count = await prisma.youtubeReaction.count({
     *   where: {
     *     // ... the filter for the YoutubeReactions we want to count
     *   }
     * })
    **/
    count<T extends YoutubeReactionCountArgs>(
      args?: Subset<T, YoutubeReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeReactionAggregateArgs>(args: Subset<T, YoutubeReactionAggregateArgs>): Prisma.PrismaPromise<GetYoutubeReactionAggregateType<T>>

    /**
     * Group by YoutubeReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeReactionGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeReactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    video<T extends YoutubeVideoArgs= {}>(args?: Subset<T, YoutubeVideoArgs>): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeReaction base type for findUnique actions
   */
  export type YoutubeReactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }

  /**
   * YoutubeReaction findUnique
   */
  export interface YoutubeReactionFindUniqueArgs extends YoutubeReactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findUniqueOrThrow
   */
  export type YoutubeReactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction base type for findFirst actions
   */
  export type YoutubeReactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }

  /**
   * YoutubeReaction findFirst
   */
  export interface YoutubeReactionFindFirstArgs extends YoutubeReactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeReaction findFirstOrThrow
   */
  export type YoutubeReactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReaction to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeReactions.
     */
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction findMany
   */
  export type YoutubeReactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter, which YoutubeReactions to fetch.
     */
    where?: YoutubeReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeReactions to fetch.
     */
    orderBy?: Enumerable<YoutubeReactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeReactions.
     */
    cursor?: YoutubeReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeReactions.
     */
    skip?: number
    distinct?: Enumerable<YoutubeReactionScalarFieldEnum>
  }


  /**
   * YoutubeReaction create
   */
  export type YoutubeReactionCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to create a YoutubeReaction.
     */
    data: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
  }


  /**
   * YoutubeReaction createMany
   */
  export type YoutubeReactionCreateManyArgs = {
    /**
     * The data used to create many YoutubeReactions.
     */
    data: Enumerable<YoutubeReactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeReaction update
   */
  export type YoutubeReactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The data needed to update a YoutubeReaction.
     */
    data: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
    /**
     * Choose, which YoutubeReaction to update.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction updateMany
   */
  export type YoutubeReactionUpdateManyArgs = {
    /**
     * The data used to update YoutubeReactions.
     */
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeReactions to update
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction upsert
   */
  export type YoutubeReactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * The filter to search for the YoutubeReaction to update in case it exists.
     */
    where: YoutubeReactionWhereUniqueInput
    /**
     * In case the YoutubeReaction found by the `where` argument doesn't exist, create a new YoutubeReaction with this data.
     */
    create: XOR<YoutubeReactionCreateInput, YoutubeReactionUncheckedCreateInput>
    /**
     * In case the YoutubeReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeReactionUpdateInput, YoutubeReactionUncheckedUpdateInput>
  }


  /**
   * YoutubeReaction delete
   */
  export type YoutubeReactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
    /**
     * Filter which YoutubeReaction to delete.
     */
    where: YoutubeReactionWhereUniqueInput
  }


  /**
   * YoutubeReaction deleteMany
   */
  export type YoutubeReactionDeleteManyArgs = {
    /**
     * Filter which YoutubeReactions to delete
     */
    where?: YoutubeReactionWhereInput
  }


  /**
   * YoutubeReaction without action
   */
  export type YoutubeReactionArgs = {
    /**
     * Select specific fields to fetch from the YoutubeReaction
     */
    select?: YoutubeReactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeReactionInclude | null
  }



  /**
   * Model YoutubeComment
   */


  export type AggregateYoutubeComment = {
    _count: YoutubeCommentCountAggregateOutputType | null
    _avg: YoutubeCommentAvgAggregateOutputType | null
    _sum: YoutubeCommentSumAggregateOutputType | null
    _min: YoutubeCommentMinAggregateOutputType | null
    _max: YoutubeCommentMaxAggregateOutputType | null
  }

  export type YoutubeCommentAvgAggregateOutputType = {
    id: number | null
    videoId: number | null
    userId: number | null
    commentToId: number | null
  }

  export type YoutubeCommentSumAggregateOutputType = {
    id: number | null
    videoId: number | null
    userId: number | null
    commentToId: number | null
  }

  export type YoutubeCommentMinAggregateOutputType = {
    id: number | null
    videoId: number | null
    userId: number | null
    message: string | null
    commentToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeCommentMaxAggregateOutputType = {
    id: number | null
    videoId: number | null
    userId: number | null
    message: string | null
    commentToId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type YoutubeCommentCountAggregateOutputType = {
    id: number
    videoId: number
    userId: number
    message: number
    commentToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type YoutubeCommentAvgAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    commentToId?: true
  }

  export type YoutubeCommentSumAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    commentToId?: true
  }

  export type YoutubeCommentMinAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    message?: true
    commentToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeCommentMaxAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    message?: true
    commentToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type YoutubeCommentCountAggregateInputType = {
    id?: true
    videoId?: true
    userId?: true
    message?: true
    commentToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type YoutubeCommentAggregateArgs = {
    /**
     * Filter which YoutubeComment to aggregate.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YoutubeComments
    **/
    _count?: true | YoutubeCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YoutubeCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YoutubeCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YoutubeCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YoutubeCommentMaxAggregateInputType
  }

  export type GetYoutubeCommentAggregateType<T extends YoutubeCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateYoutubeComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYoutubeComment[P]>
      : GetScalarType<T[P], AggregateYoutubeComment[P]>
  }




  export type YoutubeCommentGroupByArgs = {
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithAggregationInput>
    by: YoutubeCommentScalarFieldEnum[]
    having?: YoutubeCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YoutubeCommentCountAggregateInputType | true
    _avg?: YoutubeCommentAvgAggregateInputType
    _sum?: YoutubeCommentSumAggregateInputType
    _min?: YoutubeCommentMinAggregateInputType
    _max?: YoutubeCommentMaxAggregateInputType
  }


  export type YoutubeCommentGroupByOutputType = {
    id: number
    videoId: number
    userId: number
    message: string
    commentToId: number | null
    createdAt: Date
    updatedAt: Date
    _count: YoutubeCommentCountAggregateOutputType | null
    _avg: YoutubeCommentAvgAggregateOutputType | null
    _sum: YoutubeCommentSumAggregateOutputType | null
    _min: YoutubeCommentMinAggregateOutputType | null
    _max: YoutubeCommentMaxAggregateOutputType | null
  }

  type GetYoutubeCommentGroupByPayload<T extends YoutubeCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<YoutubeCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YoutubeCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YoutubeCommentGroupByOutputType[P]>
            : GetScalarType<T[P], YoutubeCommentGroupByOutputType[P]>
        }
      >
    >


  export type YoutubeCommentSelect = {
    id?: boolean
    video?: boolean | YoutubeVideoArgs
    user?: boolean | YoutubeUserArgs
    commentTo?: boolean | YoutubeCommentArgs
    videoId?: boolean
    userId?: boolean
    message?: boolean
    commentToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commentPosts?: boolean | YoutubeComment$commentPostsArgs
    _count?: boolean | YoutubeCommentCountOutputTypeArgs
  }


  export type YoutubeCommentInclude = {
    video?: boolean | YoutubeVideoArgs
    user?: boolean | YoutubeUserArgs
    commentTo?: boolean | YoutubeCommentArgs
    commentPosts?: boolean | YoutubeComment$commentPostsArgs
    _count?: boolean | YoutubeCommentCountOutputTypeArgs
  }

  export type YoutubeCommentGetPayload<S extends boolean | null | undefined | YoutubeCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? YoutubeComment :
    S extends undefined ? never :
    S extends { include: any } & (YoutubeCommentArgs | YoutubeCommentFindManyArgs)
    ? YoutubeComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'video' ? YoutubeVideoGetPayload<S['include'][P]> :
        P extends 'user' ? YoutubeUserGetPayload<S['include'][P]> :
        P extends 'commentTo' ? YoutubeCommentGetPayload<S['include'][P]> | null :
        P extends 'commentPosts' ? Array < YoutubeCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? YoutubeCommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (YoutubeCommentArgs | YoutubeCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'video' ? YoutubeVideoGetPayload<S['select'][P]> :
        P extends 'user' ? YoutubeUserGetPayload<S['select'][P]> :
        P extends 'commentTo' ? YoutubeCommentGetPayload<S['select'][P]> | null :
        P extends 'commentPosts' ? Array < YoutubeCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? YoutubeCommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof YoutubeComment ? YoutubeComment[P] : never
  } 
      : YoutubeComment


  type YoutubeCommentCountArgs = 
    Omit<YoutubeCommentFindManyArgs, 'select' | 'include'> & {
      select?: YoutubeCommentCountAggregateInputType | true
    }

  export interface YoutubeCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one YoutubeComment that matches the filter.
     * @param {YoutubeCommentFindUniqueArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends YoutubeCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, YoutubeCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'YoutubeComment'> extends True ? Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>> : Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | null, null>

    /**
     * Find one YoutubeComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {YoutubeCommentFindUniqueOrThrowArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends YoutubeCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentFindUniqueOrThrowArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Find the first YoutubeComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindFirstArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends YoutubeCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, YoutubeCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'YoutubeComment'> extends True ? Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>> : Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | null, null>

    /**
     * Find the first YoutubeComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindFirstOrThrowArgs} args - Arguments to find a YoutubeComment
     * @example
     * // Get one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends YoutubeCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, YoutubeCommentFindFirstOrThrowArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Find zero or more YoutubeComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YoutubeComments
     * const youtubeComments = await prisma.youtubeComment.findMany()
     * 
     * // Get first 10 YoutubeComments
     * const youtubeComments = await prisma.youtubeComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const youtubeCommentWithIdOnly = await prisma.youtubeComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends YoutubeCommentFindManyArgs>(
      args?: SelectSubset<T, YoutubeCommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>>

    /**
     * Create a YoutubeComment.
     * @param {YoutubeCommentCreateArgs} args - Arguments to create a YoutubeComment.
     * @example
     * // Create one YoutubeComment
     * const YoutubeComment = await prisma.youtubeComment.create({
     *   data: {
     *     // ... data to create a YoutubeComment
     *   }
     * })
     * 
    **/
    create<T extends YoutubeCommentCreateArgs>(
      args: SelectSubset<T, YoutubeCommentCreateArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Create many YoutubeComments.
     *     @param {YoutubeCommentCreateManyArgs} args - Arguments to create many YoutubeComments.
     *     @example
     *     // Create many YoutubeComments
     *     const youtubeComment = await prisma.youtubeComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends YoutubeCommentCreateManyArgs>(
      args?: SelectSubset<T, YoutubeCommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a YoutubeComment.
     * @param {YoutubeCommentDeleteArgs} args - Arguments to delete one YoutubeComment.
     * @example
     * // Delete one YoutubeComment
     * const YoutubeComment = await prisma.youtubeComment.delete({
     *   where: {
     *     // ... filter to delete one YoutubeComment
     *   }
     * })
     * 
    **/
    delete<T extends YoutubeCommentDeleteArgs>(
      args: SelectSubset<T, YoutubeCommentDeleteArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Update one YoutubeComment.
     * @param {YoutubeCommentUpdateArgs} args - Arguments to update one YoutubeComment.
     * @example
     * // Update one YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends YoutubeCommentUpdateArgs>(
      args: SelectSubset<T, YoutubeCommentUpdateArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Delete zero or more YoutubeComments.
     * @param {YoutubeCommentDeleteManyArgs} args - Arguments to filter YoutubeComments to delete.
     * @example
     * // Delete a few YoutubeComments
     * const { count } = await prisma.youtubeComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends YoutubeCommentDeleteManyArgs>(
      args?: SelectSubset<T, YoutubeCommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YoutubeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YoutubeComments
     * const youtubeComment = await prisma.youtubeComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends YoutubeCommentUpdateManyArgs>(
      args: SelectSubset<T, YoutubeCommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one YoutubeComment.
     * @param {YoutubeCommentUpsertArgs} args - Arguments to update or create a YoutubeComment.
     * @example
     * // Update or create a YoutubeComment
     * const youtubeComment = await prisma.youtubeComment.upsert({
     *   create: {
     *     // ... data to create a YoutubeComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YoutubeComment we want to update
     *   }
     * })
    **/
    upsert<T extends YoutubeCommentUpsertArgs>(
      args: SelectSubset<T, YoutubeCommentUpsertArgs>
    ): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T>>

    /**
     * Count the number of YoutubeComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentCountArgs} args - Arguments to filter YoutubeComments to count.
     * @example
     * // Count the number of YoutubeComments
     * const count = await prisma.youtubeComment.count({
     *   where: {
     *     // ... the filter for the YoutubeComments we want to count
     *   }
     * })
    **/
    count<T extends YoutubeCommentCountArgs>(
      args?: Subset<T, YoutubeCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YoutubeCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YoutubeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YoutubeCommentAggregateArgs>(args: Subset<T, YoutubeCommentAggregateArgs>): Prisma.PrismaPromise<GetYoutubeCommentAggregateType<T>>

    /**
     * Group by YoutubeComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YoutubeCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YoutubeCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YoutubeCommentGroupByArgs['orderBy'] }
        : { orderBy?: YoutubeCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YoutubeCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYoutubeCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for YoutubeComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__YoutubeCommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    video<T extends YoutubeVideoArgs= {}>(args?: Subset<T, YoutubeVideoArgs>): Prisma__YoutubeVideoClient<YoutubeVideoGetPayload<T> | Null>;

    user<T extends YoutubeUserArgs= {}>(args?: Subset<T, YoutubeUserArgs>): Prisma__YoutubeUserClient<YoutubeUserGetPayload<T> | Null>;

    commentTo<T extends YoutubeCommentArgs= {}>(args?: Subset<T, YoutubeCommentArgs>): Prisma__YoutubeCommentClient<YoutubeCommentGetPayload<T> | Null>;

    commentPosts<T extends YoutubeComment$commentPostsArgs= {}>(args?: Subset<T, YoutubeComment$commentPostsArgs>): Prisma.PrismaPromise<Array<YoutubeCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * YoutubeComment base type for findUnique actions
   */
  export type YoutubeCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where: YoutubeCommentWhereUniqueInput
  }

  /**
   * YoutubeComment findUnique
   */
  export interface YoutubeCommentFindUniqueArgs extends YoutubeCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeComment findUniqueOrThrow
   */
  export type YoutubeCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment base type for findFirst actions
   */
  export type YoutubeCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeComments.
     */
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }

  /**
   * YoutubeComment findFirst
   */
  export interface YoutubeCommentFindFirstArgs extends YoutubeCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * YoutubeComment findFirstOrThrow
   */
  export type YoutubeCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComment to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YoutubeComments.
     */
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeComment findMany
   */
  export type YoutubeCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter, which YoutubeComments to fetch.
     */
    where?: YoutubeCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YoutubeComments to fetch.
     */
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YoutubeComments.
     */
    cursor?: YoutubeCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YoutubeComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YoutubeComments.
     */
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeComment create
   */
  export type YoutubeCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The data needed to create a YoutubeComment.
     */
    data: XOR<YoutubeCommentCreateInput, YoutubeCommentUncheckedCreateInput>
  }


  /**
   * YoutubeComment createMany
   */
  export type YoutubeCommentCreateManyArgs = {
    /**
     * The data used to create many YoutubeComments.
     */
    data: Enumerable<YoutubeCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * YoutubeComment update
   */
  export type YoutubeCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The data needed to update a YoutubeComment.
     */
    data: XOR<YoutubeCommentUpdateInput, YoutubeCommentUncheckedUpdateInput>
    /**
     * Choose, which YoutubeComment to update.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment updateMany
   */
  export type YoutubeCommentUpdateManyArgs = {
    /**
     * The data used to update YoutubeComments.
     */
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyInput>
    /**
     * Filter which YoutubeComments to update
     */
    where?: YoutubeCommentWhereInput
  }


  /**
   * YoutubeComment upsert
   */
  export type YoutubeCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * The filter to search for the YoutubeComment to update in case it exists.
     */
    where: YoutubeCommentWhereUniqueInput
    /**
     * In case the YoutubeComment found by the `where` argument doesn't exist, create a new YoutubeComment with this data.
     */
    create: XOR<YoutubeCommentCreateInput, YoutubeCommentUncheckedCreateInput>
    /**
     * In case the YoutubeComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YoutubeCommentUpdateInput, YoutubeCommentUncheckedUpdateInput>
  }


  /**
   * YoutubeComment delete
   */
  export type YoutubeCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    /**
     * Filter which YoutubeComment to delete.
     */
    where: YoutubeCommentWhereUniqueInput
  }


  /**
   * YoutubeComment deleteMany
   */
  export type YoutubeCommentDeleteManyArgs = {
    /**
     * Filter which YoutubeComments to delete
     */
    where?: YoutubeCommentWhereInput
  }


  /**
   * YoutubeComment.commentPosts
   */
  export type YoutubeComment$commentPostsArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
    where?: YoutubeCommentWhereInput
    orderBy?: Enumerable<YoutubeCommentOrderByWithRelationInput>
    cursor?: YoutubeCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<YoutubeCommentScalarFieldEnum>
  }


  /**
   * YoutubeComment without action
   */
  export type YoutubeCommentArgs = {
    /**
     * Select specific fields to fetch from the YoutubeComment
     */
    select?: YoutubeCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: YoutubeCommentInclude | null
  }



  /**
   * Model LaunderBranchInfo
   */


  export type AggregateLaunderBranchInfo = {
    _count: LaunderBranchInfoCountAggregateOutputType | null
    _avg: LaunderBranchInfoAvgAggregateOutputType | null
    _sum: LaunderBranchInfoSumAggregateOutputType | null
    _min: LaunderBranchInfoMinAggregateOutputType | null
    _max: LaunderBranchInfoMaxAggregateOutputType | null
  }

  export type LaunderBranchInfoAvgAggregateOutputType = {
    id: number | null
    phone: number | null
    areaSize: number | null
  }

  export type LaunderBranchInfoSumAggregateOutputType = {
    id: number | null
    phone: number | null
    areaSize: number | null
  }

  export type LaunderBranchInfoMinAggregateOutputType = {
    id: number | null
    owner: string | null
    phone: number | null
    location: string | null
    areaSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderBranchInfoMaxAggregateOutputType = {
    id: number | null
    owner: string | null
    phone: number | null
    location: string | null
    areaSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderBranchInfoCountAggregateOutputType = {
    id: number
    owner: number
    phone: number
    location: number
    areaSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderBranchInfoAvgAggregateInputType = {
    id?: true
    phone?: true
    areaSize?: true
  }

  export type LaunderBranchInfoSumAggregateInputType = {
    id?: true
    phone?: true
    areaSize?: true
  }

  export type LaunderBranchInfoMinAggregateInputType = {
    id?: true
    owner?: true
    phone?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderBranchInfoMaxAggregateInputType = {
    id?: true
    owner?: true
    phone?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderBranchInfoCountAggregateInputType = {
    id?: true
    owner?: true
    phone?: true
    location?: true
    areaSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderBranchInfoAggregateArgs = {
    /**
     * Filter which LaunderBranchInfo to aggregate.
     */
    where?: LaunderBranchInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderBranchInfos to fetch.
     */
    orderBy?: Enumerable<LaunderBranchInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderBranchInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderBranchInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderBranchInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderBranchInfos
    **/
    _count?: true | LaunderBranchInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderBranchInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderBranchInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderBranchInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderBranchInfoMaxAggregateInputType
  }

  export type GetLaunderBranchInfoAggregateType<T extends LaunderBranchInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderBranchInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderBranchInfo[P]>
      : GetScalarType<T[P], AggregateLaunderBranchInfo[P]>
  }




  export type LaunderBranchInfoGroupByArgs = {
    where?: LaunderBranchInfoWhereInput
    orderBy?: Enumerable<LaunderBranchInfoOrderByWithAggregationInput>
    by: LaunderBranchInfoScalarFieldEnum[]
    having?: LaunderBranchInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderBranchInfoCountAggregateInputType | true
    _avg?: LaunderBranchInfoAvgAggregateInputType
    _sum?: LaunderBranchInfoSumAggregateInputType
    _min?: LaunderBranchInfoMinAggregateInputType
    _max?: LaunderBranchInfoMaxAggregateInputType
  }


  export type LaunderBranchInfoGroupByOutputType = {
    id: number
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderBranchInfoCountAggregateOutputType | null
    _avg: LaunderBranchInfoAvgAggregateOutputType | null
    _sum: LaunderBranchInfoSumAggregateOutputType | null
    _min: LaunderBranchInfoMinAggregateOutputType | null
    _max: LaunderBranchInfoMaxAggregateOutputType | null
  }

  type GetLaunderBranchInfoGroupByPayload<T extends LaunderBranchInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderBranchInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderBranchInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderBranchInfoGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderBranchInfoGroupByOutputType[P]>
        }
      >
    >


  export type LaunderBranchInfoSelect = {
    id?: boolean
    owner?: boolean
    phone?: boolean
    location?: boolean
    areaSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machineInStores?: boolean | LaunderBranchInfo$machineInStoresArgs
    _count?: boolean | LaunderBranchInfoCountOutputTypeArgs
  }


  export type LaunderBranchInfoInclude = {
    machineInStores?: boolean | LaunderBranchInfo$machineInStoresArgs
    _count?: boolean | LaunderBranchInfoCountOutputTypeArgs
  }

  export type LaunderBranchInfoGetPayload<S extends boolean | null | undefined | LaunderBranchInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderBranchInfo :
    S extends undefined ? never :
    S extends { include: any } & (LaunderBranchInfoArgs | LaunderBranchInfoFindManyArgs)
    ? LaunderBranchInfo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machineInStores' ? Array < LaundryMachineInStoreGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaunderBranchInfoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderBranchInfoArgs | LaunderBranchInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machineInStores' ? Array < LaundryMachineInStoreGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaunderBranchInfoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaunderBranchInfo ? LaunderBranchInfo[P] : never
  } 
      : LaunderBranchInfo


  type LaunderBranchInfoCountArgs = 
    Omit<LaunderBranchInfoFindManyArgs, 'select' | 'include'> & {
      select?: LaunderBranchInfoCountAggregateInputType | true
    }

  export interface LaunderBranchInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderBranchInfo that matches the filter.
     * @param {LaunderBranchInfoFindUniqueArgs} args - Arguments to find a LaunderBranchInfo
     * @example
     * // Get one LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderBranchInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderBranchInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderBranchInfo'> extends True ? Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>> : Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T> | null, null>

    /**
     * Find one LaunderBranchInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderBranchInfoFindUniqueOrThrowArgs} args - Arguments to find a LaunderBranchInfo
     * @example
     * // Get one LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderBranchInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderBranchInfoFindUniqueOrThrowArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Find the first LaunderBranchInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoFindFirstArgs} args - Arguments to find a LaunderBranchInfo
     * @example
     * // Get one LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderBranchInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderBranchInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderBranchInfo'> extends True ? Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>> : Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T> | null, null>

    /**
     * Find the first LaunderBranchInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoFindFirstOrThrowArgs} args - Arguments to find a LaunderBranchInfo
     * @example
     * // Get one LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderBranchInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderBranchInfoFindFirstOrThrowArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Find zero or more LaunderBranchInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderBranchInfos
     * const launderBranchInfos = await prisma.launderBranchInfo.findMany()
     * 
     * // Get first 10 LaunderBranchInfos
     * const launderBranchInfos = await prisma.launderBranchInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderBranchInfoWithIdOnly = await prisma.launderBranchInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderBranchInfoFindManyArgs>(
      args?: SelectSubset<T, LaunderBranchInfoFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderBranchInfoGetPayload<T>>>

    /**
     * Create a LaunderBranchInfo.
     * @param {LaunderBranchInfoCreateArgs} args - Arguments to create a LaunderBranchInfo.
     * @example
     * // Create one LaunderBranchInfo
     * const LaunderBranchInfo = await prisma.launderBranchInfo.create({
     *   data: {
     *     // ... data to create a LaunderBranchInfo
     *   }
     * })
     * 
    **/
    create<T extends LaunderBranchInfoCreateArgs>(
      args: SelectSubset<T, LaunderBranchInfoCreateArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Create many LaunderBranchInfos.
     *     @param {LaunderBranchInfoCreateManyArgs} args - Arguments to create many LaunderBranchInfos.
     *     @example
     *     // Create many LaunderBranchInfos
     *     const launderBranchInfo = await prisma.launderBranchInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderBranchInfoCreateManyArgs>(
      args?: SelectSubset<T, LaunderBranchInfoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderBranchInfo.
     * @param {LaunderBranchInfoDeleteArgs} args - Arguments to delete one LaunderBranchInfo.
     * @example
     * // Delete one LaunderBranchInfo
     * const LaunderBranchInfo = await prisma.launderBranchInfo.delete({
     *   where: {
     *     // ... filter to delete one LaunderBranchInfo
     *   }
     * })
     * 
    **/
    delete<T extends LaunderBranchInfoDeleteArgs>(
      args: SelectSubset<T, LaunderBranchInfoDeleteArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Update one LaunderBranchInfo.
     * @param {LaunderBranchInfoUpdateArgs} args - Arguments to update one LaunderBranchInfo.
     * @example
     * // Update one LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderBranchInfoUpdateArgs>(
      args: SelectSubset<T, LaunderBranchInfoUpdateArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Delete zero or more LaunderBranchInfos.
     * @param {LaunderBranchInfoDeleteManyArgs} args - Arguments to filter LaunderBranchInfos to delete.
     * @example
     * // Delete a few LaunderBranchInfos
     * const { count } = await prisma.launderBranchInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderBranchInfoDeleteManyArgs>(
      args?: SelectSubset<T, LaunderBranchInfoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderBranchInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderBranchInfos
     * const launderBranchInfo = await prisma.launderBranchInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderBranchInfoUpdateManyArgs>(
      args: SelectSubset<T, LaunderBranchInfoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderBranchInfo.
     * @param {LaunderBranchInfoUpsertArgs} args - Arguments to update or create a LaunderBranchInfo.
     * @example
     * // Update or create a LaunderBranchInfo
     * const launderBranchInfo = await prisma.launderBranchInfo.upsert({
     *   create: {
     *     // ... data to create a LaunderBranchInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderBranchInfo we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderBranchInfoUpsertArgs>(
      args: SelectSubset<T, LaunderBranchInfoUpsertArgs>
    ): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T>>

    /**
     * Count the number of LaunderBranchInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoCountArgs} args - Arguments to filter LaunderBranchInfos to count.
     * @example
     * // Count the number of LaunderBranchInfos
     * const count = await prisma.launderBranchInfo.count({
     *   where: {
     *     // ... the filter for the LaunderBranchInfos we want to count
     *   }
     * })
    **/
    count<T extends LaunderBranchInfoCountArgs>(
      args?: Subset<T, LaunderBranchInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderBranchInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderBranchInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderBranchInfoAggregateArgs>(args: Subset<T, LaunderBranchInfoAggregateArgs>): Prisma.PrismaPromise<GetLaunderBranchInfoAggregateType<T>>

    /**
     * Group by LaunderBranchInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderBranchInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderBranchInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderBranchInfoGroupByArgs['orderBy'] }
        : { orderBy?: LaunderBranchInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderBranchInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderBranchInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderBranchInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderBranchInfoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machineInStores<T extends LaunderBranchInfo$machineInStoresArgs= {}>(args?: Subset<T, LaunderBranchInfo$machineInStoresArgs>): Prisma.PrismaPromise<Array<LaundryMachineInStoreGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderBranchInfo base type for findUnique actions
   */
  export type LaunderBranchInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter, which LaunderBranchInfo to fetch.
     */
    where: LaunderBranchInfoWhereUniqueInput
  }

  /**
   * LaunderBranchInfo findUnique
   */
  export interface LaunderBranchInfoFindUniqueArgs extends LaunderBranchInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderBranchInfo findUniqueOrThrow
   */
  export type LaunderBranchInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter, which LaunderBranchInfo to fetch.
     */
    where: LaunderBranchInfoWhereUniqueInput
  }


  /**
   * LaunderBranchInfo base type for findFirst actions
   */
  export type LaunderBranchInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter, which LaunderBranchInfo to fetch.
     */
    where?: LaunderBranchInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderBranchInfos to fetch.
     */
    orderBy?: Enumerable<LaunderBranchInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderBranchInfos.
     */
    cursor?: LaunderBranchInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderBranchInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderBranchInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderBranchInfos.
     */
    distinct?: Enumerable<LaunderBranchInfoScalarFieldEnum>
  }

  /**
   * LaunderBranchInfo findFirst
   */
  export interface LaunderBranchInfoFindFirstArgs extends LaunderBranchInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderBranchInfo findFirstOrThrow
   */
  export type LaunderBranchInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter, which LaunderBranchInfo to fetch.
     */
    where?: LaunderBranchInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderBranchInfos to fetch.
     */
    orderBy?: Enumerable<LaunderBranchInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderBranchInfos.
     */
    cursor?: LaunderBranchInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderBranchInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderBranchInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderBranchInfos.
     */
    distinct?: Enumerable<LaunderBranchInfoScalarFieldEnum>
  }


  /**
   * LaunderBranchInfo findMany
   */
  export type LaunderBranchInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter, which LaunderBranchInfos to fetch.
     */
    where?: LaunderBranchInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderBranchInfos to fetch.
     */
    orderBy?: Enumerable<LaunderBranchInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderBranchInfos.
     */
    cursor?: LaunderBranchInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderBranchInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderBranchInfos.
     */
    skip?: number
    distinct?: Enumerable<LaunderBranchInfoScalarFieldEnum>
  }


  /**
   * LaunderBranchInfo create
   */
  export type LaunderBranchInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * The data needed to create a LaunderBranchInfo.
     */
    data: XOR<LaunderBranchInfoCreateInput, LaunderBranchInfoUncheckedCreateInput>
  }


  /**
   * LaunderBranchInfo createMany
   */
  export type LaunderBranchInfoCreateManyArgs = {
    /**
     * The data used to create many LaunderBranchInfos.
     */
    data: Enumerable<LaunderBranchInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderBranchInfo update
   */
  export type LaunderBranchInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * The data needed to update a LaunderBranchInfo.
     */
    data: XOR<LaunderBranchInfoUpdateInput, LaunderBranchInfoUncheckedUpdateInput>
    /**
     * Choose, which LaunderBranchInfo to update.
     */
    where: LaunderBranchInfoWhereUniqueInput
  }


  /**
   * LaunderBranchInfo updateMany
   */
  export type LaunderBranchInfoUpdateManyArgs = {
    /**
     * The data used to update LaunderBranchInfos.
     */
    data: XOR<LaunderBranchInfoUpdateManyMutationInput, LaunderBranchInfoUncheckedUpdateManyInput>
    /**
     * Filter which LaunderBranchInfos to update
     */
    where?: LaunderBranchInfoWhereInput
  }


  /**
   * LaunderBranchInfo upsert
   */
  export type LaunderBranchInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * The filter to search for the LaunderBranchInfo to update in case it exists.
     */
    where: LaunderBranchInfoWhereUniqueInput
    /**
     * In case the LaunderBranchInfo found by the `where` argument doesn't exist, create a new LaunderBranchInfo with this data.
     */
    create: XOR<LaunderBranchInfoCreateInput, LaunderBranchInfoUncheckedCreateInput>
    /**
     * In case the LaunderBranchInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderBranchInfoUpdateInput, LaunderBranchInfoUncheckedUpdateInput>
  }


  /**
   * LaunderBranchInfo delete
   */
  export type LaunderBranchInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
    /**
     * Filter which LaunderBranchInfo to delete.
     */
    where: LaunderBranchInfoWhereUniqueInput
  }


  /**
   * LaunderBranchInfo deleteMany
   */
  export type LaunderBranchInfoDeleteManyArgs = {
    /**
     * Filter which LaunderBranchInfos to delete
     */
    where?: LaunderBranchInfoWhereInput
  }


  /**
   * LaunderBranchInfo.machineInStores
   */
  export type LaunderBranchInfo$machineInStoresArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    where?: LaundryMachineInStoreWhereInput
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    cursor?: LaundryMachineInStoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryMachineInStoreScalarFieldEnum>
  }


  /**
   * LaunderBranchInfo without action
   */
  export type LaunderBranchInfoArgs = {
    /**
     * Select specific fields to fetch from the LaunderBranchInfo
     */
    select?: LaunderBranchInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderBranchInfoInclude | null
  }



  /**
   * Model LaunderMachine
   */


  export type AggregateLaunderMachine = {
    _count: LaunderMachineCountAggregateOutputType | null
    _avg: LaunderMachineAvgAggregateOutputType | null
    _sum: LaunderMachineSumAggregateOutputType | null
    _min: LaunderMachineMinAggregateOutputType | null
    _max: LaunderMachineMaxAggregateOutputType | null
  }

  export type LaunderMachineAvgAggregateOutputType = {
    id: number | null
    Capacity: number | null
    serialNumber: number | null
  }

  export type LaunderMachineSumAggregateOutputType = {
    id: number | null
    Capacity: number | null
    serialNumber: number | null
  }

  export type LaunderMachineMinAggregateOutputType = {
    id: number | null
    brand: string | null
    Capacity: number | null
    type: string | null
    serialNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderMachineMaxAggregateOutputType = {
    id: number | null
    brand: string | null
    Capacity: number | null
    type: string | null
    serialNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderMachineCountAggregateOutputType = {
    id: number
    brand: number
    Capacity: number
    type: number
    serialNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderMachineAvgAggregateInputType = {
    id?: true
    Capacity?: true
    serialNumber?: true
  }

  export type LaunderMachineSumAggregateInputType = {
    id?: true
    Capacity?: true
    serialNumber?: true
  }

  export type LaunderMachineMinAggregateInputType = {
    id?: true
    brand?: true
    Capacity?: true
    type?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderMachineMaxAggregateInputType = {
    id?: true
    brand?: true
    Capacity?: true
    type?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderMachineCountAggregateInputType = {
    id?: true
    brand?: true
    Capacity?: true
    type?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderMachineAggregateArgs = {
    /**
     * Filter which LaunderMachine to aggregate.
     */
    where?: LaunderMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderMachines to fetch.
     */
    orderBy?: Enumerable<LaunderMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderMachines
    **/
    _count?: true | LaunderMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderMachineMaxAggregateInputType
  }

  export type GetLaunderMachineAggregateType<T extends LaunderMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderMachine[P]>
      : GetScalarType<T[P], AggregateLaunderMachine[P]>
  }




  export type LaunderMachineGroupByArgs = {
    where?: LaunderMachineWhereInput
    orderBy?: Enumerable<LaunderMachineOrderByWithAggregationInput>
    by: LaunderMachineScalarFieldEnum[]
    having?: LaunderMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderMachineCountAggregateInputType | true
    _avg?: LaunderMachineAvgAggregateInputType
    _sum?: LaunderMachineSumAggregateInputType
    _min?: LaunderMachineMinAggregateInputType
    _max?: LaunderMachineMaxAggregateInputType
  }


  export type LaunderMachineGroupByOutputType = {
    id: number
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderMachineCountAggregateOutputType | null
    _avg: LaunderMachineAvgAggregateOutputType | null
    _sum: LaunderMachineSumAggregateOutputType | null
    _min: LaunderMachineMinAggregateOutputType | null
    _max: LaunderMachineMaxAggregateOutputType | null
  }

  type GetLaunderMachineGroupByPayload<T extends LaunderMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderMachineGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderMachineGroupByOutputType[P]>
        }
      >
    >


  export type LaunderMachineSelect = {
    id?: boolean
    brand?: boolean
    Capacity?: boolean
    type?: boolean
    serialNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machineInStores?: boolean | LaunderMachine$machineInStoresArgs
    serviceHistories?: boolean | LaunderMachine$serviceHistoriesArgs
    _count?: boolean | LaunderMachineCountOutputTypeArgs
  }


  export type LaunderMachineInclude = {
    machineInStores?: boolean | LaunderMachine$machineInStoresArgs
    serviceHistories?: boolean | LaunderMachine$serviceHistoriesArgs
    _count?: boolean | LaunderMachineCountOutputTypeArgs
  }

  export type LaunderMachineGetPayload<S extends boolean | null | undefined | LaunderMachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderMachine :
    S extends undefined ? never :
    S extends { include: any } & (LaunderMachineArgs | LaunderMachineFindManyArgs)
    ? LaunderMachine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machineInStores' ? Array < LaundryMachineInStoreGetPayload<S['include'][P]>>  :
        P extends 'serviceHistories' ? Array < LaunderServiceHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaunderMachineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderMachineArgs | LaunderMachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machineInStores' ? Array < LaundryMachineInStoreGetPayload<S['select'][P]>>  :
        P extends 'serviceHistories' ? Array < LaunderServiceHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaunderMachineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaunderMachine ? LaunderMachine[P] : never
  } 
      : LaunderMachine


  type LaunderMachineCountArgs = 
    Omit<LaunderMachineFindManyArgs, 'select' | 'include'> & {
      select?: LaunderMachineCountAggregateInputType | true
    }

  export interface LaunderMachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderMachine that matches the filter.
     * @param {LaunderMachineFindUniqueArgs} args - Arguments to find a LaunderMachine
     * @example
     * // Get one LaunderMachine
     * const launderMachine = await prisma.launderMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderMachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderMachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderMachine'> extends True ? Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>> : Prisma__LaunderMachineClient<LaunderMachineGetPayload<T> | null, null>

    /**
     * Find one LaunderMachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderMachineFindUniqueOrThrowArgs} args - Arguments to find a LaunderMachine
     * @example
     * // Get one LaunderMachine
     * const launderMachine = await prisma.launderMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderMachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderMachineFindUniqueOrThrowArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Find the first LaunderMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineFindFirstArgs} args - Arguments to find a LaunderMachine
     * @example
     * // Get one LaunderMachine
     * const launderMachine = await prisma.launderMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderMachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderMachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderMachine'> extends True ? Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>> : Prisma__LaunderMachineClient<LaunderMachineGetPayload<T> | null, null>

    /**
     * Find the first LaunderMachine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineFindFirstOrThrowArgs} args - Arguments to find a LaunderMachine
     * @example
     * // Get one LaunderMachine
     * const launderMachine = await prisma.launderMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderMachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderMachineFindFirstOrThrowArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Find zero or more LaunderMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderMachines
     * const launderMachines = await prisma.launderMachine.findMany()
     * 
     * // Get first 10 LaunderMachines
     * const launderMachines = await prisma.launderMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderMachineWithIdOnly = await prisma.launderMachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderMachineFindManyArgs>(
      args?: SelectSubset<T, LaunderMachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderMachineGetPayload<T>>>

    /**
     * Create a LaunderMachine.
     * @param {LaunderMachineCreateArgs} args - Arguments to create a LaunderMachine.
     * @example
     * // Create one LaunderMachine
     * const LaunderMachine = await prisma.launderMachine.create({
     *   data: {
     *     // ... data to create a LaunderMachine
     *   }
     * })
     * 
    **/
    create<T extends LaunderMachineCreateArgs>(
      args: SelectSubset<T, LaunderMachineCreateArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Create many LaunderMachines.
     *     @param {LaunderMachineCreateManyArgs} args - Arguments to create many LaunderMachines.
     *     @example
     *     // Create many LaunderMachines
     *     const launderMachine = await prisma.launderMachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderMachineCreateManyArgs>(
      args?: SelectSubset<T, LaunderMachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderMachine.
     * @param {LaunderMachineDeleteArgs} args - Arguments to delete one LaunderMachine.
     * @example
     * // Delete one LaunderMachine
     * const LaunderMachine = await prisma.launderMachine.delete({
     *   where: {
     *     // ... filter to delete one LaunderMachine
     *   }
     * })
     * 
    **/
    delete<T extends LaunderMachineDeleteArgs>(
      args: SelectSubset<T, LaunderMachineDeleteArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Update one LaunderMachine.
     * @param {LaunderMachineUpdateArgs} args - Arguments to update one LaunderMachine.
     * @example
     * // Update one LaunderMachine
     * const launderMachine = await prisma.launderMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderMachineUpdateArgs>(
      args: SelectSubset<T, LaunderMachineUpdateArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Delete zero or more LaunderMachines.
     * @param {LaunderMachineDeleteManyArgs} args - Arguments to filter LaunderMachines to delete.
     * @example
     * // Delete a few LaunderMachines
     * const { count } = await prisma.launderMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderMachineDeleteManyArgs>(
      args?: SelectSubset<T, LaunderMachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderMachines
     * const launderMachine = await prisma.launderMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderMachineUpdateManyArgs>(
      args: SelectSubset<T, LaunderMachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderMachine.
     * @param {LaunderMachineUpsertArgs} args - Arguments to update or create a LaunderMachine.
     * @example
     * // Update or create a LaunderMachine
     * const launderMachine = await prisma.launderMachine.upsert({
     *   create: {
     *     // ... data to create a LaunderMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderMachine we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderMachineUpsertArgs>(
      args: SelectSubset<T, LaunderMachineUpsertArgs>
    ): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T>>

    /**
     * Count the number of LaunderMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineCountArgs} args - Arguments to filter LaunderMachines to count.
     * @example
     * // Count the number of LaunderMachines
     * const count = await prisma.launderMachine.count({
     *   where: {
     *     // ... the filter for the LaunderMachines we want to count
     *   }
     * })
    **/
    count<T extends LaunderMachineCountArgs>(
      args?: Subset<T, LaunderMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderMachineAggregateArgs>(args: Subset<T, LaunderMachineAggregateArgs>): Prisma.PrismaPromise<GetLaunderMachineAggregateType<T>>

    /**
     * Group by LaunderMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderMachineGroupByArgs['orderBy'] }
        : { orderBy?: LaunderMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderMachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machineInStores<T extends LaunderMachine$machineInStoresArgs= {}>(args?: Subset<T, LaunderMachine$machineInStoresArgs>): Prisma.PrismaPromise<Array<LaundryMachineInStoreGetPayload<T>>| Null>;

    serviceHistories<T extends LaunderMachine$serviceHistoriesArgs= {}>(args?: Subset<T, LaunderMachine$serviceHistoriesArgs>): Prisma.PrismaPromise<Array<LaunderServiceHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderMachine base type for findUnique actions
   */
  export type LaunderMachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter, which LaunderMachine to fetch.
     */
    where: LaunderMachineWhereUniqueInput
  }

  /**
   * LaunderMachine findUnique
   */
  export interface LaunderMachineFindUniqueArgs extends LaunderMachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderMachine findUniqueOrThrow
   */
  export type LaunderMachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter, which LaunderMachine to fetch.
     */
    where: LaunderMachineWhereUniqueInput
  }


  /**
   * LaunderMachine base type for findFirst actions
   */
  export type LaunderMachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter, which LaunderMachine to fetch.
     */
    where?: LaunderMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderMachines to fetch.
     */
    orderBy?: Enumerable<LaunderMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderMachines.
     */
    cursor?: LaunderMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderMachines.
     */
    distinct?: Enumerable<LaunderMachineScalarFieldEnum>
  }

  /**
   * LaunderMachine findFirst
   */
  export interface LaunderMachineFindFirstArgs extends LaunderMachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderMachine findFirstOrThrow
   */
  export type LaunderMachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter, which LaunderMachine to fetch.
     */
    where?: LaunderMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderMachines to fetch.
     */
    orderBy?: Enumerable<LaunderMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderMachines.
     */
    cursor?: LaunderMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderMachines.
     */
    distinct?: Enumerable<LaunderMachineScalarFieldEnum>
  }


  /**
   * LaunderMachine findMany
   */
  export type LaunderMachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter, which LaunderMachines to fetch.
     */
    where?: LaunderMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderMachines to fetch.
     */
    orderBy?: Enumerable<LaunderMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderMachines.
     */
    cursor?: LaunderMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderMachines.
     */
    skip?: number
    distinct?: Enumerable<LaunderMachineScalarFieldEnum>
  }


  /**
   * LaunderMachine create
   */
  export type LaunderMachineCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * The data needed to create a LaunderMachine.
     */
    data: XOR<LaunderMachineCreateInput, LaunderMachineUncheckedCreateInput>
  }


  /**
   * LaunderMachine createMany
   */
  export type LaunderMachineCreateManyArgs = {
    /**
     * The data used to create many LaunderMachines.
     */
    data: Enumerable<LaunderMachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderMachine update
   */
  export type LaunderMachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * The data needed to update a LaunderMachine.
     */
    data: XOR<LaunderMachineUpdateInput, LaunderMachineUncheckedUpdateInput>
    /**
     * Choose, which LaunderMachine to update.
     */
    where: LaunderMachineWhereUniqueInput
  }


  /**
   * LaunderMachine updateMany
   */
  export type LaunderMachineUpdateManyArgs = {
    /**
     * The data used to update LaunderMachines.
     */
    data: XOR<LaunderMachineUpdateManyMutationInput, LaunderMachineUncheckedUpdateManyInput>
    /**
     * Filter which LaunderMachines to update
     */
    where?: LaunderMachineWhereInput
  }


  /**
   * LaunderMachine upsert
   */
  export type LaunderMachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * The filter to search for the LaunderMachine to update in case it exists.
     */
    where: LaunderMachineWhereUniqueInput
    /**
     * In case the LaunderMachine found by the `where` argument doesn't exist, create a new LaunderMachine with this data.
     */
    create: XOR<LaunderMachineCreateInput, LaunderMachineUncheckedCreateInput>
    /**
     * In case the LaunderMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderMachineUpdateInput, LaunderMachineUncheckedUpdateInput>
  }


  /**
   * LaunderMachine delete
   */
  export type LaunderMachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
    /**
     * Filter which LaunderMachine to delete.
     */
    where: LaunderMachineWhereUniqueInput
  }


  /**
   * LaunderMachine deleteMany
   */
  export type LaunderMachineDeleteManyArgs = {
    /**
     * Filter which LaunderMachines to delete
     */
    where?: LaunderMachineWhereInput
  }


  /**
   * LaunderMachine.machineInStores
   */
  export type LaunderMachine$machineInStoresArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    where?: LaundryMachineInStoreWhereInput
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    cursor?: LaundryMachineInStoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryMachineInStoreScalarFieldEnum>
  }


  /**
   * LaunderMachine.serviceHistories
   */
  export type LaunderMachine$serviceHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    where?: LaunderServiceHistoryWhereInput
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    cursor?: LaunderServiceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaunderServiceHistoryScalarFieldEnum>
  }


  /**
   * LaunderMachine without action
   */
  export type LaunderMachineArgs = {
    /**
     * Select specific fields to fetch from the LaunderMachine
     */
    select?: LaunderMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderMachineInclude | null
  }



  /**
   * Model LaundryMachineInStore
   */


  export type AggregateLaundryMachineInStore = {
    _count: LaundryMachineInStoreCountAggregateOutputType | null
    _avg: LaundryMachineInStoreAvgAggregateOutputType | null
    _sum: LaundryMachineInStoreSumAggregateOutputType | null
    _min: LaundryMachineInStoreMinAggregateOutputType | null
    _max: LaundryMachineInStoreMaxAggregateOutputType | null
  }

  export type LaundryMachineInStoreAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    machineId: number | null
  }

  export type LaundryMachineInStoreSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    machineId: number | null
  }

  export type LaundryMachineInStoreMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    machineId: number | null
    mfd: string | null
    Warranty: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryMachineInStoreMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    machineId: number | null
    mfd: string | null
    Warranty: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryMachineInStoreCountAggregateOutputType = {
    id: number
    branchId: number
    machineId: number
    mfd: number
    Warranty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryMachineInStoreAvgAggregateInputType = {
    id?: true
    branchId?: true
    machineId?: true
  }

  export type LaundryMachineInStoreSumAggregateInputType = {
    id?: true
    branchId?: true
    machineId?: true
  }

  export type LaundryMachineInStoreMinAggregateInputType = {
    id?: true
    branchId?: true
    machineId?: true
    mfd?: true
    Warranty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryMachineInStoreMaxAggregateInputType = {
    id?: true
    branchId?: true
    machineId?: true
    mfd?: true
    Warranty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryMachineInStoreCountAggregateInputType = {
    id?: true
    branchId?: true
    machineId?: true
    mfd?: true
    Warranty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryMachineInStoreAggregateArgs = {
    /**
     * Filter which LaundryMachineInStore to aggregate.
     */
    where?: LaundryMachineInStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMachineInStores to fetch.
     */
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryMachineInStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMachineInStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMachineInStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryMachineInStores
    **/
    _count?: true | LaundryMachineInStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryMachineInStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryMachineInStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryMachineInStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryMachineInStoreMaxAggregateInputType
  }

  export type GetLaundryMachineInStoreAggregateType<T extends LaundryMachineInStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryMachineInStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryMachineInStore[P]>
      : GetScalarType<T[P], AggregateLaundryMachineInStore[P]>
  }




  export type LaundryMachineInStoreGroupByArgs = {
    where?: LaundryMachineInStoreWhereInput
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithAggregationInput>
    by: LaundryMachineInStoreScalarFieldEnum[]
    having?: LaundryMachineInStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryMachineInStoreCountAggregateInputType | true
    _avg?: LaundryMachineInStoreAvgAggregateInputType
    _sum?: LaundryMachineInStoreSumAggregateInputType
    _min?: LaundryMachineInStoreMinAggregateInputType
    _max?: LaundryMachineInStoreMaxAggregateInputType
  }


  export type LaundryMachineInStoreGroupByOutputType = {
    id: number
    branchId: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt: Date
    updatedAt: Date
    _count: LaundryMachineInStoreCountAggregateOutputType | null
    _avg: LaundryMachineInStoreAvgAggregateOutputType | null
    _sum: LaundryMachineInStoreSumAggregateOutputType | null
    _min: LaundryMachineInStoreMinAggregateOutputType | null
    _max: LaundryMachineInStoreMaxAggregateOutputType | null
  }

  type GetLaundryMachineInStoreGroupByPayload<T extends LaundryMachineInStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryMachineInStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryMachineInStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryMachineInStoreGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryMachineInStoreGroupByOutputType[P]>
        }
      >
    >


  export type LaundryMachineInStoreSelect = {
    id?: boolean
    branch?: boolean | LaunderBranchInfoArgs
    machine?: boolean | LaunderMachineArgs
    branchId?: boolean
    machineId?: boolean
    mfd?: boolean
    Warranty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programInMachines?: boolean | LaundryMachineInStore$programInMachinesArgs
    washingHistories?: boolean | LaundryMachineInStore$washingHistoriesArgs
    _count?: boolean | LaundryMachineInStoreCountOutputTypeArgs
  }


  export type LaundryMachineInStoreInclude = {
    branch?: boolean | LaunderBranchInfoArgs
    machine?: boolean | LaunderMachineArgs
    programInMachines?: boolean | LaundryMachineInStore$programInMachinesArgs
    washingHistories?: boolean | LaundryMachineInStore$washingHistoriesArgs
    _count?: boolean | LaundryMachineInStoreCountOutputTypeArgs
  }

  export type LaundryMachineInStoreGetPayload<S extends boolean | null | undefined | LaundryMachineInStoreArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryMachineInStore :
    S extends undefined ? never :
    S extends { include: any } & (LaundryMachineInStoreArgs | LaundryMachineInStoreFindManyArgs)
    ? LaundryMachineInStore  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'branch' ? LaunderBranchInfoGetPayload<S['include'][P]> :
        P extends 'machine' ? LaunderMachineGetPayload<S['include'][P]> :
        P extends 'programInMachines' ? Array < LaunderProgramInMachineGetPayload<S['include'][P]>>  :
        P extends 'washingHistories' ? Array < LaundryWashingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaundryMachineInStoreCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryMachineInStoreArgs | LaundryMachineInStoreFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'branch' ? LaunderBranchInfoGetPayload<S['select'][P]> :
        P extends 'machine' ? LaunderMachineGetPayload<S['select'][P]> :
        P extends 'programInMachines' ? Array < LaunderProgramInMachineGetPayload<S['select'][P]>>  :
        P extends 'washingHistories' ? Array < LaundryWashingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaundryMachineInStoreCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaundryMachineInStore ? LaundryMachineInStore[P] : never
  } 
      : LaundryMachineInStore


  type LaundryMachineInStoreCountArgs = 
    Omit<LaundryMachineInStoreFindManyArgs, 'select' | 'include'> & {
      select?: LaundryMachineInStoreCountAggregateInputType | true
    }

  export interface LaundryMachineInStoreDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryMachineInStore that matches the filter.
     * @param {LaundryMachineInStoreFindUniqueArgs} args - Arguments to find a LaundryMachineInStore
     * @example
     * // Get one LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryMachineInStoreFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryMachineInStoreFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryMachineInStore'> extends True ? Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>> : Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T> | null, null>

    /**
     * Find one LaundryMachineInStore that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryMachineInStoreFindUniqueOrThrowArgs} args - Arguments to find a LaundryMachineInStore
     * @example
     * // Get one LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryMachineInStoreFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryMachineInStoreFindUniqueOrThrowArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Find the first LaundryMachineInStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreFindFirstArgs} args - Arguments to find a LaundryMachineInStore
     * @example
     * // Get one LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryMachineInStoreFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryMachineInStoreFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryMachineInStore'> extends True ? Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>> : Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T> | null, null>

    /**
     * Find the first LaundryMachineInStore that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreFindFirstOrThrowArgs} args - Arguments to find a LaundryMachineInStore
     * @example
     * // Get one LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryMachineInStoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryMachineInStoreFindFirstOrThrowArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Find zero or more LaundryMachineInStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryMachineInStores
     * const laundryMachineInStores = await prisma.laundryMachineInStore.findMany()
     * 
     * // Get first 10 LaundryMachineInStores
     * const laundryMachineInStores = await prisma.laundryMachineInStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryMachineInStoreWithIdOnly = await prisma.laundryMachineInStore.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryMachineInStoreFindManyArgs>(
      args?: SelectSubset<T, LaundryMachineInStoreFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryMachineInStoreGetPayload<T>>>

    /**
     * Create a LaundryMachineInStore.
     * @param {LaundryMachineInStoreCreateArgs} args - Arguments to create a LaundryMachineInStore.
     * @example
     * // Create one LaundryMachineInStore
     * const LaundryMachineInStore = await prisma.laundryMachineInStore.create({
     *   data: {
     *     // ... data to create a LaundryMachineInStore
     *   }
     * })
     * 
    **/
    create<T extends LaundryMachineInStoreCreateArgs>(
      args: SelectSubset<T, LaundryMachineInStoreCreateArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Create many LaundryMachineInStores.
     *     @param {LaundryMachineInStoreCreateManyArgs} args - Arguments to create many LaundryMachineInStores.
     *     @example
     *     // Create many LaundryMachineInStores
     *     const laundryMachineInStore = await prisma.laundryMachineInStore.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryMachineInStoreCreateManyArgs>(
      args?: SelectSubset<T, LaundryMachineInStoreCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryMachineInStore.
     * @param {LaundryMachineInStoreDeleteArgs} args - Arguments to delete one LaundryMachineInStore.
     * @example
     * // Delete one LaundryMachineInStore
     * const LaundryMachineInStore = await prisma.laundryMachineInStore.delete({
     *   where: {
     *     // ... filter to delete one LaundryMachineInStore
     *   }
     * })
     * 
    **/
    delete<T extends LaundryMachineInStoreDeleteArgs>(
      args: SelectSubset<T, LaundryMachineInStoreDeleteArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Update one LaundryMachineInStore.
     * @param {LaundryMachineInStoreUpdateArgs} args - Arguments to update one LaundryMachineInStore.
     * @example
     * // Update one LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryMachineInStoreUpdateArgs>(
      args: SelectSubset<T, LaundryMachineInStoreUpdateArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Delete zero or more LaundryMachineInStores.
     * @param {LaundryMachineInStoreDeleteManyArgs} args - Arguments to filter LaundryMachineInStores to delete.
     * @example
     * // Delete a few LaundryMachineInStores
     * const { count } = await prisma.laundryMachineInStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryMachineInStoreDeleteManyArgs>(
      args?: SelectSubset<T, LaundryMachineInStoreDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryMachineInStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryMachineInStores
     * const laundryMachineInStore = await prisma.laundryMachineInStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryMachineInStoreUpdateManyArgs>(
      args: SelectSubset<T, LaundryMachineInStoreUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryMachineInStore.
     * @param {LaundryMachineInStoreUpsertArgs} args - Arguments to update or create a LaundryMachineInStore.
     * @example
     * // Update or create a LaundryMachineInStore
     * const laundryMachineInStore = await prisma.laundryMachineInStore.upsert({
     *   create: {
     *     // ... data to create a LaundryMachineInStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryMachineInStore we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryMachineInStoreUpsertArgs>(
      args: SelectSubset<T, LaundryMachineInStoreUpsertArgs>
    ): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T>>

    /**
     * Count the number of LaundryMachineInStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreCountArgs} args - Arguments to filter LaundryMachineInStores to count.
     * @example
     * // Count the number of LaundryMachineInStores
     * const count = await prisma.laundryMachineInStore.count({
     *   where: {
     *     // ... the filter for the LaundryMachineInStores we want to count
     *   }
     * })
    **/
    count<T extends LaundryMachineInStoreCountArgs>(
      args?: Subset<T, LaundryMachineInStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryMachineInStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryMachineInStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryMachineInStoreAggregateArgs>(args: Subset<T, LaundryMachineInStoreAggregateArgs>): Prisma.PrismaPromise<GetLaundryMachineInStoreAggregateType<T>>

    /**
     * Group by LaundryMachineInStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryMachineInStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryMachineInStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryMachineInStoreGroupByArgs['orderBy'] }
        : { orderBy?: LaundryMachineInStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryMachineInStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryMachineInStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryMachineInStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryMachineInStoreClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    branch<T extends LaunderBranchInfoArgs= {}>(args?: Subset<T, LaunderBranchInfoArgs>): Prisma__LaunderBranchInfoClient<LaunderBranchInfoGetPayload<T> | Null>;

    machine<T extends LaunderMachineArgs= {}>(args?: Subset<T, LaunderMachineArgs>): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T> | Null>;

    programInMachines<T extends LaundryMachineInStore$programInMachinesArgs= {}>(args?: Subset<T, LaundryMachineInStore$programInMachinesArgs>): Prisma.PrismaPromise<Array<LaunderProgramInMachineGetPayload<T>>| Null>;

    washingHistories<T extends LaundryMachineInStore$washingHistoriesArgs= {}>(args?: Subset<T, LaundryMachineInStore$washingHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryWashingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryMachineInStore base type for findUnique actions
   */
  export type LaundryMachineInStoreFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter, which LaundryMachineInStore to fetch.
     */
    where: LaundryMachineInStoreWhereUniqueInput
  }

  /**
   * LaundryMachineInStore findUnique
   */
  export interface LaundryMachineInStoreFindUniqueArgs extends LaundryMachineInStoreFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryMachineInStore findUniqueOrThrow
   */
  export type LaundryMachineInStoreFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter, which LaundryMachineInStore to fetch.
     */
    where: LaundryMachineInStoreWhereUniqueInput
  }


  /**
   * LaundryMachineInStore base type for findFirst actions
   */
  export type LaundryMachineInStoreFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter, which LaundryMachineInStore to fetch.
     */
    where?: LaundryMachineInStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMachineInStores to fetch.
     */
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryMachineInStores.
     */
    cursor?: LaundryMachineInStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMachineInStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMachineInStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryMachineInStores.
     */
    distinct?: Enumerable<LaundryMachineInStoreScalarFieldEnum>
  }

  /**
   * LaundryMachineInStore findFirst
   */
  export interface LaundryMachineInStoreFindFirstArgs extends LaundryMachineInStoreFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryMachineInStore findFirstOrThrow
   */
  export type LaundryMachineInStoreFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter, which LaundryMachineInStore to fetch.
     */
    where?: LaundryMachineInStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMachineInStores to fetch.
     */
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryMachineInStores.
     */
    cursor?: LaundryMachineInStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMachineInStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMachineInStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryMachineInStores.
     */
    distinct?: Enumerable<LaundryMachineInStoreScalarFieldEnum>
  }


  /**
   * LaundryMachineInStore findMany
   */
  export type LaundryMachineInStoreFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter, which LaundryMachineInStores to fetch.
     */
    where?: LaundryMachineInStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryMachineInStores to fetch.
     */
    orderBy?: Enumerable<LaundryMachineInStoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryMachineInStores.
     */
    cursor?: LaundryMachineInStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryMachineInStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryMachineInStores.
     */
    skip?: number
    distinct?: Enumerable<LaundryMachineInStoreScalarFieldEnum>
  }


  /**
   * LaundryMachineInStore create
   */
  export type LaundryMachineInStoreCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * The data needed to create a LaundryMachineInStore.
     */
    data: XOR<LaundryMachineInStoreCreateInput, LaundryMachineInStoreUncheckedCreateInput>
  }


  /**
   * LaundryMachineInStore createMany
   */
  export type LaundryMachineInStoreCreateManyArgs = {
    /**
     * The data used to create many LaundryMachineInStores.
     */
    data: Enumerable<LaundryMachineInStoreCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryMachineInStore update
   */
  export type LaundryMachineInStoreUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * The data needed to update a LaundryMachineInStore.
     */
    data: XOR<LaundryMachineInStoreUpdateInput, LaundryMachineInStoreUncheckedUpdateInput>
    /**
     * Choose, which LaundryMachineInStore to update.
     */
    where: LaundryMachineInStoreWhereUniqueInput
  }


  /**
   * LaundryMachineInStore updateMany
   */
  export type LaundryMachineInStoreUpdateManyArgs = {
    /**
     * The data used to update LaundryMachineInStores.
     */
    data: XOR<LaundryMachineInStoreUpdateManyMutationInput, LaundryMachineInStoreUncheckedUpdateManyInput>
    /**
     * Filter which LaundryMachineInStores to update
     */
    where?: LaundryMachineInStoreWhereInput
  }


  /**
   * LaundryMachineInStore upsert
   */
  export type LaundryMachineInStoreUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * The filter to search for the LaundryMachineInStore to update in case it exists.
     */
    where: LaundryMachineInStoreWhereUniqueInput
    /**
     * In case the LaundryMachineInStore found by the `where` argument doesn't exist, create a new LaundryMachineInStore with this data.
     */
    create: XOR<LaundryMachineInStoreCreateInput, LaundryMachineInStoreUncheckedCreateInput>
    /**
     * In case the LaundryMachineInStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryMachineInStoreUpdateInput, LaundryMachineInStoreUncheckedUpdateInput>
  }


  /**
   * LaundryMachineInStore delete
   */
  export type LaundryMachineInStoreDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
    /**
     * Filter which LaundryMachineInStore to delete.
     */
    where: LaundryMachineInStoreWhereUniqueInput
  }


  /**
   * LaundryMachineInStore deleteMany
   */
  export type LaundryMachineInStoreDeleteManyArgs = {
    /**
     * Filter which LaundryMachineInStores to delete
     */
    where?: LaundryMachineInStoreWhereInput
  }


  /**
   * LaundryMachineInStore.programInMachines
   */
  export type LaundryMachineInStore$programInMachinesArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    where?: LaunderProgramInMachineWhereInput
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    cursor?: LaunderProgramInMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaunderProgramInMachineScalarFieldEnum>
  }


  /**
   * LaundryMachineInStore.washingHistories
   */
  export type LaundryMachineInStore$washingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    where?: LaundryWashingHistoryWhereInput
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    cursor?: LaundryWashingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryWashingHistoryScalarFieldEnum>
  }


  /**
   * LaundryMachineInStore without action
   */
  export type LaundryMachineInStoreArgs = {
    /**
     * Select specific fields to fetch from the LaundryMachineInStore
     */
    select?: LaundryMachineInStoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryMachineInStoreInclude | null
  }



  /**
   * Model LaunderTechnician
   */


  export type AggregateLaunderTechnician = {
    _count: LaunderTechnicianCountAggregateOutputType | null
    _avg: LaunderTechnicianAvgAggregateOutputType | null
    _sum: LaunderTechnicianSumAggregateOutputType | null
    _min: LaunderTechnicianMinAggregateOutputType | null
    _max: LaunderTechnicianMaxAggregateOutputType | null
  }

  export type LaunderTechnicianAvgAggregateOutputType = {
    id: number | null
    phone: number | null
  }

  export type LaunderTechnicianSumAggregateOutputType = {
    id: number | null
    phone: number | null
  }

  export type LaunderTechnicianMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    image: string | null
    phone: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderTechnicianMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    image: string | null
    phone: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderTechnicianCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    image: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderTechnicianAvgAggregateInputType = {
    id?: true
    phone?: true
  }

  export type LaunderTechnicianSumAggregateInputType = {
    id?: true
    phone?: true
  }

  export type LaunderTechnicianMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderTechnicianMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderTechnicianCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderTechnicianAggregateArgs = {
    /**
     * Filter which LaunderTechnician to aggregate.
     */
    where?: LaunderTechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderTechnicians to fetch.
     */
    orderBy?: Enumerable<LaunderTechnicianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderTechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderTechnicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderTechnicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderTechnicians
    **/
    _count?: true | LaunderTechnicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderTechnicianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderTechnicianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderTechnicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderTechnicianMaxAggregateInputType
  }

  export type GetLaunderTechnicianAggregateType<T extends LaunderTechnicianAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderTechnician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderTechnician[P]>
      : GetScalarType<T[P], AggregateLaunderTechnician[P]>
  }




  export type LaunderTechnicianGroupByArgs = {
    where?: LaunderTechnicianWhereInput
    orderBy?: Enumerable<LaunderTechnicianOrderByWithAggregationInput>
    by: LaunderTechnicianScalarFieldEnum[]
    having?: LaunderTechnicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderTechnicianCountAggregateInputType | true
    _avg?: LaunderTechnicianAvgAggregateInputType
    _sum?: LaunderTechnicianSumAggregateInputType
    _min?: LaunderTechnicianMinAggregateInputType
    _max?: LaunderTechnicianMaxAggregateInputType
  }


  export type LaunderTechnicianGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    image: string | null
    phone: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderTechnicianCountAggregateOutputType | null
    _avg: LaunderTechnicianAvgAggregateOutputType | null
    _sum: LaunderTechnicianSumAggregateOutputType | null
    _min: LaunderTechnicianMinAggregateOutputType | null
    _max: LaunderTechnicianMaxAggregateOutputType | null
  }

  type GetLaunderTechnicianGroupByPayload<T extends LaunderTechnicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderTechnicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderTechnicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderTechnicianGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderTechnicianGroupByOutputType[P]>
        }
      >
    >


  export type LaunderTechnicianSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceHistories?: boolean | LaunderTechnician$serviceHistoriesArgs
    _count?: boolean | LaunderTechnicianCountOutputTypeArgs
  }


  export type LaunderTechnicianInclude = {
    serviceHistories?: boolean | LaunderTechnician$serviceHistoriesArgs
    _count?: boolean | LaunderTechnicianCountOutputTypeArgs
  }

  export type LaunderTechnicianGetPayload<S extends boolean | null | undefined | LaunderTechnicianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderTechnician :
    S extends undefined ? never :
    S extends { include: any } & (LaunderTechnicianArgs | LaunderTechnicianFindManyArgs)
    ? LaunderTechnician  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'serviceHistories' ? Array < LaunderServiceHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaunderTechnicianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderTechnicianArgs | LaunderTechnicianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'serviceHistories' ? Array < LaunderServiceHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaunderTechnicianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaunderTechnician ? LaunderTechnician[P] : never
  } 
      : LaunderTechnician


  type LaunderTechnicianCountArgs = 
    Omit<LaunderTechnicianFindManyArgs, 'select' | 'include'> & {
      select?: LaunderTechnicianCountAggregateInputType | true
    }

  export interface LaunderTechnicianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderTechnician that matches the filter.
     * @param {LaunderTechnicianFindUniqueArgs} args - Arguments to find a LaunderTechnician
     * @example
     * // Get one LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderTechnicianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderTechnicianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderTechnician'> extends True ? Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>> : Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T> | null, null>

    /**
     * Find one LaunderTechnician that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderTechnicianFindUniqueOrThrowArgs} args - Arguments to find a LaunderTechnician
     * @example
     * // Get one LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderTechnicianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderTechnicianFindUniqueOrThrowArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Find the first LaunderTechnician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianFindFirstArgs} args - Arguments to find a LaunderTechnician
     * @example
     * // Get one LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderTechnicianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderTechnicianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderTechnician'> extends True ? Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>> : Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T> | null, null>

    /**
     * Find the first LaunderTechnician that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianFindFirstOrThrowArgs} args - Arguments to find a LaunderTechnician
     * @example
     * // Get one LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderTechnicianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderTechnicianFindFirstOrThrowArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Find zero or more LaunderTechnicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderTechnicians
     * const launderTechnicians = await prisma.launderTechnician.findMany()
     * 
     * // Get first 10 LaunderTechnicians
     * const launderTechnicians = await prisma.launderTechnician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderTechnicianWithIdOnly = await prisma.launderTechnician.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderTechnicianFindManyArgs>(
      args?: SelectSubset<T, LaunderTechnicianFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderTechnicianGetPayload<T>>>

    /**
     * Create a LaunderTechnician.
     * @param {LaunderTechnicianCreateArgs} args - Arguments to create a LaunderTechnician.
     * @example
     * // Create one LaunderTechnician
     * const LaunderTechnician = await prisma.launderTechnician.create({
     *   data: {
     *     // ... data to create a LaunderTechnician
     *   }
     * })
     * 
    **/
    create<T extends LaunderTechnicianCreateArgs>(
      args: SelectSubset<T, LaunderTechnicianCreateArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Create many LaunderTechnicians.
     *     @param {LaunderTechnicianCreateManyArgs} args - Arguments to create many LaunderTechnicians.
     *     @example
     *     // Create many LaunderTechnicians
     *     const launderTechnician = await prisma.launderTechnician.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderTechnicianCreateManyArgs>(
      args?: SelectSubset<T, LaunderTechnicianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderTechnician.
     * @param {LaunderTechnicianDeleteArgs} args - Arguments to delete one LaunderTechnician.
     * @example
     * // Delete one LaunderTechnician
     * const LaunderTechnician = await prisma.launderTechnician.delete({
     *   where: {
     *     // ... filter to delete one LaunderTechnician
     *   }
     * })
     * 
    **/
    delete<T extends LaunderTechnicianDeleteArgs>(
      args: SelectSubset<T, LaunderTechnicianDeleteArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Update one LaunderTechnician.
     * @param {LaunderTechnicianUpdateArgs} args - Arguments to update one LaunderTechnician.
     * @example
     * // Update one LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderTechnicianUpdateArgs>(
      args: SelectSubset<T, LaunderTechnicianUpdateArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Delete zero or more LaunderTechnicians.
     * @param {LaunderTechnicianDeleteManyArgs} args - Arguments to filter LaunderTechnicians to delete.
     * @example
     * // Delete a few LaunderTechnicians
     * const { count } = await prisma.launderTechnician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderTechnicianDeleteManyArgs>(
      args?: SelectSubset<T, LaunderTechnicianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderTechnicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderTechnicians
     * const launderTechnician = await prisma.launderTechnician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderTechnicianUpdateManyArgs>(
      args: SelectSubset<T, LaunderTechnicianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderTechnician.
     * @param {LaunderTechnicianUpsertArgs} args - Arguments to update or create a LaunderTechnician.
     * @example
     * // Update or create a LaunderTechnician
     * const launderTechnician = await prisma.launderTechnician.upsert({
     *   create: {
     *     // ... data to create a LaunderTechnician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderTechnician we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderTechnicianUpsertArgs>(
      args: SelectSubset<T, LaunderTechnicianUpsertArgs>
    ): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T>>

    /**
     * Count the number of LaunderTechnicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianCountArgs} args - Arguments to filter LaunderTechnicians to count.
     * @example
     * // Count the number of LaunderTechnicians
     * const count = await prisma.launderTechnician.count({
     *   where: {
     *     // ... the filter for the LaunderTechnicians we want to count
     *   }
     * })
    **/
    count<T extends LaunderTechnicianCountArgs>(
      args?: Subset<T, LaunderTechnicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderTechnicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderTechnician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderTechnicianAggregateArgs>(args: Subset<T, LaunderTechnicianAggregateArgs>): Prisma.PrismaPromise<GetLaunderTechnicianAggregateType<T>>

    /**
     * Group by LaunderTechnician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderTechnicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderTechnicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderTechnicianGroupByArgs['orderBy'] }
        : { orderBy?: LaunderTechnicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderTechnicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderTechnicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderTechnician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderTechnicianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    serviceHistories<T extends LaunderTechnician$serviceHistoriesArgs= {}>(args?: Subset<T, LaunderTechnician$serviceHistoriesArgs>): Prisma.PrismaPromise<Array<LaunderServiceHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderTechnician base type for findUnique actions
   */
  export type LaunderTechnicianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter, which LaunderTechnician to fetch.
     */
    where: LaunderTechnicianWhereUniqueInput
  }

  /**
   * LaunderTechnician findUnique
   */
  export interface LaunderTechnicianFindUniqueArgs extends LaunderTechnicianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderTechnician findUniqueOrThrow
   */
  export type LaunderTechnicianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter, which LaunderTechnician to fetch.
     */
    where: LaunderTechnicianWhereUniqueInput
  }


  /**
   * LaunderTechnician base type for findFirst actions
   */
  export type LaunderTechnicianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter, which LaunderTechnician to fetch.
     */
    where?: LaunderTechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderTechnicians to fetch.
     */
    orderBy?: Enumerable<LaunderTechnicianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderTechnicians.
     */
    cursor?: LaunderTechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderTechnicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderTechnicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderTechnicians.
     */
    distinct?: Enumerable<LaunderTechnicianScalarFieldEnum>
  }

  /**
   * LaunderTechnician findFirst
   */
  export interface LaunderTechnicianFindFirstArgs extends LaunderTechnicianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderTechnician findFirstOrThrow
   */
  export type LaunderTechnicianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter, which LaunderTechnician to fetch.
     */
    where?: LaunderTechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderTechnicians to fetch.
     */
    orderBy?: Enumerable<LaunderTechnicianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderTechnicians.
     */
    cursor?: LaunderTechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderTechnicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderTechnicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderTechnicians.
     */
    distinct?: Enumerable<LaunderTechnicianScalarFieldEnum>
  }


  /**
   * LaunderTechnician findMany
   */
  export type LaunderTechnicianFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter, which LaunderTechnicians to fetch.
     */
    where?: LaunderTechnicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderTechnicians to fetch.
     */
    orderBy?: Enumerable<LaunderTechnicianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderTechnicians.
     */
    cursor?: LaunderTechnicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderTechnicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderTechnicians.
     */
    skip?: number
    distinct?: Enumerable<LaunderTechnicianScalarFieldEnum>
  }


  /**
   * LaunderTechnician create
   */
  export type LaunderTechnicianCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * The data needed to create a LaunderTechnician.
     */
    data: XOR<LaunderTechnicianCreateInput, LaunderTechnicianUncheckedCreateInput>
  }


  /**
   * LaunderTechnician createMany
   */
  export type LaunderTechnicianCreateManyArgs = {
    /**
     * The data used to create many LaunderTechnicians.
     */
    data: Enumerable<LaunderTechnicianCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderTechnician update
   */
  export type LaunderTechnicianUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * The data needed to update a LaunderTechnician.
     */
    data: XOR<LaunderTechnicianUpdateInput, LaunderTechnicianUncheckedUpdateInput>
    /**
     * Choose, which LaunderTechnician to update.
     */
    where: LaunderTechnicianWhereUniqueInput
  }


  /**
   * LaunderTechnician updateMany
   */
  export type LaunderTechnicianUpdateManyArgs = {
    /**
     * The data used to update LaunderTechnicians.
     */
    data: XOR<LaunderTechnicianUpdateManyMutationInput, LaunderTechnicianUncheckedUpdateManyInput>
    /**
     * Filter which LaunderTechnicians to update
     */
    where?: LaunderTechnicianWhereInput
  }


  /**
   * LaunderTechnician upsert
   */
  export type LaunderTechnicianUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * The filter to search for the LaunderTechnician to update in case it exists.
     */
    where: LaunderTechnicianWhereUniqueInput
    /**
     * In case the LaunderTechnician found by the `where` argument doesn't exist, create a new LaunderTechnician with this data.
     */
    create: XOR<LaunderTechnicianCreateInput, LaunderTechnicianUncheckedCreateInput>
    /**
     * In case the LaunderTechnician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderTechnicianUpdateInput, LaunderTechnicianUncheckedUpdateInput>
  }


  /**
   * LaunderTechnician delete
   */
  export type LaunderTechnicianDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
    /**
     * Filter which LaunderTechnician to delete.
     */
    where: LaunderTechnicianWhereUniqueInput
  }


  /**
   * LaunderTechnician deleteMany
   */
  export type LaunderTechnicianDeleteManyArgs = {
    /**
     * Filter which LaunderTechnicians to delete
     */
    where?: LaunderTechnicianWhereInput
  }


  /**
   * LaunderTechnician.serviceHistories
   */
  export type LaunderTechnician$serviceHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    where?: LaunderServiceHistoryWhereInput
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    cursor?: LaunderServiceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaunderServiceHistoryScalarFieldEnum>
  }


  /**
   * LaunderTechnician without action
   */
  export type LaunderTechnicianArgs = {
    /**
     * Select specific fields to fetch from the LaunderTechnician
     */
    select?: LaunderTechnicianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderTechnicianInclude | null
  }



  /**
   * Model LaunderServiceHistory
   */


  export type AggregateLaunderServiceHistory = {
    _count: LaunderServiceHistoryCountAggregateOutputType | null
    _avg: LaunderServiceHistoryAvgAggregateOutputType | null
    _sum: LaunderServiceHistorySumAggregateOutputType | null
    _min: LaunderServiceHistoryMinAggregateOutputType | null
    _max: LaunderServiceHistoryMaxAggregateOutputType | null
  }

  export type LaunderServiceHistoryAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
    technicianId: number | null
  }

  export type LaunderServiceHistorySumAggregateOutputType = {
    id: number | null
    machineId: number | null
    technicianId: number | null
  }

  export type LaunderServiceHistoryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    machineId: number | null
    technicianId: number | null
    descriptions: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderServiceHistoryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    machineId: number | null
    technicianId: number | null
    descriptions: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderServiceHistoryCountAggregateOutputType = {
    id: number
    date: number
    machineId: number
    technicianId: number
    descriptions: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderServiceHistoryAvgAggregateInputType = {
    id?: true
    machineId?: true
    technicianId?: true
  }

  export type LaunderServiceHistorySumAggregateInputType = {
    id?: true
    machineId?: true
    technicianId?: true
  }

  export type LaunderServiceHistoryMinAggregateInputType = {
    id?: true
    date?: true
    machineId?: true
    technicianId?: true
    descriptions?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderServiceHistoryMaxAggregateInputType = {
    id?: true
    date?: true
    machineId?: true
    technicianId?: true
    descriptions?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderServiceHistoryCountAggregateInputType = {
    id?: true
    date?: true
    machineId?: true
    technicianId?: true
    descriptions?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderServiceHistoryAggregateArgs = {
    /**
     * Filter which LaunderServiceHistory to aggregate.
     */
    where?: LaunderServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderServiceHistories to fetch.
     */
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderServiceHistories
    **/
    _count?: true | LaunderServiceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderServiceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderServiceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderServiceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderServiceHistoryMaxAggregateInputType
  }

  export type GetLaunderServiceHistoryAggregateType<T extends LaunderServiceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderServiceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderServiceHistory[P]>
      : GetScalarType<T[P], AggregateLaunderServiceHistory[P]>
  }




  export type LaunderServiceHistoryGroupByArgs = {
    where?: LaunderServiceHistoryWhereInput
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithAggregationInput>
    by: LaunderServiceHistoryScalarFieldEnum[]
    having?: LaunderServiceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderServiceHistoryCountAggregateInputType | true
    _avg?: LaunderServiceHistoryAvgAggregateInputType
    _sum?: LaunderServiceHistorySumAggregateInputType
    _min?: LaunderServiceHistoryMinAggregateInputType
    _max?: LaunderServiceHistoryMaxAggregateInputType
  }


  export type LaunderServiceHistoryGroupByOutputType = {
    id: number
    date: Date
    machineId: number
    technicianId: number
    descriptions: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: LaunderServiceHistoryCountAggregateOutputType | null
    _avg: LaunderServiceHistoryAvgAggregateOutputType | null
    _sum: LaunderServiceHistorySumAggregateOutputType | null
    _min: LaunderServiceHistoryMinAggregateOutputType | null
    _max: LaunderServiceHistoryMaxAggregateOutputType | null
  }

  type GetLaunderServiceHistoryGroupByPayload<T extends LaunderServiceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderServiceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderServiceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderServiceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderServiceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LaunderServiceHistorySelect = {
    id?: boolean
    date?: boolean
    machine?: boolean | LaunderMachineArgs
    technician?: boolean | LaunderTechnicianArgs
    machineId?: boolean
    technicianId?: boolean
    descriptions?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LaunderServiceHistoryInclude = {
    machine?: boolean | LaunderMachineArgs
    technician?: boolean | LaunderTechnicianArgs
  }

  export type LaunderServiceHistoryGetPayload<S extends boolean | null | undefined | LaunderServiceHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderServiceHistory :
    S extends undefined ? never :
    S extends { include: any } & (LaunderServiceHistoryArgs | LaunderServiceHistoryFindManyArgs)
    ? LaunderServiceHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? LaunderMachineGetPayload<S['include'][P]> :
        P extends 'technician' ? LaunderTechnicianGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderServiceHistoryArgs | LaunderServiceHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? LaunderMachineGetPayload<S['select'][P]> :
        P extends 'technician' ? LaunderTechnicianGetPayload<S['select'][P]> :  P extends keyof LaunderServiceHistory ? LaunderServiceHistory[P] : never
  } 
      : LaunderServiceHistory


  type LaunderServiceHistoryCountArgs = 
    Omit<LaunderServiceHistoryFindManyArgs, 'select' | 'include'> & {
      select?: LaunderServiceHistoryCountAggregateInputType | true
    }

  export interface LaunderServiceHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderServiceHistory that matches the filter.
     * @param {LaunderServiceHistoryFindUniqueArgs} args - Arguments to find a LaunderServiceHistory
     * @example
     * // Get one LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderServiceHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderServiceHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderServiceHistory'> extends True ? Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>> : Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T> | null, null>

    /**
     * Find one LaunderServiceHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderServiceHistoryFindUniqueOrThrowArgs} args - Arguments to find a LaunderServiceHistory
     * @example
     * // Get one LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderServiceHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderServiceHistoryFindUniqueOrThrowArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Find the first LaunderServiceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryFindFirstArgs} args - Arguments to find a LaunderServiceHistory
     * @example
     * // Get one LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderServiceHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderServiceHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderServiceHistory'> extends True ? Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>> : Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T> | null, null>

    /**
     * Find the first LaunderServiceHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryFindFirstOrThrowArgs} args - Arguments to find a LaunderServiceHistory
     * @example
     * // Get one LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderServiceHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderServiceHistoryFindFirstOrThrowArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Find zero or more LaunderServiceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderServiceHistories
     * const launderServiceHistories = await prisma.launderServiceHistory.findMany()
     * 
     * // Get first 10 LaunderServiceHistories
     * const launderServiceHistories = await prisma.launderServiceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderServiceHistoryWithIdOnly = await prisma.launderServiceHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderServiceHistoryFindManyArgs>(
      args?: SelectSubset<T, LaunderServiceHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderServiceHistoryGetPayload<T>>>

    /**
     * Create a LaunderServiceHistory.
     * @param {LaunderServiceHistoryCreateArgs} args - Arguments to create a LaunderServiceHistory.
     * @example
     * // Create one LaunderServiceHistory
     * const LaunderServiceHistory = await prisma.launderServiceHistory.create({
     *   data: {
     *     // ... data to create a LaunderServiceHistory
     *   }
     * })
     * 
    **/
    create<T extends LaunderServiceHistoryCreateArgs>(
      args: SelectSubset<T, LaunderServiceHistoryCreateArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Create many LaunderServiceHistories.
     *     @param {LaunderServiceHistoryCreateManyArgs} args - Arguments to create many LaunderServiceHistories.
     *     @example
     *     // Create many LaunderServiceHistories
     *     const launderServiceHistory = await prisma.launderServiceHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderServiceHistoryCreateManyArgs>(
      args?: SelectSubset<T, LaunderServiceHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderServiceHistory.
     * @param {LaunderServiceHistoryDeleteArgs} args - Arguments to delete one LaunderServiceHistory.
     * @example
     * // Delete one LaunderServiceHistory
     * const LaunderServiceHistory = await prisma.launderServiceHistory.delete({
     *   where: {
     *     // ... filter to delete one LaunderServiceHistory
     *   }
     * })
     * 
    **/
    delete<T extends LaunderServiceHistoryDeleteArgs>(
      args: SelectSubset<T, LaunderServiceHistoryDeleteArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Update one LaunderServiceHistory.
     * @param {LaunderServiceHistoryUpdateArgs} args - Arguments to update one LaunderServiceHistory.
     * @example
     * // Update one LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderServiceHistoryUpdateArgs>(
      args: SelectSubset<T, LaunderServiceHistoryUpdateArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Delete zero or more LaunderServiceHistories.
     * @param {LaunderServiceHistoryDeleteManyArgs} args - Arguments to filter LaunderServiceHistories to delete.
     * @example
     * // Delete a few LaunderServiceHistories
     * const { count } = await prisma.launderServiceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderServiceHistoryDeleteManyArgs>(
      args?: SelectSubset<T, LaunderServiceHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderServiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderServiceHistories
     * const launderServiceHistory = await prisma.launderServiceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderServiceHistoryUpdateManyArgs>(
      args: SelectSubset<T, LaunderServiceHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderServiceHistory.
     * @param {LaunderServiceHistoryUpsertArgs} args - Arguments to update or create a LaunderServiceHistory.
     * @example
     * // Update or create a LaunderServiceHistory
     * const launderServiceHistory = await prisma.launderServiceHistory.upsert({
     *   create: {
     *     // ... data to create a LaunderServiceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderServiceHistory we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderServiceHistoryUpsertArgs>(
      args: SelectSubset<T, LaunderServiceHistoryUpsertArgs>
    ): Prisma__LaunderServiceHistoryClient<LaunderServiceHistoryGetPayload<T>>

    /**
     * Count the number of LaunderServiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryCountArgs} args - Arguments to filter LaunderServiceHistories to count.
     * @example
     * // Count the number of LaunderServiceHistories
     * const count = await prisma.launderServiceHistory.count({
     *   where: {
     *     // ... the filter for the LaunderServiceHistories we want to count
     *   }
     * })
    **/
    count<T extends LaunderServiceHistoryCountArgs>(
      args?: Subset<T, LaunderServiceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderServiceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderServiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderServiceHistoryAggregateArgs>(args: Subset<T, LaunderServiceHistoryAggregateArgs>): Prisma.PrismaPromise<GetLaunderServiceHistoryAggregateType<T>>

    /**
     * Group by LaunderServiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderServiceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderServiceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderServiceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LaunderServiceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderServiceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderServiceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderServiceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderServiceHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends LaunderMachineArgs= {}>(args?: Subset<T, LaunderMachineArgs>): Prisma__LaunderMachineClient<LaunderMachineGetPayload<T> | Null>;

    technician<T extends LaunderTechnicianArgs= {}>(args?: Subset<T, LaunderTechnicianArgs>): Prisma__LaunderTechnicianClient<LaunderTechnicianGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderServiceHistory base type for findUnique actions
   */
  export type LaunderServiceHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter, which LaunderServiceHistory to fetch.
     */
    where: LaunderServiceHistoryWhereUniqueInput
  }

  /**
   * LaunderServiceHistory findUnique
   */
  export interface LaunderServiceHistoryFindUniqueArgs extends LaunderServiceHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderServiceHistory findUniqueOrThrow
   */
  export type LaunderServiceHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter, which LaunderServiceHistory to fetch.
     */
    where: LaunderServiceHistoryWhereUniqueInput
  }


  /**
   * LaunderServiceHistory base type for findFirst actions
   */
  export type LaunderServiceHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter, which LaunderServiceHistory to fetch.
     */
    where?: LaunderServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderServiceHistories to fetch.
     */
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderServiceHistories.
     */
    cursor?: LaunderServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderServiceHistories.
     */
    distinct?: Enumerable<LaunderServiceHistoryScalarFieldEnum>
  }

  /**
   * LaunderServiceHistory findFirst
   */
  export interface LaunderServiceHistoryFindFirstArgs extends LaunderServiceHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderServiceHistory findFirstOrThrow
   */
  export type LaunderServiceHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter, which LaunderServiceHistory to fetch.
     */
    where?: LaunderServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderServiceHistories to fetch.
     */
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderServiceHistories.
     */
    cursor?: LaunderServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderServiceHistories.
     */
    distinct?: Enumerable<LaunderServiceHistoryScalarFieldEnum>
  }


  /**
   * LaunderServiceHistory findMany
   */
  export type LaunderServiceHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter, which LaunderServiceHistories to fetch.
     */
    where?: LaunderServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderServiceHistories to fetch.
     */
    orderBy?: Enumerable<LaunderServiceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderServiceHistories.
     */
    cursor?: LaunderServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderServiceHistories.
     */
    skip?: number
    distinct?: Enumerable<LaunderServiceHistoryScalarFieldEnum>
  }


  /**
   * LaunderServiceHistory create
   */
  export type LaunderServiceHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * The data needed to create a LaunderServiceHistory.
     */
    data: XOR<LaunderServiceHistoryCreateInput, LaunderServiceHistoryUncheckedCreateInput>
  }


  /**
   * LaunderServiceHistory createMany
   */
  export type LaunderServiceHistoryCreateManyArgs = {
    /**
     * The data used to create many LaunderServiceHistories.
     */
    data: Enumerable<LaunderServiceHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderServiceHistory update
   */
  export type LaunderServiceHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * The data needed to update a LaunderServiceHistory.
     */
    data: XOR<LaunderServiceHistoryUpdateInput, LaunderServiceHistoryUncheckedUpdateInput>
    /**
     * Choose, which LaunderServiceHistory to update.
     */
    where: LaunderServiceHistoryWhereUniqueInput
  }


  /**
   * LaunderServiceHistory updateMany
   */
  export type LaunderServiceHistoryUpdateManyArgs = {
    /**
     * The data used to update LaunderServiceHistories.
     */
    data: XOR<LaunderServiceHistoryUpdateManyMutationInput, LaunderServiceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LaunderServiceHistories to update
     */
    where?: LaunderServiceHistoryWhereInput
  }


  /**
   * LaunderServiceHistory upsert
   */
  export type LaunderServiceHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * The filter to search for the LaunderServiceHistory to update in case it exists.
     */
    where: LaunderServiceHistoryWhereUniqueInput
    /**
     * In case the LaunderServiceHistory found by the `where` argument doesn't exist, create a new LaunderServiceHistory with this data.
     */
    create: XOR<LaunderServiceHistoryCreateInput, LaunderServiceHistoryUncheckedCreateInput>
    /**
     * In case the LaunderServiceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderServiceHistoryUpdateInput, LaunderServiceHistoryUncheckedUpdateInput>
  }


  /**
   * LaunderServiceHistory delete
   */
  export type LaunderServiceHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
    /**
     * Filter which LaunderServiceHistory to delete.
     */
    where: LaunderServiceHistoryWhereUniqueInput
  }


  /**
   * LaunderServiceHistory deleteMany
   */
  export type LaunderServiceHistoryDeleteManyArgs = {
    /**
     * Filter which LaunderServiceHistories to delete
     */
    where?: LaunderServiceHistoryWhereInput
  }


  /**
   * LaunderServiceHistory without action
   */
  export type LaunderServiceHistoryArgs = {
    /**
     * Select specific fields to fetch from the LaunderServiceHistory
     */
    select?: LaunderServiceHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderServiceHistoryInclude | null
  }



  /**
   * Model LaunderWashingProgram
   */


  export type AggregateLaunderWashingProgram = {
    _count: LaunderWashingProgramCountAggregateOutputType | null
    _avg: LaunderWashingProgramAvgAggregateOutputType | null
    _sum: LaunderWashingProgramSumAggregateOutputType | null
    _min: LaunderWashingProgramMinAggregateOutputType | null
    _max: LaunderWashingProgramMaxAggregateOutputType | null
  }

  export type LaunderWashingProgramAvgAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
    capacityLimit: number | null
  }

  export type LaunderWashingProgramSumAggregateOutputType = {
    id: number | null
    price: number | null
    duration: number | null
    capacityLimit: number | null
  }

  export type LaunderWashingProgramMinAggregateOutputType = {
    id: number | null
    program: string | null
    price: number | null
    duration: number | null
    capacityLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderWashingProgramMaxAggregateOutputType = {
    id: number | null
    program: string | null
    price: number | null
    duration: number | null
    capacityLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderWashingProgramCountAggregateOutputType = {
    id: number
    program: number
    price: number
    duration: number
    capacityLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderWashingProgramAvgAggregateInputType = {
    id?: true
    price?: true
    duration?: true
    capacityLimit?: true
  }

  export type LaunderWashingProgramSumAggregateInputType = {
    id?: true
    price?: true
    duration?: true
    capacityLimit?: true
  }

  export type LaunderWashingProgramMinAggregateInputType = {
    id?: true
    program?: true
    price?: true
    duration?: true
    capacityLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderWashingProgramMaxAggregateInputType = {
    id?: true
    program?: true
    price?: true
    duration?: true
    capacityLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderWashingProgramCountAggregateInputType = {
    id?: true
    program?: true
    price?: true
    duration?: true
    capacityLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderWashingProgramAggregateArgs = {
    /**
     * Filter which LaunderWashingProgram to aggregate.
     */
    where?: LaunderWashingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderWashingPrograms to fetch.
     */
    orderBy?: Enumerable<LaunderWashingProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderWashingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderWashingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderWashingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderWashingPrograms
    **/
    _count?: true | LaunderWashingProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderWashingProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderWashingProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderWashingProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderWashingProgramMaxAggregateInputType
  }

  export type GetLaunderWashingProgramAggregateType<T extends LaunderWashingProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderWashingProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderWashingProgram[P]>
      : GetScalarType<T[P], AggregateLaunderWashingProgram[P]>
  }




  export type LaunderWashingProgramGroupByArgs = {
    where?: LaunderWashingProgramWhereInput
    orderBy?: Enumerable<LaunderWashingProgramOrderByWithAggregationInput>
    by: LaunderWashingProgramScalarFieldEnum[]
    having?: LaunderWashingProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderWashingProgramCountAggregateInputType | true
    _avg?: LaunderWashingProgramAvgAggregateInputType
    _sum?: LaunderWashingProgramSumAggregateInputType
    _min?: LaunderWashingProgramMinAggregateInputType
    _max?: LaunderWashingProgramMaxAggregateInputType
  }


  export type LaunderWashingProgramGroupByOutputType = {
    id: number
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderWashingProgramCountAggregateOutputType | null
    _avg: LaunderWashingProgramAvgAggregateOutputType | null
    _sum: LaunderWashingProgramSumAggregateOutputType | null
    _min: LaunderWashingProgramMinAggregateOutputType | null
    _max: LaunderWashingProgramMaxAggregateOutputType | null
  }

  type GetLaunderWashingProgramGroupByPayload<T extends LaunderWashingProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderWashingProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderWashingProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderWashingProgramGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderWashingProgramGroupByOutputType[P]>
        }
      >
    >


  export type LaunderWashingProgramSelect = {
    id?: boolean
    program?: boolean
    price?: boolean
    duration?: boolean
    capacityLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    programInMachines?: boolean | LaunderWashingProgram$programInMachinesArgs
    washingHistories?: boolean | LaunderWashingProgram$washingHistoriesArgs
    _count?: boolean | LaunderWashingProgramCountOutputTypeArgs
  }


  export type LaunderWashingProgramInclude = {
    programInMachines?: boolean | LaunderWashingProgram$programInMachinesArgs
    washingHistories?: boolean | LaunderWashingProgram$washingHistoriesArgs
    _count?: boolean | LaunderWashingProgramCountOutputTypeArgs
  }

  export type LaunderWashingProgramGetPayload<S extends boolean | null | undefined | LaunderWashingProgramArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderWashingProgram :
    S extends undefined ? never :
    S extends { include: any } & (LaunderWashingProgramArgs | LaunderWashingProgramFindManyArgs)
    ? LaunderWashingProgram  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'programInMachines' ? Array < LaunderProgramInMachineGetPayload<S['include'][P]>>  :
        P extends 'washingHistories' ? Array < LaundryWashingHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaunderWashingProgramCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderWashingProgramArgs | LaunderWashingProgramFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'programInMachines' ? Array < LaunderProgramInMachineGetPayload<S['select'][P]>>  :
        P extends 'washingHistories' ? Array < LaundryWashingHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaunderWashingProgramCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaunderWashingProgram ? LaunderWashingProgram[P] : never
  } 
      : LaunderWashingProgram


  type LaunderWashingProgramCountArgs = 
    Omit<LaunderWashingProgramFindManyArgs, 'select' | 'include'> & {
      select?: LaunderWashingProgramCountAggregateInputType | true
    }

  export interface LaunderWashingProgramDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderWashingProgram that matches the filter.
     * @param {LaunderWashingProgramFindUniqueArgs} args - Arguments to find a LaunderWashingProgram
     * @example
     * // Get one LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderWashingProgramFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderWashingProgramFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderWashingProgram'> extends True ? Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>> : Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T> | null, null>

    /**
     * Find one LaunderWashingProgram that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderWashingProgramFindUniqueOrThrowArgs} args - Arguments to find a LaunderWashingProgram
     * @example
     * // Get one LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderWashingProgramFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderWashingProgramFindUniqueOrThrowArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Find the first LaunderWashingProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramFindFirstArgs} args - Arguments to find a LaunderWashingProgram
     * @example
     * // Get one LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderWashingProgramFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderWashingProgramFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderWashingProgram'> extends True ? Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>> : Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T> | null, null>

    /**
     * Find the first LaunderWashingProgram that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramFindFirstOrThrowArgs} args - Arguments to find a LaunderWashingProgram
     * @example
     * // Get one LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderWashingProgramFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderWashingProgramFindFirstOrThrowArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Find zero or more LaunderWashingPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderWashingPrograms
     * const launderWashingPrograms = await prisma.launderWashingProgram.findMany()
     * 
     * // Get first 10 LaunderWashingPrograms
     * const launderWashingPrograms = await prisma.launderWashingProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderWashingProgramWithIdOnly = await prisma.launderWashingProgram.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderWashingProgramFindManyArgs>(
      args?: SelectSubset<T, LaunderWashingProgramFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderWashingProgramGetPayload<T>>>

    /**
     * Create a LaunderWashingProgram.
     * @param {LaunderWashingProgramCreateArgs} args - Arguments to create a LaunderWashingProgram.
     * @example
     * // Create one LaunderWashingProgram
     * const LaunderWashingProgram = await prisma.launderWashingProgram.create({
     *   data: {
     *     // ... data to create a LaunderWashingProgram
     *   }
     * })
     * 
    **/
    create<T extends LaunderWashingProgramCreateArgs>(
      args: SelectSubset<T, LaunderWashingProgramCreateArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Create many LaunderWashingPrograms.
     *     @param {LaunderWashingProgramCreateManyArgs} args - Arguments to create many LaunderWashingPrograms.
     *     @example
     *     // Create many LaunderWashingPrograms
     *     const launderWashingProgram = await prisma.launderWashingProgram.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderWashingProgramCreateManyArgs>(
      args?: SelectSubset<T, LaunderWashingProgramCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderWashingProgram.
     * @param {LaunderWashingProgramDeleteArgs} args - Arguments to delete one LaunderWashingProgram.
     * @example
     * // Delete one LaunderWashingProgram
     * const LaunderWashingProgram = await prisma.launderWashingProgram.delete({
     *   where: {
     *     // ... filter to delete one LaunderWashingProgram
     *   }
     * })
     * 
    **/
    delete<T extends LaunderWashingProgramDeleteArgs>(
      args: SelectSubset<T, LaunderWashingProgramDeleteArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Update one LaunderWashingProgram.
     * @param {LaunderWashingProgramUpdateArgs} args - Arguments to update one LaunderWashingProgram.
     * @example
     * // Update one LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderWashingProgramUpdateArgs>(
      args: SelectSubset<T, LaunderWashingProgramUpdateArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Delete zero or more LaunderWashingPrograms.
     * @param {LaunderWashingProgramDeleteManyArgs} args - Arguments to filter LaunderWashingPrograms to delete.
     * @example
     * // Delete a few LaunderWashingPrograms
     * const { count } = await prisma.launderWashingProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderWashingProgramDeleteManyArgs>(
      args?: SelectSubset<T, LaunderWashingProgramDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderWashingPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderWashingPrograms
     * const launderWashingProgram = await prisma.launderWashingProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderWashingProgramUpdateManyArgs>(
      args: SelectSubset<T, LaunderWashingProgramUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderWashingProgram.
     * @param {LaunderWashingProgramUpsertArgs} args - Arguments to update or create a LaunderWashingProgram.
     * @example
     * // Update or create a LaunderWashingProgram
     * const launderWashingProgram = await prisma.launderWashingProgram.upsert({
     *   create: {
     *     // ... data to create a LaunderWashingProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderWashingProgram we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderWashingProgramUpsertArgs>(
      args: SelectSubset<T, LaunderWashingProgramUpsertArgs>
    ): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T>>

    /**
     * Count the number of LaunderWashingPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramCountArgs} args - Arguments to filter LaunderWashingPrograms to count.
     * @example
     * // Count the number of LaunderWashingPrograms
     * const count = await prisma.launderWashingProgram.count({
     *   where: {
     *     // ... the filter for the LaunderWashingPrograms we want to count
     *   }
     * })
    **/
    count<T extends LaunderWashingProgramCountArgs>(
      args?: Subset<T, LaunderWashingProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderWashingProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderWashingProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderWashingProgramAggregateArgs>(args: Subset<T, LaunderWashingProgramAggregateArgs>): Prisma.PrismaPromise<GetLaunderWashingProgramAggregateType<T>>

    /**
     * Group by LaunderWashingProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderWashingProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderWashingProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderWashingProgramGroupByArgs['orderBy'] }
        : { orderBy?: LaunderWashingProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderWashingProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderWashingProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderWashingProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderWashingProgramClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    programInMachines<T extends LaunderWashingProgram$programInMachinesArgs= {}>(args?: Subset<T, LaunderWashingProgram$programInMachinesArgs>): Prisma.PrismaPromise<Array<LaunderProgramInMachineGetPayload<T>>| Null>;

    washingHistories<T extends LaunderWashingProgram$washingHistoriesArgs= {}>(args?: Subset<T, LaunderWashingProgram$washingHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryWashingHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderWashingProgram base type for findUnique actions
   */
  export type LaunderWashingProgramFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter, which LaunderWashingProgram to fetch.
     */
    where: LaunderWashingProgramWhereUniqueInput
  }

  /**
   * LaunderWashingProgram findUnique
   */
  export interface LaunderWashingProgramFindUniqueArgs extends LaunderWashingProgramFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderWashingProgram findUniqueOrThrow
   */
  export type LaunderWashingProgramFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter, which LaunderWashingProgram to fetch.
     */
    where: LaunderWashingProgramWhereUniqueInput
  }


  /**
   * LaunderWashingProgram base type for findFirst actions
   */
  export type LaunderWashingProgramFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter, which LaunderWashingProgram to fetch.
     */
    where?: LaunderWashingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderWashingPrograms to fetch.
     */
    orderBy?: Enumerable<LaunderWashingProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderWashingPrograms.
     */
    cursor?: LaunderWashingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderWashingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderWashingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderWashingPrograms.
     */
    distinct?: Enumerable<LaunderWashingProgramScalarFieldEnum>
  }

  /**
   * LaunderWashingProgram findFirst
   */
  export interface LaunderWashingProgramFindFirstArgs extends LaunderWashingProgramFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderWashingProgram findFirstOrThrow
   */
  export type LaunderWashingProgramFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter, which LaunderWashingProgram to fetch.
     */
    where?: LaunderWashingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderWashingPrograms to fetch.
     */
    orderBy?: Enumerable<LaunderWashingProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderWashingPrograms.
     */
    cursor?: LaunderWashingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderWashingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderWashingPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderWashingPrograms.
     */
    distinct?: Enumerable<LaunderWashingProgramScalarFieldEnum>
  }


  /**
   * LaunderWashingProgram findMany
   */
  export type LaunderWashingProgramFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter, which LaunderWashingPrograms to fetch.
     */
    where?: LaunderWashingProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderWashingPrograms to fetch.
     */
    orderBy?: Enumerable<LaunderWashingProgramOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderWashingPrograms.
     */
    cursor?: LaunderWashingProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderWashingPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderWashingPrograms.
     */
    skip?: number
    distinct?: Enumerable<LaunderWashingProgramScalarFieldEnum>
  }


  /**
   * LaunderWashingProgram create
   */
  export type LaunderWashingProgramCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * The data needed to create a LaunderWashingProgram.
     */
    data: XOR<LaunderWashingProgramCreateInput, LaunderWashingProgramUncheckedCreateInput>
  }


  /**
   * LaunderWashingProgram createMany
   */
  export type LaunderWashingProgramCreateManyArgs = {
    /**
     * The data used to create many LaunderWashingPrograms.
     */
    data: Enumerable<LaunderWashingProgramCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderWashingProgram update
   */
  export type LaunderWashingProgramUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * The data needed to update a LaunderWashingProgram.
     */
    data: XOR<LaunderWashingProgramUpdateInput, LaunderWashingProgramUncheckedUpdateInput>
    /**
     * Choose, which LaunderWashingProgram to update.
     */
    where: LaunderWashingProgramWhereUniqueInput
  }


  /**
   * LaunderWashingProgram updateMany
   */
  export type LaunderWashingProgramUpdateManyArgs = {
    /**
     * The data used to update LaunderWashingPrograms.
     */
    data: XOR<LaunderWashingProgramUpdateManyMutationInput, LaunderWashingProgramUncheckedUpdateManyInput>
    /**
     * Filter which LaunderWashingPrograms to update
     */
    where?: LaunderWashingProgramWhereInput
  }


  /**
   * LaunderWashingProgram upsert
   */
  export type LaunderWashingProgramUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * The filter to search for the LaunderWashingProgram to update in case it exists.
     */
    where: LaunderWashingProgramWhereUniqueInput
    /**
     * In case the LaunderWashingProgram found by the `where` argument doesn't exist, create a new LaunderWashingProgram with this data.
     */
    create: XOR<LaunderWashingProgramCreateInput, LaunderWashingProgramUncheckedCreateInput>
    /**
     * In case the LaunderWashingProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderWashingProgramUpdateInput, LaunderWashingProgramUncheckedUpdateInput>
  }


  /**
   * LaunderWashingProgram delete
   */
  export type LaunderWashingProgramDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
    /**
     * Filter which LaunderWashingProgram to delete.
     */
    where: LaunderWashingProgramWhereUniqueInput
  }


  /**
   * LaunderWashingProgram deleteMany
   */
  export type LaunderWashingProgramDeleteManyArgs = {
    /**
     * Filter which LaunderWashingPrograms to delete
     */
    where?: LaunderWashingProgramWhereInput
  }


  /**
   * LaunderWashingProgram.programInMachines
   */
  export type LaunderWashingProgram$programInMachinesArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    where?: LaunderProgramInMachineWhereInput
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    cursor?: LaunderProgramInMachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaunderProgramInMachineScalarFieldEnum>
  }


  /**
   * LaunderWashingProgram.washingHistories
   */
  export type LaunderWashingProgram$washingHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    where?: LaundryWashingHistoryWhereInput
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    cursor?: LaundryWashingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryWashingHistoryScalarFieldEnum>
  }


  /**
   * LaunderWashingProgram without action
   */
  export type LaunderWashingProgramArgs = {
    /**
     * Select specific fields to fetch from the LaunderWashingProgram
     */
    select?: LaunderWashingProgramSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderWashingProgramInclude | null
  }



  /**
   * Model LaunderProgramInMachine
   */


  export type AggregateLaunderProgramInMachine = {
    _count: LaunderProgramInMachineCountAggregateOutputType | null
    _avg: LaunderProgramInMachineAvgAggregateOutputType | null
    _sum: LaunderProgramInMachineSumAggregateOutputType | null
    _min: LaunderProgramInMachineMinAggregateOutputType | null
    _max: LaunderProgramInMachineMaxAggregateOutputType | null
  }

  export type LaunderProgramInMachineAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type LaunderProgramInMachineSumAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
  }

  export type LaunderProgramInMachineMinAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderProgramInMachineMaxAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderProgramInMachineCountAggregateOutputType = {
    id: number
    machineId: number
    programId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderProgramInMachineAvgAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type LaunderProgramInMachineSumAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
  }

  export type LaunderProgramInMachineMinAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderProgramInMachineMaxAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderProgramInMachineCountAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderProgramInMachineAggregateArgs = {
    /**
     * Filter which LaunderProgramInMachine to aggregate.
     */
    where?: LaunderProgramInMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderProgramInMachines to fetch.
     */
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderProgramInMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderProgramInMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderProgramInMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderProgramInMachines
    **/
    _count?: true | LaunderProgramInMachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderProgramInMachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderProgramInMachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderProgramInMachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderProgramInMachineMaxAggregateInputType
  }

  export type GetLaunderProgramInMachineAggregateType<T extends LaunderProgramInMachineAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderProgramInMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderProgramInMachine[P]>
      : GetScalarType<T[P], AggregateLaunderProgramInMachine[P]>
  }




  export type LaunderProgramInMachineGroupByArgs = {
    where?: LaunderProgramInMachineWhereInput
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithAggregationInput>
    by: LaunderProgramInMachineScalarFieldEnum[]
    having?: LaunderProgramInMachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderProgramInMachineCountAggregateInputType | true
    _avg?: LaunderProgramInMachineAvgAggregateInputType
    _sum?: LaunderProgramInMachineSumAggregateInputType
    _min?: LaunderProgramInMachineMinAggregateInputType
    _max?: LaunderProgramInMachineMaxAggregateInputType
  }


  export type LaunderProgramInMachineGroupByOutputType = {
    id: number
    machineId: number
    programId: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderProgramInMachineCountAggregateOutputType | null
    _avg: LaunderProgramInMachineAvgAggregateOutputType | null
    _sum: LaunderProgramInMachineSumAggregateOutputType | null
    _min: LaunderProgramInMachineMinAggregateOutputType | null
    _max: LaunderProgramInMachineMaxAggregateOutputType | null
  }

  type GetLaunderProgramInMachineGroupByPayload<T extends LaunderProgramInMachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderProgramInMachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderProgramInMachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderProgramInMachineGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderProgramInMachineGroupByOutputType[P]>
        }
      >
    >


  export type LaunderProgramInMachineSelect = {
    id?: boolean
    machine?: boolean | LaundryMachineInStoreArgs
    program?: boolean | LaunderWashingProgramArgs
    machineId?: boolean
    programId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LaunderProgramInMachineInclude = {
    machine?: boolean | LaundryMachineInStoreArgs
    program?: boolean | LaunderWashingProgramArgs
  }

  export type LaunderProgramInMachineGetPayload<S extends boolean | null | undefined | LaunderProgramInMachineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderProgramInMachine :
    S extends undefined ? never :
    S extends { include: any } & (LaunderProgramInMachineArgs | LaunderProgramInMachineFindManyArgs)
    ? LaunderProgramInMachine  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? LaundryMachineInStoreGetPayload<S['include'][P]> :
        P extends 'program' ? LaunderWashingProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderProgramInMachineArgs | LaunderProgramInMachineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? LaundryMachineInStoreGetPayload<S['select'][P]> :
        P extends 'program' ? LaunderWashingProgramGetPayload<S['select'][P]> :  P extends keyof LaunderProgramInMachine ? LaunderProgramInMachine[P] : never
  } 
      : LaunderProgramInMachine


  type LaunderProgramInMachineCountArgs = 
    Omit<LaunderProgramInMachineFindManyArgs, 'select' | 'include'> & {
      select?: LaunderProgramInMachineCountAggregateInputType | true
    }

  export interface LaunderProgramInMachineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderProgramInMachine that matches the filter.
     * @param {LaunderProgramInMachineFindUniqueArgs} args - Arguments to find a LaunderProgramInMachine
     * @example
     * // Get one LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderProgramInMachineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderProgramInMachineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderProgramInMachine'> extends True ? Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>> : Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T> | null, null>

    /**
     * Find one LaunderProgramInMachine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderProgramInMachineFindUniqueOrThrowArgs} args - Arguments to find a LaunderProgramInMachine
     * @example
     * // Get one LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderProgramInMachineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderProgramInMachineFindUniqueOrThrowArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Find the first LaunderProgramInMachine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineFindFirstArgs} args - Arguments to find a LaunderProgramInMachine
     * @example
     * // Get one LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderProgramInMachineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderProgramInMachineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderProgramInMachine'> extends True ? Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>> : Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T> | null, null>

    /**
     * Find the first LaunderProgramInMachine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineFindFirstOrThrowArgs} args - Arguments to find a LaunderProgramInMachine
     * @example
     * // Get one LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderProgramInMachineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderProgramInMachineFindFirstOrThrowArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Find zero or more LaunderProgramInMachines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderProgramInMachines
     * const launderProgramInMachines = await prisma.launderProgramInMachine.findMany()
     * 
     * // Get first 10 LaunderProgramInMachines
     * const launderProgramInMachines = await prisma.launderProgramInMachine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderProgramInMachineWithIdOnly = await prisma.launderProgramInMachine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderProgramInMachineFindManyArgs>(
      args?: SelectSubset<T, LaunderProgramInMachineFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderProgramInMachineGetPayload<T>>>

    /**
     * Create a LaunderProgramInMachine.
     * @param {LaunderProgramInMachineCreateArgs} args - Arguments to create a LaunderProgramInMachine.
     * @example
     * // Create one LaunderProgramInMachine
     * const LaunderProgramInMachine = await prisma.launderProgramInMachine.create({
     *   data: {
     *     // ... data to create a LaunderProgramInMachine
     *   }
     * })
     * 
    **/
    create<T extends LaunderProgramInMachineCreateArgs>(
      args: SelectSubset<T, LaunderProgramInMachineCreateArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Create many LaunderProgramInMachines.
     *     @param {LaunderProgramInMachineCreateManyArgs} args - Arguments to create many LaunderProgramInMachines.
     *     @example
     *     // Create many LaunderProgramInMachines
     *     const launderProgramInMachine = await prisma.launderProgramInMachine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderProgramInMachineCreateManyArgs>(
      args?: SelectSubset<T, LaunderProgramInMachineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderProgramInMachine.
     * @param {LaunderProgramInMachineDeleteArgs} args - Arguments to delete one LaunderProgramInMachine.
     * @example
     * // Delete one LaunderProgramInMachine
     * const LaunderProgramInMachine = await prisma.launderProgramInMachine.delete({
     *   where: {
     *     // ... filter to delete one LaunderProgramInMachine
     *   }
     * })
     * 
    **/
    delete<T extends LaunderProgramInMachineDeleteArgs>(
      args: SelectSubset<T, LaunderProgramInMachineDeleteArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Update one LaunderProgramInMachine.
     * @param {LaunderProgramInMachineUpdateArgs} args - Arguments to update one LaunderProgramInMachine.
     * @example
     * // Update one LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderProgramInMachineUpdateArgs>(
      args: SelectSubset<T, LaunderProgramInMachineUpdateArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Delete zero or more LaunderProgramInMachines.
     * @param {LaunderProgramInMachineDeleteManyArgs} args - Arguments to filter LaunderProgramInMachines to delete.
     * @example
     * // Delete a few LaunderProgramInMachines
     * const { count } = await prisma.launderProgramInMachine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderProgramInMachineDeleteManyArgs>(
      args?: SelectSubset<T, LaunderProgramInMachineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderProgramInMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderProgramInMachines
     * const launderProgramInMachine = await prisma.launderProgramInMachine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderProgramInMachineUpdateManyArgs>(
      args: SelectSubset<T, LaunderProgramInMachineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderProgramInMachine.
     * @param {LaunderProgramInMachineUpsertArgs} args - Arguments to update or create a LaunderProgramInMachine.
     * @example
     * // Update or create a LaunderProgramInMachine
     * const launderProgramInMachine = await prisma.launderProgramInMachine.upsert({
     *   create: {
     *     // ... data to create a LaunderProgramInMachine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderProgramInMachine we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderProgramInMachineUpsertArgs>(
      args: SelectSubset<T, LaunderProgramInMachineUpsertArgs>
    ): Prisma__LaunderProgramInMachineClient<LaunderProgramInMachineGetPayload<T>>

    /**
     * Count the number of LaunderProgramInMachines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineCountArgs} args - Arguments to filter LaunderProgramInMachines to count.
     * @example
     * // Count the number of LaunderProgramInMachines
     * const count = await prisma.launderProgramInMachine.count({
     *   where: {
     *     // ... the filter for the LaunderProgramInMachines we want to count
     *   }
     * })
    **/
    count<T extends LaunderProgramInMachineCountArgs>(
      args?: Subset<T, LaunderProgramInMachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderProgramInMachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderProgramInMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderProgramInMachineAggregateArgs>(args: Subset<T, LaunderProgramInMachineAggregateArgs>): Prisma.PrismaPromise<GetLaunderProgramInMachineAggregateType<T>>

    /**
     * Group by LaunderProgramInMachine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderProgramInMachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderProgramInMachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderProgramInMachineGroupByArgs['orderBy'] }
        : { orderBy?: LaunderProgramInMachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderProgramInMachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderProgramInMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderProgramInMachine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderProgramInMachineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends LaundryMachineInStoreArgs= {}>(args?: Subset<T, LaundryMachineInStoreArgs>): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T> | Null>;

    program<T extends LaunderWashingProgramArgs= {}>(args?: Subset<T, LaunderWashingProgramArgs>): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderProgramInMachine base type for findUnique actions
   */
  export type LaunderProgramInMachineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter, which LaunderProgramInMachine to fetch.
     */
    where: LaunderProgramInMachineWhereUniqueInput
  }

  /**
   * LaunderProgramInMachine findUnique
   */
  export interface LaunderProgramInMachineFindUniqueArgs extends LaunderProgramInMachineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderProgramInMachine findUniqueOrThrow
   */
  export type LaunderProgramInMachineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter, which LaunderProgramInMachine to fetch.
     */
    where: LaunderProgramInMachineWhereUniqueInput
  }


  /**
   * LaunderProgramInMachine base type for findFirst actions
   */
  export type LaunderProgramInMachineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter, which LaunderProgramInMachine to fetch.
     */
    where?: LaunderProgramInMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderProgramInMachines to fetch.
     */
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderProgramInMachines.
     */
    cursor?: LaunderProgramInMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderProgramInMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderProgramInMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderProgramInMachines.
     */
    distinct?: Enumerable<LaunderProgramInMachineScalarFieldEnum>
  }

  /**
   * LaunderProgramInMachine findFirst
   */
  export interface LaunderProgramInMachineFindFirstArgs extends LaunderProgramInMachineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderProgramInMachine findFirstOrThrow
   */
  export type LaunderProgramInMachineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter, which LaunderProgramInMachine to fetch.
     */
    where?: LaunderProgramInMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderProgramInMachines to fetch.
     */
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderProgramInMachines.
     */
    cursor?: LaunderProgramInMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderProgramInMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderProgramInMachines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderProgramInMachines.
     */
    distinct?: Enumerable<LaunderProgramInMachineScalarFieldEnum>
  }


  /**
   * LaunderProgramInMachine findMany
   */
  export type LaunderProgramInMachineFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter, which LaunderProgramInMachines to fetch.
     */
    where?: LaunderProgramInMachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderProgramInMachines to fetch.
     */
    orderBy?: Enumerable<LaunderProgramInMachineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderProgramInMachines.
     */
    cursor?: LaunderProgramInMachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderProgramInMachines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderProgramInMachines.
     */
    skip?: number
    distinct?: Enumerable<LaunderProgramInMachineScalarFieldEnum>
  }


  /**
   * LaunderProgramInMachine create
   */
  export type LaunderProgramInMachineCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * The data needed to create a LaunderProgramInMachine.
     */
    data: XOR<LaunderProgramInMachineCreateInput, LaunderProgramInMachineUncheckedCreateInput>
  }


  /**
   * LaunderProgramInMachine createMany
   */
  export type LaunderProgramInMachineCreateManyArgs = {
    /**
     * The data used to create many LaunderProgramInMachines.
     */
    data: Enumerable<LaunderProgramInMachineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderProgramInMachine update
   */
  export type LaunderProgramInMachineUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * The data needed to update a LaunderProgramInMachine.
     */
    data: XOR<LaunderProgramInMachineUpdateInput, LaunderProgramInMachineUncheckedUpdateInput>
    /**
     * Choose, which LaunderProgramInMachine to update.
     */
    where: LaunderProgramInMachineWhereUniqueInput
  }


  /**
   * LaunderProgramInMachine updateMany
   */
  export type LaunderProgramInMachineUpdateManyArgs = {
    /**
     * The data used to update LaunderProgramInMachines.
     */
    data: XOR<LaunderProgramInMachineUpdateManyMutationInput, LaunderProgramInMachineUncheckedUpdateManyInput>
    /**
     * Filter which LaunderProgramInMachines to update
     */
    where?: LaunderProgramInMachineWhereInput
  }


  /**
   * LaunderProgramInMachine upsert
   */
  export type LaunderProgramInMachineUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * The filter to search for the LaunderProgramInMachine to update in case it exists.
     */
    where: LaunderProgramInMachineWhereUniqueInput
    /**
     * In case the LaunderProgramInMachine found by the `where` argument doesn't exist, create a new LaunderProgramInMachine with this data.
     */
    create: XOR<LaunderProgramInMachineCreateInput, LaunderProgramInMachineUncheckedCreateInput>
    /**
     * In case the LaunderProgramInMachine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderProgramInMachineUpdateInput, LaunderProgramInMachineUncheckedUpdateInput>
  }


  /**
   * LaunderProgramInMachine delete
   */
  export type LaunderProgramInMachineDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
    /**
     * Filter which LaunderProgramInMachine to delete.
     */
    where: LaunderProgramInMachineWhereUniqueInput
  }


  /**
   * LaunderProgramInMachine deleteMany
   */
  export type LaunderProgramInMachineDeleteManyArgs = {
    /**
     * Filter which LaunderProgramInMachines to delete
     */
    where?: LaunderProgramInMachineWhereInput
  }


  /**
   * LaunderProgramInMachine without action
   */
  export type LaunderProgramInMachineArgs = {
    /**
     * Select specific fields to fetch from the LaunderProgramInMachine
     */
    select?: LaunderProgramInMachineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderProgramInMachineInclude | null
  }



  /**
   * Model LaunderUser
   */


  export type AggregateLaunderUser = {
    _count: LaunderUserCountAggregateOutputType | null
    _avg: LaunderUserAvgAggregateOutputType | null
    _sum: LaunderUserSumAggregateOutputType | null
    _min: LaunderUserMinAggregateOutputType | null
    _max: LaunderUserMaxAggregateOutputType | null
  }

  export type LaunderUserAvgAggregateOutputType = {
    id: number | null
    phone: number | null
    walletBalance: number | null
  }

  export type LaunderUserSumAggregateOutputType = {
    id: number | null
    phone: number | null
    walletBalance: number | null
  }

  export type LaunderUserMinAggregateOutputType = {
    id: number | null
    username: string | null
    phone: number | null
    walletBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderUserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    phone: number | null
    walletBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunderUserCountAggregateOutputType = {
    id: number
    username: number
    phone: number
    walletBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunderUserAvgAggregateInputType = {
    id?: true
    phone?: true
    walletBalance?: true
  }

  export type LaunderUserSumAggregateInputType = {
    id?: true
    phone?: true
    walletBalance?: true
  }

  export type LaunderUserMinAggregateInputType = {
    id?: true
    username?: true
    phone?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderUserMaxAggregateInputType = {
    id?: true
    username?: true
    phone?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunderUserCountAggregateInputType = {
    id?: true
    username?: true
    phone?: true
    walletBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunderUserAggregateArgs = {
    /**
     * Filter which LaunderUser to aggregate.
     */
    where?: LaunderUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderUsers to fetch.
     */
    orderBy?: Enumerable<LaunderUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunderUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunderUsers
    **/
    _count?: true | LaunderUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaunderUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaunderUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunderUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunderUserMaxAggregateInputType
  }

  export type GetLaunderUserAggregateType<T extends LaunderUserAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunderUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunderUser[P]>
      : GetScalarType<T[P], AggregateLaunderUser[P]>
  }




  export type LaunderUserGroupByArgs = {
    where?: LaunderUserWhereInput
    orderBy?: Enumerable<LaunderUserOrderByWithAggregationInput>
    by: LaunderUserScalarFieldEnum[]
    having?: LaunderUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunderUserCountAggregateInputType | true
    _avg?: LaunderUserAvgAggregateInputType
    _sum?: LaunderUserSumAggregateInputType
    _min?: LaunderUserMinAggregateInputType
    _max?: LaunderUserMaxAggregateInputType
  }


  export type LaunderUserGroupByOutputType = {
    id: number
    username: string
    phone: number
    walletBalance: number
    createdAt: Date
    updatedAt: Date
    _count: LaunderUserCountAggregateOutputType | null
    _avg: LaunderUserAvgAggregateOutputType | null
    _sum: LaunderUserSumAggregateOutputType | null
    _min: LaunderUserMinAggregateOutputType | null
    _max: LaunderUserMaxAggregateOutputType | null
  }

  type GetLaunderUserGroupByPayload<T extends LaunderUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaunderUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunderUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunderUserGroupByOutputType[P]>
            : GetScalarType<T[P], LaunderUserGroupByOutputType[P]>
        }
      >
    >


  export type LaunderUserSelect = {
    id?: boolean
    username?: boolean
    phone?: boolean
    walletBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topupHistories?: boolean | LaunderUser$topupHistoriesArgs
    _count?: boolean | LaunderUserCountOutputTypeArgs
  }


  export type LaunderUserInclude = {
    topupHistories?: boolean | LaunderUser$topupHistoriesArgs
    _count?: boolean | LaunderUserCountOutputTypeArgs
  }

  export type LaunderUserGetPayload<S extends boolean | null | undefined | LaunderUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaunderUser :
    S extends undefined ? never :
    S extends { include: any } & (LaunderUserArgs | LaunderUserFindManyArgs)
    ? LaunderUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'topupHistories' ? Array < LaundryTopupHistoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LaunderUserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaunderUserArgs | LaunderUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'topupHistories' ? Array < LaundryTopupHistoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LaunderUserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LaunderUser ? LaunderUser[P] : never
  } 
      : LaunderUser


  type LaunderUserCountArgs = 
    Omit<LaunderUserFindManyArgs, 'select' | 'include'> & {
      select?: LaunderUserCountAggregateInputType | true
    }

  export interface LaunderUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaunderUser that matches the filter.
     * @param {LaunderUserFindUniqueArgs} args - Arguments to find a LaunderUser
     * @example
     * // Get one LaunderUser
     * const launderUser = await prisma.launderUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaunderUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaunderUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaunderUser'> extends True ? Prisma__LaunderUserClient<LaunderUserGetPayload<T>> : Prisma__LaunderUserClient<LaunderUserGetPayload<T> | null, null>

    /**
     * Find one LaunderUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaunderUserFindUniqueOrThrowArgs} args - Arguments to find a LaunderUser
     * @example
     * // Get one LaunderUser
     * const launderUser = await prisma.launderUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaunderUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaunderUserFindUniqueOrThrowArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Find the first LaunderUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserFindFirstArgs} args - Arguments to find a LaunderUser
     * @example
     * // Get one LaunderUser
     * const launderUser = await prisma.launderUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaunderUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaunderUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaunderUser'> extends True ? Prisma__LaunderUserClient<LaunderUserGetPayload<T>> : Prisma__LaunderUserClient<LaunderUserGetPayload<T> | null, null>

    /**
     * Find the first LaunderUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserFindFirstOrThrowArgs} args - Arguments to find a LaunderUser
     * @example
     * // Get one LaunderUser
     * const launderUser = await prisma.launderUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaunderUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaunderUserFindFirstOrThrowArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Find zero or more LaunderUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunderUsers
     * const launderUsers = await prisma.launderUser.findMany()
     * 
     * // Get first 10 LaunderUsers
     * const launderUsers = await prisma.launderUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launderUserWithIdOnly = await prisma.launderUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaunderUserFindManyArgs>(
      args?: SelectSubset<T, LaunderUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaunderUserGetPayload<T>>>

    /**
     * Create a LaunderUser.
     * @param {LaunderUserCreateArgs} args - Arguments to create a LaunderUser.
     * @example
     * // Create one LaunderUser
     * const LaunderUser = await prisma.launderUser.create({
     *   data: {
     *     // ... data to create a LaunderUser
     *   }
     * })
     * 
    **/
    create<T extends LaunderUserCreateArgs>(
      args: SelectSubset<T, LaunderUserCreateArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Create many LaunderUsers.
     *     @param {LaunderUserCreateManyArgs} args - Arguments to create many LaunderUsers.
     *     @example
     *     // Create many LaunderUsers
     *     const launderUser = await prisma.launderUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaunderUserCreateManyArgs>(
      args?: SelectSubset<T, LaunderUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaunderUser.
     * @param {LaunderUserDeleteArgs} args - Arguments to delete one LaunderUser.
     * @example
     * // Delete one LaunderUser
     * const LaunderUser = await prisma.launderUser.delete({
     *   where: {
     *     // ... filter to delete one LaunderUser
     *   }
     * })
     * 
    **/
    delete<T extends LaunderUserDeleteArgs>(
      args: SelectSubset<T, LaunderUserDeleteArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Update one LaunderUser.
     * @param {LaunderUserUpdateArgs} args - Arguments to update one LaunderUser.
     * @example
     * // Update one LaunderUser
     * const launderUser = await prisma.launderUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaunderUserUpdateArgs>(
      args: SelectSubset<T, LaunderUserUpdateArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Delete zero or more LaunderUsers.
     * @param {LaunderUserDeleteManyArgs} args - Arguments to filter LaunderUsers to delete.
     * @example
     * // Delete a few LaunderUsers
     * const { count } = await prisma.launderUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaunderUserDeleteManyArgs>(
      args?: SelectSubset<T, LaunderUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunderUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunderUsers
     * const launderUser = await prisma.launderUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaunderUserUpdateManyArgs>(
      args: SelectSubset<T, LaunderUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunderUser.
     * @param {LaunderUserUpsertArgs} args - Arguments to update or create a LaunderUser.
     * @example
     * // Update or create a LaunderUser
     * const launderUser = await prisma.launderUser.upsert({
     *   create: {
     *     // ... data to create a LaunderUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunderUser we want to update
     *   }
     * })
    **/
    upsert<T extends LaunderUserUpsertArgs>(
      args: SelectSubset<T, LaunderUserUpsertArgs>
    ): Prisma__LaunderUserClient<LaunderUserGetPayload<T>>

    /**
     * Count the number of LaunderUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserCountArgs} args - Arguments to filter LaunderUsers to count.
     * @example
     * // Count the number of LaunderUsers
     * const count = await prisma.launderUser.count({
     *   where: {
     *     // ... the filter for the LaunderUsers we want to count
     *   }
     * })
    **/
    count<T extends LaunderUserCountArgs>(
      args?: Subset<T, LaunderUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunderUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunderUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunderUserAggregateArgs>(args: Subset<T, LaunderUserAggregateArgs>): Prisma.PrismaPromise<GetLaunderUserAggregateType<T>>

    /**
     * Group by LaunderUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunderUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunderUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunderUserGroupByArgs['orderBy'] }
        : { orderBy?: LaunderUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunderUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunderUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunderUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaunderUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    topupHistories<T extends LaunderUser$topupHistoriesArgs= {}>(args?: Subset<T, LaunderUser$topupHistoriesArgs>): Prisma.PrismaPromise<Array<LaundryTopupHistoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaunderUser base type for findUnique actions
   */
  export type LaunderUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter, which LaunderUser to fetch.
     */
    where: LaunderUserWhereUniqueInput
  }

  /**
   * LaunderUser findUnique
   */
  export interface LaunderUserFindUniqueArgs extends LaunderUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderUser findUniqueOrThrow
   */
  export type LaunderUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter, which LaunderUser to fetch.
     */
    where: LaunderUserWhereUniqueInput
  }


  /**
   * LaunderUser base type for findFirst actions
   */
  export type LaunderUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter, which LaunderUser to fetch.
     */
    where?: LaunderUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderUsers to fetch.
     */
    orderBy?: Enumerable<LaunderUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderUsers.
     */
    cursor?: LaunderUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderUsers.
     */
    distinct?: Enumerable<LaunderUserScalarFieldEnum>
  }

  /**
   * LaunderUser findFirst
   */
  export interface LaunderUserFindFirstArgs extends LaunderUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaunderUser findFirstOrThrow
   */
  export type LaunderUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter, which LaunderUser to fetch.
     */
    where?: LaunderUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderUsers to fetch.
     */
    orderBy?: Enumerable<LaunderUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunderUsers.
     */
    cursor?: LaunderUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunderUsers.
     */
    distinct?: Enumerable<LaunderUserScalarFieldEnum>
  }


  /**
   * LaunderUser findMany
   */
  export type LaunderUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter, which LaunderUsers to fetch.
     */
    where?: LaunderUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunderUsers to fetch.
     */
    orderBy?: Enumerable<LaunderUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunderUsers.
     */
    cursor?: LaunderUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunderUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunderUsers.
     */
    skip?: number
    distinct?: Enumerable<LaunderUserScalarFieldEnum>
  }


  /**
   * LaunderUser create
   */
  export type LaunderUserCreateArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * The data needed to create a LaunderUser.
     */
    data: XOR<LaunderUserCreateInput, LaunderUserUncheckedCreateInput>
  }


  /**
   * LaunderUser createMany
   */
  export type LaunderUserCreateManyArgs = {
    /**
     * The data used to create many LaunderUsers.
     */
    data: Enumerable<LaunderUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaunderUser update
   */
  export type LaunderUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * The data needed to update a LaunderUser.
     */
    data: XOR<LaunderUserUpdateInput, LaunderUserUncheckedUpdateInput>
    /**
     * Choose, which LaunderUser to update.
     */
    where: LaunderUserWhereUniqueInput
  }


  /**
   * LaunderUser updateMany
   */
  export type LaunderUserUpdateManyArgs = {
    /**
     * The data used to update LaunderUsers.
     */
    data: XOR<LaunderUserUpdateManyMutationInput, LaunderUserUncheckedUpdateManyInput>
    /**
     * Filter which LaunderUsers to update
     */
    where?: LaunderUserWhereInput
  }


  /**
   * LaunderUser upsert
   */
  export type LaunderUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * The filter to search for the LaunderUser to update in case it exists.
     */
    where: LaunderUserWhereUniqueInput
    /**
     * In case the LaunderUser found by the `where` argument doesn't exist, create a new LaunderUser with this data.
     */
    create: XOR<LaunderUserCreateInput, LaunderUserUncheckedCreateInput>
    /**
     * In case the LaunderUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunderUserUpdateInput, LaunderUserUncheckedUpdateInput>
  }


  /**
   * LaunderUser delete
   */
  export type LaunderUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
    /**
     * Filter which LaunderUser to delete.
     */
    where: LaunderUserWhereUniqueInput
  }


  /**
   * LaunderUser deleteMany
   */
  export type LaunderUserDeleteManyArgs = {
    /**
     * Filter which LaunderUsers to delete
     */
    where?: LaunderUserWhereInput
  }


  /**
   * LaunderUser.topupHistories
   */
  export type LaunderUser$topupHistoriesArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    where?: LaundryTopupHistoryWhereInput
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithRelationInput>
    cursor?: LaundryTopupHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LaundryTopupHistoryScalarFieldEnum>
  }


  /**
   * LaunderUser without action
   */
  export type LaunderUserArgs = {
    /**
     * Select specific fields to fetch from the LaunderUser
     */
    select?: LaunderUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaunderUserInclude | null
  }



  /**
   * Model LaundryTopupHistory
   */


  export type AggregateLaundryTopupHistory = {
    _count: LaundryTopupHistoryCountAggregateOutputType | null
    _avg: LaundryTopupHistoryAvgAggregateOutputType | null
    _sum: LaundryTopupHistorySumAggregateOutputType | null
    _min: LaundryTopupHistoryMinAggregateOutputType | null
    _max: LaundryTopupHistoryMaxAggregateOutputType | null
  }

  export type LaundryTopupHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    value: number | null
  }

  export type LaundryTopupHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    value: number | null
  }

  export type LaundryTopupHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryTopupHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryTopupHistoryCountAggregateOutputType = {
    id: number
    userId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryTopupHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    value?: true
  }

  export type LaundryTopupHistorySumAggregateInputType = {
    id?: true
    userId?: true
    value?: true
  }

  export type LaundryTopupHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryTopupHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryTopupHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryTopupHistoryAggregateArgs = {
    /**
     * Filter which LaundryTopupHistory to aggregate.
     */
    where?: LaundryTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryTopupHistories to fetch.
     */
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryTopupHistories
    **/
    _count?: true | LaundryTopupHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryTopupHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryTopupHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryTopupHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryTopupHistoryMaxAggregateInputType
  }

  export type GetLaundryTopupHistoryAggregateType<T extends LaundryTopupHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryTopupHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryTopupHistory[P]>
      : GetScalarType<T[P], AggregateLaundryTopupHistory[P]>
  }




  export type LaundryTopupHistoryGroupByArgs = {
    where?: LaundryTopupHistoryWhereInput
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithAggregationInput>
    by: LaundryTopupHistoryScalarFieldEnum[]
    having?: LaundryTopupHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryTopupHistoryCountAggregateInputType | true
    _avg?: LaundryTopupHistoryAvgAggregateInputType
    _sum?: LaundryTopupHistorySumAggregateInputType
    _min?: LaundryTopupHistoryMinAggregateInputType
    _max?: LaundryTopupHistoryMaxAggregateInputType
  }


  export type LaundryTopupHistoryGroupByOutputType = {
    id: number
    userId: number
    value: number
    createdAt: Date
    updatedAt: Date
    _count: LaundryTopupHistoryCountAggregateOutputType | null
    _avg: LaundryTopupHistoryAvgAggregateOutputType | null
    _sum: LaundryTopupHistorySumAggregateOutputType | null
    _min: LaundryTopupHistoryMinAggregateOutputType | null
    _max: LaundryTopupHistoryMaxAggregateOutputType | null
  }

  type GetLaundryTopupHistoryGroupByPayload<T extends LaundryTopupHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryTopupHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryTopupHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryTopupHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryTopupHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LaundryTopupHistorySelect = {
    id?: boolean
    user?: boolean | LaunderUserArgs
    userId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LaundryTopupHistoryInclude = {
    user?: boolean | LaunderUserArgs
  }

  export type LaundryTopupHistoryGetPayload<S extends boolean | null | undefined | LaundryTopupHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryTopupHistory :
    S extends undefined ? never :
    S extends { include: any } & (LaundryTopupHistoryArgs | LaundryTopupHistoryFindManyArgs)
    ? LaundryTopupHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? LaunderUserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryTopupHistoryArgs | LaundryTopupHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? LaunderUserGetPayload<S['select'][P]> :  P extends keyof LaundryTopupHistory ? LaundryTopupHistory[P] : never
  } 
      : LaundryTopupHistory


  type LaundryTopupHistoryCountArgs = 
    Omit<LaundryTopupHistoryFindManyArgs, 'select' | 'include'> & {
      select?: LaundryTopupHistoryCountAggregateInputType | true
    }

  export interface LaundryTopupHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryTopupHistory that matches the filter.
     * @param {LaundryTopupHistoryFindUniqueArgs} args - Arguments to find a LaundryTopupHistory
     * @example
     * // Get one LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryTopupHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryTopupHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryTopupHistory'> extends True ? Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>> : Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T> | null, null>

    /**
     * Find one LaundryTopupHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryTopupHistoryFindUniqueOrThrowArgs} args - Arguments to find a LaundryTopupHistory
     * @example
     * // Get one LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryTopupHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryTopupHistoryFindUniqueOrThrowArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Find the first LaundryTopupHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryFindFirstArgs} args - Arguments to find a LaundryTopupHistory
     * @example
     * // Get one LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryTopupHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryTopupHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryTopupHistory'> extends True ? Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>> : Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T> | null, null>

    /**
     * Find the first LaundryTopupHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryFindFirstOrThrowArgs} args - Arguments to find a LaundryTopupHistory
     * @example
     * // Get one LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryTopupHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryTopupHistoryFindFirstOrThrowArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Find zero or more LaundryTopupHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryTopupHistories
     * const laundryTopupHistories = await prisma.laundryTopupHistory.findMany()
     * 
     * // Get first 10 LaundryTopupHistories
     * const laundryTopupHistories = await prisma.laundryTopupHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryTopupHistoryWithIdOnly = await prisma.laundryTopupHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryTopupHistoryFindManyArgs>(
      args?: SelectSubset<T, LaundryTopupHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryTopupHistoryGetPayload<T>>>

    /**
     * Create a LaundryTopupHistory.
     * @param {LaundryTopupHistoryCreateArgs} args - Arguments to create a LaundryTopupHistory.
     * @example
     * // Create one LaundryTopupHistory
     * const LaundryTopupHistory = await prisma.laundryTopupHistory.create({
     *   data: {
     *     // ... data to create a LaundryTopupHistory
     *   }
     * })
     * 
    **/
    create<T extends LaundryTopupHistoryCreateArgs>(
      args: SelectSubset<T, LaundryTopupHistoryCreateArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Create many LaundryTopupHistories.
     *     @param {LaundryTopupHistoryCreateManyArgs} args - Arguments to create many LaundryTopupHistories.
     *     @example
     *     // Create many LaundryTopupHistories
     *     const laundryTopupHistory = await prisma.laundryTopupHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryTopupHistoryCreateManyArgs>(
      args?: SelectSubset<T, LaundryTopupHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryTopupHistory.
     * @param {LaundryTopupHistoryDeleteArgs} args - Arguments to delete one LaundryTopupHistory.
     * @example
     * // Delete one LaundryTopupHistory
     * const LaundryTopupHistory = await prisma.laundryTopupHistory.delete({
     *   where: {
     *     // ... filter to delete one LaundryTopupHistory
     *   }
     * })
     * 
    **/
    delete<T extends LaundryTopupHistoryDeleteArgs>(
      args: SelectSubset<T, LaundryTopupHistoryDeleteArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Update one LaundryTopupHistory.
     * @param {LaundryTopupHistoryUpdateArgs} args - Arguments to update one LaundryTopupHistory.
     * @example
     * // Update one LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryTopupHistoryUpdateArgs>(
      args: SelectSubset<T, LaundryTopupHistoryUpdateArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Delete zero or more LaundryTopupHistories.
     * @param {LaundryTopupHistoryDeleteManyArgs} args - Arguments to filter LaundryTopupHistories to delete.
     * @example
     * // Delete a few LaundryTopupHistories
     * const { count } = await prisma.laundryTopupHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryTopupHistoryDeleteManyArgs>(
      args?: SelectSubset<T, LaundryTopupHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryTopupHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryTopupHistories
     * const laundryTopupHistory = await prisma.laundryTopupHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryTopupHistoryUpdateManyArgs>(
      args: SelectSubset<T, LaundryTopupHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryTopupHistory.
     * @param {LaundryTopupHistoryUpsertArgs} args - Arguments to update or create a LaundryTopupHistory.
     * @example
     * // Update or create a LaundryTopupHistory
     * const laundryTopupHistory = await prisma.laundryTopupHistory.upsert({
     *   create: {
     *     // ... data to create a LaundryTopupHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryTopupHistory we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryTopupHistoryUpsertArgs>(
      args: SelectSubset<T, LaundryTopupHistoryUpsertArgs>
    ): Prisma__LaundryTopupHistoryClient<LaundryTopupHistoryGetPayload<T>>

    /**
     * Count the number of LaundryTopupHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryCountArgs} args - Arguments to filter LaundryTopupHistories to count.
     * @example
     * // Count the number of LaundryTopupHistories
     * const count = await prisma.laundryTopupHistory.count({
     *   where: {
     *     // ... the filter for the LaundryTopupHistories we want to count
     *   }
     * })
    **/
    count<T extends LaundryTopupHistoryCountArgs>(
      args?: Subset<T, LaundryTopupHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryTopupHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryTopupHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryTopupHistoryAggregateArgs>(args: Subset<T, LaundryTopupHistoryAggregateArgs>): Prisma.PrismaPromise<GetLaundryTopupHistoryAggregateType<T>>

    /**
     * Group by LaundryTopupHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryTopupHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryTopupHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryTopupHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LaundryTopupHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryTopupHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryTopupHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryTopupHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryTopupHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends LaunderUserArgs= {}>(args?: Subset<T, LaunderUserArgs>): Prisma__LaunderUserClient<LaunderUserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryTopupHistory base type for findUnique actions
   */
  export type LaundryTopupHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter, which LaundryTopupHistory to fetch.
     */
    where: LaundryTopupHistoryWhereUniqueInput
  }

  /**
   * LaundryTopupHistory findUnique
   */
  export interface LaundryTopupHistoryFindUniqueArgs extends LaundryTopupHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryTopupHistory findUniqueOrThrow
   */
  export type LaundryTopupHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter, which LaundryTopupHistory to fetch.
     */
    where: LaundryTopupHistoryWhereUniqueInput
  }


  /**
   * LaundryTopupHistory base type for findFirst actions
   */
  export type LaundryTopupHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter, which LaundryTopupHistory to fetch.
     */
    where?: LaundryTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryTopupHistories to fetch.
     */
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryTopupHistories.
     */
    cursor?: LaundryTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryTopupHistories.
     */
    distinct?: Enumerable<LaundryTopupHistoryScalarFieldEnum>
  }

  /**
   * LaundryTopupHistory findFirst
   */
  export interface LaundryTopupHistoryFindFirstArgs extends LaundryTopupHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryTopupHistory findFirstOrThrow
   */
  export type LaundryTopupHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter, which LaundryTopupHistory to fetch.
     */
    where?: LaundryTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryTopupHistories to fetch.
     */
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryTopupHistories.
     */
    cursor?: LaundryTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryTopupHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryTopupHistories.
     */
    distinct?: Enumerable<LaundryTopupHistoryScalarFieldEnum>
  }


  /**
   * LaundryTopupHistory findMany
   */
  export type LaundryTopupHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter, which LaundryTopupHistories to fetch.
     */
    where?: LaundryTopupHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryTopupHistories to fetch.
     */
    orderBy?: Enumerable<LaundryTopupHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryTopupHistories.
     */
    cursor?: LaundryTopupHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryTopupHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryTopupHistories.
     */
    skip?: number
    distinct?: Enumerable<LaundryTopupHistoryScalarFieldEnum>
  }


  /**
   * LaundryTopupHistory create
   */
  export type LaundryTopupHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * The data needed to create a LaundryTopupHistory.
     */
    data: XOR<LaundryTopupHistoryCreateInput, LaundryTopupHistoryUncheckedCreateInput>
  }


  /**
   * LaundryTopupHistory createMany
   */
  export type LaundryTopupHistoryCreateManyArgs = {
    /**
     * The data used to create many LaundryTopupHistories.
     */
    data: Enumerable<LaundryTopupHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryTopupHistory update
   */
  export type LaundryTopupHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * The data needed to update a LaundryTopupHistory.
     */
    data: XOR<LaundryTopupHistoryUpdateInput, LaundryTopupHistoryUncheckedUpdateInput>
    /**
     * Choose, which LaundryTopupHistory to update.
     */
    where: LaundryTopupHistoryWhereUniqueInput
  }


  /**
   * LaundryTopupHistory updateMany
   */
  export type LaundryTopupHistoryUpdateManyArgs = {
    /**
     * The data used to update LaundryTopupHistories.
     */
    data: XOR<LaundryTopupHistoryUpdateManyMutationInput, LaundryTopupHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LaundryTopupHistories to update
     */
    where?: LaundryTopupHistoryWhereInput
  }


  /**
   * LaundryTopupHistory upsert
   */
  export type LaundryTopupHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * The filter to search for the LaundryTopupHistory to update in case it exists.
     */
    where: LaundryTopupHistoryWhereUniqueInput
    /**
     * In case the LaundryTopupHistory found by the `where` argument doesn't exist, create a new LaundryTopupHistory with this data.
     */
    create: XOR<LaundryTopupHistoryCreateInput, LaundryTopupHistoryUncheckedCreateInput>
    /**
     * In case the LaundryTopupHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryTopupHistoryUpdateInput, LaundryTopupHistoryUncheckedUpdateInput>
  }


  /**
   * LaundryTopupHistory delete
   */
  export type LaundryTopupHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
    /**
     * Filter which LaundryTopupHistory to delete.
     */
    where: LaundryTopupHistoryWhereUniqueInput
  }


  /**
   * LaundryTopupHistory deleteMany
   */
  export type LaundryTopupHistoryDeleteManyArgs = {
    /**
     * Filter which LaundryTopupHistories to delete
     */
    where?: LaundryTopupHistoryWhereInput
  }


  /**
   * LaundryTopupHistory without action
   */
  export type LaundryTopupHistoryArgs = {
    /**
     * Select specific fields to fetch from the LaundryTopupHistory
     */
    select?: LaundryTopupHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryTopupHistoryInclude | null
  }



  /**
   * Model LaundryWashingHistory
   */


  export type AggregateLaundryWashingHistory = {
    _count: LaundryWashingHistoryCountAggregateOutputType | null
    _avg: LaundryWashingHistoryAvgAggregateOutputType | null
    _sum: LaundryWashingHistorySumAggregateOutputType | null
    _min: LaundryWashingHistoryMinAggregateOutputType | null
    _max: LaundryWashingHistoryMaxAggregateOutputType | null
  }

  export type LaundryWashingHistoryAvgAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    price: number | null
  }

  export type LaundryWashingHistorySumAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    price: number | null
  }

  export type LaundryWashingHistoryMinAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    date: Date | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryWashingHistoryMaxAggregateOutputType = {
    id: number | null
    machineId: number | null
    programId: number | null
    date: Date | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaundryWashingHistoryCountAggregateOutputType = {
    id: number
    machineId: number
    programId: number
    date: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaundryWashingHistoryAvgAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    price?: true
  }

  export type LaundryWashingHistorySumAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    price?: true
  }

  export type LaundryWashingHistoryMinAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    date?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryWashingHistoryMaxAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    date?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaundryWashingHistoryCountAggregateInputType = {
    id?: true
    machineId?: true
    programId?: true
    date?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaundryWashingHistoryAggregateArgs = {
    /**
     * Filter which LaundryWashingHistory to aggregate.
     */
    where?: LaundryWashingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingHistories to fetch.
     */
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaundryWashingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaundryWashingHistories
    **/
    _count?: true | LaundryWashingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaundryWashingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaundryWashingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaundryWashingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaundryWashingHistoryMaxAggregateInputType
  }

  export type GetLaundryWashingHistoryAggregateType<T extends LaundryWashingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLaundryWashingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaundryWashingHistory[P]>
      : GetScalarType<T[P], AggregateLaundryWashingHistory[P]>
  }




  export type LaundryWashingHistoryGroupByArgs = {
    where?: LaundryWashingHistoryWhereInput
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithAggregationInput>
    by: LaundryWashingHistoryScalarFieldEnum[]
    having?: LaundryWashingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaundryWashingHistoryCountAggregateInputType | true
    _avg?: LaundryWashingHistoryAvgAggregateInputType
    _sum?: LaundryWashingHistorySumAggregateInputType
    _min?: LaundryWashingHistoryMinAggregateInputType
    _max?: LaundryWashingHistoryMaxAggregateInputType
  }


  export type LaundryWashingHistoryGroupByOutputType = {
    id: number
    machineId: number
    programId: number
    date: Date
    price: number
    createdAt: Date
    updatedAt: Date
    _count: LaundryWashingHistoryCountAggregateOutputType | null
    _avg: LaundryWashingHistoryAvgAggregateOutputType | null
    _sum: LaundryWashingHistorySumAggregateOutputType | null
    _min: LaundryWashingHistoryMinAggregateOutputType | null
    _max: LaundryWashingHistoryMaxAggregateOutputType | null
  }

  type GetLaundryWashingHistoryGroupByPayload<T extends LaundryWashingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LaundryWashingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaundryWashingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaundryWashingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LaundryWashingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LaundryWashingHistorySelect = {
    id?: boolean
    machine?: boolean | LaundryMachineInStoreArgs
    program?: boolean | LaunderWashingProgramArgs
    machineId?: boolean
    programId?: boolean
    date?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LaundryWashingHistoryInclude = {
    machine?: boolean | LaundryMachineInStoreArgs
    program?: boolean | LaunderWashingProgramArgs
  }

  export type LaundryWashingHistoryGetPayload<S extends boolean | null | undefined | LaundryWashingHistoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LaundryWashingHistory :
    S extends undefined ? never :
    S extends { include: any } & (LaundryWashingHistoryArgs | LaundryWashingHistoryFindManyArgs)
    ? LaundryWashingHistory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'machine' ? LaundryMachineInStoreGetPayload<S['include'][P]> :
        P extends 'program' ? LaunderWashingProgramGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LaundryWashingHistoryArgs | LaundryWashingHistoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'machine' ? LaundryMachineInStoreGetPayload<S['select'][P]> :
        P extends 'program' ? LaunderWashingProgramGetPayload<S['select'][P]> :  P extends keyof LaundryWashingHistory ? LaundryWashingHistory[P] : never
  } 
      : LaundryWashingHistory


  type LaundryWashingHistoryCountArgs = 
    Omit<LaundryWashingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: LaundryWashingHistoryCountAggregateInputType | true
    }

  export interface LaundryWashingHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LaundryWashingHistory that matches the filter.
     * @param {LaundryWashingHistoryFindUniqueArgs} args - Arguments to find a LaundryWashingHistory
     * @example
     * // Get one LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaundryWashingHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LaundryWashingHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LaundryWashingHistory'> extends True ? Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>> : Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T> | null, null>

    /**
     * Find one LaundryWashingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaundryWashingHistoryFindUniqueOrThrowArgs} args - Arguments to find a LaundryWashingHistory
     * @example
     * // Get one LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaundryWashingHistoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingHistoryFindUniqueOrThrowArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Find the first LaundryWashingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryFindFirstArgs} args - Arguments to find a LaundryWashingHistory
     * @example
     * // Get one LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaundryWashingHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LaundryWashingHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LaundryWashingHistory'> extends True ? Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>> : Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T> | null, null>

    /**
     * Find the first LaundryWashingHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryFindFirstOrThrowArgs} args - Arguments to find a LaundryWashingHistory
     * @example
     * // Get one LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaundryWashingHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LaundryWashingHistoryFindFirstOrThrowArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Find zero or more LaundryWashingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaundryWashingHistories
     * const laundryWashingHistories = await prisma.laundryWashingHistory.findMany()
     * 
     * // Get first 10 LaundryWashingHistories
     * const laundryWashingHistories = await prisma.laundryWashingHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laundryWashingHistoryWithIdOnly = await prisma.laundryWashingHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaundryWashingHistoryFindManyArgs>(
      args?: SelectSubset<T, LaundryWashingHistoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LaundryWashingHistoryGetPayload<T>>>

    /**
     * Create a LaundryWashingHistory.
     * @param {LaundryWashingHistoryCreateArgs} args - Arguments to create a LaundryWashingHistory.
     * @example
     * // Create one LaundryWashingHistory
     * const LaundryWashingHistory = await prisma.laundryWashingHistory.create({
     *   data: {
     *     // ... data to create a LaundryWashingHistory
     *   }
     * })
     * 
    **/
    create<T extends LaundryWashingHistoryCreateArgs>(
      args: SelectSubset<T, LaundryWashingHistoryCreateArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Create many LaundryWashingHistories.
     *     @param {LaundryWashingHistoryCreateManyArgs} args - Arguments to create many LaundryWashingHistories.
     *     @example
     *     // Create many LaundryWashingHistories
     *     const laundryWashingHistory = await prisma.laundryWashingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaundryWashingHistoryCreateManyArgs>(
      args?: SelectSubset<T, LaundryWashingHistoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaundryWashingHistory.
     * @param {LaundryWashingHistoryDeleteArgs} args - Arguments to delete one LaundryWashingHistory.
     * @example
     * // Delete one LaundryWashingHistory
     * const LaundryWashingHistory = await prisma.laundryWashingHistory.delete({
     *   where: {
     *     // ... filter to delete one LaundryWashingHistory
     *   }
     * })
     * 
    **/
    delete<T extends LaundryWashingHistoryDeleteArgs>(
      args: SelectSubset<T, LaundryWashingHistoryDeleteArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Update one LaundryWashingHistory.
     * @param {LaundryWashingHistoryUpdateArgs} args - Arguments to update one LaundryWashingHistory.
     * @example
     * // Update one LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaundryWashingHistoryUpdateArgs>(
      args: SelectSubset<T, LaundryWashingHistoryUpdateArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Delete zero or more LaundryWashingHistories.
     * @param {LaundryWashingHistoryDeleteManyArgs} args - Arguments to filter LaundryWashingHistories to delete.
     * @example
     * // Delete a few LaundryWashingHistories
     * const { count } = await prisma.laundryWashingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaundryWashingHistoryDeleteManyArgs>(
      args?: SelectSubset<T, LaundryWashingHistoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaundryWashingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaundryWashingHistories
     * const laundryWashingHistory = await prisma.laundryWashingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaundryWashingHistoryUpdateManyArgs>(
      args: SelectSubset<T, LaundryWashingHistoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaundryWashingHistory.
     * @param {LaundryWashingHistoryUpsertArgs} args - Arguments to update or create a LaundryWashingHistory.
     * @example
     * // Update or create a LaundryWashingHistory
     * const laundryWashingHistory = await prisma.laundryWashingHistory.upsert({
     *   create: {
     *     // ... data to create a LaundryWashingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaundryWashingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends LaundryWashingHistoryUpsertArgs>(
      args: SelectSubset<T, LaundryWashingHistoryUpsertArgs>
    ): Prisma__LaundryWashingHistoryClient<LaundryWashingHistoryGetPayload<T>>

    /**
     * Count the number of LaundryWashingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryCountArgs} args - Arguments to filter LaundryWashingHistories to count.
     * @example
     * // Count the number of LaundryWashingHistories
     * const count = await prisma.laundryWashingHistory.count({
     *   where: {
     *     // ... the filter for the LaundryWashingHistories we want to count
     *   }
     * })
    **/
    count<T extends LaundryWashingHistoryCountArgs>(
      args?: Subset<T, LaundryWashingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaundryWashingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaundryWashingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaundryWashingHistoryAggregateArgs>(args: Subset<T, LaundryWashingHistoryAggregateArgs>): Prisma.PrismaPromise<GetLaundryWashingHistoryAggregateType<T>>

    /**
     * Group by LaundryWashingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaundryWashingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaundryWashingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaundryWashingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LaundryWashingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaundryWashingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaundryWashingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LaundryWashingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaundryWashingHistoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    machine<T extends LaundryMachineInStoreArgs= {}>(args?: Subset<T, LaundryMachineInStoreArgs>): Prisma__LaundryMachineInStoreClient<LaundryMachineInStoreGetPayload<T> | Null>;

    program<T extends LaunderWashingProgramArgs= {}>(args?: Subset<T, LaunderWashingProgramArgs>): Prisma__LaunderWashingProgramClient<LaunderWashingProgramGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LaundryWashingHistory base type for findUnique actions
   */
  export type LaundryWashingHistoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter, which LaundryWashingHistory to fetch.
     */
    where: LaundryWashingHistoryWhereUniqueInput
  }

  /**
   * LaundryWashingHistory findUnique
   */
  export interface LaundryWashingHistoryFindUniqueArgs extends LaundryWashingHistoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingHistory findUniqueOrThrow
   */
  export type LaundryWashingHistoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter, which LaundryWashingHistory to fetch.
     */
    where: LaundryWashingHistoryWhereUniqueInput
  }


  /**
   * LaundryWashingHistory base type for findFirst actions
   */
  export type LaundryWashingHistoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter, which LaundryWashingHistory to fetch.
     */
    where?: LaundryWashingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingHistories to fetch.
     */
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingHistories.
     */
    cursor?: LaundryWashingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingHistories.
     */
    distinct?: Enumerable<LaundryWashingHistoryScalarFieldEnum>
  }

  /**
   * LaundryWashingHistory findFirst
   */
  export interface LaundryWashingHistoryFindFirstArgs extends LaundryWashingHistoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LaundryWashingHistory findFirstOrThrow
   */
  export type LaundryWashingHistoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter, which LaundryWashingHistory to fetch.
     */
    where?: LaundryWashingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingHistories to fetch.
     */
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaundryWashingHistories.
     */
    cursor?: LaundryWashingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaundryWashingHistories.
     */
    distinct?: Enumerable<LaundryWashingHistoryScalarFieldEnum>
  }


  /**
   * LaundryWashingHistory findMany
   */
  export type LaundryWashingHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter, which LaundryWashingHistories to fetch.
     */
    where?: LaundryWashingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaundryWashingHistories to fetch.
     */
    orderBy?: Enumerable<LaundryWashingHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaundryWashingHistories.
     */
    cursor?: LaundryWashingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaundryWashingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaundryWashingHistories.
     */
    skip?: number
    distinct?: Enumerable<LaundryWashingHistoryScalarFieldEnum>
  }


  /**
   * LaundryWashingHistory create
   */
  export type LaundryWashingHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * The data needed to create a LaundryWashingHistory.
     */
    data: XOR<LaundryWashingHistoryCreateInput, LaundryWashingHistoryUncheckedCreateInput>
  }


  /**
   * LaundryWashingHistory createMany
   */
  export type LaundryWashingHistoryCreateManyArgs = {
    /**
     * The data used to create many LaundryWashingHistories.
     */
    data: Enumerable<LaundryWashingHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LaundryWashingHistory update
   */
  export type LaundryWashingHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * The data needed to update a LaundryWashingHistory.
     */
    data: XOR<LaundryWashingHistoryUpdateInput, LaundryWashingHistoryUncheckedUpdateInput>
    /**
     * Choose, which LaundryWashingHistory to update.
     */
    where: LaundryWashingHistoryWhereUniqueInput
  }


  /**
   * LaundryWashingHistory updateMany
   */
  export type LaundryWashingHistoryUpdateManyArgs = {
    /**
     * The data used to update LaundryWashingHistories.
     */
    data: XOR<LaundryWashingHistoryUpdateManyMutationInput, LaundryWashingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LaundryWashingHistories to update
     */
    where?: LaundryWashingHistoryWhereInput
  }


  /**
   * LaundryWashingHistory upsert
   */
  export type LaundryWashingHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * The filter to search for the LaundryWashingHistory to update in case it exists.
     */
    where: LaundryWashingHistoryWhereUniqueInput
    /**
     * In case the LaundryWashingHistory found by the `where` argument doesn't exist, create a new LaundryWashingHistory with this data.
     */
    create: XOR<LaundryWashingHistoryCreateInput, LaundryWashingHistoryUncheckedCreateInput>
    /**
     * In case the LaundryWashingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaundryWashingHistoryUpdateInput, LaundryWashingHistoryUncheckedUpdateInput>
  }


  /**
   * LaundryWashingHistory delete
   */
  export type LaundryWashingHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
    /**
     * Filter which LaundryWashingHistory to delete.
     */
    where: LaundryWashingHistoryWhereUniqueInput
  }


  /**
   * LaundryWashingHistory deleteMany
   */
  export type LaundryWashingHistoryDeleteManyArgs = {
    /**
     * Filter which LaundryWashingHistories to delete
     */
    where?: LaundryWashingHistoryWhereInput
  }


  /**
   * LaundryWashingHistory without action
   */
  export type LaundryWashingHistoryArgs = {
    /**
     * Select specific fields to fetch from the LaundryWashingHistory
     */
    select?: LaundryWashingHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaundryWashingHistoryInclude | null
  }



  /**
   * Model LibraryStudent
   */


  export type AggregateLibraryStudent = {
    _count: LibraryStudentCountAggregateOutputType | null
    _avg: LibraryStudentAvgAggregateOutputType | null
    _sum: LibraryStudentSumAggregateOutputType | null
    _min: LibraryStudentMinAggregateOutputType | null
    _max: LibraryStudentMaxAggregateOutputType | null
  }

  export type LibraryStudentAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryStudentSumAggregateOutputType = {
    id: number | null
  }

  export type LibraryStudentMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryStudentMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryStudentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryStudentAvgAggregateInputType = {
    id?: true
  }

  export type LibraryStudentSumAggregateInputType = {
    id?: true
  }

  export type LibraryStudentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryStudentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryStudentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryStudentAggregateArgs = {
    /**
     * Filter which LibraryStudent to aggregate.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryStudents
    **/
    _count?: true | LibraryStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryStudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryStudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryStudentMaxAggregateInputType
  }

  export type GetLibraryStudentAggregateType<T extends LibraryStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryStudent[P]>
      : GetScalarType<T[P], AggregateLibraryStudent[P]>
  }




  export type LibraryStudentGroupByArgs = {
    where?: LibraryStudentWhereInput
    orderBy?: Enumerable<LibraryStudentOrderByWithAggregationInput>
    by: LibraryStudentScalarFieldEnum[]
    having?: LibraryStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryStudentCountAggregateInputType | true
    _avg?: LibraryStudentAvgAggregateInputType
    _sum?: LibraryStudentSumAggregateInputType
    _min?: LibraryStudentMinAggregateInputType
    _max?: LibraryStudentMaxAggregateInputType
  }


  export type LibraryStudentGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryStudentCountAggregateOutputType | null
    _avg: LibraryStudentAvgAggregateOutputType | null
    _sum: LibraryStudentSumAggregateOutputType | null
    _min: LibraryStudentMinAggregateOutputType | null
    _max: LibraryStudentMaxAggregateOutputType | null
  }

  type GetLibraryStudentGroupByPayload<T extends LibraryStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryStudentGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryStudentGroupByOutputType[P]>
        }
      >
    >


  export type LibraryStudentSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requests?: boolean | LibraryStudent$requestsArgs
    borrowings?: boolean | LibraryStudent$borrowingsArgs
    _count?: boolean | LibraryStudentCountOutputTypeArgs
  }


  export type LibraryStudentInclude = {
    requests?: boolean | LibraryStudent$requestsArgs
    borrowings?: boolean | LibraryStudent$borrowingsArgs
    _count?: boolean | LibraryStudentCountOutputTypeArgs
  }

  export type LibraryStudentGetPayload<S extends boolean | null | undefined | LibraryStudentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryStudent :
    S extends undefined ? never :
    S extends { include: any } & (LibraryStudentArgs | LibraryStudentFindManyArgs)
    ? LibraryStudent  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryStudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryStudentArgs | LibraryStudentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryStudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryStudent ? LibraryStudent[P] : never
  } 
      : LibraryStudent


  type LibraryStudentCountArgs = 
    Omit<LibraryStudentFindManyArgs, 'select' | 'include'> & {
      select?: LibraryStudentCountAggregateInputType | true
    }

  export interface LibraryStudentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryStudent that matches the filter.
     * @param {LibraryStudentFindUniqueArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryStudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryStudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryStudent'> extends True ? Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>> : Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | null, null>

    /**
     * Find one LibraryStudent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryStudentFindUniqueOrThrowArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryStudentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryStudentFindUniqueOrThrowArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Find the first LibraryStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindFirstArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryStudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryStudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryStudent'> extends True ? Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>> : Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | null, null>

    /**
     * Find the first LibraryStudent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindFirstOrThrowArgs} args - Arguments to find a LibraryStudent
     * @example
     * // Get one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryStudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryStudentFindFirstOrThrowArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Find zero or more LibraryStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryStudents
     * const libraryStudents = await prisma.libraryStudent.findMany()
     * 
     * // Get first 10 LibraryStudents
     * const libraryStudents = await prisma.libraryStudent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryStudentWithIdOnly = await prisma.libraryStudent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryStudentFindManyArgs>(
      args?: SelectSubset<T, LibraryStudentFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryStudentGetPayload<T>>>

    /**
     * Create a LibraryStudent.
     * @param {LibraryStudentCreateArgs} args - Arguments to create a LibraryStudent.
     * @example
     * // Create one LibraryStudent
     * const LibraryStudent = await prisma.libraryStudent.create({
     *   data: {
     *     // ... data to create a LibraryStudent
     *   }
     * })
     * 
    **/
    create<T extends LibraryStudentCreateArgs>(
      args: SelectSubset<T, LibraryStudentCreateArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Create many LibraryStudents.
     *     @param {LibraryStudentCreateManyArgs} args - Arguments to create many LibraryStudents.
     *     @example
     *     // Create many LibraryStudents
     *     const libraryStudent = await prisma.libraryStudent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryStudentCreateManyArgs>(
      args?: SelectSubset<T, LibraryStudentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryStudent.
     * @param {LibraryStudentDeleteArgs} args - Arguments to delete one LibraryStudent.
     * @example
     * // Delete one LibraryStudent
     * const LibraryStudent = await prisma.libraryStudent.delete({
     *   where: {
     *     // ... filter to delete one LibraryStudent
     *   }
     * })
     * 
    **/
    delete<T extends LibraryStudentDeleteArgs>(
      args: SelectSubset<T, LibraryStudentDeleteArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Update one LibraryStudent.
     * @param {LibraryStudentUpdateArgs} args - Arguments to update one LibraryStudent.
     * @example
     * // Update one LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryStudentUpdateArgs>(
      args: SelectSubset<T, LibraryStudentUpdateArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Delete zero or more LibraryStudents.
     * @param {LibraryStudentDeleteManyArgs} args - Arguments to filter LibraryStudents to delete.
     * @example
     * // Delete a few LibraryStudents
     * const { count } = await prisma.libraryStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryStudentDeleteManyArgs>(
      args?: SelectSubset<T, LibraryStudentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryStudents
     * const libraryStudent = await prisma.libraryStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryStudentUpdateManyArgs>(
      args: SelectSubset<T, LibraryStudentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryStudent.
     * @param {LibraryStudentUpsertArgs} args - Arguments to update or create a LibraryStudent.
     * @example
     * // Update or create a LibraryStudent
     * const libraryStudent = await prisma.libraryStudent.upsert({
     *   create: {
     *     // ... data to create a LibraryStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryStudent we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryStudentUpsertArgs>(
      args: SelectSubset<T, LibraryStudentUpsertArgs>
    ): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T>>

    /**
     * Count the number of LibraryStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentCountArgs} args - Arguments to filter LibraryStudents to count.
     * @example
     * // Count the number of LibraryStudents
     * const count = await prisma.libraryStudent.count({
     *   where: {
     *     // ... the filter for the LibraryStudents we want to count
     *   }
     * })
    **/
    count<T extends LibraryStudentCountArgs>(
      args?: Subset<T, LibraryStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryStudentAggregateArgs>(args: Subset<T, LibraryStudentAggregateArgs>): Prisma.PrismaPromise<GetLibraryStudentAggregateType<T>>

    /**
     * Group by LibraryStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryStudentGroupByArgs['orderBy'] }
        : { orderBy?: LibraryStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryStudentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requests<T extends LibraryStudent$requestsArgs= {}>(args?: Subset<T, LibraryStudent$requestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    borrowings<T extends LibraryStudent$borrowingsArgs= {}>(args?: Subset<T, LibraryStudent$borrowingsArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryStudent base type for findUnique actions
   */
  export type LibraryStudentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where: LibraryStudentWhereUniqueInput
  }

  /**
   * LibraryStudent findUnique
   */
  export interface LibraryStudentFindUniqueArgs extends LibraryStudentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryStudent findUniqueOrThrow
   */
  export type LibraryStudentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent base type for findFirst actions
   */
  export type LibraryStudentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStudents.
     */
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }

  /**
   * LibraryStudent findFirst
   */
  export interface LibraryStudentFindFirstArgs extends LibraryStudentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryStudent findFirstOrThrow
   */
  export type LibraryStudentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudent to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryStudents.
     */
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }


  /**
   * LibraryStudent findMany
   */
  export type LibraryStudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter, which LibraryStudents to fetch.
     */
    where?: LibraryStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryStudents to fetch.
     */
    orderBy?: Enumerable<LibraryStudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryStudents.
     */
    cursor?: LibraryStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryStudents.
     */
    skip?: number
    distinct?: Enumerable<LibraryStudentScalarFieldEnum>
  }


  /**
   * LibraryStudent create
   */
  export type LibraryStudentCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The data needed to create a LibraryStudent.
     */
    data: XOR<LibraryStudentCreateInput, LibraryStudentUncheckedCreateInput>
  }


  /**
   * LibraryStudent createMany
   */
  export type LibraryStudentCreateManyArgs = {
    /**
     * The data used to create many LibraryStudents.
     */
    data: Enumerable<LibraryStudentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryStudent update
   */
  export type LibraryStudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The data needed to update a LibraryStudent.
     */
    data: XOR<LibraryStudentUpdateInput, LibraryStudentUncheckedUpdateInput>
    /**
     * Choose, which LibraryStudent to update.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent updateMany
   */
  export type LibraryStudentUpdateManyArgs = {
    /**
     * The data used to update LibraryStudents.
     */
    data: XOR<LibraryStudentUpdateManyMutationInput, LibraryStudentUncheckedUpdateManyInput>
    /**
     * Filter which LibraryStudents to update
     */
    where?: LibraryStudentWhereInput
  }


  /**
   * LibraryStudent upsert
   */
  export type LibraryStudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * The filter to search for the LibraryStudent to update in case it exists.
     */
    where: LibraryStudentWhereUniqueInput
    /**
     * In case the LibraryStudent found by the `where` argument doesn't exist, create a new LibraryStudent with this data.
     */
    create: XOR<LibraryStudentCreateInput, LibraryStudentUncheckedCreateInput>
    /**
     * In case the LibraryStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryStudentUpdateInput, LibraryStudentUncheckedUpdateInput>
  }


  /**
   * LibraryStudent delete
   */
  export type LibraryStudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
    /**
     * Filter which LibraryStudent to delete.
     */
    where: LibraryStudentWhereUniqueInput
  }


  /**
   * LibraryStudent deleteMany
   */
  export type LibraryStudentDeleteManyArgs = {
    /**
     * Filter which LibraryStudents to delete
     */
    where?: LibraryStudentWhereInput
  }


  /**
   * LibraryStudent.requests
   */
  export type LibraryStudent$requestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryStudent.borrowings
   */
  export type LibraryStudent$borrowingsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    where?: LibraryBorrowingWhereInput
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    cursor?: LibraryBorrowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }


  /**
   * LibraryStudent without action
   */
  export type LibraryStudentArgs = {
    /**
     * Select specific fields to fetch from the LibraryStudent
     */
    select?: LibraryStudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryStudentInclude | null
  }



  /**
   * Model LibraryUniversity
   */


  export type AggregateLibraryUniversity = {
    _count: LibraryUniversityCountAggregateOutputType | null
    _avg: LibraryUniversityAvgAggregateOutputType | null
    _sum: LibraryUniversitySumAggregateOutputType | null
    _min: LibraryUniversityMinAggregateOutputType | null
    _max: LibraryUniversityMaxAggregateOutputType | null
  }

  export type LibraryUniversityAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryUniversitySumAggregateOutputType = {
    id: number | null
  }

  export type LibraryUniversityMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryUniversityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryUniversityCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryUniversityAvgAggregateInputType = {
    id?: true
  }

  export type LibraryUniversitySumAggregateInputType = {
    id?: true
  }

  export type LibraryUniversityMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryUniversityMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryUniversityCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryUniversityAggregateArgs = {
    /**
     * Filter which LibraryUniversity to aggregate.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryUniversities
    **/
    _count?: true | LibraryUniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryUniversityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryUniversitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryUniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryUniversityMaxAggregateInputType
  }

  export type GetLibraryUniversityAggregateType<T extends LibraryUniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryUniversity[P]>
      : GetScalarType<T[P], AggregateLibraryUniversity[P]>
  }




  export type LibraryUniversityGroupByArgs = {
    where?: LibraryUniversityWhereInput
    orderBy?: Enumerable<LibraryUniversityOrderByWithAggregationInput>
    by: LibraryUniversityScalarFieldEnum[]
    having?: LibraryUniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryUniversityCountAggregateInputType | true
    _avg?: LibraryUniversityAvgAggregateInputType
    _sum?: LibraryUniversitySumAggregateInputType
    _min?: LibraryUniversityMinAggregateInputType
    _max?: LibraryUniversityMaxAggregateInputType
  }


  export type LibraryUniversityGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryUniversityCountAggregateOutputType | null
    _avg: LibraryUniversityAvgAggregateOutputType | null
    _sum: LibraryUniversitySumAggregateOutputType | null
    _min: LibraryUniversityMinAggregateOutputType | null
    _max: LibraryUniversityMaxAggregateOutputType | null
  }

  type GetLibraryUniversityGroupByPayload<T extends LibraryUniversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryUniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryUniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryUniversityGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryUniversityGroupByOutputType[P]>
        }
      >
    >


  export type LibraryUniversitySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookCopies?: boolean | LibraryUniversity$bookCopiesArgs
    fromRequests?: boolean | LibraryUniversity$fromRequestsArgs
    toRequests?: boolean | LibraryUniversity$toRequestsArgs
    borrowings?: boolean | LibraryUniversity$borrowingsArgs
    _count?: boolean | LibraryUniversityCountOutputTypeArgs
  }


  export type LibraryUniversityInclude = {
    bookCopies?: boolean | LibraryUniversity$bookCopiesArgs
    fromRequests?: boolean | LibraryUniversity$fromRequestsArgs
    toRequests?: boolean | LibraryUniversity$toRequestsArgs
    borrowings?: boolean | LibraryUniversity$borrowingsArgs
    _count?: boolean | LibraryUniversityCountOutputTypeArgs
  }

  export type LibraryUniversityGetPayload<S extends boolean | null | undefined | LibraryUniversityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryUniversity :
    S extends undefined ? never :
    S extends { include: any } & (LibraryUniversityArgs | LibraryUniversityFindManyArgs)
    ? LibraryUniversity  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookCopies' ? Array < LibraryBookCopyGetPayload<S['include'][P]>>  :
        P extends 'fromRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends 'toRequests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryUniversityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryUniversityArgs | LibraryUniversityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookCopies' ? Array < LibraryBookCopyGetPayload<S['select'][P]>>  :
        P extends 'fromRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends 'toRequests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryUniversityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryUniversity ? LibraryUniversity[P] : never
  } 
      : LibraryUniversity


  type LibraryUniversityCountArgs = 
    Omit<LibraryUniversityFindManyArgs, 'select' | 'include'> & {
      select?: LibraryUniversityCountAggregateInputType | true
    }

  export interface LibraryUniversityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryUniversity that matches the filter.
     * @param {LibraryUniversityFindUniqueArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryUniversityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryUniversityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryUniversity'> extends True ? Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>> : Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | null, null>

    /**
     * Find one LibraryUniversity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryUniversityFindUniqueOrThrowArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryUniversityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryUniversityFindUniqueOrThrowArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Find the first LibraryUniversity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindFirstArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryUniversityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryUniversityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryUniversity'> extends True ? Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>> : Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | null, null>

    /**
     * Find the first LibraryUniversity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindFirstOrThrowArgs} args - Arguments to find a LibraryUniversity
     * @example
     * // Get one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryUniversityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryUniversityFindFirstOrThrowArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Find zero or more LibraryUniversities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryUniversities
     * const libraryUniversities = await prisma.libraryUniversity.findMany()
     * 
     * // Get first 10 LibraryUniversities
     * const libraryUniversities = await prisma.libraryUniversity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryUniversityWithIdOnly = await prisma.libraryUniversity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryUniversityFindManyArgs>(
      args?: SelectSubset<T, LibraryUniversityFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryUniversityGetPayload<T>>>

    /**
     * Create a LibraryUniversity.
     * @param {LibraryUniversityCreateArgs} args - Arguments to create a LibraryUniversity.
     * @example
     * // Create one LibraryUniversity
     * const LibraryUniversity = await prisma.libraryUniversity.create({
     *   data: {
     *     // ... data to create a LibraryUniversity
     *   }
     * })
     * 
    **/
    create<T extends LibraryUniversityCreateArgs>(
      args: SelectSubset<T, LibraryUniversityCreateArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Create many LibraryUniversities.
     *     @param {LibraryUniversityCreateManyArgs} args - Arguments to create many LibraryUniversities.
     *     @example
     *     // Create many LibraryUniversities
     *     const libraryUniversity = await prisma.libraryUniversity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryUniversityCreateManyArgs>(
      args?: SelectSubset<T, LibraryUniversityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryUniversity.
     * @param {LibraryUniversityDeleteArgs} args - Arguments to delete one LibraryUniversity.
     * @example
     * // Delete one LibraryUniversity
     * const LibraryUniversity = await prisma.libraryUniversity.delete({
     *   where: {
     *     // ... filter to delete one LibraryUniversity
     *   }
     * })
     * 
    **/
    delete<T extends LibraryUniversityDeleteArgs>(
      args: SelectSubset<T, LibraryUniversityDeleteArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Update one LibraryUniversity.
     * @param {LibraryUniversityUpdateArgs} args - Arguments to update one LibraryUniversity.
     * @example
     * // Update one LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryUniversityUpdateArgs>(
      args: SelectSubset<T, LibraryUniversityUpdateArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Delete zero or more LibraryUniversities.
     * @param {LibraryUniversityDeleteManyArgs} args - Arguments to filter LibraryUniversities to delete.
     * @example
     * // Delete a few LibraryUniversities
     * const { count } = await prisma.libraryUniversity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryUniversityDeleteManyArgs>(
      args?: SelectSubset<T, LibraryUniversityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryUniversities
     * const libraryUniversity = await prisma.libraryUniversity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryUniversityUpdateManyArgs>(
      args: SelectSubset<T, LibraryUniversityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryUniversity.
     * @param {LibraryUniversityUpsertArgs} args - Arguments to update or create a LibraryUniversity.
     * @example
     * // Update or create a LibraryUniversity
     * const libraryUniversity = await prisma.libraryUniversity.upsert({
     *   create: {
     *     // ... data to create a LibraryUniversity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryUniversity we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryUniversityUpsertArgs>(
      args: SelectSubset<T, LibraryUniversityUpsertArgs>
    ): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T>>

    /**
     * Count the number of LibraryUniversities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityCountArgs} args - Arguments to filter LibraryUniversities to count.
     * @example
     * // Count the number of LibraryUniversities
     * const count = await prisma.libraryUniversity.count({
     *   where: {
     *     // ... the filter for the LibraryUniversities we want to count
     *   }
     * })
    **/
    count<T extends LibraryUniversityCountArgs>(
      args?: Subset<T, LibraryUniversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryUniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryUniversityAggregateArgs>(args: Subset<T, LibraryUniversityAggregateArgs>): Prisma.PrismaPromise<GetLibraryUniversityAggregateType<T>>

    /**
     * Group by LibraryUniversity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryUniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryUniversityGroupByArgs['orderBy'] }
        : { orderBy?: LibraryUniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryUniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryUniversity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryUniversityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookCopies<T extends LibraryUniversity$bookCopiesArgs= {}>(args?: Subset<T, LibraryUniversity$bookCopiesArgs>): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>| Null>;

    fromRequests<T extends LibraryUniversity$fromRequestsArgs= {}>(args?: Subset<T, LibraryUniversity$fromRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    toRequests<T extends LibraryUniversity$toRequestsArgs= {}>(args?: Subset<T, LibraryUniversity$toRequestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    borrowings<T extends LibraryUniversity$borrowingsArgs= {}>(args?: Subset<T, LibraryUniversity$borrowingsArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryUniversity base type for findUnique actions
   */
  export type LibraryUniversityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where: LibraryUniversityWhereUniqueInput
  }

  /**
   * LibraryUniversity findUnique
   */
  export interface LibraryUniversityFindUniqueArgs extends LibraryUniversityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryUniversity findUniqueOrThrow
   */
  export type LibraryUniversityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity base type for findFirst actions
   */
  export type LibraryUniversityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryUniversities.
     */
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }

  /**
   * LibraryUniversity findFirst
   */
  export interface LibraryUniversityFindFirstArgs extends LibraryUniversityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryUniversity findFirstOrThrow
   */
  export type LibraryUniversityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversity to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryUniversities.
     */
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }


  /**
   * LibraryUniversity findMany
   */
  export type LibraryUniversityFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter, which LibraryUniversities to fetch.
     */
    where?: LibraryUniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryUniversities to fetch.
     */
    orderBy?: Enumerable<LibraryUniversityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryUniversities.
     */
    cursor?: LibraryUniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryUniversities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryUniversities.
     */
    skip?: number
    distinct?: Enumerable<LibraryUniversityScalarFieldEnum>
  }


  /**
   * LibraryUniversity create
   */
  export type LibraryUniversityCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The data needed to create a LibraryUniversity.
     */
    data: XOR<LibraryUniversityCreateInput, LibraryUniversityUncheckedCreateInput>
  }


  /**
   * LibraryUniversity createMany
   */
  export type LibraryUniversityCreateManyArgs = {
    /**
     * The data used to create many LibraryUniversities.
     */
    data: Enumerable<LibraryUniversityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryUniversity update
   */
  export type LibraryUniversityUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The data needed to update a LibraryUniversity.
     */
    data: XOR<LibraryUniversityUpdateInput, LibraryUniversityUncheckedUpdateInput>
    /**
     * Choose, which LibraryUniversity to update.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity updateMany
   */
  export type LibraryUniversityUpdateManyArgs = {
    /**
     * The data used to update LibraryUniversities.
     */
    data: XOR<LibraryUniversityUpdateManyMutationInput, LibraryUniversityUncheckedUpdateManyInput>
    /**
     * Filter which LibraryUniversities to update
     */
    where?: LibraryUniversityWhereInput
  }


  /**
   * LibraryUniversity upsert
   */
  export type LibraryUniversityUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * The filter to search for the LibraryUniversity to update in case it exists.
     */
    where: LibraryUniversityWhereUniqueInput
    /**
     * In case the LibraryUniversity found by the `where` argument doesn't exist, create a new LibraryUniversity with this data.
     */
    create: XOR<LibraryUniversityCreateInput, LibraryUniversityUncheckedCreateInput>
    /**
     * In case the LibraryUniversity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUniversityUpdateInput, LibraryUniversityUncheckedUpdateInput>
  }


  /**
   * LibraryUniversity delete
   */
  export type LibraryUniversityDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
    /**
     * Filter which LibraryUniversity to delete.
     */
    where: LibraryUniversityWhereUniqueInput
  }


  /**
   * LibraryUniversity deleteMany
   */
  export type LibraryUniversityDeleteManyArgs = {
    /**
     * Filter which LibraryUniversities to delete
     */
    where?: LibraryUniversityWhereInput
  }


  /**
   * LibraryUniversity.bookCopies
   */
  export type LibraryUniversity$bookCopiesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    cursor?: LibraryBookCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryUniversity.fromRequests
   */
  export type LibraryUniversity$fromRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryUniversity.toRequests
   */
  export type LibraryUniversity$toRequestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryUniversity.borrowings
   */
  export type LibraryUniversity$borrowingsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    where?: LibraryBorrowingWhereInput
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    cursor?: LibraryBorrowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }


  /**
   * LibraryUniversity without action
   */
  export type LibraryUniversityArgs = {
    /**
     * Select specific fields to fetch from the LibraryUniversity
     */
    select?: LibraryUniversitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryUniversityInclude | null
  }



  /**
   * Model LibraryCategory
   */


  export type AggregateLibraryCategory = {
    _count: LibraryCategoryCountAggregateOutputType | null
    _avg: LibraryCategoryAvgAggregateOutputType | null
    _sum: LibraryCategorySumAggregateOutputType | null
    _min: LibraryCategoryMinAggregateOutputType | null
    _max: LibraryCategoryMaxAggregateOutputType | null
  }

  export type LibraryCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryCategorySumAggregateOutputType = {
    id: number | null
  }

  export type LibraryCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryCategoryAvgAggregateInputType = {
    id?: true
  }

  export type LibraryCategorySumAggregateInputType = {
    id?: true
  }

  export type LibraryCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryCategoryAggregateArgs = {
    /**
     * Filter which LibraryCategory to aggregate.
     */
    where?: LibraryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategories to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryCategories
    **/
    _count?: true | LibraryCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryCategoryMaxAggregateInputType
  }

  export type GetLibraryCategoryAggregateType<T extends LibraryCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryCategory[P]>
      : GetScalarType<T[P], AggregateLibraryCategory[P]>
  }




  export type LibraryCategoryGroupByArgs = {
    where?: LibraryCategoryWhereInput
    orderBy?: Enumerable<LibraryCategoryOrderByWithAggregationInput>
    by: LibraryCategoryScalarFieldEnum[]
    having?: LibraryCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCategoryCountAggregateInputType | true
    _avg?: LibraryCategoryAvgAggregateInputType
    _sum?: LibraryCategorySumAggregateInputType
    _min?: LibraryCategoryMinAggregateInputType
    _max?: LibraryCategoryMaxAggregateInputType
  }


  export type LibraryCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryCategoryCountAggregateOutputType | null
    _avg: LibraryCategoryAvgAggregateOutputType | null
    _sum: LibraryCategorySumAggregateOutputType | null
    _min: LibraryCategoryMinAggregateOutputType | null
    _max: LibraryCategoryMaxAggregateOutputType | null
  }

  type GetLibraryCategoryGroupByPayload<T extends LibraryCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryCategoryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryCategorySelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookCategories?: boolean | LibraryCategory$bookCategoriesArgs
    _count?: boolean | LibraryCategoryCountOutputTypeArgs
  }


  export type LibraryCategoryInclude = {
    bookCategories?: boolean | LibraryCategory$bookCategoriesArgs
    _count?: boolean | LibraryCategoryCountOutputTypeArgs
  }

  export type LibraryCategoryGetPayload<S extends boolean | null | undefined | LibraryCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryCategory :
    S extends undefined ? never :
    S extends { include: any } & (LibraryCategoryArgs | LibraryCategoryFindManyArgs)
    ? LibraryCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookCategories' ? Array < LibraryBookCategoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryCategoryArgs | LibraryCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookCategories' ? Array < LibraryBookCategoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryCategory ? LibraryCategory[P] : never
  } 
      : LibraryCategory


  type LibraryCategoryCountArgs = 
    Omit<LibraryCategoryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryCategoryCountAggregateInputType | true
    }

  export interface LibraryCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryCategory that matches the filter.
     * @param {LibraryCategoryFindUniqueArgs} args - Arguments to find a LibraryCategory
     * @example
     * // Get one LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryCategory'> extends True ? Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>> : Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T> | null, null>

    /**
     * Find one LibraryCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryCategoryFindUniqueOrThrowArgs} args - Arguments to find a LibraryCategory
     * @example
     * // Get one LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryCategoryFindUniqueOrThrowArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Find the first LibraryCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryFindFirstArgs} args - Arguments to find a LibraryCategory
     * @example
     * // Get one LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryCategory'> extends True ? Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>> : Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T> | null, null>

    /**
     * Find the first LibraryCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryFindFirstOrThrowArgs} args - Arguments to find a LibraryCategory
     * @example
     * // Get one LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryCategoryFindFirstOrThrowArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Find zero or more LibraryCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryCategories
     * const libraryCategories = await prisma.libraryCategory.findMany()
     * 
     * // Get first 10 LibraryCategories
     * const libraryCategories = await prisma.libraryCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryCategoryWithIdOnly = await prisma.libraryCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryCategoryFindManyArgs>(
      args?: SelectSubset<T, LibraryCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryCategoryGetPayload<T>>>

    /**
     * Create a LibraryCategory.
     * @param {LibraryCategoryCreateArgs} args - Arguments to create a LibraryCategory.
     * @example
     * // Create one LibraryCategory
     * const LibraryCategory = await prisma.libraryCategory.create({
     *   data: {
     *     // ... data to create a LibraryCategory
     *   }
     * })
     * 
    **/
    create<T extends LibraryCategoryCreateArgs>(
      args: SelectSubset<T, LibraryCategoryCreateArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Create many LibraryCategories.
     *     @param {LibraryCategoryCreateManyArgs} args - Arguments to create many LibraryCategories.
     *     @example
     *     // Create many LibraryCategories
     *     const libraryCategory = await prisma.libraryCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryCategoryCreateManyArgs>(
      args?: SelectSubset<T, LibraryCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryCategory.
     * @param {LibraryCategoryDeleteArgs} args - Arguments to delete one LibraryCategory.
     * @example
     * // Delete one LibraryCategory
     * const LibraryCategory = await prisma.libraryCategory.delete({
     *   where: {
     *     // ... filter to delete one LibraryCategory
     *   }
     * })
     * 
    **/
    delete<T extends LibraryCategoryDeleteArgs>(
      args: SelectSubset<T, LibraryCategoryDeleteArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Update one LibraryCategory.
     * @param {LibraryCategoryUpdateArgs} args - Arguments to update one LibraryCategory.
     * @example
     * // Update one LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryCategoryUpdateArgs>(
      args: SelectSubset<T, LibraryCategoryUpdateArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Delete zero or more LibraryCategories.
     * @param {LibraryCategoryDeleteManyArgs} args - Arguments to filter LibraryCategories to delete.
     * @example
     * // Delete a few LibraryCategories
     * const { count } = await prisma.libraryCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryCategoryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryCategories
     * const libraryCategory = await prisma.libraryCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryCategoryUpdateManyArgs>(
      args: SelectSubset<T, LibraryCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryCategory.
     * @param {LibraryCategoryUpsertArgs} args - Arguments to update or create a LibraryCategory.
     * @example
     * // Update or create a LibraryCategory
     * const libraryCategory = await prisma.libraryCategory.upsert({
     *   create: {
     *     // ... data to create a LibraryCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryCategory we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryCategoryUpsertArgs>(
      args: SelectSubset<T, LibraryCategoryUpsertArgs>
    ): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T>>

    /**
     * Count the number of LibraryCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryCountArgs} args - Arguments to filter LibraryCategories to count.
     * @example
     * // Count the number of LibraryCategories
     * const count = await prisma.libraryCategory.count({
     *   where: {
     *     // ... the filter for the LibraryCategories we want to count
     *   }
     * })
    **/
    count<T extends LibraryCategoryCountArgs>(
      args?: Subset<T, LibraryCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryCategoryAggregateArgs>(args: Subset<T, LibraryCategoryAggregateArgs>): Prisma.PrismaPromise<GetLibraryCategoryAggregateType<T>>

    /**
     * Group by LibraryCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryCategoryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookCategories<T extends LibraryCategory$bookCategoriesArgs= {}>(args?: Subset<T, LibraryCategory$bookCategoriesArgs>): Prisma.PrismaPromise<Array<LibraryBookCategoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryCategory base type for findUnique actions
   */
  export type LibraryCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter, which LibraryCategory to fetch.
     */
    where: LibraryCategoryWhereUniqueInput
  }

  /**
   * LibraryCategory findUnique
   */
  export interface LibraryCategoryFindUniqueArgs extends LibraryCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryCategory findUniqueOrThrow
   */
  export type LibraryCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter, which LibraryCategory to fetch.
     */
    where: LibraryCategoryWhereUniqueInput
  }


  /**
   * LibraryCategory base type for findFirst actions
   */
  export type LibraryCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter, which LibraryCategory to fetch.
     */
    where?: LibraryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategories to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCategories.
     */
    cursor?: LibraryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCategories.
     */
    distinct?: Enumerable<LibraryCategoryScalarFieldEnum>
  }

  /**
   * LibraryCategory findFirst
   */
  export interface LibraryCategoryFindFirstArgs extends LibraryCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryCategory findFirstOrThrow
   */
  export type LibraryCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter, which LibraryCategory to fetch.
     */
    where?: LibraryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategories to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryCategories.
     */
    cursor?: LibraryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryCategories.
     */
    distinct?: Enumerable<LibraryCategoryScalarFieldEnum>
  }


  /**
   * LibraryCategory findMany
   */
  export type LibraryCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter, which LibraryCategories to fetch.
     */
    where?: LibraryCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryCategories to fetch.
     */
    orderBy?: Enumerable<LibraryCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryCategories.
     */
    cursor?: LibraryCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryCategories.
     */
    skip?: number
    distinct?: Enumerable<LibraryCategoryScalarFieldEnum>
  }


  /**
   * LibraryCategory create
   */
  export type LibraryCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * The data needed to create a LibraryCategory.
     */
    data: XOR<LibraryCategoryCreateInput, LibraryCategoryUncheckedCreateInput>
  }


  /**
   * LibraryCategory createMany
   */
  export type LibraryCategoryCreateManyArgs = {
    /**
     * The data used to create many LibraryCategories.
     */
    data: Enumerable<LibraryCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryCategory update
   */
  export type LibraryCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * The data needed to update a LibraryCategory.
     */
    data: XOR<LibraryCategoryUpdateInput, LibraryCategoryUncheckedUpdateInput>
    /**
     * Choose, which LibraryCategory to update.
     */
    where: LibraryCategoryWhereUniqueInput
  }


  /**
   * LibraryCategory updateMany
   */
  export type LibraryCategoryUpdateManyArgs = {
    /**
     * The data used to update LibraryCategories.
     */
    data: XOR<LibraryCategoryUpdateManyMutationInput, LibraryCategoryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryCategories to update
     */
    where?: LibraryCategoryWhereInput
  }


  /**
   * LibraryCategory upsert
   */
  export type LibraryCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * The filter to search for the LibraryCategory to update in case it exists.
     */
    where: LibraryCategoryWhereUniqueInput
    /**
     * In case the LibraryCategory found by the `where` argument doesn't exist, create a new LibraryCategory with this data.
     */
    create: XOR<LibraryCategoryCreateInput, LibraryCategoryUncheckedCreateInput>
    /**
     * In case the LibraryCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryCategoryUpdateInput, LibraryCategoryUncheckedUpdateInput>
  }


  /**
   * LibraryCategory delete
   */
  export type LibraryCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
    /**
     * Filter which LibraryCategory to delete.
     */
    where: LibraryCategoryWhereUniqueInput
  }


  /**
   * LibraryCategory deleteMany
   */
  export type LibraryCategoryDeleteManyArgs = {
    /**
     * Filter which LibraryCategories to delete
     */
    where?: LibraryCategoryWhereInput
  }


  /**
   * LibraryCategory.bookCategories
   */
  export type LibraryCategory$bookCategoriesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    where?: LibraryBookCategoryWhereInput
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    cursor?: LibraryBookCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryCategory without action
   */
  export type LibraryCategoryArgs = {
    /**
     * Select specific fields to fetch from the LibraryCategory
     */
    select?: LibraryCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryCategoryInclude | null
  }



  /**
   * Model LibraryAuthor
   */


  export type AggregateLibraryAuthor = {
    _count: LibraryAuthorCountAggregateOutputType | null
    _avg: LibraryAuthorAvgAggregateOutputType | null
    _sum: LibraryAuthorSumAggregateOutputType | null
    _min: LibraryAuthorMinAggregateOutputType | null
    _max: LibraryAuthorMaxAggregateOutputType | null
  }

  export type LibraryAuthorAvgAggregateOutputType = {
    id: number | null
  }

  export type LibraryAuthorSumAggregateOutputType = {
    id: number | null
  }

  export type LibraryAuthorMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryAuthorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryAuthorCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryAuthorAvgAggregateInputType = {
    id?: true
  }

  export type LibraryAuthorSumAggregateInputType = {
    id?: true
  }

  export type LibraryAuthorMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryAuthorMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryAuthorCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryAuthorAggregateArgs = {
    /**
     * Filter which LibraryAuthor to aggregate.
     */
    where?: LibraryAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryAuthors
    **/
    _count?: true | LibraryAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryAuthorMaxAggregateInputType
  }

  export type GetLibraryAuthorAggregateType<T extends LibraryAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryAuthor[P]>
      : GetScalarType<T[P], AggregateLibraryAuthor[P]>
  }




  export type LibraryAuthorGroupByArgs = {
    where?: LibraryAuthorWhereInput
    orderBy?: Enumerable<LibraryAuthorOrderByWithAggregationInput>
    by: LibraryAuthorScalarFieldEnum[]
    having?: LibraryAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryAuthorCountAggregateInputType | true
    _avg?: LibraryAuthorAvgAggregateInputType
    _sum?: LibraryAuthorSumAggregateInputType
    _min?: LibraryAuthorMinAggregateInputType
    _max?: LibraryAuthorMaxAggregateInputType
  }


  export type LibraryAuthorGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryAuthorCountAggregateOutputType | null
    _avg: LibraryAuthorAvgAggregateOutputType | null
    _sum: LibraryAuthorSumAggregateOutputType | null
    _min: LibraryAuthorMinAggregateOutputType | null
    _max: LibraryAuthorMaxAggregateOutputType | null
  }

  type GetLibraryAuthorGroupByPayload<T extends LibraryAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryAuthorGroupByOutputType[P]>
        }
      >
    >


  export type LibraryAuthorSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookAuthors?: boolean | LibraryAuthor$bookAuthorsArgs
    _count?: boolean | LibraryAuthorCountOutputTypeArgs
  }


  export type LibraryAuthorInclude = {
    bookAuthors?: boolean | LibraryAuthor$bookAuthorsArgs
    _count?: boolean | LibraryAuthorCountOutputTypeArgs
  }

  export type LibraryAuthorGetPayload<S extends boolean | null | undefined | LibraryAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryAuthor :
    S extends undefined ? never :
    S extends { include: any } & (LibraryAuthorArgs | LibraryAuthorFindManyArgs)
    ? LibraryAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookAuthors' ? Array < LibraryBookAuthorGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryAuthorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryAuthorArgs | LibraryAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookAuthors' ? Array < LibraryBookAuthorGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryAuthorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryAuthor ? LibraryAuthor[P] : never
  } 
      : LibraryAuthor


  type LibraryAuthorCountArgs = 
    Omit<LibraryAuthorFindManyArgs, 'select' | 'include'> & {
      select?: LibraryAuthorCountAggregateInputType | true
    }

  export interface LibraryAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryAuthor that matches the filter.
     * @param {LibraryAuthorFindUniqueArgs} args - Arguments to find a LibraryAuthor
     * @example
     * // Get one LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryAuthor'> extends True ? Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>> : Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T> | null, null>

    /**
     * Find one LibraryAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryAuthorFindUniqueOrThrowArgs} args - Arguments to find a LibraryAuthor
     * @example
     * // Get one LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryAuthorFindUniqueOrThrowArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Find the first LibraryAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorFindFirstArgs} args - Arguments to find a LibraryAuthor
     * @example
     * // Get one LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryAuthor'> extends True ? Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>> : Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T> | null, null>

    /**
     * Find the first LibraryAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorFindFirstOrThrowArgs} args - Arguments to find a LibraryAuthor
     * @example
     * // Get one LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryAuthorFindFirstOrThrowArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Find zero or more LibraryAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryAuthors
     * const libraryAuthors = await prisma.libraryAuthor.findMany()
     * 
     * // Get first 10 LibraryAuthors
     * const libraryAuthors = await prisma.libraryAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryAuthorWithIdOnly = await prisma.libraryAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryAuthorFindManyArgs>(
      args?: SelectSubset<T, LibraryAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryAuthorGetPayload<T>>>

    /**
     * Create a LibraryAuthor.
     * @param {LibraryAuthorCreateArgs} args - Arguments to create a LibraryAuthor.
     * @example
     * // Create one LibraryAuthor
     * const LibraryAuthor = await prisma.libraryAuthor.create({
     *   data: {
     *     // ... data to create a LibraryAuthor
     *   }
     * })
     * 
    **/
    create<T extends LibraryAuthorCreateArgs>(
      args: SelectSubset<T, LibraryAuthorCreateArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Create many LibraryAuthors.
     *     @param {LibraryAuthorCreateManyArgs} args - Arguments to create many LibraryAuthors.
     *     @example
     *     // Create many LibraryAuthors
     *     const libraryAuthor = await prisma.libraryAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryAuthorCreateManyArgs>(
      args?: SelectSubset<T, LibraryAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryAuthor.
     * @param {LibraryAuthorDeleteArgs} args - Arguments to delete one LibraryAuthor.
     * @example
     * // Delete one LibraryAuthor
     * const LibraryAuthor = await prisma.libraryAuthor.delete({
     *   where: {
     *     // ... filter to delete one LibraryAuthor
     *   }
     * })
     * 
    **/
    delete<T extends LibraryAuthorDeleteArgs>(
      args: SelectSubset<T, LibraryAuthorDeleteArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Update one LibraryAuthor.
     * @param {LibraryAuthorUpdateArgs} args - Arguments to update one LibraryAuthor.
     * @example
     * // Update one LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryAuthorUpdateArgs>(
      args: SelectSubset<T, LibraryAuthorUpdateArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Delete zero or more LibraryAuthors.
     * @param {LibraryAuthorDeleteManyArgs} args - Arguments to filter LibraryAuthors to delete.
     * @example
     * // Delete a few LibraryAuthors
     * const { count } = await prisma.libraryAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryAuthorDeleteManyArgs>(
      args?: SelectSubset<T, LibraryAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryAuthors
     * const libraryAuthor = await prisma.libraryAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryAuthorUpdateManyArgs>(
      args: SelectSubset<T, LibraryAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryAuthor.
     * @param {LibraryAuthorUpsertArgs} args - Arguments to update or create a LibraryAuthor.
     * @example
     * // Update or create a LibraryAuthor
     * const libraryAuthor = await prisma.libraryAuthor.upsert({
     *   create: {
     *     // ... data to create a LibraryAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryAuthorUpsertArgs>(
      args: SelectSubset<T, LibraryAuthorUpsertArgs>
    ): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T>>

    /**
     * Count the number of LibraryAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorCountArgs} args - Arguments to filter LibraryAuthors to count.
     * @example
     * // Count the number of LibraryAuthors
     * const count = await prisma.libraryAuthor.count({
     *   where: {
     *     // ... the filter for the LibraryAuthors we want to count
     *   }
     * })
    **/
    count<T extends LibraryAuthorCountArgs>(
      args?: Subset<T, LibraryAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAuthorAggregateArgs>(args: Subset<T, LibraryAuthorAggregateArgs>): Prisma.PrismaPromise<GetLibraryAuthorAggregateType<T>>

    /**
     * Group by LibraryAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryAuthorGroupByArgs['orderBy'] }
        : { orderBy?: LibraryAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookAuthors<T extends LibraryAuthor$bookAuthorsArgs= {}>(args?: Subset<T, LibraryAuthor$bookAuthorsArgs>): Prisma.PrismaPromise<Array<LibraryBookAuthorGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryAuthor base type for findUnique actions
   */
  export type LibraryAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter, which LibraryAuthor to fetch.
     */
    where: LibraryAuthorWhereUniqueInput
  }

  /**
   * LibraryAuthor findUnique
   */
  export interface LibraryAuthorFindUniqueArgs extends LibraryAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryAuthor findUniqueOrThrow
   */
  export type LibraryAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter, which LibraryAuthor to fetch.
     */
    where: LibraryAuthorWhereUniqueInput
  }


  /**
   * LibraryAuthor base type for findFirst actions
   */
  export type LibraryAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter, which LibraryAuthor to fetch.
     */
    where?: LibraryAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryAuthors.
     */
    cursor?: LibraryAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryAuthors.
     */
    distinct?: Enumerable<LibraryAuthorScalarFieldEnum>
  }

  /**
   * LibraryAuthor findFirst
   */
  export interface LibraryAuthorFindFirstArgs extends LibraryAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryAuthor findFirstOrThrow
   */
  export type LibraryAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter, which LibraryAuthor to fetch.
     */
    where?: LibraryAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryAuthors.
     */
    cursor?: LibraryAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryAuthors.
     */
    distinct?: Enumerable<LibraryAuthorScalarFieldEnum>
  }


  /**
   * LibraryAuthor findMany
   */
  export type LibraryAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter, which LibraryAuthors to fetch.
     */
    where?: LibraryAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryAuthors.
     */
    cursor?: LibraryAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAuthors.
     */
    skip?: number
    distinct?: Enumerable<LibraryAuthorScalarFieldEnum>
  }


  /**
   * LibraryAuthor create
   */
  export type LibraryAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * The data needed to create a LibraryAuthor.
     */
    data: XOR<LibraryAuthorCreateInput, LibraryAuthorUncheckedCreateInput>
  }


  /**
   * LibraryAuthor createMany
   */
  export type LibraryAuthorCreateManyArgs = {
    /**
     * The data used to create many LibraryAuthors.
     */
    data: Enumerable<LibraryAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryAuthor update
   */
  export type LibraryAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * The data needed to update a LibraryAuthor.
     */
    data: XOR<LibraryAuthorUpdateInput, LibraryAuthorUncheckedUpdateInput>
    /**
     * Choose, which LibraryAuthor to update.
     */
    where: LibraryAuthorWhereUniqueInput
  }


  /**
   * LibraryAuthor updateMany
   */
  export type LibraryAuthorUpdateManyArgs = {
    /**
     * The data used to update LibraryAuthors.
     */
    data: XOR<LibraryAuthorUpdateManyMutationInput, LibraryAuthorUncheckedUpdateManyInput>
    /**
     * Filter which LibraryAuthors to update
     */
    where?: LibraryAuthorWhereInput
  }


  /**
   * LibraryAuthor upsert
   */
  export type LibraryAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * The filter to search for the LibraryAuthor to update in case it exists.
     */
    where: LibraryAuthorWhereUniqueInput
    /**
     * In case the LibraryAuthor found by the `where` argument doesn't exist, create a new LibraryAuthor with this data.
     */
    create: XOR<LibraryAuthorCreateInput, LibraryAuthorUncheckedCreateInput>
    /**
     * In case the LibraryAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryAuthorUpdateInput, LibraryAuthorUncheckedUpdateInput>
  }


  /**
   * LibraryAuthor delete
   */
  export type LibraryAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
    /**
     * Filter which LibraryAuthor to delete.
     */
    where: LibraryAuthorWhereUniqueInput
  }


  /**
   * LibraryAuthor deleteMany
   */
  export type LibraryAuthorDeleteManyArgs = {
    /**
     * Filter which LibraryAuthors to delete
     */
    where?: LibraryAuthorWhereInput
  }


  /**
   * LibraryAuthor.bookAuthors
   */
  export type LibraryAuthor$bookAuthorsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    where?: LibraryBookAuthorWhereInput
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    cursor?: LibraryBookAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryAuthor without action
   */
  export type LibraryAuthorArgs = {
    /**
     * Select specific fields to fetch from the LibraryAuthor
     */
    select?: LibraryAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAuthorInclude | null
  }



  /**
   * Model LibraryBook
   */


  export type AggregateLibraryBook = {
    _count: LibraryBookCountAggregateOutputType | null
    _avg: LibraryBookAvgAggregateOutputType | null
    _sum: LibraryBookSumAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  export type LibraryBookAvgAggregateOutputType = {
    id: number | null
    isbn: number | null
  }

  export type LibraryBookSumAggregateOutputType = {
    id: number | null
    isbn: number | null
  }

  export type LibraryBookMinAggregateOutputType = {
    id: number | null
    name: string | null
    isbn: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isbn: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCountAggregateOutputType = {
    id: number
    name: number
    isbn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookAvgAggregateInputType = {
    id?: true
    isbn?: true
  }

  export type LibraryBookSumAggregateInputType = {
    id?: true
    isbn?: true
  }

  export type LibraryBookMinAggregateInputType = {
    id?: true
    name?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookMaxAggregateInputType = {
    id?: true
    name?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCountAggregateInputType = {
    id?: true
    name?: true
    isbn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookAggregateArgs = {
    /**
     * Filter which LibraryBook to aggregate.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBooks
    **/
    _count?: true | LibraryBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookMaxAggregateInputType
  }

  export type GetLibraryBookAggregateType<T extends LibraryBookAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBook[P]>
      : GetScalarType<T[P], AggregateLibraryBook[P]>
  }




  export type LibraryBookGroupByArgs = {
    where?: LibraryBookWhereInput
    orderBy?: Enumerable<LibraryBookOrderByWithAggregationInput>
    by: LibraryBookScalarFieldEnum[]
    having?: LibraryBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCountAggregateInputType | true
    _avg?: LibraryBookAvgAggregateInputType
    _sum?: LibraryBookSumAggregateInputType
    _min?: LibraryBookMinAggregateInputType
    _max?: LibraryBookMaxAggregateInputType
  }


  export type LibraryBookGroupByOutputType = {
    id: number
    name: string
    isbn: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCountAggregateOutputType | null
    _avg: LibraryBookAvgAggregateOutputType | null
    _sum: LibraryBookSumAggregateOutputType | null
    _min: LibraryBookMinAggregateOutputType | null
    _max: LibraryBookMaxAggregateOutputType | null
  }

  type GetLibraryBookGroupByPayload<T extends LibraryBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookSelect = {
    id?: boolean
    name?: boolean
    isbn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookCategories?: boolean | LibraryBook$bookCategoriesArgs
    bookAuthors?: boolean | LibraryBook$bookAuthorsArgs
    bookCopies?: boolean | LibraryBook$bookCopiesArgs
    requests?: boolean | LibraryBook$requestsArgs
    borrowings?: boolean | LibraryBook$borrowingsArgs
    _count?: boolean | LibraryBookCountOutputTypeArgs
  }


  export type LibraryBookInclude = {
    bookCategories?: boolean | LibraryBook$bookCategoriesArgs
    bookAuthors?: boolean | LibraryBook$bookAuthorsArgs
    bookCopies?: boolean | LibraryBook$bookCopiesArgs
    requests?: boolean | LibraryBook$requestsArgs
    borrowings?: boolean | LibraryBook$borrowingsArgs
    _count?: boolean | LibraryBookCountOutputTypeArgs
  }

  export type LibraryBookGetPayload<S extends boolean | null | undefined | LibraryBookArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBook :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookArgs | LibraryBookFindManyArgs)
    ? LibraryBook  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bookCategories' ? Array < LibraryBookCategoryGetPayload<S['include'][P]>>  :
        P extends 'bookAuthors' ? Array < LibraryBookAuthorGetPayload<S['include'][P]>>  :
        P extends 'bookCopies' ? Array < LibraryBookCopyGetPayload<S['include'][P]>>  :
        P extends 'requests' ? Array < LibraryRequestGetPayload<S['include'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['include'][P]>>  :
        P extends '_count' ? LibraryBookCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookArgs | LibraryBookFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bookCategories' ? Array < LibraryBookCategoryGetPayload<S['select'][P]>>  :
        P extends 'bookAuthors' ? Array < LibraryBookAuthorGetPayload<S['select'][P]>>  :
        P extends 'bookCopies' ? Array < LibraryBookCopyGetPayload<S['select'][P]>>  :
        P extends 'requests' ? Array < LibraryRequestGetPayload<S['select'][P]>>  :
        P extends 'borrowings' ? Array < LibraryBorrowingGetPayload<S['select'][P]>>  :
        P extends '_count' ? LibraryBookCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof LibraryBook ? LibraryBook[P] : never
  } 
      : LibraryBook


  type LibraryBookCountArgs = 
    Omit<LibraryBookFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCountAggregateInputType | true
    }

  export interface LibraryBookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBook that matches the filter.
     * @param {LibraryBookFindUniqueArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBook'> extends True ? Prisma__LibraryBookClient<LibraryBookGetPayload<T>> : Prisma__LibraryBookClient<LibraryBookGetPayload<T> | null, null>

    /**
     * Find one LibraryBook that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookFindUniqueOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Find the first LibraryBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBook'> extends True ? Prisma__LibraryBookClient<LibraryBookGetPayload<T>> : Prisma__LibraryBookClient<LibraryBookGetPayload<T> | null, null>

    /**
     * Find the first LibraryBook that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindFirstOrThrowArgs} args - Arguments to find a LibraryBook
     * @example
     * // Get one LibraryBook
     * const libraryBook = await prisma.libraryBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookFindFirstOrThrowArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Find zero or more LibraryBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany()
     * 
     * // Get first 10 LibraryBooks
     * const libraryBooks = await prisma.libraryBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookWithIdOnly = await prisma.libraryBook.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookFindManyArgs>(
      args?: SelectSubset<T, LibraryBookFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookGetPayload<T>>>

    /**
     * Create a LibraryBook.
     * @param {LibraryBookCreateArgs} args - Arguments to create a LibraryBook.
     * @example
     * // Create one LibraryBook
     * const LibraryBook = await prisma.libraryBook.create({
     *   data: {
     *     // ... data to create a LibraryBook
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCreateArgs>(
      args: SelectSubset<T, LibraryBookCreateArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Create many LibraryBooks.
     *     @param {LibraryBookCreateManyArgs} args - Arguments to create many LibraryBooks.
     *     @example
     *     // Create many LibraryBooks
     *     const libraryBook = await prisma.libraryBook.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBook.
     * @param {LibraryBookDeleteArgs} args - Arguments to delete one LibraryBook.
     * @example
     * // Delete one LibraryBook
     * const LibraryBook = await prisma.libraryBook.delete({
     *   where: {
     *     // ... filter to delete one LibraryBook
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookDeleteArgs>(
      args: SelectSubset<T, LibraryBookDeleteArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Update one LibraryBook.
     * @param {LibraryBookUpdateArgs} args - Arguments to update one LibraryBook.
     * @example
     * // Update one LibraryBook
     * const libraryBook = await prisma.libraryBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookUpdateArgs>(
      args: SelectSubset<T, LibraryBookUpdateArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Delete zero or more LibraryBooks.
     * @param {LibraryBookDeleteManyArgs} args - Arguments to filter LibraryBooks to delete.
     * @example
     * // Delete a few LibraryBooks
     * const { count } = await prisma.libraryBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBooks
     * const libraryBook = await prisma.libraryBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBook.
     * @param {LibraryBookUpsertArgs} args - Arguments to update or create a LibraryBook.
     * @example
     * // Update or create a LibraryBook
     * const libraryBook = await prisma.libraryBook.upsert({
     *   create: {
     *     // ... data to create a LibraryBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBook we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookUpsertArgs>(
      args: SelectSubset<T, LibraryBookUpsertArgs>
    ): Prisma__LibraryBookClient<LibraryBookGetPayload<T>>

    /**
     * Count the number of LibraryBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCountArgs} args - Arguments to filter LibraryBooks to count.
     * @example
     * // Count the number of LibraryBooks
     * const count = await prisma.libraryBook.count({
     *   where: {
     *     // ... the filter for the LibraryBooks we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCountArgs>(
      args?: Subset<T, LibraryBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookAggregateArgs>(args: Subset<T, LibraryBookAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookAggregateType<T>>

    /**
     * Group by LibraryBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bookCategories<T extends LibraryBook$bookCategoriesArgs= {}>(args?: Subset<T, LibraryBook$bookCategoriesArgs>): Prisma.PrismaPromise<Array<LibraryBookCategoryGetPayload<T>>| Null>;

    bookAuthors<T extends LibraryBook$bookAuthorsArgs= {}>(args?: Subset<T, LibraryBook$bookAuthorsArgs>): Prisma.PrismaPromise<Array<LibraryBookAuthorGetPayload<T>>| Null>;

    bookCopies<T extends LibraryBook$bookCopiesArgs= {}>(args?: Subset<T, LibraryBook$bookCopiesArgs>): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>| Null>;

    requests<T extends LibraryBook$requestsArgs= {}>(args?: Subset<T, LibraryBook$requestsArgs>): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>| Null>;

    borrowings<T extends LibraryBook$borrowingsArgs= {}>(args?: Subset<T, LibraryBook$borrowingsArgs>): Prisma.PrismaPromise<Array<LibraryBorrowingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBook base type for findUnique actions
   */
  export type LibraryBookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }

  /**
   * LibraryBook findUnique
   */
  export interface LibraryBookFindUniqueArgs extends LibraryBookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBook findUniqueOrThrow
   */
  export type LibraryBookFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook base type for findFirst actions
   */
  export type LibraryBookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }

  /**
   * LibraryBook findFirst
   */
  export interface LibraryBookFindFirstArgs extends LibraryBookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBook findFirstOrThrow
   */
  export type LibraryBookFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBook to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBooks.
     */
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }


  /**
   * LibraryBook findMany
   */
  export type LibraryBookFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter, which LibraryBooks to fetch.
     */
    where?: LibraryBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBooks to fetch.
     */
    orderBy?: Enumerable<LibraryBookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBooks.
     */
    cursor?: LibraryBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBooks.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookScalarFieldEnum>
  }


  /**
   * LibraryBook create
   */
  export type LibraryBookCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The data needed to create a LibraryBook.
     */
    data: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
  }


  /**
   * LibraryBook createMany
   */
  export type LibraryBookCreateManyArgs = {
    /**
     * The data used to create many LibraryBooks.
     */
    data: Enumerable<LibraryBookCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBook update
   */
  export type LibraryBookUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The data needed to update a LibraryBook.
     */
    data: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
    /**
     * Choose, which LibraryBook to update.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook updateMany
   */
  export type LibraryBookUpdateManyArgs = {
    /**
     * The data used to update LibraryBooks.
     */
    data: XOR<LibraryBookUpdateManyMutationInput, LibraryBookUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBooks to update
     */
    where?: LibraryBookWhereInput
  }


  /**
   * LibraryBook upsert
   */
  export type LibraryBookUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * The filter to search for the LibraryBook to update in case it exists.
     */
    where: LibraryBookWhereUniqueInput
    /**
     * In case the LibraryBook found by the `where` argument doesn't exist, create a new LibraryBook with this data.
     */
    create: XOR<LibraryBookCreateInput, LibraryBookUncheckedCreateInput>
    /**
     * In case the LibraryBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookUpdateInput, LibraryBookUncheckedUpdateInput>
  }


  /**
   * LibraryBook delete
   */
  export type LibraryBookDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
    /**
     * Filter which LibraryBook to delete.
     */
    where: LibraryBookWhereUniqueInput
  }


  /**
   * LibraryBook deleteMany
   */
  export type LibraryBookDeleteManyArgs = {
    /**
     * Filter which LibraryBooks to delete
     */
    where?: LibraryBookWhereInput
  }


  /**
   * LibraryBook.bookCategories
   */
  export type LibraryBook$bookCategoriesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    where?: LibraryBookCategoryWhereInput
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    cursor?: LibraryBookCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryBook.bookAuthors
   */
  export type LibraryBook$bookAuthorsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    where?: LibraryBookAuthorWhereInput
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    cursor?: LibraryBookAuthorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryBook.bookCopies
   */
  export type LibraryBook$bookCopiesArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    cursor?: LibraryBookCopyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBook.requests
   */
  export type LibraryBook$requestsArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    cursor?: LibraryRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryBook.borrowings
   */
  export type LibraryBook$borrowingsArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    where?: LibraryBorrowingWhereInput
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    cursor?: LibraryBorrowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }


  /**
   * LibraryBook without action
   */
  export type LibraryBookArgs = {
    /**
     * Select specific fields to fetch from the LibraryBook
     */
    select?: LibraryBookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookInclude | null
  }



  /**
   * Model LibraryBookCategory
   */


  export type AggregateLibraryBookCategory = {
    _count: LibraryBookCategoryCountAggregateOutputType | null
    _avg: LibraryBookCategoryAvgAggregateOutputType | null
    _sum: LibraryBookCategorySumAggregateOutputType | null
    _min: LibraryBookCategoryMinAggregateOutputType | null
    _max: LibraryBookCategoryMaxAggregateOutputType | null
  }

  export type LibraryBookCategoryAvgAggregateOutputType = {
    id: number | null
    bookId: number | null
    categoryId: number | null
  }

  export type LibraryBookCategorySumAggregateOutputType = {
    id: number | null
    bookId: number | null
    categoryId: number | null
  }

  export type LibraryBookCategoryMinAggregateOutputType = {
    id: number | null
    bookId: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCategoryMaxAggregateOutputType = {
    id: number | null
    bookId: number | null
    categoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCategoryCountAggregateOutputType = {
    id: number
    bookId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookCategoryAvgAggregateInputType = {
    id?: true
    bookId?: true
    categoryId?: true
  }

  export type LibraryBookCategorySumAggregateInputType = {
    id?: true
    bookId?: true
    categoryId?: true
  }

  export type LibraryBookCategoryMinAggregateInputType = {
    id?: true
    bookId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCategoryMaxAggregateInputType = {
    id?: true
    bookId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCategoryCountAggregateInputType = {
    id?: true
    bookId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookCategoryAggregateArgs = {
    /**
     * Filter which LibraryBookCategory to aggregate.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookCategories
    **/
    _count?: true | LibraryBookCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookCategoryMaxAggregateInputType
  }

  export type GetLibraryBookCategoryAggregateType<T extends LibraryBookCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookCategory[P]>
      : GetScalarType<T[P], AggregateLibraryBookCategory[P]>
  }




  export type LibraryBookCategoryGroupByArgs = {
    where?: LibraryBookCategoryWhereInput
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithAggregationInput>
    by: LibraryBookCategoryScalarFieldEnum[]
    having?: LibraryBookCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCategoryCountAggregateInputType | true
    _avg?: LibraryBookCategoryAvgAggregateInputType
    _sum?: LibraryBookCategorySumAggregateInputType
    _min?: LibraryBookCategoryMinAggregateInputType
    _max?: LibraryBookCategoryMaxAggregateInputType
  }


  export type LibraryBookCategoryGroupByOutputType = {
    id: number
    bookId: number
    categoryId: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCategoryCountAggregateOutputType | null
    _avg: LibraryBookCategoryAvgAggregateOutputType | null
    _sum: LibraryBookCategorySumAggregateOutputType | null
    _min: LibraryBookCategoryMinAggregateOutputType | null
    _max: LibraryBookCategoryMaxAggregateOutputType | null
  }

  type GetLibraryBookCategoryGroupByPayload<T extends LibraryBookCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookCategoryGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookCategorySelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    category?: boolean | LibraryCategoryArgs
    bookId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LibraryBookCategoryInclude = {
    book?: boolean | LibraryBookArgs
    category?: boolean | LibraryCategoryArgs
  }

  export type LibraryBookCategoryGetPayload<S extends boolean | null | undefined | LibraryBookCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCategory :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCategoryArgs | LibraryBookCategoryFindManyArgs)
    ? LibraryBookCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'category' ? LibraryCategoryGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookCategoryArgs | LibraryBookCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'category' ? LibraryCategoryGetPayload<S['select'][P]> :  P extends keyof LibraryBookCategory ? LibraryBookCategory[P] : never
  } 
      : LibraryBookCategory


  type LibraryBookCategoryCountArgs = 
    Omit<LibraryBookCategoryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCategoryCountAggregateInputType | true
    }

  export interface LibraryBookCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookCategory that matches the filter.
     * @param {LibraryBookCategoryFindUniqueArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookCategory'> extends True ? Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>> : Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T> | null, null>

    /**
     * Find one LibraryBookCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookCategoryFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Find the first LibraryBookCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookCategory'> extends True ? Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>> : Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindFirstOrThrowArgs} args - Arguments to find a LibraryBookCategory
     * @example
     * // Get one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindFirstOrThrowArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Find zero or more LibraryBookCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany()
     * 
     * // Get first 10 LibraryBookCategories
     * const libraryBookCategories = await prisma.libraryBookCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookCategoryWithIdOnly = await prisma.libraryBookCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookCategoryFindManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookCategoryGetPayload<T>>>

    /**
     * Create a LibraryBookCategory.
     * @param {LibraryBookCategoryCreateArgs} args - Arguments to create a LibraryBookCategory.
     * @example
     * // Create one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.create({
     *   data: {
     *     // ... data to create a LibraryBookCategory
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCategoryCreateArgs>(
      args: SelectSubset<T, LibraryBookCategoryCreateArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Create many LibraryBookCategories.
     *     @param {LibraryBookCategoryCreateManyArgs} args - Arguments to create many LibraryBookCategories.
     *     @example
     *     // Create many LibraryBookCategories
     *     const libraryBookCategory = await prisma.libraryBookCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCategoryCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookCategory.
     * @param {LibraryBookCategoryDeleteArgs} args - Arguments to delete one LibraryBookCategory.
     * @example
     * // Delete one LibraryBookCategory
     * const LibraryBookCategory = await prisma.libraryBookCategory.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookCategory
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookCategoryDeleteArgs>(
      args: SelectSubset<T, LibraryBookCategoryDeleteArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpdateArgs} args - Arguments to update one LibraryBookCategory.
     * @example
     * // Update one LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookCategoryUpdateArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Delete zero or more LibraryBookCategories.
     * @param {LibraryBookCategoryDeleteManyArgs} args - Arguments to filter LibraryBookCategories to delete.
     * @example
     * // Delete a few LibraryBookCategories
     * const { count } = await prisma.libraryBookCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookCategoryDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookCategories
     * const libraryBookCategory = await prisma.libraryBookCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookCategoryUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookCategory.
     * @param {LibraryBookCategoryUpsertArgs} args - Arguments to update or create a LibraryBookCategory.
     * @example
     * // Update or create a LibraryBookCategory
     * const libraryBookCategory = await prisma.libraryBookCategory.upsert({
     *   create: {
     *     // ... data to create a LibraryBookCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookCategory we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookCategoryUpsertArgs>(
      args: SelectSubset<T, LibraryBookCategoryUpsertArgs>
    ): Prisma__LibraryBookCategoryClient<LibraryBookCategoryGetPayload<T>>

    /**
     * Count the number of LibraryBookCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryCountArgs} args - Arguments to filter LibraryBookCategories to count.
     * @example
     * // Count the number of LibraryBookCategories
     * const count = await prisma.libraryBookCategory.count({
     *   where: {
     *     // ... the filter for the LibraryBookCategories we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCategoryCountArgs>(
      args?: Subset<T, LibraryBookCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookCategoryAggregateArgs>(args: Subset<T, LibraryBookCategoryAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookCategoryAggregateType<T>>

    /**
     * Group by LibraryBookCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookCategoryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    category<T extends LibraryCategoryArgs= {}>(args?: Subset<T, LibraryCategoryArgs>): Prisma__LibraryCategoryClient<LibraryCategoryGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookCategory base type for findUnique actions
   */
  export type LibraryBookCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }

  /**
   * LibraryBookCategory findUnique
   */
  export interface LibraryBookCategoryFindUniqueArgs extends LibraryBookCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCategory findUniqueOrThrow
   */
  export type LibraryBookCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory base type for findFirst actions
   */
  export type LibraryBookCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }

  /**
   * LibraryBookCategory findFirst
   */
  export interface LibraryBookCategoryFindFirstArgs extends LibraryBookCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCategory findFirstOrThrow
   */
  export type LibraryBookCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategory to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCategories.
     */
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryBookCategory findMany
   */
  export type LibraryBookCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter, which LibraryBookCategories to fetch.
     */
    where?: LibraryBookCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCategories to fetch.
     */
    orderBy?: Enumerable<LibraryBookCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookCategories.
     */
    cursor?: LibraryBookCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCategories.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookCategoryScalarFieldEnum>
  }


  /**
   * LibraryBookCategory create
   */
  export type LibraryBookCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The data needed to create a LibraryBookCategory.
     */
    data: XOR<LibraryBookCategoryCreateInput, LibraryBookCategoryUncheckedCreateInput>
  }


  /**
   * LibraryBookCategory createMany
   */
  export type LibraryBookCategoryCreateManyArgs = {
    /**
     * The data used to create many LibraryBookCategories.
     */
    data: Enumerable<LibraryBookCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookCategory update
   */
  export type LibraryBookCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The data needed to update a LibraryBookCategory.
     */
    data: XOR<LibraryBookCategoryUpdateInput, LibraryBookCategoryUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookCategory to update.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory updateMany
   */
  export type LibraryBookCategoryUpdateManyArgs = {
    /**
     * The data used to update LibraryBookCategories.
     */
    data: XOR<LibraryBookCategoryUpdateManyMutationInput, LibraryBookCategoryUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookCategories to update
     */
    where?: LibraryBookCategoryWhereInput
  }


  /**
   * LibraryBookCategory upsert
   */
  export type LibraryBookCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * The filter to search for the LibraryBookCategory to update in case it exists.
     */
    where: LibraryBookCategoryWhereUniqueInput
    /**
     * In case the LibraryBookCategory found by the `where` argument doesn't exist, create a new LibraryBookCategory with this data.
     */
    create: XOR<LibraryBookCategoryCreateInput, LibraryBookCategoryUncheckedCreateInput>
    /**
     * In case the LibraryBookCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookCategoryUpdateInput, LibraryBookCategoryUncheckedUpdateInput>
  }


  /**
   * LibraryBookCategory delete
   */
  export type LibraryBookCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
    /**
     * Filter which LibraryBookCategory to delete.
     */
    where: LibraryBookCategoryWhereUniqueInput
  }


  /**
   * LibraryBookCategory deleteMany
   */
  export type LibraryBookCategoryDeleteManyArgs = {
    /**
     * Filter which LibraryBookCategories to delete
     */
    where?: LibraryBookCategoryWhereInput
  }


  /**
   * LibraryBookCategory without action
   */
  export type LibraryBookCategoryArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCategory
     */
    select?: LibraryBookCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCategoryInclude | null
  }



  /**
   * Model LibraryBookAuthor
   */


  export type AggregateLibraryBookAuthor = {
    _count: LibraryBookAuthorCountAggregateOutputType | null
    _avg: LibraryBookAuthorAvgAggregateOutputType | null
    _sum: LibraryBookAuthorSumAggregateOutputType | null
    _min: LibraryBookAuthorMinAggregateOutputType | null
    _max: LibraryBookAuthorMaxAggregateOutputType | null
  }

  export type LibraryBookAuthorAvgAggregateOutputType = {
    id: number | null
    bookId: number | null
    authorId: number | null
  }

  export type LibraryBookAuthorSumAggregateOutputType = {
    id: number | null
    bookId: number | null
    authorId: number | null
  }

  export type LibraryBookAuthorMinAggregateOutputType = {
    id: number | null
    bookId: number | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookAuthorMaxAggregateOutputType = {
    id: number | null
    bookId: number | null
    authorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookAuthorCountAggregateOutputType = {
    id: number
    bookId: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookAuthorAvgAggregateInputType = {
    id?: true
    bookId?: true
    authorId?: true
  }

  export type LibraryBookAuthorSumAggregateInputType = {
    id?: true
    bookId?: true
    authorId?: true
  }

  export type LibraryBookAuthorMinAggregateInputType = {
    id?: true
    bookId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookAuthorMaxAggregateInputType = {
    id?: true
    bookId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookAuthorCountAggregateInputType = {
    id?: true
    bookId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookAuthorAggregateArgs = {
    /**
     * Filter which LibraryBookAuthor to aggregate.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookAuthors
    **/
    _count?: true | LibraryBookAuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookAuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookAuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookAuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookAuthorMaxAggregateInputType
  }

  export type GetLibraryBookAuthorAggregateType<T extends LibraryBookAuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookAuthor[P]>
      : GetScalarType<T[P], AggregateLibraryBookAuthor[P]>
  }




  export type LibraryBookAuthorGroupByArgs = {
    where?: LibraryBookAuthorWhereInput
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithAggregationInput>
    by: LibraryBookAuthorScalarFieldEnum[]
    having?: LibraryBookAuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookAuthorCountAggregateInputType | true
    _avg?: LibraryBookAuthorAvgAggregateInputType
    _sum?: LibraryBookAuthorSumAggregateInputType
    _min?: LibraryBookAuthorMinAggregateInputType
    _max?: LibraryBookAuthorMaxAggregateInputType
  }


  export type LibraryBookAuthorGroupByOutputType = {
    id: number
    bookId: number
    authorId: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookAuthorCountAggregateOutputType | null
    _avg: LibraryBookAuthorAvgAggregateOutputType | null
    _sum: LibraryBookAuthorSumAggregateOutputType | null
    _min: LibraryBookAuthorMinAggregateOutputType | null
    _max: LibraryBookAuthorMaxAggregateOutputType | null
  }

  type GetLibraryBookAuthorGroupByPayload<T extends LibraryBookAuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookAuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookAuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookAuthorGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookAuthorGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookAuthorSelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    author?: boolean | LibraryAuthorArgs
    bookId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LibraryBookAuthorInclude = {
    book?: boolean | LibraryBookArgs
    author?: boolean | LibraryAuthorArgs
  }

  export type LibraryBookAuthorGetPayload<S extends boolean | null | undefined | LibraryBookAuthorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookAuthor :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookAuthorArgs | LibraryBookAuthorFindManyArgs)
    ? LibraryBookAuthor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'author' ? LibraryAuthorGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookAuthorArgs | LibraryBookAuthorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'author' ? LibraryAuthorGetPayload<S['select'][P]> :  P extends keyof LibraryBookAuthor ? LibraryBookAuthor[P] : never
  } 
      : LibraryBookAuthor


  type LibraryBookAuthorCountArgs = 
    Omit<LibraryBookAuthorFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookAuthorCountAggregateInputType | true
    }

  export interface LibraryBookAuthorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookAuthor that matches the filter.
     * @param {LibraryBookAuthorFindUniqueArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookAuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookAuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookAuthor'> extends True ? Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>> : Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T> | null, null>

    /**
     * Find one LibraryBookAuthor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookAuthorFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookAuthorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Find the first LibraryBookAuthor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindFirstArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookAuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookAuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookAuthor'> extends True ? Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>> : Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookAuthor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindFirstOrThrowArgs} args - Arguments to find a LibraryBookAuthor
     * @example
     * // Get one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookAuthorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindFirstOrThrowArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Find zero or more LibraryBookAuthors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookAuthors
     * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany()
     * 
     * // Get first 10 LibraryBookAuthors
     * const libraryBookAuthors = await prisma.libraryBookAuthor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookAuthorWithIdOnly = await prisma.libraryBookAuthor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookAuthorFindManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookAuthorGetPayload<T>>>

    /**
     * Create a LibraryBookAuthor.
     * @param {LibraryBookAuthorCreateArgs} args - Arguments to create a LibraryBookAuthor.
     * @example
     * // Create one LibraryBookAuthor
     * const LibraryBookAuthor = await prisma.libraryBookAuthor.create({
     *   data: {
     *     // ... data to create a LibraryBookAuthor
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookAuthorCreateArgs>(
      args: SelectSubset<T, LibraryBookAuthorCreateArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Create many LibraryBookAuthors.
     *     @param {LibraryBookAuthorCreateManyArgs} args - Arguments to create many LibraryBookAuthors.
     *     @example
     *     // Create many LibraryBookAuthors
     *     const libraryBookAuthor = await prisma.libraryBookAuthor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookAuthorCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookAuthor.
     * @param {LibraryBookAuthorDeleteArgs} args - Arguments to delete one LibraryBookAuthor.
     * @example
     * // Delete one LibraryBookAuthor
     * const LibraryBookAuthor = await prisma.libraryBookAuthor.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookAuthor
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookAuthorDeleteArgs>(
      args: SelectSubset<T, LibraryBookAuthorDeleteArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Update one LibraryBookAuthor.
     * @param {LibraryBookAuthorUpdateArgs} args - Arguments to update one LibraryBookAuthor.
     * @example
     * // Update one LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookAuthorUpdateArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpdateArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Delete zero or more LibraryBookAuthors.
     * @param {LibraryBookAuthorDeleteManyArgs} args - Arguments to filter LibraryBookAuthors to delete.
     * @example
     * // Delete a few LibraryBookAuthors
     * const { count } = await prisma.libraryBookAuthor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookAuthorDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookAuthorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookAuthors
     * const libraryBookAuthor = await prisma.libraryBookAuthor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookAuthorUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookAuthor.
     * @param {LibraryBookAuthorUpsertArgs} args - Arguments to update or create a LibraryBookAuthor.
     * @example
     * // Update or create a LibraryBookAuthor
     * const libraryBookAuthor = await prisma.libraryBookAuthor.upsert({
     *   create: {
     *     // ... data to create a LibraryBookAuthor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookAuthor we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookAuthorUpsertArgs>(
      args: SelectSubset<T, LibraryBookAuthorUpsertArgs>
    ): Prisma__LibraryBookAuthorClient<LibraryBookAuthorGetPayload<T>>

    /**
     * Count the number of LibraryBookAuthors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorCountArgs} args - Arguments to filter LibraryBookAuthors to count.
     * @example
     * // Count the number of LibraryBookAuthors
     * const count = await prisma.libraryBookAuthor.count({
     *   where: {
     *     // ... the filter for the LibraryBookAuthors we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookAuthorCountArgs>(
      args?: Subset<T, LibraryBookAuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookAuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookAuthorAggregateArgs>(args: Subset<T, LibraryBookAuthorAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookAuthorAggregateType<T>>

    /**
     * Group by LibraryBookAuthor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookAuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookAuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookAuthorGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookAuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookAuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookAuthor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookAuthorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    author<T extends LibraryAuthorArgs= {}>(args?: Subset<T, LibraryAuthorArgs>): Prisma__LibraryAuthorClient<LibraryAuthorGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookAuthor base type for findUnique actions
   */
  export type LibraryBookAuthorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }

  /**
   * LibraryBookAuthor findUnique
   */
  export interface LibraryBookAuthorFindUniqueArgs extends LibraryBookAuthorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookAuthor findUniqueOrThrow
   */
  export type LibraryBookAuthorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor base type for findFirst actions
   */
  export type LibraryBookAuthorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookAuthors.
     */
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }

  /**
   * LibraryBookAuthor findFirst
   */
  export interface LibraryBookAuthorFindFirstArgs extends LibraryBookAuthorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookAuthor findFirstOrThrow
   */
  export type LibraryBookAuthorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthor to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookAuthors.
     */
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookAuthor findMany
   */
  export type LibraryBookAuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter, which LibraryBookAuthors to fetch.
     */
    where?: LibraryBookAuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookAuthors to fetch.
     */
    orderBy?: Enumerable<LibraryBookAuthorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookAuthors.
     */
    cursor?: LibraryBookAuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookAuthors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookAuthors.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookAuthorScalarFieldEnum>
  }


  /**
   * LibraryBookAuthor create
   */
  export type LibraryBookAuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The data needed to create a LibraryBookAuthor.
     */
    data: XOR<LibraryBookAuthorCreateInput, LibraryBookAuthorUncheckedCreateInput>
  }


  /**
   * LibraryBookAuthor createMany
   */
  export type LibraryBookAuthorCreateManyArgs = {
    /**
     * The data used to create many LibraryBookAuthors.
     */
    data: Enumerable<LibraryBookAuthorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookAuthor update
   */
  export type LibraryBookAuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The data needed to update a LibraryBookAuthor.
     */
    data: XOR<LibraryBookAuthorUpdateInput, LibraryBookAuthorUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookAuthor to update.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor updateMany
   */
  export type LibraryBookAuthorUpdateManyArgs = {
    /**
     * The data used to update LibraryBookAuthors.
     */
    data: XOR<LibraryBookAuthorUpdateManyMutationInput, LibraryBookAuthorUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookAuthors to update
     */
    where?: LibraryBookAuthorWhereInput
  }


  /**
   * LibraryBookAuthor upsert
   */
  export type LibraryBookAuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * The filter to search for the LibraryBookAuthor to update in case it exists.
     */
    where: LibraryBookAuthorWhereUniqueInput
    /**
     * In case the LibraryBookAuthor found by the `where` argument doesn't exist, create a new LibraryBookAuthor with this data.
     */
    create: XOR<LibraryBookAuthorCreateInput, LibraryBookAuthorUncheckedCreateInput>
    /**
     * In case the LibraryBookAuthor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookAuthorUpdateInput, LibraryBookAuthorUncheckedUpdateInput>
  }


  /**
   * LibraryBookAuthor delete
   */
  export type LibraryBookAuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
    /**
     * Filter which LibraryBookAuthor to delete.
     */
    where: LibraryBookAuthorWhereUniqueInput
  }


  /**
   * LibraryBookAuthor deleteMany
   */
  export type LibraryBookAuthorDeleteManyArgs = {
    /**
     * Filter which LibraryBookAuthors to delete
     */
    where?: LibraryBookAuthorWhereInput
  }


  /**
   * LibraryBookAuthor without action
   */
  export type LibraryBookAuthorArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookAuthor
     */
    select?: LibraryBookAuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookAuthorInclude | null
  }



  /**
   * Model LibraryBookCopy
   */


  export type AggregateLibraryBookCopy = {
    _count: LibraryBookCopyCountAggregateOutputType | null
    _avg: LibraryBookCopyAvgAggregateOutputType | null
    _sum: LibraryBookCopySumAggregateOutputType | null
    _min: LibraryBookCopyMinAggregateOutputType | null
    _max: LibraryBookCopyMaxAggregateOutputType | null
  }

  export type LibraryBookCopyAvgAggregateOutputType = {
    id: number | null
    bookId: number | null
    universityId: number | null
  }

  export type LibraryBookCopySumAggregateOutputType = {
    id: number | null
    bookId: number | null
    universityId: number | null
  }

  export type LibraryBookCopyMinAggregateOutputType = {
    id: number | null
    bookId: number | null
    universityId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCopyMaxAggregateOutputType = {
    id: number | null
    bookId: number | null
    universityId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBookCopyCountAggregateOutputType = {
    id: number
    bookId: number
    universityId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBookCopyAvgAggregateInputType = {
    id?: true
    bookId?: true
    universityId?: true
  }

  export type LibraryBookCopySumAggregateInputType = {
    id?: true
    bookId?: true
    universityId?: true
  }

  export type LibraryBookCopyMinAggregateInputType = {
    id?: true
    bookId?: true
    universityId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCopyMaxAggregateInputType = {
    id?: true
    bookId?: true
    universityId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBookCopyCountAggregateInputType = {
    id?: true
    bookId?: true
    universityId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBookCopyAggregateArgs = {
    /**
     * Filter which LibraryBookCopy to aggregate.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBookCopies
    **/
    _count?: true | LibraryBookCopyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBookCopyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBookCopySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBookCopyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBookCopyMaxAggregateInputType
  }

  export type GetLibraryBookCopyAggregateType<T extends LibraryBookCopyAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBookCopy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBookCopy[P]>
      : GetScalarType<T[P], AggregateLibraryBookCopy[P]>
  }




  export type LibraryBookCopyGroupByArgs = {
    where?: LibraryBookCopyWhereInput
    orderBy?: Enumerable<LibraryBookCopyOrderByWithAggregationInput>
    by: LibraryBookCopyScalarFieldEnum[]
    having?: LibraryBookCopyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBookCopyCountAggregateInputType | true
    _avg?: LibraryBookCopyAvgAggregateInputType
    _sum?: LibraryBookCopySumAggregateInputType
    _min?: LibraryBookCopyMinAggregateInputType
    _max?: LibraryBookCopyMaxAggregateInputType
  }


  export type LibraryBookCopyGroupByOutputType = {
    id: number
    bookId: number
    universityId: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LibraryBookCopyCountAggregateOutputType | null
    _avg: LibraryBookCopyAvgAggregateOutputType | null
    _sum: LibraryBookCopySumAggregateOutputType | null
    _min: LibraryBookCopyMinAggregateOutputType | null
    _max: LibraryBookCopyMaxAggregateOutputType | null
  }

  type GetLibraryBookCopyGroupByPayload<T extends LibraryBookCopyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBookCopyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBookCopyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBookCopyGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBookCopyGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBookCopySelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    university?: boolean | LibraryUniversityArgs
    bookId?: boolean
    universityId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LibraryBookCopyInclude = {
    book?: boolean | LibraryBookArgs
    university?: boolean | LibraryUniversityArgs
  }

  export type LibraryBookCopyGetPayload<S extends boolean | null | undefined | LibraryBookCopyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBookCopy :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBookCopyArgs | LibraryBookCopyFindManyArgs)
    ? LibraryBookCopy  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBookCopyArgs | LibraryBookCopyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['select'][P]> :  P extends keyof LibraryBookCopy ? LibraryBookCopy[P] : never
  } 
      : LibraryBookCopy


  type LibraryBookCopyCountArgs = 
    Omit<LibraryBookCopyFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBookCopyCountAggregateInputType | true
    }

  export interface LibraryBookCopyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBookCopy that matches the filter.
     * @param {LibraryBookCopyFindUniqueArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBookCopyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBookCopyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBookCopy'> extends True ? Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>> : Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | null, null>

    /**
     * Find one LibraryBookCopy that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBookCopyFindUniqueOrThrowArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBookCopyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindUniqueOrThrowArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Find the first LibraryBookCopy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindFirstArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBookCopyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBookCopyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBookCopy'> extends True ? Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>> : Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T> | null, null>

    /**
     * Find the first LibraryBookCopy that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindFirstOrThrowArgs} args - Arguments to find a LibraryBookCopy
     * @example
     * // Get one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBookCopyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindFirstOrThrowArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Find zero or more LibraryBookCopies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBookCopies
     * const libraryBookCopies = await prisma.libraryBookCopy.findMany()
     * 
     * // Get first 10 LibraryBookCopies
     * const libraryBookCopies = await prisma.libraryBookCopy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBookCopyWithIdOnly = await prisma.libraryBookCopy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBookCopyFindManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBookCopyGetPayload<T>>>

    /**
     * Create a LibraryBookCopy.
     * @param {LibraryBookCopyCreateArgs} args - Arguments to create a LibraryBookCopy.
     * @example
     * // Create one LibraryBookCopy
     * const LibraryBookCopy = await prisma.libraryBookCopy.create({
     *   data: {
     *     // ... data to create a LibraryBookCopy
     *   }
     * })
     * 
    **/
    create<T extends LibraryBookCopyCreateArgs>(
      args: SelectSubset<T, LibraryBookCopyCreateArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Create many LibraryBookCopies.
     *     @param {LibraryBookCopyCreateManyArgs} args - Arguments to create many LibraryBookCopies.
     *     @example
     *     // Create many LibraryBookCopies
     *     const libraryBookCopy = await prisma.libraryBookCopy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBookCopyCreateManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBookCopy.
     * @param {LibraryBookCopyDeleteArgs} args - Arguments to delete one LibraryBookCopy.
     * @example
     * // Delete one LibraryBookCopy
     * const LibraryBookCopy = await prisma.libraryBookCopy.delete({
     *   where: {
     *     // ... filter to delete one LibraryBookCopy
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBookCopyDeleteArgs>(
      args: SelectSubset<T, LibraryBookCopyDeleteArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Update one LibraryBookCopy.
     * @param {LibraryBookCopyUpdateArgs} args - Arguments to update one LibraryBookCopy.
     * @example
     * // Update one LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBookCopyUpdateArgs>(
      args: SelectSubset<T, LibraryBookCopyUpdateArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Delete zero or more LibraryBookCopies.
     * @param {LibraryBookCopyDeleteManyArgs} args - Arguments to filter LibraryBookCopies to delete.
     * @example
     * // Delete a few LibraryBookCopies
     * const { count } = await prisma.libraryBookCopy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBookCopyDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBookCopyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBookCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBookCopies
     * const libraryBookCopy = await prisma.libraryBookCopy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBookCopyUpdateManyArgs>(
      args: SelectSubset<T, LibraryBookCopyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBookCopy.
     * @param {LibraryBookCopyUpsertArgs} args - Arguments to update or create a LibraryBookCopy.
     * @example
     * // Update or create a LibraryBookCopy
     * const libraryBookCopy = await prisma.libraryBookCopy.upsert({
     *   create: {
     *     // ... data to create a LibraryBookCopy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBookCopy we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBookCopyUpsertArgs>(
      args: SelectSubset<T, LibraryBookCopyUpsertArgs>
    ): Prisma__LibraryBookCopyClient<LibraryBookCopyGetPayload<T>>

    /**
     * Count the number of LibraryBookCopies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyCountArgs} args - Arguments to filter LibraryBookCopies to count.
     * @example
     * // Count the number of LibraryBookCopies
     * const count = await prisma.libraryBookCopy.count({
     *   where: {
     *     // ... the filter for the LibraryBookCopies we want to count
     *   }
     * })
    **/
    count<T extends LibraryBookCopyCountArgs>(
      args?: Subset<T, LibraryBookCopyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBookCopyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBookCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBookCopyAggregateArgs>(args: Subset<T, LibraryBookCopyAggregateArgs>): Prisma.PrismaPromise<GetLibraryBookCopyAggregateType<T>>

    /**
     * Group by LibraryBookCopy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBookCopyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBookCopyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBookCopyGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBookCopyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBookCopyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBookCopyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBookCopy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBookCopyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    university<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBookCopy base type for findUnique actions
   */
  export type LibraryBookCopyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where: LibraryBookCopyWhereUniqueInput
  }

  /**
   * LibraryBookCopy findUnique
   */
  export interface LibraryBookCopyFindUniqueArgs extends LibraryBookCopyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCopy findUniqueOrThrow
   */
  export type LibraryBookCopyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy base type for findFirst actions
   */
  export type LibraryBookCopyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCopies.
     */
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }

  /**
   * LibraryBookCopy findFirst
   */
  export interface LibraryBookCopyFindFirstArgs extends LibraryBookCopyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBookCopy findFirstOrThrow
   */
  export type LibraryBookCopyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopy to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBookCopies.
     */
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBookCopy findMany
   */
  export type LibraryBookCopyFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter, which LibraryBookCopies to fetch.
     */
    where?: LibraryBookCopyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBookCopies to fetch.
     */
    orderBy?: Enumerable<LibraryBookCopyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBookCopies.
     */
    cursor?: LibraryBookCopyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBookCopies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBookCopies.
     */
    skip?: number
    distinct?: Enumerable<LibraryBookCopyScalarFieldEnum>
  }


  /**
   * LibraryBookCopy create
   */
  export type LibraryBookCopyCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The data needed to create a LibraryBookCopy.
     */
    data: XOR<LibraryBookCopyCreateInput, LibraryBookCopyUncheckedCreateInput>
  }


  /**
   * LibraryBookCopy createMany
   */
  export type LibraryBookCopyCreateManyArgs = {
    /**
     * The data used to create many LibraryBookCopies.
     */
    data: Enumerable<LibraryBookCopyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBookCopy update
   */
  export type LibraryBookCopyUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The data needed to update a LibraryBookCopy.
     */
    data: XOR<LibraryBookCopyUpdateInput, LibraryBookCopyUncheckedUpdateInput>
    /**
     * Choose, which LibraryBookCopy to update.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy updateMany
   */
  export type LibraryBookCopyUpdateManyArgs = {
    /**
     * The data used to update LibraryBookCopies.
     */
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBookCopies to update
     */
    where?: LibraryBookCopyWhereInput
  }


  /**
   * LibraryBookCopy upsert
   */
  export type LibraryBookCopyUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * The filter to search for the LibraryBookCopy to update in case it exists.
     */
    where: LibraryBookCopyWhereUniqueInput
    /**
     * In case the LibraryBookCopy found by the `where` argument doesn't exist, create a new LibraryBookCopy with this data.
     */
    create: XOR<LibraryBookCopyCreateInput, LibraryBookCopyUncheckedCreateInput>
    /**
     * In case the LibraryBookCopy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBookCopyUpdateInput, LibraryBookCopyUncheckedUpdateInput>
  }


  /**
   * LibraryBookCopy delete
   */
  export type LibraryBookCopyDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
    /**
     * Filter which LibraryBookCopy to delete.
     */
    where: LibraryBookCopyWhereUniqueInput
  }


  /**
   * LibraryBookCopy deleteMany
   */
  export type LibraryBookCopyDeleteManyArgs = {
    /**
     * Filter which LibraryBookCopies to delete
     */
    where?: LibraryBookCopyWhereInput
  }


  /**
   * LibraryBookCopy without action
   */
  export type LibraryBookCopyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBookCopy
     */
    select?: LibraryBookCopySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBookCopyInclude | null
  }



  /**
   * Model LibraryRequest
   */


  export type AggregateLibraryRequest = {
    _count: LibraryRequestCountAggregateOutputType | null
    _avg: LibraryRequestAvgAggregateOutputType | null
    _sum: LibraryRequestSumAggregateOutputType | null
    _min: LibraryRequestMinAggregateOutputType | null
    _max: LibraryRequestMaxAggregateOutputType | null
  }

  export type LibraryRequestAvgAggregateOutputType = {
    id: number | null
    bookId: number | null
    studentId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
  }

  export type LibraryRequestSumAggregateOutputType = {
    id: number | null
    bookId: number | null
    studentId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
  }

  export type LibraryRequestMinAggregateOutputType = {
    id: number | null
    borrowDate: Date | null
    returnDate: Date | null
    bookId: number | null
    studentId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryRequestMaxAggregateOutputType = {
    id: number | null
    borrowDate: Date | null
    returnDate: Date | null
    bookId: number | null
    studentId: number | null
    fromUniversityId: number | null
    toUniversityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryRequestCountAggregateOutputType = {
    id: number
    borrowDate: number
    returnDate: number
    bookId: number
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryRequestAvgAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    fromUniversityId?: true
    toUniversityId?: true
  }

  export type LibraryRequestSumAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    fromUniversityId?: true
    toUniversityId?: true
  }

  export type LibraryRequestMinAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    bookId?: true
    studentId?: true
    fromUniversityId?: true
    toUniversityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryRequestMaxAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    bookId?: true
    studentId?: true
    fromUniversityId?: true
    toUniversityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryRequestCountAggregateInputType = {
    id?: true
    borrowDate?: true
    returnDate?: true
    bookId?: true
    studentId?: true
    fromUniversityId?: true
    toUniversityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryRequestAggregateArgs = {
    /**
     * Filter which LibraryRequest to aggregate.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryRequests
    **/
    _count?: true | LibraryRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryRequestMaxAggregateInputType
  }

  export type GetLibraryRequestAggregateType<T extends LibraryRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryRequest[P]>
      : GetScalarType<T[P], AggregateLibraryRequest[P]>
  }




  export type LibraryRequestGroupByArgs = {
    where?: LibraryRequestWhereInput
    orderBy?: Enumerable<LibraryRequestOrderByWithAggregationInput>
    by: LibraryRequestScalarFieldEnum[]
    having?: LibraryRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryRequestCountAggregateInputType | true
    _avg?: LibraryRequestAvgAggregateInputType
    _sum?: LibraryRequestSumAggregateInputType
    _min?: LibraryRequestMinAggregateInputType
    _max?: LibraryRequestMaxAggregateInputType
  }


  export type LibraryRequestGroupByOutputType = {
    id: number
    borrowDate: Date
    returnDate: Date
    bookId: number
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryRequestCountAggregateOutputType | null
    _avg: LibraryRequestAvgAggregateOutputType | null
    _sum: LibraryRequestSumAggregateOutputType | null
    _min: LibraryRequestMinAggregateOutputType | null
    _max: LibraryRequestMaxAggregateOutputType | null
  }

  type GetLibraryRequestGroupByPayload<T extends LibraryRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryRequestGroupByOutputType[P]>
        }
      >
    >


  export type LibraryRequestSelect = {
    id?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    book?: boolean | LibraryBookArgs
    student?: boolean | LibraryStudentArgs
    fromUniversity?: boolean | LibraryUniversityArgs
    toUniversity?: boolean | LibraryUniversityArgs
    bookId?: boolean
    studentId?: boolean
    fromUniversityId?: boolean
    toUniversityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LibraryRequestInclude = {
    book?: boolean | LibraryBookArgs
    student?: boolean | LibraryStudentArgs
    fromUniversity?: boolean | LibraryUniversityArgs
    toUniversity?: boolean | LibraryUniversityArgs
  }

  export type LibraryRequestGetPayload<S extends boolean | null | undefined | LibraryRequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryRequest :
    S extends undefined ? never :
    S extends { include: any } & (LibraryRequestArgs | LibraryRequestFindManyArgs)
    ? LibraryRequest  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'student' ? LibraryStudentGetPayload<S['include'][P]> :
        P extends 'fromUniversity' ? LibraryUniversityGetPayload<S['include'][P]> :
        P extends 'toUniversity' ? LibraryUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryRequestArgs | LibraryRequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'student' ? LibraryStudentGetPayload<S['select'][P]> :
        P extends 'fromUniversity' ? LibraryUniversityGetPayload<S['select'][P]> :
        P extends 'toUniversity' ? LibraryUniversityGetPayload<S['select'][P]> :  P extends keyof LibraryRequest ? LibraryRequest[P] : never
  } 
      : LibraryRequest


  type LibraryRequestCountArgs = 
    Omit<LibraryRequestFindManyArgs, 'select' | 'include'> & {
      select?: LibraryRequestCountAggregateInputType | true
    }

  export interface LibraryRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryRequest that matches the filter.
     * @param {LibraryRequestFindUniqueArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryRequest'> extends True ? Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>> : Prisma__LibraryRequestClient<LibraryRequestGetPayload<T> | null, null>

    /**
     * Find one LibraryRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryRequestFindUniqueOrThrowArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryRequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryRequestFindUniqueOrThrowArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Find the first LibraryRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindFirstArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryRequest'> extends True ? Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>> : Prisma__LibraryRequestClient<LibraryRequestGetPayload<T> | null, null>

    /**
     * Find the first LibraryRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindFirstOrThrowArgs} args - Arguments to find a LibraryRequest
     * @example
     * // Get one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryRequestFindFirstOrThrowArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Find zero or more LibraryRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryRequests
     * const libraryRequests = await prisma.libraryRequest.findMany()
     * 
     * // Get first 10 LibraryRequests
     * const libraryRequests = await prisma.libraryRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryRequestWithIdOnly = await prisma.libraryRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryRequestFindManyArgs>(
      args?: SelectSubset<T, LibraryRequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryRequestGetPayload<T>>>

    /**
     * Create a LibraryRequest.
     * @param {LibraryRequestCreateArgs} args - Arguments to create a LibraryRequest.
     * @example
     * // Create one LibraryRequest
     * const LibraryRequest = await prisma.libraryRequest.create({
     *   data: {
     *     // ... data to create a LibraryRequest
     *   }
     * })
     * 
    **/
    create<T extends LibraryRequestCreateArgs>(
      args: SelectSubset<T, LibraryRequestCreateArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Create many LibraryRequests.
     *     @param {LibraryRequestCreateManyArgs} args - Arguments to create many LibraryRequests.
     *     @example
     *     // Create many LibraryRequests
     *     const libraryRequest = await prisma.libraryRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryRequestCreateManyArgs>(
      args?: SelectSubset<T, LibraryRequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryRequest.
     * @param {LibraryRequestDeleteArgs} args - Arguments to delete one LibraryRequest.
     * @example
     * // Delete one LibraryRequest
     * const LibraryRequest = await prisma.libraryRequest.delete({
     *   where: {
     *     // ... filter to delete one LibraryRequest
     *   }
     * })
     * 
    **/
    delete<T extends LibraryRequestDeleteArgs>(
      args: SelectSubset<T, LibraryRequestDeleteArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Update one LibraryRequest.
     * @param {LibraryRequestUpdateArgs} args - Arguments to update one LibraryRequest.
     * @example
     * // Update one LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryRequestUpdateArgs>(
      args: SelectSubset<T, LibraryRequestUpdateArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Delete zero or more LibraryRequests.
     * @param {LibraryRequestDeleteManyArgs} args - Arguments to filter LibraryRequests to delete.
     * @example
     * // Delete a few LibraryRequests
     * const { count } = await prisma.libraryRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryRequestDeleteManyArgs>(
      args?: SelectSubset<T, LibraryRequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryRequests
     * const libraryRequest = await prisma.libraryRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryRequestUpdateManyArgs>(
      args: SelectSubset<T, LibraryRequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryRequest.
     * @param {LibraryRequestUpsertArgs} args - Arguments to update or create a LibraryRequest.
     * @example
     * // Update or create a LibraryRequest
     * const libraryRequest = await prisma.libraryRequest.upsert({
     *   create: {
     *     // ... data to create a LibraryRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryRequest we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryRequestUpsertArgs>(
      args: SelectSubset<T, LibraryRequestUpsertArgs>
    ): Prisma__LibraryRequestClient<LibraryRequestGetPayload<T>>

    /**
     * Count the number of LibraryRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestCountArgs} args - Arguments to filter LibraryRequests to count.
     * @example
     * // Count the number of LibraryRequests
     * const count = await prisma.libraryRequest.count({
     *   where: {
     *     // ... the filter for the LibraryRequests we want to count
     *   }
     * })
    **/
    count<T extends LibraryRequestCountArgs>(
      args?: Subset<T, LibraryRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryRequestAggregateArgs>(args: Subset<T, LibraryRequestAggregateArgs>): Prisma.PrismaPromise<GetLibraryRequestAggregateType<T>>

    /**
     * Group by LibraryRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryRequestGroupByArgs['orderBy'] }
        : { orderBy?: LibraryRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryRequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    student<T extends LibraryStudentArgs= {}>(args?: Subset<T, LibraryStudentArgs>): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | Null>;

    fromUniversity<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    toUniversity<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryRequest base type for findUnique actions
   */
  export type LibraryRequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where: LibraryRequestWhereUniqueInput
  }

  /**
   * LibraryRequest findUnique
   */
  export interface LibraryRequestFindUniqueArgs extends LibraryRequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryRequest findUniqueOrThrow
   */
  export type LibraryRequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest base type for findFirst actions
   */
  export type LibraryRequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryRequests.
     */
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }

  /**
   * LibraryRequest findFirst
   */
  export interface LibraryRequestFindFirstArgs extends LibraryRequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryRequest findFirstOrThrow
   */
  export type LibraryRequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequest to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryRequests.
     */
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryRequest findMany
   */
  export type LibraryRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter, which LibraryRequests to fetch.
     */
    where?: LibraryRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryRequests to fetch.
     */
    orderBy?: Enumerable<LibraryRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryRequests.
     */
    cursor?: LibraryRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryRequests.
     */
    skip?: number
    distinct?: Enumerable<LibraryRequestScalarFieldEnum>
  }


  /**
   * LibraryRequest create
   */
  export type LibraryRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The data needed to create a LibraryRequest.
     */
    data: XOR<LibraryRequestCreateInput, LibraryRequestUncheckedCreateInput>
  }


  /**
   * LibraryRequest createMany
   */
  export type LibraryRequestCreateManyArgs = {
    /**
     * The data used to create many LibraryRequests.
     */
    data: Enumerable<LibraryRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryRequest update
   */
  export type LibraryRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The data needed to update a LibraryRequest.
     */
    data: XOR<LibraryRequestUpdateInput, LibraryRequestUncheckedUpdateInput>
    /**
     * Choose, which LibraryRequest to update.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest updateMany
   */
  export type LibraryRequestUpdateManyArgs = {
    /**
     * The data used to update LibraryRequests.
     */
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyInput>
    /**
     * Filter which LibraryRequests to update
     */
    where?: LibraryRequestWhereInput
  }


  /**
   * LibraryRequest upsert
   */
  export type LibraryRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * The filter to search for the LibraryRequest to update in case it exists.
     */
    where: LibraryRequestWhereUniqueInput
    /**
     * In case the LibraryRequest found by the `where` argument doesn't exist, create a new LibraryRequest with this data.
     */
    create: XOR<LibraryRequestCreateInput, LibraryRequestUncheckedCreateInput>
    /**
     * In case the LibraryRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryRequestUpdateInput, LibraryRequestUncheckedUpdateInput>
  }


  /**
   * LibraryRequest delete
   */
  export type LibraryRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
    /**
     * Filter which LibraryRequest to delete.
     */
    where: LibraryRequestWhereUniqueInput
  }


  /**
   * LibraryRequest deleteMany
   */
  export type LibraryRequestDeleteManyArgs = {
    /**
     * Filter which LibraryRequests to delete
     */
    where?: LibraryRequestWhereInput
  }


  /**
   * LibraryRequest without action
   */
  export type LibraryRequestArgs = {
    /**
     * Select specific fields to fetch from the LibraryRequest
     */
    select?: LibraryRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryRequestInclude | null
  }



  /**
   * Model LibraryBorrowing
   */


  export type AggregateLibraryBorrowing = {
    _count: LibraryBorrowingCountAggregateOutputType | null
    _avg: LibraryBorrowingAvgAggregateOutputType | null
    _sum: LibraryBorrowingSumAggregateOutputType | null
    _min: LibraryBorrowingMinAggregateOutputType | null
    _max: LibraryBorrowingMaxAggregateOutputType | null
  }

  export type LibraryBorrowingAvgAggregateOutputType = {
    id: number | null
    bookId: number | null
    studentId: number | null
    universityId: number | null
  }

  export type LibraryBorrowingSumAggregateOutputType = {
    id: number | null
    bookId: number | null
    studentId: number | null
    universityId: number | null
  }

  export type LibraryBorrowingMinAggregateOutputType = {
    id: number | null
    bookId: number | null
    borrowDate: Date | null
    returnDate: Date | null
    actualReturnDate: Date | null
    studentId: number | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBorrowingMaxAggregateOutputType = {
    id: number | null
    bookId: number | null
    borrowDate: Date | null
    returnDate: Date | null
    actualReturnDate: Date | null
    studentId: number | null
    universityId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryBorrowingCountAggregateOutputType = {
    id: number
    bookId: number
    borrowDate: number
    returnDate: number
    actualReturnDate: number
    studentId: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryBorrowingAvgAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    universityId?: true
  }

  export type LibraryBorrowingSumAggregateInputType = {
    id?: true
    bookId?: true
    studentId?: true
    universityId?: true
  }

  export type LibraryBorrowingMinAggregateInputType = {
    id?: true
    bookId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    studentId?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBorrowingMaxAggregateInputType = {
    id?: true
    bookId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    studentId?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryBorrowingCountAggregateInputType = {
    id?: true
    bookId?: true
    borrowDate?: true
    returnDate?: true
    actualReturnDate?: true
    studentId?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryBorrowingAggregateArgs = {
    /**
     * Filter which LibraryBorrowing to aggregate.
     */
    where?: LibraryBorrowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowings to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryBorrowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryBorrowings
    **/
    _count?: true | LibraryBorrowingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryBorrowingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibraryBorrowingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryBorrowingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryBorrowingMaxAggregateInputType
  }

  export type GetLibraryBorrowingAggregateType<T extends LibraryBorrowingAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryBorrowing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryBorrowing[P]>
      : GetScalarType<T[P], AggregateLibraryBorrowing[P]>
  }




  export type LibraryBorrowingGroupByArgs = {
    where?: LibraryBorrowingWhereInput
    orderBy?: Enumerable<LibraryBorrowingOrderByWithAggregationInput>
    by: LibraryBorrowingScalarFieldEnum[]
    having?: LibraryBorrowingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryBorrowingCountAggregateInputType | true
    _avg?: LibraryBorrowingAvgAggregateInputType
    _sum?: LibraryBorrowingSumAggregateInputType
    _min?: LibraryBorrowingMinAggregateInputType
    _max?: LibraryBorrowingMaxAggregateInputType
  }


  export type LibraryBorrowingGroupByOutputType = {
    id: number
    bookId: number
    borrowDate: Date
    returnDate: Date
    actualReturnDate: Date
    studentId: number
    universityId: number
    createdAt: Date
    updatedAt: Date
    _count: LibraryBorrowingCountAggregateOutputType | null
    _avg: LibraryBorrowingAvgAggregateOutputType | null
    _sum: LibraryBorrowingSumAggregateOutputType | null
    _min: LibraryBorrowingMinAggregateOutputType | null
    _max: LibraryBorrowingMaxAggregateOutputType | null
  }

  type GetLibraryBorrowingGroupByPayload<T extends LibraryBorrowingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LibraryBorrowingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryBorrowingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryBorrowingGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryBorrowingGroupByOutputType[P]>
        }
      >
    >


  export type LibraryBorrowingSelect = {
    id?: boolean
    book?: boolean | LibraryBookArgs
    student?: boolean | LibraryStudentArgs
    university?: boolean | LibraryUniversityArgs
    bookId?: boolean
    borrowDate?: boolean
    returnDate?: boolean
    actualReturnDate?: boolean
    studentId?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type LibraryBorrowingInclude = {
    book?: boolean | LibraryBookArgs
    student?: boolean | LibraryStudentArgs
    university?: boolean | LibraryUniversityArgs
  }

  export type LibraryBorrowingGetPayload<S extends boolean | null | undefined | LibraryBorrowingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LibraryBorrowing :
    S extends undefined ? never :
    S extends { include: any } & (LibraryBorrowingArgs | LibraryBorrowingFindManyArgs)
    ? LibraryBorrowing  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'book' ? LibraryBookGetPayload<S['include'][P]> :
        P extends 'student' ? LibraryStudentGetPayload<S['include'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LibraryBorrowingArgs | LibraryBorrowingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'book' ? LibraryBookGetPayload<S['select'][P]> :
        P extends 'student' ? LibraryStudentGetPayload<S['select'][P]> :
        P extends 'university' ? LibraryUniversityGetPayload<S['select'][P]> :  P extends keyof LibraryBorrowing ? LibraryBorrowing[P] : never
  } 
      : LibraryBorrowing


  type LibraryBorrowingCountArgs = 
    Omit<LibraryBorrowingFindManyArgs, 'select' | 'include'> & {
      select?: LibraryBorrowingCountAggregateInputType | true
    }

  export interface LibraryBorrowingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one LibraryBorrowing that matches the filter.
     * @param {LibraryBorrowingFindUniqueArgs} args - Arguments to find a LibraryBorrowing
     * @example
     * // Get one LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryBorrowingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LibraryBorrowingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LibraryBorrowing'> extends True ? Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>> : Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T> | null, null>

    /**
     * Find one LibraryBorrowing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryBorrowingFindUniqueOrThrowArgs} args - Arguments to find a LibraryBorrowing
     * @example
     * // Get one LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryBorrowingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LibraryBorrowingFindUniqueOrThrowArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Find the first LibraryBorrowing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingFindFirstArgs} args - Arguments to find a LibraryBorrowing
     * @example
     * // Get one LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryBorrowingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LibraryBorrowingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LibraryBorrowing'> extends True ? Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>> : Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T> | null, null>

    /**
     * Find the first LibraryBorrowing that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingFindFirstOrThrowArgs} args - Arguments to find a LibraryBorrowing
     * @example
     * // Get one LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryBorrowingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LibraryBorrowingFindFirstOrThrowArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Find zero or more LibraryBorrowings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryBorrowings
     * const libraryBorrowings = await prisma.libraryBorrowing.findMany()
     * 
     * // Get first 10 LibraryBorrowings
     * const libraryBorrowings = await prisma.libraryBorrowing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryBorrowingWithIdOnly = await prisma.libraryBorrowing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryBorrowingFindManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingFindManyArgs>
    ): Prisma.PrismaPromise<Array<LibraryBorrowingGetPayload<T>>>

    /**
     * Create a LibraryBorrowing.
     * @param {LibraryBorrowingCreateArgs} args - Arguments to create a LibraryBorrowing.
     * @example
     * // Create one LibraryBorrowing
     * const LibraryBorrowing = await prisma.libraryBorrowing.create({
     *   data: {
     *     // ... data to create a LibraryBorrowing
     *   }
     * })
     * 
    **/
    create<T extends LibraryBorrowingCreateArgs>(
      args: SelectSubset<T, LibraryBorrowingCreateArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Create many LibraryBorrowings.
     *     @param {LibraryBorrowingCreateManyArgs} args - Arguments to create many LibraryBorrowings.
     *     @example
     *     // Create many LibraryBorrowings
     *     const libraryBorrowing = await prisma.libraryBorrowing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryBorrowingCreateManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryBorrowing.
     * @param {LibraryBorrowingDeleteArgs} args - Arguments to delete one LibraryBorrowing.
     * @example
     * // Delete one LibraryBorrowing
     * const LibraryBorrowing = await prisma.libraryBorrowing.delete({
     *   where: {
     *     // ... filter to delete one LibraryBorrowing
     *   }
     * })
     * 
    **/
    delete<T extends LibraryBorrowingDeleteArgs>(
      args: SelectSubset<T, LibraryBorrowingDeleteArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Update one LibraryBorrowing.
     * @param {LibraryBorrowingUpdateArgs} args - Arguments to update one LibraryBorrowing.
     * @example
     * // Update one LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryBorrowingUpdateArgs>(
      args: SelectSubset<T, LibraryBorrowingUpdateArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Delete zero or more LibraryBorrowings.
     * @param {LibraryBorrowingDeleteManyArgs} args - Arguments to filter LibraryBorrowings to delete.
     * @example
     * // Delete a few LibraryBorrowings
     * const { count } = await prisma.libraryBorrowing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryBorrowingDeleteManyArgs>(
      args?: SelectSubset<T, LibraryBorrowingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryBorrowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryBorrowings
     * const libraryBorrowing = await prisma.libraryBorrowing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryBorrowingUpdateManyArgs>(
      args: SelectSubset<T, LibraryBorrowingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryBorrowing.
     * @param {LibraryBorrowingUpsertArgs} args - Arguments to update or create a LibraryBorrowing.
     * @example
     * // Update or create a LibraryBorrowing
     * const libraryBorrowing = await prisma.libraryBorrowing.upsert({
     *   create: {
     *     // ... data to create a LibraryBorrowing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryBorrowing we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryBorrowingUpsertArgs>(
      args: SelectSubset<T, LibraryBorrowingUpsertArgs>
    ): Prisma__LibraryBorrowingClient<LibraryBorrowingGetPayload<T>>

    /**
     * Count the number of LibraryBorrowings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingCountArgs} args - Arguments to filter LibraryBorrowings to count.
     * @example
     * // Count the number of LibraryBorrowings
     * const count = await prisma.libraryBorrowing.count({
     *   where: {
     *     // ... the filter for the LibraryBorrowings we want to count
     *   }
     * })
    **/
    count<T extends LibraryBorrowingCountArgs>(
      args?: Subset<T, LibraryBorrowingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryBorrowingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryBorrowing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryBorrowingAggregateArgs>(args: Subset<T, LibraryBorrowingAggregateArgs>): Prisma.PrismaPromise<GetLibraryBorrowingAggregateType<T>>

    /**
     * Group by LibraryBorrowing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryBorrowingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryBorrowingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryBorrowingGroupByArgs['orderBy'] }
        : { orderBy?: LibraryBorrowingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryBorrowingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryBorrowingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryBorrowing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryBorrowingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    book<T extends LibraryBookArgs= {}>(args?: Subset<T, LibraryBookArgs>): Prisma__LibraryBookClient<LibraryBookGetPayload<T> | Null>;

    student<T extends LibraryStudentArgs= {}>(args?: Subset<T, LibraryStudentArgs>): Prisma__LibraryStudentClient<LibraryStudentGetPayload<T> | Null>;

    university<T extends LibraryUniversityArgs= {}>(args?: Subset<T, LibraryUniversityArgs>): Prisma__LibraryUniversityClient<LibraryUniversityGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LibraryBorrowing base type for findUnique actions
   */
  export type LibraryBorrowingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter, which LibraryBorrowing to fetch.
     */
    where: LibraryBorrowingWhereUniqueInput
  }

  /**
   * LibraryBorrowing findUnique
   */
  export interface LibraryBorrowingFindUniqueArgs extends LibraryBorrowingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBorrowing findUniqueOrThrow
   */
  export type LibraryBorrowingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter, which LibraryBorrowing to fetch.
     */
    where: LibraryBorrowingWhereUniqueInput
  }


  /**
   * LibraryBorrowing base type for findFirst actions
   */
  export type LibraryBorrowingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter, which LibraryBorrowing to fetch.
     */
    where?: LibraryBorrowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowings to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBorrowings.
     */
    cursor?: LibraryBorrowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBorrowings.
     */
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }

  /**
   * LibraryBorrowing findFirst
   */
  export interface LibraryBorrowingFindFirstArgs extends LibraryBorrowingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LibraryBorrowing findFirstOrThrow
   */
  export type LibraryBorrowingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter, which LibraryBorrowing to fetch.
     */
    where?: LibraryBorrowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowings to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryBorrowings.
     */
    cursor?: LibraryBorrowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryBorrowings.
     */
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }


  /**
   * LibraryBorrowing findMany
   */
  export type LibraryBorrowingFindManyArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter, which LibraryBorrowings to fetch.
     */
    where?: LibraryBorrowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryBorrowings to fetch.
     */
    orderBy?: Enumerable<LibraryBorrowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryBorrowings.
     */
    cursor?: LibraryBorrowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryBorrowings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryBorrowings.
     */
    skip?: number
    distinct?: Enumerable<LibraryBorrowingScalarFieldEnum>
  }


  /**
   * LibraryBorrowing create
   */
  export type LibraryBorrowingCreateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * The data needed to create a LibraryBorrowing.
     */
    data: XOR<LibraryBorrowingCreateInput, LibraryBorrowingUncheckedCreateInput>
  }


  /**
   * LibraryBorrowing createMany
   */
  export type LibraryBorrowingCreateManyArgs = {
    /**
     * The data used to create many LibraryBorrowings.
     */
    data: Enumerable<LibraryBorrowingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LibraryBorrowing update
   */
  export type LibraryBorrowingUpdateArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * The data needed to update a LibraryBorrowing.
     */
    data: XOR<LibraryBorrowingUpdateInput, LibraryBorrowingUncheckedUpdateInput>
    /**
     * Choose, which LibraryBorrowing to update.
     */
    where: LibraryBorrowingWhereUniqueInput
  }


  /**
   * LibraryBorrowing updateMany
   */
  export type LibraryBorrowingUpdateManyArgs = {
    /**
     * The data used to update LibraryBorrowings.
     */
    data: XOR<LibraryBorrowingUpdateManyMutationInput, LibraryBorrowingUncheckedUpdateManyInput>
    /**
     * Filter which LibraryBorrowings to update
     */
    where?: LibraryBorrowingWhereInput
  }


  /**
   * LibraryBorrowing upsert
   */
  export type LibraryBorrowingUpsertArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * The filter to search for the LibraryBorrowing to update in case it exists.
     */
    where: LibraryBorrowingWhereUniqueInput
    /**
     * In case the LibraryBorrowing found by the `where` argument doesn't exist, create a new LibraryBorrowing with this data.
     */
    create: XOR<LibraryBorrowingCreateInput, LibraryBorrowingUncheckedCreateInput>
    /**
     * In case the LibraryBorrowing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryBorrowingUpdateInput, LibraryBorrowingUncheckedUpdateInput>
  }


  /**
   * LibraryBorrowing delete
   */
  export type LibraryBorrowingDeleteArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
    /**
     * Filter which LibraryBorrowing to delete.
     */
    where: LibraryBorrowingWhereUniqueInput
  }


  /**
   * LibraryBorrowing deleteMany
   */
  export type LibraryBorrowingDeleteManyArgs = {
    /**
     * Filter which LibraryBorrowings to delete
     */
    where?: LibraryBorrowingWhereInput
  }


  /**
   * LibraryBorrowing without action
   */
  export type LibraryBorrowingArgs = {
    /**
     * Select specific fields to fetch from the LibraryBorrowing
     */
    select?: LibraryBorrowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryBorrowingInclude | null
  }



  /**
   * Model TodoList
   */


  export type AggregateTodoList = {
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  export type TodoListAvgAggregateOutputType = {
    id: number | null
  }

  export type TodoListSumAggregateOutputType = {
    id: number | null
  }

  export type TodoListMinAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListMaxAggregateOutputType = {
    id: number | null
    task: string | null
    status: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TodoListCountAggregateOutputType = {
    id: number
    task: number
    status: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TodoListAvgAggregateInputType = {
    id?: true
  }

  export type TodoListSumAggregateInputType = {
    id?: true
  }

  export type TodoListMinAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListMaxAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TodoListCountAggregateInputType = {
    id?: true
    task?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TodoListAggregateArgs = {
    /**
     * Filter which TodoList to aggregate.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TodoLists
    **/
    _count?: true | TodoListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoListMaxAggregateInputType
  }

  export type GetTodoListAggregateType<T extends TodoListAggregateArgs> = {
        [P in keyof T & keyof AggregateTodoList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodoList[P]>
      : GetScalarType<T[P], AggregateTodoList[P]>
  }




  export type TodoListGroupByArgs = {
    where?: TodoListWhereInput
    orderBy?: Enumerable<TodoListOrderByWithAggregationInput>
    by: TodoListScalarFieldEnum[]
    having?: TodoListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoListCountAggregateInputType | true
    _avg?: TodoListAvgAggregateInputType
    _sum?: TodoListSumAggregateInputType
    _min?: TodoListMinAggregateInputType
    _max?: TodoListMaxAggregateInputType
  }


  export type TodoListGroupByOutputType = {
    id: number
    task: string
    status: string
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: TodoListCountAggregateOutputType | null
    _avg: TodoListAvgAggregateOutputType | null
    _sum: TodoListSumAggregateOutputType | null
    _min: TodoListMinAggregateOutputType | null
    _max: TodoListMaxAggregateOutputType | null
  }

  type GetTodoListGroupByPayload<T extends TodoListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TodoListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoListGroupByOutputType[P]>
            : GetScalarType<T[P], TodoListGroupByOutputType[P]>
        }
      >
    >


  export type TodoListSelect = {
    id?: boolean
    task?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TodoListGetPayload<S extends boolean | null | undefined | TodoListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TodoList :
    S extends undefined ? never :
    S extends { include: any } & (TodoListArgs | TodoListFindManyArgs)
    ? TodoList 
    : S extends { select: any } & (TodoListArgs | TodoListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TodoList ? TodoList[P] : never
  } 
      : TodoList


  type TodoListCountArgs = 
    Omit<TodoListFindManyArgs, 'select' | 'include'> & {
      select?: TodoListCountAggregateInputType | true
    }

  export interface TodoListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TodoList that matches the filter.
     * @param {TodoListFindUniqueArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TodoListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TodoListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find one TodoList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TodoListFindUniqueOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TodoListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindUniqueOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find the first TodoList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TodoListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TodoListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TodoList'> extends True ? Prisma__TodoListClient<TodoListGetPayload<T>> : Prisma__TodoListClient<TodoListGetPayload<T> | null, null>

    /**
     * Find the first TodoList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindFirstOrThrowArgs} args - Arguments to find a TodoList
     * @example
     * // Get one TodoList
     * const todoList = await prisma.todoList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TodoListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TodoListFindFirstOrThrowArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Find zero or more TodoLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TodoLists
     * const todoLists = await prisma.todoList.findMany()
     * 
     * // Get first 10 TodoLists
     * const todoLists = await prisma.todoList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoListWithIdOnly = await prisma.todoList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TodoListFindManyArgs>(
      args?: SelectSubset<T, TodoListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TodoListGetPayload<T>>>

    /**
     * Create a TodoList.
     * @param {TodoListCreateArgs} args - Arguments to create a TodoList.
     * @example
     * // Create one TodoList
     * const TodoList = await prisma.todoList.create({
     *   data: {
     *     // ... data to create a TodoList
     *   }
     * })
     * 
    **/
    create<T extends TodoListCreateArgs>(
      args: SelectSubset<T, TodoListCreateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Create many TodoLists.
     *     @param {TodoListCreateManyArgs} args - Arguments to create many TodoLists.
     *     @example
     *     // Create many TodoLists
     *     const todoList = await prisma.todoList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TodoListCreateManyArgs>(
      args?: SelectSubset<T, TodoListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TodoList.
     * @param {TodoListDeleteArgs} args - Arguments to delete one TodoList.
     * @example
     * // Delete one TodoList
     * const TodoList = await prisma.todoList.delete({
     *   where: {
     *     // ... filter to delete one TodoList
     *   }
     * })
     * 
    **/
    delete<T extends TodoListDeleteArgs>(
      args: SelectSubset<T, TodoListDeleteArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Update one TodoList.
     * @param {TodoListUpdateArgs} args - Arguments to update one TodoList.
     * @example
     * // Update one TodoList
     * const todoList = await prisma.todoList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TodoListUpdateArgs>(
      args: SelectSubset<T, TodoListUpdateArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Delete zero or more TodoLists.
     * @param {TodoListDeleteManyArgs} args - Arguments to filter TodoLists to delete.
     * @example
     * // Delete a few TodoLists
     * const { count } = await prisma.todoList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TodoListDeleteManyArgs>(
      args?: SelectSubset<T, TodoListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TodoLists
     * const todoList = await prisma.todoList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TodoListUpdateManyArgs>(
      args: SelectSubset<T, TodoListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TodoList.
     * @param {TodoListUpsertArgs} args - Arguments to update or create a TodoList.
     * @example
     * // Update or create a TodoList
     * const todoList = await prisma.todoList.upsert({
     *   create: {
     *     // ... data to create a TodoList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TodoList we want to update
     *   }
     * })
    **/
    upsert<T extends TodoListUpsertArgs>(
      args: SelectSubset<T, TodoListUpsertArgs>
    ): Prisma__TodoListClient<TodoListGetPayload<T>>

    /**
     * Count the number of TodoLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListCountArgs} args - Arguments to filter TodoLists to count.
     * @example
     * // Count the number of TodoLists
     * const count = await prisma.todoList.count({
     *   where: {
     *     // ... the filter for the TodoLists we want to count
     *   }
     * })
    **/
    count<T extends TodoListCountArgs>(
      args?: Subset<T, TodoListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoListAggregateArgs>(args: Subset<T, TodoListAggregateArgs>): Prisma.PrismaPromise<GetTodoListAggregateType<T>>

    /**
     * Group by TodoList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoListGroupByArgs['orderBy'] }
        : { orderBy?: TodoListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TodoList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TodoListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TodoList base type for findUnique actions
   */
  export type TodoListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }

  /**
   * TodoList findUnique
   */
  export interface TodoListFindUniqueArgs extends TodoListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findUniqueOrThrow
   */
  export type TodoListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList base type for findFirst actions
   */
  export type TodoListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }

  /**
   * TodoList findFirst
   */
  export interface TodoListFindFirstArgs extends TodoListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TodoList findFirstOrThrow
   */
  export type TodoListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoList to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TodoLists.
     */
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList findMany
   */
  export type TodoListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter, which TodoLists to fetch.
     */
    where?: TodoListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TodoLists to fetch.
     */
    orderBy?: Enumerable<TodoListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TodoLists.
     */
    cursor?: TodoListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TodoLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TodoLists.
     */
    skip?: number
    distinct?: Enumerable<TodoListScalarFieldEnum>
  }


  /**
   * TodoList create
   */
  export type TodoListCreateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to create a TodoList.
     */
    data: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
  }


  /**
   * TodoList createMany
   */
  export type TodoListCreateManyArgs = {
    /**
     * The data used to create many TodoLists.
     */
    data: Enumerable<TodoListCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TodoList update
   */
  export type TodoListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The data needed to update a TodoList.
     */
    data: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
    /**
     * Choose, which TodoList to update.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList updateMany
   */
  export type TodoListUpdateManyArgs = {
    /**
     * The data used to update TodoLists.
     */
    data: XOR<TodoListUpdateManyMutationInput, TodoListUncheckedUpdateManyInput>
    /**
     * Filter which TodoLists to update
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList upsert
   */
  export type TodoListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * The filter to search for the TodoList to update in case it exists.
     */
    where: TodoListWhereUniqueInput
    /**
     * In case the TodoList found by the `where` argument doesn't exist, create a new TodoList with this data.
     */
    create: XOR<TodoListCreateInput, TodoListUncheckedCreateInput>
    /**
     * In case the TodoList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoListUpdateInput, TodoListUncheckedUpdateInput>
  }


  /**
   * TodoList delete
   */
  export type TodoListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
    /**
     * Filter which TodoList to delete.
     */
    where: TodoListWhereUniqueInput
  }


  /**
   * TodoList deleteMany
   */
  export type TodoListDeleteManyArgs = {
    /**
     * Filter which TodoLists to delete
     */
    where?: TodoListWhereInput
  }


  /**
   * TodoList without action
   */
  export type TodoListArgs = {
    /**
     * Select specific fields to fetch from the TodoList
     */
    select?: TodoListSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BinKitchenCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenCategoryScalarFieldEnum = (typeof BinKitchenCategoryScalarFieldEnum)[keyof typeof BinKitchenCategoryScalarFieldEnum]


  export const BinKitchenMenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    price: 'price',
    categoryName: 'categoryName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenMenuScalarFieldEnum = (typeof BinKitchenMenuScalarFieldEnum)[keyof typeof BinKitchenMenuScalarFieldEnum]


  export const BinKitchenOrderItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    orderId: 'orderId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenOrderItemScalarFieldEnum = (typeof BinKitchenOrderItemScalarFieldEnum)[keyof typeof BinKitchenOrderItemScalarFieldEnum]


  export const BinKitchenOrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    tableId: 'tableId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BinKitchenOrderScalarFieldEnum = (typeof BinKitchenOrderScalarFieldEnum)[keyof typeof BinKitchenOrderScalarFieldEnum]


  export const FacebookCommentPostScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    message: 'message',
    image: 'image',
    commentToId: 'commentToId',
    shareToId: 'shareToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookCommentPostScalarFieldEnum = (typeof FacebookCommentPostScalarFieldEnum)[keyof typeof FacebookCommentPostScalarFieldEnum]


  export const FacebookDirectMessageScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    message: 'message',
    image: 'image',
    readStatus: 'readStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookDirectMessageScalarFieldEnum = (typeof FacebookDirectMessageScalarFieldEnum)[keyof typeof FacebookDirectMessageScalarFieldEnum]


  export const FacebookGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookGroupScalarFieldEnum = (typeof FacebookGroupScalarFieldEnum)[keyof typeof FacebookGroupScalarFieldEnum]


  export const FacebookHashtagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookHashtagScalarFieldEnum = (typeof FacebookHashtagScalarFieldEnum)[keyof typeof FacebookHashtagScalarFieldEnum]


  export const FacebookLikeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookLikeScalarFieldEnum = (typeof FacebookLikeScalarFieldEnum)[keyof typeof FacebookLikeScalarFieldEnum]


  export const FacebookLocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookLocationScalarFieldEnum = (typeof FacebookLocationScalarFieldEnum)[keyof typeof FacebookLocationScalarFieldEnum]


  export const FacebookPostDestinationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    groupId: 'groupId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookPostDestinationScalarFieldEnum = (typeof FacebookPostDestinationScalarFieldEnum)[keyof typeof FacebookPostDestinationScalarFieldEnum]


  export const FacebookPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    image: 'image',
    locationId: 'locationId',
    hashtagId: 'hashtagId',
    shareToId: 'shareToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookPostScalarFieldEnum = (typeof FacebookPostScalarFieldEnum)[keyof typeof FacebookPostScalarFieldEnum]


  export const FacebookShareTypeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookShareTypeScalarFieldEnum = (typeof FacebookShareTypeScalarFieldEnum)[keyof typeof FacebookShareTypeScalarFieldEnum]


  export const FacebookUserInGroupScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserInGroupScalarFieldEnum = (typeof FacebookUserInGroupScalarFieldEnum)[keyof typeof FacebookUserInGroupScalarFieldEnum]


  export const FacebookUserRelationshipScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserRelationshipScalarFieldEnum = (typeof FacebookUserRelationshipScalarFieldEnum)[keyof typeof FacebookUserRelationshipScalarFieldEnum]


  export const FacebookUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    image: 'image',
    coverImage: 'coverImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacebookUserScalarFieldEnum = (typeof FacebookUserScalarFieldEnum)[keyof typeof FacebookUserScalarFieldEnum]


  export const LaunderBranchInfoScalarFieldEnum: {
    id: 'id',
    owner: 'owner',
    phone: 'phone',
    location: 'location',
    areaSize: 'areaSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderBranchInfoScalarFieldEnum = (typeof LaunderBranchInfoScalarFieldEnum)[keyof typeof LaunderBranchInfoScalarFieldEnum]


  export const LaunderMachineScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    Capacity: 'Capacity',
    type: 'type',
    serialNumber: 'serialNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderMachineScalarFieldEnum = (typeof LaunderMachineScalarFieldEnum)[keyof typeof LaunderMachineScalarFieldEnum]


  export const LaunderProgramInMachineScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    programId: 'programId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderProgramInMachineScalarFieldEnum = (typeof LaunderProgramInMachineScalarFieldEnum)[keyof typeof LaunderProgramInMachineScalarFieldEnum]


  export const LaunderServiceHistoryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    machineId: 'machineId',
    technicianId: 'technicianId',
    descriptions: 'descriptions',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderServiceHistoryScalarFieldEnum = (typeof LaunderServiceHistoryScalarFieldEnum)[keyof typeof LaunderServiceHistoryScalarFieldEnum]


  export const LaunderTechnicianScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    image: 'image',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderTechnicianScalarFieldEnum = (typeof LaunderTechnicianScalarFieldEnum)[keyof typeof LaunderTechnicianScalarFieldEnum]


  export const LaunderUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    phone: 'phone',
    walletBalance: 'walletBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderUserScalarFieldEnum = (typeof LaunderUserScalarFieldEnum)[keyof typeof LaunderUserScalarFieldEnum]


  export const LaunderWashingProgramScalarFieldEnum: {
    id: 'id',
    program: 'program',
    price: 'price',
    duration: 'duration',
    capacityLimit: 'capacityLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunderWashingProgramScalarFieldEnum = (typeof LaunderWashingProgramScalarFieldEnum)[keyof typeof LaunderWashingProgramScalarFieldEnum]


  export const LaundryMachineInStoreScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    machineId: 'machineId',
    mfd: 'mfd',
    Warranty: 'Warranty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryMachineInStoreScalarFieldEnum = (typeof LaundryMachineInStoreScalarFieldEnum)[keyof typeof LaundryMachineInStoreScalarFieldEnum]


  export const LaundryTopupHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryTopupHistoryScalarFieldEnum = (typeof LaundryTopupHistoryScalarFieldEnum)[keyof typeof LaundryTopupHistoryScalarFieldEnum]


  export const LaundryWashingHistoryScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    programId: 'programId',
    date: 'date',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaundryWashingHistoryScalarFieldEnum = (typeof LaundryWashingHistoryScalarFieldEnum)[keyof typeof LaundryWashingHistoryScalarFieldEnum]


  export const LibraryAuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryAuthorScalarFieldEnum = (typeof LibraryAuthorScalarFieldEnum)[keyof typeof LibraryAuthorScalarFieldEnum]


  export const LibraryBookAuthorScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookAuthorScalarFieldEnum = (typeof LibraryBookAuthorScalarFieldEnum)[keyof typeof LibraryBookAuthorScalarFieldEnum]


  export const LibraryBookCategoryScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookCategoryScalarFieldEnum = (typeof LibraryBookCategoryScalarFieldEnum)[keyof typeof LibraryBookCategoryScalarFieldEnum]


  export const LibraryBookCopyScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    universityId: 'universityId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookCopyScalarFieldEnum = (typeof LibraryBookCopyScalarFieldEnum)[keyof typeof LibraryBookCopyScalarFieldEnum]


  export const LibraryBookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isbn: 'isbn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBookScalarFieldEnum = (typeof LibraryBookScalarFieldEnum)[keyof typeof LibraryBookScalarFieldEnum]


  export const LibraryBorrowingScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    actualReturnDate: 'actualReturnDate',
    studentId: 'studentId',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryBorrowingScalarFieldEnum = (typeof LibraryBorrowingScalarFieldEnum)[keyof typeof LibraryBorrowingScalarFieldEnum]


  export const LibraryCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryCategoryScalarFieldEnum = (typeof LibraryCategoryScalarFieldEnum)[keyof typeof LibraryCategoryScalarFieldEnum]


  export const LibraryRequestScalarFieldEnum: {
    id: 'id',
    borrowDate: 'borrowDate',
    returnDate: 'returnDate',
    bookId: 'bookId',
    studentId: 'studentId',
    fromUniversityId: 'fromUniversityId',
    toUniversityId: 'toUniversityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryRequestScalarFieldEnum = (typeof LibraryRequestScalarFieldEnum)[keyof typeof LibraryRequestScalarFieldEnum]


  export const LibraryStudentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryStudentScalarFieldEnum = (typeof LibraryStudentScalarFieldEnum)[keyof typeof LibraryStudentScalarFieldEnum]


  export const LibraryUniversityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryUniversityScalarFieldEnum = (typeof LibraryUniversityScalarFieldEnum)[keyof typeof LibraryUniversityScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuizCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizCategoryScalarFieldEnum = (typeof QuizCategoryScalarFieldEnum)[keyof typeof QuizCategoryScalarFieldEnum]


  export const QuizChoiceScalarFieldEnum: {
    id: 'id',
    choiceName: 'choiceName',
    questionId: 'questionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizChoiceScalarFieldEnum = (typeof QuizChoiceScalarFieldEnum)[keyof typeof QuizChoiceScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    questName: 'questName',
    categoryId: 'categoryId',
    answerChoiceId: 'answerChoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizRoundQuestionScalarFieldEnum: {
    id: 'id',
    userChoiceId: 'userChoiceId',
    questionId: 'questionId',
    roundId: 'roundId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizRoundQuestionScalarFieldEnum = (typeof QuizRoundQuestionScalarFieldEnum)[keyof typeof QuizRoundQuestionScalarFieldEnum]


  export const QuizRoundScalarFieldEnum: {
    id: 'id',
    user: 'user',
    categoryId: 'categoryId',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizRoundScalarFieldEnum = (typeof QuizRoundScalarFieldEnum)[keyof typeof QuizRoundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TodoListScalarFieldEnum: {
    id: 'id',
    task: 'task',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TodoListScalarFieldEnum = (typeof TodoListScalarFieldEnum)[keyof typeof TodoListScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TwitterDirectMessageScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    message: 'message',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterDirectMessageScalarFieldEnum = (typeof TwitterDirectMessageScalarFieldEnum)[keyof typeof TwitterDirectMessageScalarFieldEnum]


  export const TwitterHashtagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterHashtagScalarFieldEnum = (typeof TwitterHashtagScalarFieldEnum)[keyof typeof TwitterHashtagScalarFieldEnum]


  export const TwitterPostAndHashtagScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    hashtagId: 'hashtagId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterPostAndHashtagScalarFieldEnum = (typeof TwitterPostAndHashtagScalarFieldEnum)[keyof typeof TwitterPostAndHashtagScalarFieldEnum]


  export const TwitterPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterPostScalarFieldEnum = (typeof TwitterPostScalarFieldEnum)[keyof typeof TwitterPostScalarFieldEnum]


  export const TwitterReplyPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    image: 'image',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterReplyPostScalarFieldEnum = (typeof TwitterReplyPostScalarFieldEnum)[keyof typeof TwitterReplyPostScalarFieldEnum]


  export const TwitterUserRelationshipScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterUserRelationshipScalarFieldEnum = (typeof TwitterUserRelationshipScalarFieldEnum)[keyof typeof TwitterUserRelationshipScalarFieldEnum]


  export const TwitterUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwitterUserScalarFieldEnum = (typeof TwitterUserScalarFieldEnum)[keyof typeof TwitterUserScalarFieldEnum]


  export const YoutubeChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    descriptions: 'descriptions',
    image: 'image',
    coverImage: 'coverImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeChannelScalarFieldEnum = (typeof YoutubeChannelScalarFieldEnum)[keyof typeof YoutubeChannelScalarFieldEnum]


  export const YoutubeCommentScalarFieldEnum: {
    id: 'id',
    videoId: 'videoId',
    userId: 'userId',
    message: 'message',
    commentToId: 'commentToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeCommentScalarFieldEnum = (typeof YoutubeCommentScalarFieldEnum)[keyof typeof YoutubeCommentScalarFieldEnum]


  export const YoutubeReactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    videoId: 'videoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeReactionScalarFieldEnum = (typeof YoutubeReactionScalarFieldEnum)[keyof typeof YoutubeReactionScalarFieldEnum]


  export const YoutubeRoleScalarFieldEnum: {
    id: 'id',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeRoleScalarFieldEnum = (typeof YoutubeRoleScalarFieldEnum)[keyof typeof YoutubeRoleScalarFieldEnum]


  export const YoutubeSubscriberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    membership: 'membership',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeSubscriberScalarFieldEnum = (typeof YoutubeSubscriberScalarFieldEnum)[keyof typeof YoutubeSubscriberScalarFieldEnum]


  export const YoutubeUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeUserScalarFieldEnum = (typeof YoutubeUserScalarFieldEnum)[keyof typeof YoutubeUserScalarFieldEnum]


  export const YoutubeUserToChannelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    channelId: 'channelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeUserToChannelScalarFieldEnum = (typeof YoutubeUserToChannelScalarFieldEnum)[keyof typeof YoutubeUserToChannelScalarFieldEnum]


  export const YoutubeVideoScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    name: 'name',
    urlFile: 'urlFile',
    coverImage: 'coverImage',
    descriptions: 'descriptions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type YoutubeVideoScalarFieldEnum = (typeof YoutubeVideoScalarFieldEnum)[keyof typeof YoutubeVideoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type BinKitchenCategoryWhereInput = {
    AND?: Enumerable<BinKitchenCategoryWhereInput>
    OR?: Enumerable<BinKitchenCategoryWhereInput>
    NOT?: Enumerable<BinKitchenCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    menus?: BinKitchenMenuListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    menus?: BinKitchenMenuOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type BinKitchenCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenCategoryCountOrderByAggregateInput
    _avg?: BinKitchenCategoryAvgOrderByAggregateInput
    _max?: BinKitchenCategoryMaxOrderByAggregateInput
    _min?: BinKitchenCategoryMinOrderByAggregateInput
    _sum?: BinKitchenCategorySumOrderByAggregateInput
  }

  export type BinKitchenCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenMenuWhereInput = {
    AND?: Enumerable<BinKitchenMenuWhereInput>
    OR?: Enumerable<BinKitchenMenuWhereInput>
    NOT?: Enumerable<BinKitchenMenuWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    category?: XOR<BinKitchenCategoryRelationFilter, BinKitchenCategoryWhereInput> | null
    categoryName?: StringNullableFilter | string | null
    orderItems?: BinKitchenOrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenMenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    category?: BinKitchenCategoryOrderByWithRelationInput
    categoryName?: SortOrder
    orderItems?: BinKitchenOrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenMenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenMenuCountOrderByAggregateInput
    _avg?: BinKitchenMenuAvgOrderByAggregateInput
    _max?: BinKitchenMenuMaxOrderByAggregateInput
    _min?: BinKitchenMenuMinOrderByAggregateInput
    _sum?: BinKitchenMenuSumOrderByAggregateInput
  }

  export type BinKitchenMenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenMenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenOrderWhereInput = {
    AND?: Enumerable<BinKitchenOrderWhereInput>
    OR?: Enumerable<BinKitchenOrderWhereInput>
    NOT?: Enumerable<BinKitchenOrderWhereInput>
    id?: IntFilter | number
    status?: StringFilter | string
    tableId?: IntFilter | number
    items?: BinKitchenOrderItemListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenOrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    items?: BinKitchenOrderItemOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenOrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenOrderCountOrderByAggregateInput
    _avg?: BinKitchenOrderAvgOrderByAggregateInput
    _max?: BinKitchenOrderMaxOrderByAggregateInput
    _min?: BinKitchenOrderMinOrderByAggregateInput
    _sum?: BinKitchenOrderSumOrderByAggregateInput
  }

  export type BinKitchenOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    tableId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenOrderItemWhereInput = {
    AND?: Enumerable<BinKitchenOrderItemWhereInput>
    OR?: Enumerable<BinKitchenOrderItemWhereInput>
    NOT?: Enumerable<BinKitchenOrderItemWhereInput>
    id?: IntFilter | number
    menu?: XOR<BinKitchenMenuRelationFilter, BinKitchenMenuWhereInput>
    menuId?: IntFilter | number
    order?: XOR<BinKitchenOrderRelationFilter, BinKitchenOrderWhereInput> | null
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    menu?: BinKitchenMenuOrderByWithRelationInput
    menuId?: SortOrder
    order?: BinKitchenOrderOrderByWithRelationInput
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderItemWhereUniqueInput = {
    id?: number
  }

  export type BinKitchenOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BinKitchenOrderItemCountOrderByAggregateInput
    _avg?: BinKitchenOrderItemAvgOrderByAggregateInput
    _max?: BinKitchenOrderItemMaxOrderByAggregateInput
    _min?: BinKitchenOrderItemMinOrderByAggregateInput
    _sum?: BinKitchenOrderItemSumOrderByAggregateInput
  }

  export type BinKitchenOrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BinKitchenOrderItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    menuId?: IntWithAggregatesFilter | number
    orderId?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    totalPrice?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizCategoryWhereInput = {
    AND?: Enumerable<QuizCategoryWhereInput>
    OR?: Enumerable<QuizCategoryWhereInput>
    NOT?: Enumerable<QuizCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    questions?: QuizQuestionListRelationFilter
    rounds?: QuizRoundListRelationFilter
  }

  export type QuizCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuizQuestionOrderByRelationAggregateInput
    rounds?: QuizRoundOrderByRelationAggregateInput
  }

  export type QuizCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type QuizCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCategoryCountOrderByAggregateInput
    _avg?: QuizCategoryAvgOrderByAggregateInput
    _max?: QuizCategoryMaxOrderByAggregateInput
    _min?: QuizCategoryMinOrderByAggregateInput
    _sum?: QuizCategorySumOrderByAggregateInput
  }

  export type QuizCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizQuestionWhereInput = {
    AND?: Enumerable<QuizQuestionWhereInput>
    OR?: Enumerable<QuizQuestionWhereInput>
    NOT?: Enumerable<QuizQuestionWhereInput>
    id?: IntFilter | number
    questName?: StringFilter | string
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput>
    categoryId?: IntFilter | number
    answer?: XOR<QuizChoiceRelationFilter, QuizChoiceWhereInput>
    answerChoiceId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    choices?: QuizChoiceListRelationFilter
    roundQuestions?: QuizRoundQuestionListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    questName?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    categoryId?: SortOrder
    answer?: QuizChoiceOrderByWithRelationInput
    answerChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    choices?: QuizChoiceOrderByRelationAggregateInput
    roundQuestions?: QuizRoundQuestionOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = {
    id?: number
    answerChoiceId?: number
  }

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questName?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questName?: StringWithAggregatesFilter | string
    categoryId?: IntWithAggregatesFilter | number
    answerChoiceId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizChoiceWhereInput = {
    AND?: Enumerable<QuizChoiceWhereInput>
    OR?: Enumerable<QuizChoiceWhereInput>
    NOT?: Enumerable<QuizChoiceWhereInput>
    id?: IntFilter | number
    choiceName?: StringFilter | string
    questione?: XOR<QuizQuestionRelationFilter, QuizQuestionWhereInput> | null
    questionId?: IntNullableFilter | number | null
    questionAnswer?: XOR<QuizQuestionRelationFilter, QuizQuestionWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizChoiceOrderByWithRelationInput = {
    id?: SortOrder
    choiceName?: SortOrder
    questione?: QuizQuestionOrderByWithRelationInput
    questionId?: SortOrder
    questionAnswer?: QuizQuestionOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceWhereUniqueInput = {
    id?: number
  }

  export type QuizChoiceOrderByWithAggregationInput = {
    id?: SortOrder
    choiceName?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizChoiceCountOrderByAggregateInput
    _avg?: QuizChoiceAvgOrderByAggregateInput
    _max?: QuizChoiceMaxOrderByAggregateInput
    _min?: QuizChoiceMinOrderByAggregateInput
    _sum?: QuizChoiceSumOrderByAggregateInput
  }

  export type QuizChoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizChoiceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    choiceName?: StringWithAggregatesFilter | string
    questionId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizRoundQuestionWhereInput = {
    AND?: Enumerable<QuizRoundQuestionWhereInput>
    OR?: Enumerable<QuizRoundQuestionWhereInput>
    NOT?: Enumerable<QuizRoundQuestionWhereInput>
    id?: IntFilter | number
    userChoiceId?: IntFilter | number
    question?: XOR<QuizQuestionRelationFilter, QuizQuestionWhereInput>
    questionId?: IntFilter | number
    round?: XOR<QuizRoundRelationFilter, QuizRoundWhereInput>
    roundId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRoundQuestionOrderByWithRelationInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    question?: QuizQuestionOrderByWithRelationInput
    questionId?: SortOrder
    round?: QuizRoundOrderByWithRelationInput
    roundId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundQuestionWhereUniqueInput = {
    id?: number
  }

  export type QuizRoundQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizRoundQuestionCountOrderByAggregateInput
    _avg?: QuizRoundQuestionAvgOrderByAggregateInput
    _max?: QuizRoundQuestionMaxOrderByAggregateInput
    _min?: QuizRoundQuestionMinOrderByAggregateInput
    _sum?: QuizRoundQuestionSumOrderByAggregateInput
  }

  export type QuizRoundQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizRoundQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizRoundQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizRoundQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userChoiceId?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    roundId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuizRoundWhereInput = {
    AND?: Enumerable<QuizRoundWhereInput>
    OR?: Enumerable<QuizRoundWhereInput>
    NOT?: Enumerable<QuizRoundWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    category?: XOR<QuizCategoryRelationFilter, QuizCategoryWhereInput>
    categoryId?: IntFilter | number
    score?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    questions?: QuizRoundQuestionListRelationFilter
  }

  export type QuizRoundOrderByWithRelationInput = {
    id?: SortOrder
    user?: SortOrder
    category?: QuizCategoryOrderByWithRelationInput
    categoryId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuizRoundQuestionOrderByRelationAggregateInput
  }

  export type QuizRoundWhereUniqueInput = {
    id?: number
  }

  export type QuizRoundOrderByWithAggregationInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizRoundCountOrderByAggregateInput
    _avg?: QuizRoundAvgOrderByAggregateInput
    _max?: QuizRoundMaxOrderByAggregateInput
    _min?: QuizRoundMinOrderByAggregateInput
    _sum?: QuizRoundSumOrderByAggregateInput
  }

  export type QuizRoundScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuizRoundScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user?: StringWithAggregatesFilter | string
    categoryId?: IntWithAggregatesFilter | number
    score?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserWhereInput = {
    AND?: Enumerable<FacebookUserWhereInput>
    OR?: Enumerable<FacebookUserWhereInput>
    NOT?: Enumerable<FacebookUserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    image?: StringNullableFilter | string | null
    coverImage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    from?: FacebookUserRelationshipListRelationFilter
    to?: FacebookUserRelationshipListRelationFilter
    userInGroups?: FacebookUserInGroupListRelationFilter
    posts?: FacebookPostListRelationFilter
    directMessageFrom?: FacebookDirectMessageListRelationFilter
    directMessageTo?: FacebookDirectMessageListRelationFilter
    commentPosts?: FacebookCommentPostListRelationFilter
    likes?: FacebookLikeListRelationFilter
    postDestinations?: FacebookPostDestinationListRelationFilter
  }

  export type FacebookUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    from?: FacebookUserRelationshipOrderByRelationAggregateInput
    to?: FacebookUserRelationshipOrderByRelationAggregateInput
    userInGroups?: FacebookUserInGroupOrderByRelationAggregateInput
    posts?: FacebookPostOrderByRelationAggregateInput
    directMessageFrom?: FacebookDirectMessageOrderByRelationAggregateInput
    directMessageTo?: FacebookDirectMessageOrderByRelationAggregateInput
    commentPosts?: FacebookCommentPostOrderByRelationAggregateInput
    likes?: FacebookLikeOrderByRelationAggregateInput
    postDestinations?: FacebookPostDestinationOrderByRelationAggregateInput
  }

  export type FacebookUserWhereUniqueInput = {
    id?: number
    username?: string
  }

  export type FacebookUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserCountOrderByAggregateInput
    _avg?: FacebookUserAvgOrderByAggregateInput
    _max?: FacebookUserMaxOrderByAggregateInput
    _min?: FacebookUserMinOrderByAggregateInput
    _sum?: FacebookUserSumOrderByAggregateInput
  }

  export type FacebookUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    coverImage?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserRelationshipWhereInput = {
    AND?: Enumerable<FacebookUserRelationshipWhereInput>
    OR?: Enumerable<FacebookUserRelationshipWhereInput>
    NOT?: Enumerable<FacebookUserRelationshipWhereInput>
    id?: IntFilter | number
    from?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    to?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    from?: FacebookUserOrderByWithRelationInput
    to?: FacebookUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationshipWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserRelationshipCountOrderByAggregateInput
    _avg?: FacebookUserRelationshipAvgOrderByAggregateInput
    _max?: FacebookUserRelationshipMaxOrderByAggregateInput
    _min?: FacebookUserRelationshipMinOrderByAggregateInput
    _sum?: FacebookUserRelationshipSumOrderByAggregateInput
  }

  export type FacebookUserRelationshipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserRelationshipScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserRelationshipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserRelationshipScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookDirectMessageWhereInput = {
    AND?: Enumerable<FacebookDirectMessageWhereInput>
    OR?: Enumerable<FacebookDirectMessageWhereInput>
    NOT?: Enumerable<FacebookDirectMessageWhereInput>
    id?: IntFilter | number
    from?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    to?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    readStatus?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookDirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    from?: FacebookUserOrderByWithRelationInput
    to?: FacebookUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookDirectMessageWhereUniqueInput = {
    id?: number
  }

  export type FacebookDirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookDirectMessageCountOrderByAggregateInput
    _avg?: FacebookDirectMessageAvgOrderByAggregateInput
    _max?: FacebookDirectMessageMaxOrderByAggregateInput
    _min?: FacebookDirectMessageMinOrderByAggregateInput
    _sum?: FacebookDirectMessageSumOrderByAggregateInput
  }

  export type FacebookDirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookDirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookDirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookDirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    readStatus?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookLocationWhereInput = {
    AND?: Enumerable<FacebookLocationWhereInput>
    OR?: Enumerable<FacebookLocationWhereInput>
    NOT?: Enumerable<FacebookLocationWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    posts?: FacebookPostListRelationFilter
  }

  export type FacebookLocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: FacebookPostOrderByRelationAggregateInput
  }

  export type FacebookLocationWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type FacebookLocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookLocationCountOrderByAggregateInput
    _avg?: FacebookLocationAvgOrderByAggregateInput
    _max?: FacebookLocationMaxOrderByAggregateInput
    _min?: FacebookLocationMinOrderByAggregateInput
    _sum?: FacebookLocationSumOrderByAggregateInput
  }

  export type FacebookLocationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookLocationScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookLocationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookLocationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookHashtagWhereInput = {
    AND?: Enumerable<FacebookHashtagWhereInput>
    OR?: Enumerable<FacebookHashtagWhereInput>
    NOT?: Enumerable<FacebookHashtagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    posts?: FacebookPostListRelationFilter
  }

  export type FacebookHashtagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: FacebookPostOrderByRelationAggregateInput
  }

  export type FacebookHashtagWhereUniqueInput = {
    id?: number
  }

  export type FacebookHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookHashtagCountOrderByAggregateInput
    _avg?: FacebookHashtagAvgOrderByAggregateInput
    _max?: FacebookHashtagMaxOrderByAggregateInput
    _min?: FacebookHashtagMinOrderByAggregateInput
    _sum?: FacebookHashtagSumOrderByAggregateInput
  }

  export type FacebookHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookLikeWhereInput = {
    AND?: Enumerable<FacebookLikeWhereInput>
    OR?: Enumerable<FacebookLikeWhereInput>
    NOT?: Enumerable<FacebookLikeWhereInput>
    id?: IntFilter | number
    type?: EnumFacebookLikeTypeEnumFilter | FacebookLikeTypeEnum
    user?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    posts?: XOR<FacebookPostRelationFilter, FacebookPostWhereInput> | null
    postId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookLikeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    user?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    posts?: FacebookPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLikeWhereUniqueInput = {
    id?: number
  }

  export type FacebookLikeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookLikeCountOrderByAggregateInput
    _avg?: FacebookLikeAvgOrderByAggregateInput
    _max?: FacebookLikeMaxOrderByAggregateInput
    _min?: FacebookLikeMinOrderByAggregateInput
    _sum?: FacebookLikeSumOrderByAggregateInput
  }

  export type FacebookLikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookLikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookLikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookLikeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumFacebookLikeTypeEnumWithAggregatesFilter | FacebookLikeTypeEnum
    userId?: IntWithAggregatesFilter | number
    postId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookShareTypeWhereInput = {
    AND?: Enumerable<FacebookShareTypeWhereInput>
    OR?: Enumerable<FacebookShareTypeWhereInput>
    NOT?: Enumerable<FacebookShareTypeWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    commentPosts?: FacebookCommentPostListRelationFilter
    posts?: FacebookPostListRelationFilter
  }

  export type FacebookShareTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentPosts?: FacebookCommentPostOrderByRelationAggregateInput
    posts?: FacebookPostOrderByRelationAggregateInput
  }

  export type FacebookShareTypeWhereUniqueInput = {
    id?: number
  }

  export type FacebookShareTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookShareTypeCountOrderByAggregateInput
    _avg?: FacebookShareTypeAvgOrderByAggregateInput
    _max?: FacebookShareTypeMaxOrderByAggregateInput
    _min?: FacebookShareTypeMinOrderByAggregateInput
    _sum?: FacebookShareTypeSumOrderByAggregateInput
  }

  export type FacebookShareTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookShareTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookShareTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookShareTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookGroupWhereInput = {
    AND?: Enumerable<FacebookGroupWhereInput>
    OR?: Enumerable<FacebookGroupWhereInput>
    NOT?: Enumerable<FacebookGroupWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userInGroups?: FacebookUserInGroupListRelationFilter
    postDestinations?: FacebookPostDestinationListRelationFilter
  }

  export type FacebookGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userInGroups?: FacebookUserInGroupOrderByRelationAggregateInput
    postDestinations?: FacebookPostDestinationOrderByRelationAggregateInput
  }

  export type FacebookGroupWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type FacebookGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookGroupCountOrderByAggregateInput
    _avg?: FacebookGroupAvgOrderByAggregateInput
    _max?: FacebookGroupMaxOrderByAggregateInput
    _min?: FacebookGroupMinOrderByAggregateInput
    _sum?: FacebookGroupSumOrderByAggregateInput
  }

  export type FacebookGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookGroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookUserInGroupWhereInput = {
    AND?: Enumerable<FacebookUserInGroupWhereInput>
    OR?: Enumerable<FacebookUserInGroupWhereInput>
    NOT?: Enumerable<FacebookUserInGroupWhereInput>
    id?: IntFilter | number
    user?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    group?: XOR<FacebookGroupRelationFilter, FacebookGroupWhereInput>
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserInGroupOrderByWithRelationInput = {
    id?: SortOrder
    user?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    group?: FacebookGroupOrderByWithRelationInput
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserInGroupWhereUniqueInput = {
    id?: number
  }

  export type FacebookUserInGroupOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookUserInGroupCountOrderByAggregateInput
    _avg?: FacebookUserInGroupAvgOrderByAggregateInput
    _max?: FacebookUserInGroupMaxOrderByAggregateInput
    _min?: FacebookUserInGroupMinOrderByAggregateInput
    _sum?: FacebookUserInGroupSumOrderByAggregateInput
  }

  export type FacebookUserInGroupScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookUserInGroupScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookUserInGroupScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookUserInGroupScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    groupId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookPostDestinationWhereInput = {
    AND?: Enumerable<FacebookPostDestinationWhereInput>
    OR?: Enumerable<FacebookPostDestinationWhereInput>
    NOT?: Enumerable<FacebookPostDestinationWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    userWall?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput> | null
    group?: XOR<FacebookGroupRelationFilter, FacebookGroupWhereInput> | null
    userId?: IntFilter | number
    groupId?: IntFilter | number
    post?: XOR<FacebookPostRelationFilter, FacebookPostWhereInput> | null
    postId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookPostDestinationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    userWall?: FacebookUserOrderByWithRelationInput
    group?: FacebookGroupOrderByWithRelationInput
    userId?: SortOrder
    groupId?: SortOrder
    post?: FacebookPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostDestinationWhereUniqueInput = {
    id?: number
  }

  export type FacebookPostDestinationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookPostDestinationCountOrderByAggregateInput
    _avg?: FacebookPostDestinationAvgOrderByAggregateInput
    _max?: FacebookPostDestinationMaxOrderByAggregateInput
    _min?: FacebookPostDestinationMinOrderByAggregateInput
    _sum?: FacebookPostDestinationSumOrderByAggregateInput
  }

  export type FacebookPostDestinationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookPostDestinationScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookPostDestinationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookPostDestinationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    groupId?: IntWithAggregatesFilter | number
    postId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookPostWhereInput = {
    AND?: Enumerable<FacebookPostWhereInput>
    OR?: Enumerable<FacebookPostWhereInput>
    NOT?: Enumerable<FacebookPostWhereInput>
    id?: IntFilter | number
    user?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    message?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    location?: XOR<FacebookLocationRelationFilter, FacebookLocationWhereInput>
    locationId?: IntFilter | number
    hashtag?: XOR<FacebookHashtagRelationFilter, FacebookHashtagWhereInput> | null
    hashtagId?: IntFilter | number
    share?: XOR<FacebookShareTypeRelationFilter, FacebookShareTypeWhereInput> | null
    shareToId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    likes?: FacebookLikeListRelationFilter
    commentPosts?: FacebookCommentPostListRelationFilter
    postDestionations?: FacebookPostDestinationListRelationFilter
  }

  export type FacebookPostOrderByWithRelationInput = {
    id?: SortOrder
    user?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    location?: FacebookLocationOrderByWithRelationInput
    locationId?: SortOrder
    hashtag?: FacebookHashtagOrderByWithRelationInput
    hashtagId?: SortOrder
    share?: FacebookShareTypeOrderByWithRelationInput
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: FacebookLikeOrderByRelationAggregateInput
    commentPosts?: FacebookCommentPostOrderByRelationAggregateInput
    postDestionations?: FacebookPostDestinationOrderByRelationAggregateInput
  }

  export type FacebookPostWhereUniqueInput = {
    id?: number
  }

  export type FacebookPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookPostCountOrderByAggregateInput
    _avg?: FacebookPostAvgOrderByAggregateInput
    _max?: FacebookPostMaxOrderByAggregateInput
    _min?: FacebookPostMinOrderByAggregateInput
    _sum?: FacebookPostSumOrderByAggregateInput
  }

  export type FacebookPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    locationId?: IntWithAggregatesFilter | number
    hashtagId?: IntWithAggregatesFilter | number
    shareToId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FacebookCommentPostWhereInput = {
    AND?: Enumerable<FacebookCommentPostWhereInput>
    OR?: Enumerable<FacebookCommentPostWhereInput>
    NOT?: Enumerable<FacebookCommentPostWhereInput>
    id?: IntFilter | number
    post?: XOR<FacebookPostRelationFilter, FacebookPostWhereInput>
    postId?: IntFilter | number
    user?: XOR<FacebookUserRelationFilter, FacebookUserWhereInput>
    userId?: IntFilter | number
    message?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    commentTo?: XOR<FacebookCommentPostRelationFilter, FacebookCommentPostWhereInput> | null
    commentToId?: IntNullableFilter | number | null
    share?: XOR<FacebookShareTypeRelationFilter, FacebookShareTypeWhereInput>
    shareToId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    commentPosts?: FacebookCommentPostListRelationFilter
  }

  export type FacebookCommentPostOrderByWithRelationInput = {
    id?: SortOrder
    post?: FacebookPostOrderByWithRelationInput
    postId?: SortOrder
    user?: FacebookUserOrderByWithRelationInput
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    commentTo?: FacebookCommentPostOrderByWithRelationInput
    commentToId?: SortOrder
    share?: FacebookShareTypeOrderByWithRelationInput
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentPosts?: FacebookCommentPostOrderByRelationAggregateInput
  }

  export type FacebookCommentPostWhereUniqueInput = {
    id?: number
  }

  export type FacebookCommentPostOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacebookCommentPostCountOrderByAggregateInput
    _avg?: FacebookCommentPostAvgOrderByAggregateInput
    _max?: FacebookCommentPostMaxOrderByAggregateInput
    _min?: FacebookCommentPostMinOrderByAggregateInput
    _sum?: FacebookCommentPostSumOrderByAggregateInput
  }

  export type FacebookCommentPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FacebookCommentPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<FacebookCommentPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FacebookCommentPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    commentToId?: IntNullableWithAggregatesFilter | number | null
    shareToId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterUserWhereInput = {
    AND?: Enumerable<TwitterUserWhereInput>
    OR?: Enumerable<TwitterUserWhereInput>
    NOT?: Enumerable<TwitterUserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    posts?: TwitterPostListRelationFilter
    followings?: TwitterUserRelationshipListRelationFilter
    followers?: TwitterUserRelationshipListRelationFilter
    replyPosts?: TwitterReplyPostListRelationFilter
    directMessageFrom?: TwitterDirectMessageListRelationFilter
    directMessageTo?: TwitterDirectMessageListRelationFilter
  }

  export type TwitterUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: TwitterPostOrderByRelationAggregateInput
    followings?: TwitterUserRelationshipOrderByRelationAggregateInput
    followers?: TwitterUserRelationshipOrderByRelationAggregateInput
    replyPosts?: TwitterReplyPostOrderByRelationAggregateInput
    directMessageFrom?: TwitterDirectMessageOrderByRelationAggregateInput
    directMessageTo?: TwitterDirectMessageOrderByRelationAggregateInput
  }

  export type TwitterUserWhereUniqueInput = {
    id?: number
    username?: string
  }

  export type TwitterUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterUserCountOrderByAggregateInput
    _avg?: TwitterUserAvgOrderByAggregateInput
    _max?: TwitterUserMaxOrderByAggregateInput
    _min?: TwitterUserMinOrderByAggregateInput
    _sum?: TwitterUserSumOrderByAggregateInput
  }

  export type TwitterUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostWhereInput = {
    AND?: Enumerable<TwitterPostWhereInput>
    OR?: Enumerable<TwitterPostWhereInput>
    NOT?: Enumerable<TwitterPostWhereInput>
    id?: IntFilter | number
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    userId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postAndHashtags?: TwitterPostAndHashtagListRelationFilter
    replyPosts?: TwitterReplyPostListRelationFilter
  }

  export type TwitterPostOrderByWithRelationInput = {
    id?: SortOrder
    user?: TwitterUserOrderByWithRelationInput
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postAndHashtags?: TwitterPostAndHashtagOrderByRelationAggregateInput
    replyPosts?: TwitterReplyPostOrderByRelationAggregateInput
  }

  export type TwitterPostWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterPostCountOrderByAggregateInput
    _avg?: TwitterPostAvgOrderByAggregateInput
    _max?: TwitterPostMaxOrderByAggregateInput
    _min?: TwitterPostMinOrderByAggregateInput
    _sum?: TwitterPostSumOrderByAggregateInput
  }

  export type TwitterPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterUserRelationshipWhereInput = {
    AND?: Enumerable<TwitterUserRelationshipWhereInput>
    OR?: Enumerable<TwitterUserRelationshipWhereInput>
    NOT?: Enumerable<TwitterUserRelationshipWhereInput>
    id?: IntFilter | number
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterUserRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    to?: TwitterUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserRelationshipWhereUniqueInput = {
    id?: number
  }

  export type TwitterUserRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterUserRelationshipCountOrderByAggregateInput
    _avg?: TwitterUserRelationshipAvgOrderByAggregateInput
    _max?: TwitterUserRelationshipMaxOrderByAggregateInput
    _min?: TwitterUserRelationshipMinOrderByAggregateInput
    _sum?: TwitterUserRelationshipSumOrderByAggregateInput
  }

  export type TwitterUserRelationshipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterUserRelationshipScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterUserRelationshipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterUserRelationshipScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterHashtagWhereInput = {
    AND?: Enumerable<TwitterHashtagWhereInput>
    OR?: Enumerable<TwitterHashtagWhereInput>
    NOT?: Enumerable<TwitterHashtagWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    postAndHashtags?: TwitterPostAndHashtagListRelationFilter
  }

  export type TwitterHashtagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postAndHashtags?: TwitterPostAndHashtagOrderByRelationAggregateInput
  }

  export type TwitterHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterHashtagCountOrderByAggregateInput
    _avg?: TwitterHashtagAvgOrderByAggregateInput
    _max?: TwitterHashtagMaxOrderByAggregateInput
    _min?: TwitterHashtagMinOrderByAggregateInput
    _sum?: TwitterHashtagSumOrderByAggregateInput
  }

  export type TwitterHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterPostAndHashtagWhereInput = {
    AND?: Enumerable<TwitterPostAndHashtagWhereInput>
    OR?: Enumerable<TwitterPostAndHashtagWhereInput>
    NOT?: Enumerable<TwitterPostAndHashtagWhereInput>
    id?: IntFilter | number
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    postId?: IntFilter | number
    hashtag?: XOR<TwitterHashtagRelationFilter, TwitterHashtagWhereInput>
    hashtagId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterPostAndHashtagOrderByWithRelationInput = {
    id?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    postId?: SortOrder
    hashtag?: TwitterHashtagOrderByWithRelationInput
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAndHashtagWhereUniqueInput = {
    id?: number
  }

  export type TwitterPostAndHashtagOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterPostAndHashtagCountOrderByAggregateInput
    _avg?: TwitterPostAndHashtagAvgOrderByAggregateInput
    _max?: TwitterPostAndHashtagMaxOrderByAggregateInput
    _min?: TwitterPostAndHashtagMinOrderByAggregateInput
    _sum?: TwitterPostAndHashtagSumOrderByAggregateInput
  }

  export type TwitterPostAndHashtagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterPostAndHashtagScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterPostAndHashtagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterPostAndHashtagScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    hashtagId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterReplyPostWhereInput = {
    AND?: Enumerable<TwitterReplyPostWhereInput>
    OR?: Enumerable<TwitterReplyPostWhereInput>
    NOT?: Enumerable<TwitterReplyPostWhereInput>
    id?: IntFilter | number
    user?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    userId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    post?: XOR<TwitterPostRelationFilter, TwitterPostWhereInput>
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterReplyPostOrderByWithRelationInput = {
    id?: SortOrder
    user?: TwitterUserOrderByWithRelationInput
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    post?: TwitterPostOrderByWithRelationInput
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterReplyPostWhereUniqueInput = {
    id?: number
  }

  export type TwitterReplyPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterReplyPostCountOrderByAggregateInput
    _avg?: TwitterReplyPostAvgOrderByAggregateInput
    _max?: TwitterReplyPostMaxOrderByAggregateInput
    _min?: TwitterReplyPostMinOrderByAggregateInput
    _sum?: TwitterReplyPostSumOrderByAggregateInput
  }

  export type TwitterReplyPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterReplyPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterReplyPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterReplyPostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    postId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TwitterDirectMessageWhereInput = {
    AND?: Enumerable<TwitterDirectMessageWhereInput>
    OR?: Enumerable<TwitterDirectMessageWhereInput>
    NOT?: Enumerable<TwitterDirectMessageWhereInput>
    id?: IntFilter | number
    from?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    to?: XOR<TwitterUserRelationFilter, TwitterUserWhereInput>
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    from?: TwitterUserOrderByWithRelationInput
    to?: TwitterUserOrderByWithRelationInput
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageWhereUniqueInput = {
    id?: number
  }

  export type TwitterDirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwitterDirectMessageCountOrderByAggregateInput
    _avg?: TwitterDirectMessageAvgOrderByAggregateInput
    _max?: TwitterDirectMessageMaxOrderByAggregateInput
    _min?: TwitterDirectMessageMinOrderByAggregateInput
    _sum?: TwitterDirectMessageSumOrderByAggregateInput
  }

  export type TwitterDirectMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromUserId?: IntWithAggregatesFilter | number
    toUserId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeUserWhereInput = {
    AND?: Enumerable<YoutubeUserWhereInput>
    OR?: Enumerable<YoutubeUserWhereInput>
    NOT?: Enumerable<YoutubeUserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userToChannels?: YoutubeUserToChannelListRelationFilter
    subscribers?: YoutubeSubscriberListRelationFilter
    reactions?: YoutubeReactionListRelationFilter
    comments?: YoutubeCommentListRelationFilter
  }

  export type YoutubeUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userToChannels?: YoutubeUserToChannelOrderByRelationAggregateInput
    subscribers?: YoutubeSubscriberOrderByRelationAggregateInput
    reactions?: YoutubeReactionOrderByRelationAggregateInput
    comments?: YoutubeCommentOrderByRelationAggregateInput
  }

  export type YoutubeUserWhereUniqueInput = {
    id?: number
    username?: string
    email?: string
  }

  export type YoutubeUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeUserCountOrderByAggregateInput
    _avg?: YoutubeUserAvgOrderByAggregateInput
    _max?: YoutubeUserMaxOrderByAggregateInput
    _min?: YoutubeUserMinOrderByAggregateInput
    _sum?: YoutubeUserSumOrderByAggregateInput
  }

  export type YoutubeUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeRoleWhereInput = {
    AND?: Enumerable<YoutubeRoleWhereInput>
    OR?: Enumerable<YoutubeRoleWhereInput>
    NOT?: Enumerable<YoutubeRoleWhereInput>
    id?: IntFilter | number
    role?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userToChannels?: YoutubeUserToChannelListRelationFilter
  }

  export type YoutubeRoleOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userToChannels?: YoutubeUserToChannelOrderByRelationAggregateInput
  }

  export type YoutubeRoleWhereUniqueInput = {
    id?: number
    role?: string
  }

  export type YoutubeRoleOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeRoleCountOrderByAggregateInput
    _avg?: YoutubeRoleAvgOrderByAggregateInput
    _max?: YoutubeRoleMaxOrderByAggregateInput
    _min?: YoutubeRoleMinOrderByAggregateInput
    _sum?: YoutubeRoleSumOrderByAggregateInput
  }

  export type YoutubeRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeRoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    role?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeChannelWhereInput = {
    AND?: Enumerable<YoutubeChannelWhereInput>
    OR?: Enumerable<YoutubeChannelWhereInput>
    NOT?: Enumerable<YoutubeChannelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    descriptions?: StringFilter | string
    image?: StringNullableFilter | string | null
    coverImage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userToChannels?: YoutubeUserToChannelListRelationFilter
    videos?: YoutubeVideoListRelationFilter
    subscribers?: YoutubeSubscriberListRelationFilter
  }

  export type YoutubeChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userToChannels?: YoutubeUserToChannelOrderByRelationAggregateInput
    videos?: YoutubeVideoOrderByRelationAggregateInput
    subscribers?: YoutubeSubscriberOrderByRelationAggregateInput
  }

  export type YoutubeChannelWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type YoutubeChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeChannelCountOrderByAggregateInput
    _avg?: YoutubeChannelAvgOrderByAggregateInput
    _max?: YoutubeChannelMaxOrderByAggregateInput
    _min?: YoutubeChannelMinOrderByAggregateInput
    _sum?: YoutubeChannelSumOrderByAggregateInput
  }

  export type YoutubeChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    descriptions?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    coverImage?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeUserToChannelWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelWhereInput>
    OR?: Enumerable<YoutubeUserToChannelWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    role?: XOR<YoutubeRoleRelationFilter, YoutubeRoleWhereInput>
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    userId?: IntFilter | number
    roleId?: IntFilter | number
    channelId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserToChannelOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    role?: YoutubeRoleOrderByWithRelationInput
    channel?: YoutubeChannelOrderByWithRelationInput
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserToChannelWhereUniqueInput = {
    id?: number
  }

  export type YoutubeUserToChannelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeUserToChannelCountOrderByAggregateInput
    _avg?: YoutubeUserToChannelAvgOrderByAggregateInput
    _max?: YoutubeUserToChannelMaxOrderByAggregateInput
    _min?: YoutubeUserToChannelMinOrderByAggregateInput
    _sum?: YoutubeUserToChannelSumOrderByAggregateInput
  }

  export type YoutubeUserToChannelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    roleId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeVideoWhereInput = {
    AND?: Enumerable<YoutubeVideoWhereInput>
    OR?: Enumerable<YoutubeVideoWhereInput>
    NOT?: Enumerable<YoutubeVideoWhereInput>
    id?: IntFilter | number
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    channelId?: IntFilter | number
    name?: StringFilter | string
    urlFile?: StringFilter | string
    coverImage?: StringNullableFilter | string | null
    descriptions?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    comments?: YoutubeCommentListRelationFilter
    reactions?: YoutubeReactionListRelationFilter
  }

  export type YoutubeVideoOrderByWithRelationInput = {
    id?: SortOrder
    channel?: YoutubeChannelOrderByWithRelationInput
    channelId?: SortOrder
    name?: SortOrder
    urlFile?: SortOrder
    coverImage?: SortOrder
    descriptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: YoutubeCommentOrderByRelationAggregateInput
    reactions?: YoutubeReactionOrderByRelationAggregateInput
  }

  export type YoutubeVideoWhereUniqueInput = {
    id?: number
  }

  export type YoutubeVideoOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    urlFile?: SortOrder
    coverImage?: SortOrder
    descriptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeVideoCountOrderByAggregateInput
    _avg?: YoutubeVideoAvgOrderByAggregateInput
    _max?: YoutubeVideoMaxOrderByAggregateInput
    _min?: YoutubeVideoMinOrderByAggregateInput
    _sum?: YoutubeVideoSumOrderByAggregateInput
  }

  export type YoutubeVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    urlFile?: StringWithAggregatesFilter | string
    coverImage?: StringNullableWithAggregatesFilter | string | null
    descriptions?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeSubscriberWhereInput = {
    AND?: Enumerable<YoutubeSubscriberWhereInput>
    OR?: Enumerable<YoutubeSubscriberWhereInput>
    NOT?: Enumerable<YoutubeSubscriberWhereInput>
    id?: IntFilter | number
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    channel?: XOR<YoutubeChannelRelationFilter, YoutubeChannelWhereInput>
    userId?: IntFilter | number
    channelId?: IntFilter | number
    membership?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeSubscriberOrderByWithRelationInput = {
    id?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    channel?: YoutubeChannelOrderByWithRelationInput
    userId?: SortOrder
    channelId?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeSubscriberWhereUniqueInput = {
    id?: number
  }

  export type YoutubeSubscriberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeSubscriberCountOrderByAggregateInput
    _avg?: YoutubeSubscriberAvgOrderByAggregateInput
    _max?: YoutubeSubscriberMaxOrderByAggregateInput
    _min?: YoutubeSubscriberMinOrderByAggregateInput
    _sum?: YoutubeSubscriberSumOrderByAggregateInput
  }

  export type YoutubeSubscriberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeSubscriberScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeSubscriberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeSubscriberScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    channelId?: IntWithAggregatesFilter | number
    membership?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeReactionWhereInput = {
    AND?: Enumerable<YoutubeReactionWhereInput>
    OR?: Enumerable<YoutubeReactionWhereInput>
    NOT?: Enumerable<YoutubeReactionWhereInput>
    id?: IntFilter | number
    type?: EnumReactionEnumFilter | ReactionEnum
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    video?: XOR<YoutubeVideoRelationFilter, YoutubeVideoWhereInput>
    userId?: IntFilter | number
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeReactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    user?: YoutubeUserOrderByWithRelationInput
    video?: YoutubeVideoOrderByWithRelationInput
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeReactionWhereUniqueInput = {
    id?: number
  }

  export type YoutubeReactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeReactionCountOrderByAggregateInput
    _avg?: YoutubeReactionAvgOrderByAggregateInput
    _max?: YoutubeReactionMaxOrderByAggregateInput
    _min?: YoutubeReactionMinOrderByAggregateInput
    _sum?: YoutubeReactionSumOrderByAggregateInput
  }

  export type YoutubeReactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeReactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumReactionEnumWithAggregatesFilter | ReactionEnum
    userId?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type YoutubeCommentWhereInput = {
    AND?: Enumerable<YoutubeCommentWhereInput>
    OR?: Enumerable<YoutubeCommentWhereInput>
    NOT?: Enumerable<YoutubeCommentWhereInput>
    id?: IntFilter | number
    video?: XOR<YoutubeVideoRelationFilter, YoutubeVideoWhereInput>
    user?: XOR<YoutubeUserRelationFilter, YoutubeUserWhereInput>
    commentTo?: XOR<YoutubeCommentRelationFilter, YoutubeCommentWhereInput> | null
    videoId?: IntFilter | number
    userId?: IntFilter | number
    message?: StringFilter | string
    commentToId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    commentPosts?: YoutubeCommentListRelationFilter
  }

  export type YoutubeCommentOrderByWithRelationInput = {
    id?: SortOrder
    video?: YoutubeVideoOrderByWithRelationInput
    user?: YoutubeUserOrderByWithRelationInput
    commentTo?: YoutubeCommentOrderByWithRelationInput
    videoId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    commentToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentPosts?: YoutubeCommentOrderByRelationAggregateInput
  }

  export type YoutubeCommentWhereUniqueInput = {
    id?: number
  }

  export type YoutubeCommentOrderByWithAggregationInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    commentToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: YoutubeCommentCountOrderByAggregateInput
    _avg?: YoutubeCommentAvgOrderByAggregateInput
    _max?: YoutubeCommentMaxOrderByAggregateInput
    _min?: YoutubeCommentMinOrderByAggregateInput
    _sum?: YoutubeCommentSumOrderByAggregateInput
  }

  export type YoutubeCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<YoutubeCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    videoId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    commentToId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderBranchInfoWhereInput = {
    AND?: Enumerable<LaunderBranchInfoWhereInput>
    OR?: Enumerable<LaunderBranchInfoWhereInput>
    NOT?: Enumerable<LaunderBranchInfoWhereInput>
    id?: IntFilter | number
    owner?: StringFilter | string
    phone?: IntFilter | number
    location?: StringFilter | string
    areaSize?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    machineInStores?: LaundryMachineInStoreListRelationFilter
  }

  export type LaunderBranchInfoOrderByWithRelationInput = {
    id?: SortOrder
    owner?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    machineInStores?: LaundryMachineInStoreOrderByRelationAggregateInput
  }

  export type LaunderBranchInfoWhereUniqueInput = {
    id?: number
    phone?: number
  }

  export type LaunderBranchInfoOrderByWithAggregationInput = {
    id?: SortOrder
    owner?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderBranchInfoCountOrderByAggregateInput
    _avg?: LaunderBranchInfoAvgOrderByAggregateInput
    _max?: LaunderBranchInfoMaxOrderByAggregateInput
    _min?: LaunderBranchInfoMinOrderByAggregateInput
    _sum?: LaunderBranchInfoSumOrderByAggregateInput
  }

  export type LaunderBranchInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderBranchInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderBranchInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderBranchInfoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    owner?: StringWithAggregatesFilter | string
    phone?: IntWithAggregatesFilter | number
    location?: StringWithAggregatesFilter | string
    areaSize?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderMachineWhereInput = {
    AND?: Enumerable<LaunderMachineWhereInput>
    OR?: Enumerable<LaunderMachineWhereInput>
    NOT?: Enumerable<LaunderMachineWhereInput>
    id?: IntFilter | number
    brand?: StringFilter | string
    Capacity?: IntFilter | number
    type?: StringFilter | string
    serialNumber?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    machineInStores?: LaundryMachineInStoreListRelationFilter
    serviceHistories?: LaunderServiceHistoryListRelationFilter
  }

  export type LaunderMachineOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    Capacity?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    machineInStores?: LaundryMachineInStoreOrderByRelationAggregateInput
    serviceHistories?: LaunderServiceHistoryOrderByRelationAggregateInput
  }

  export type LaunderMachineWhereUniqueInput = {
    id?: number
  }

  export type LaunderMachineOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    Capacity?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderMachineCountOrderByAggregateInput
    _avg?: LaunderMachineAvgOrderByAggregateInput
    _max?: LaunderMachineMaxOrderByAggregateInput
    _min?: LaunderMachineMinOrderByAggregateInput
    _sum?: LaunderMachineSumOrderByAggregateInput
  }

  export type LaunderMachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderMachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderMachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderMachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    brand?: StringWithAggregatesFilter | string
    Capacity?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    serialNumber?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryMachineInStoreWhereInput = {
    AND?: Enumerable<LaundryMachineInStoreWhereInput>
    OR?: Enumerable<LaundryMachineInStoreWhereInput>
    NOT?: Enumerable<LaundryMachineInStoreWhereInput>
    id?: IntFilter | number
    branch?: XOR<LaunderBranchInfoRelationFilter, LaunderBranchInfoWhereInput>
    machine?: XOR<LaunderMachineRelationFilter, LaunderMachineWhereInput>
    branchId?: IntFilter | number
    machineId?: IntFilter | number
    mfd?: StringFilter | string
    Warranty?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    programInMachines?: LaunderProgramInMachineListRelationFilter
    washingHistories?: LaundryWashingHistoryListRelationFilter
  }

  export type LaundryMachineInStoreOrderByWithRelationInput = {
    id?: SortOrder
    branch?: LaunderBranchInfoOrderByWithRelationInput
    machine?: LaunderMachineOrderByWithRelationInput
    branchId?: SortOrder
    machineId?: SortOrder
    mfd?: SortOrder
    Warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programInMachines?: LaunderProgramInMachineOrderByRelationAggregateInput
    washingHistories?: LaundryWashingHistoryOrderByRelationAggregateInput
  }

  export type LaundryMachineInStoreWhereUniqueInput = {
    id?: number
  }

  export type LaundryMachineInStoreOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
    mfd?: SortOrder
    Warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryMachineInStoreCountOrderByAggregateInput
    _avg?: LaundryMachineInStoreAvgOrderByAggregateInput
    _max?: LaundryMachineInStoreMaxOrderByAggregateInput
    _min?: LaundryMachineInStoreMinOrderByAggregateInput
    _sum?: LaundryMachineInStoreSumOrderByAggregateInput
  }

  export type LaundryMachineInStoreScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryMachineInStoreScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryMachineInStoreScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryMachineInStoreScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    branchId?: IntWithAggregatesFilter | number
    machineId?: IntWithAggregatesFilter | number
    mfd?: StringWithAggregatesFilter | string
    Warranty?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderTechnicianWhereInput = {
    AND?: Enumerable<LaunderTechnicianWhereInput>
    OR?: Enumerable<LaunderTechnicianWhereInput>
    NOT?: Enumerable<LaunderTechnicianWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    image?: StringNullableFilter | string | null
    phone?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    serviceHistories?: LaunderServiceHistoryListRelationFilter
  }

  export type LaunderTechnicianOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceHistories?: LaunderServiceHistoryOrderByRelationAggregateInput
  }

  export type LaunderTechnicianWhereUniqueInput = {
    id?: number
  }

  export type LaunderTechnicianOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderTechnicianCountOrderByAggregateInput
    _avg?: LaunderTechnicianAvgOrderByAggregateInput
    _max?: LaunderTechnicianMaxOrderByAggregateInput
    _min?: LaunderTechnicianMinOrderByAggregateInput
    _sum?: LaunderTechnicianSumOrderByAggregateInput
  }

  export type LaunderTechnicianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderTechnicianScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderTechnicianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderTechnicianScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    phone?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderServiceHistoryWhereInput = {
    AND?: Enumerable<LaunderServiceHistoryWhereInput>
    OR?: Enumerable<LaunderServiceHistoryWhereInput>
    NOT?: Enumerable<LaunderServiceHistoryWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    machine?: XOR<LaunderMachineRelationFilter, LaunderMachineWhereInput>
    technician?: XOR<LaunderTechnicianRelationFilter, LaunderTechnicianWhereInput>
    machineId?: IntFilter | number
    technicianId?: IntFilter | number
    descriptions?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaunderServiceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    machine?: LaunderMachineOrderByWithRelationInput
    technician?: LaunderTechnicianOrderByWithRelationInput
    machineId?: SortOrder
    technicianId?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderServiceHistoryWhereUniqueInput = {
    id?: number
  }

  export type LaunderServiceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderServiceHistoryCountOrderByAggregateInput
    _avg?: LaunderServiceHistoryAvgOrderByAggregateInput
    _max?: LaunderServiceHistoryMaxOrderByAggregateInput
    _min?: LaunderServiceHistoryMinOrderByAggregateInput
    _sum?: LaunderServiceHistorySumOrderByAggregateInput
  }

  export type LaunderServiceHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderServiceHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderServiceHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderServiceHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    machineId?: IntWithAggregatesFilter | number
    technicianId?: IntWithAggregatesFilter | number
    descriptions?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderWashingProgramWhereInput = {
    AND?: Enumerable<LaunderWashingProgramWhereInput>
    OR?: Enumerable<LaunderWashingProgramWhereInput>
    NOT?: Enumerable<LaunderWashingProgramWhereInput>
    id?: IntFilter | number
    program?: StringFilter | string
    price?: IntFilter | number
    duration?: IntFilter | number
    capacityLimit?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    programInMachines?: LaunderProgramInMachineListRelationFilter
    washingHistories?: LaundryWashingHistoryListRelationFilter
  }

  export type LaunderWashingProgramOrderByWithRelationInput = {
    id?: SortOrder
    program?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    programInMachines?: LaunderProgramInMachineOrderByRelationAggregateInput
    washingHistories?: LaundryWashingHistoryOrderByRelationAggregateInput
  }

  export type LaunderWashingProgramWhereUniqueInput = {
    id?: number
  }

  export type LaunderWashingProgramOrderByWithAggregationInput = {
    id?: SortOrder
    program?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderWashingProgramCountOrderByAggregateInput
    _avg?: LaunderWashingProgramAvgOrderByAggregateInput
    _max?: LaunderWashingProgramMaxOrderByAggregateInput
    _min?: LaunderWashingProgramMinOrderByAggregateInput
    _sum?: LaunderWashingProgramSumOrderByAggregateInput
  }

  export type LaunderWashingProgramScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderWashingProgramScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderWashingProgramScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderWashingProgramScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    program?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    capacityLimit?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderProgramInMachineWhereInput = {
    AND?: Enumerable<LaunderProgramInMachineWhereInput>
    OR?: Enumerable<LaunderProgramInMachineWhereInput>
    NOT?: Enumerable<LaunderProgramInMachineWhereInput>
    id?: IntFilter | number
    machine?: XOR<LaundryMachineInStoreRelationFilter, LaundryMachineInStoreWhereInput>
    program?: XOR<LaunderWashingProgramRelationFilter, LaunderWashingProgramWhereInput>
    machineId?: IntFilter | number
    programId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaunderProgramInMachineOrderByWithRelationInput = {
    id?: SortOrder
    machine?: LaundryMachineInStoreOrderByWithRelationInput
    program?: LaunderWashingProgramOrderByWithRelationInput
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderProgramInMachineWhereUniqueInput = {
    id?: number
  }

  export type LaunderProgramInMachineOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderProgramInMachineCountOrderByAggregateInput
    _avg?: LaunderProgramInMachineAvgOrderByAggregateInput
    _max?: LaunderProgramInMachineMaxOrderByAggregateInput
    _min?: LaunderProgramInMachineMinOrderByAggregateInput
    _sum?: LaunderProgramInMachineSumOrderByAggregateInput
  }

  export type LaunderProgramInMachineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderProgramInMachineScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderProgramInMachineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderProgramInMachineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    machineId?: IntWithAggregatesFilter | number
    programId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaunderUserWhereInput = {
    AND?: Enumerable<LaunderUserWhereInput>
    OR?: Enumerable<LaunderUserWhereInput>
    NOT?: Enumerable<LaunderUserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    phone?: IntFilter | number
    walletBalance?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    topupHistories?: LaundryTopupHistoryListRelationFilter
  }

  export type LaunderUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topupHistories?: LaundryTopupHistoryOrderByRelationAggregateInput
  }

  export type LaunderUserWhereUniqueInput = {
    id?: number
  }

  export type LaunderUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunderUserCountOrderByAggregateInput
    _avg?: LaunderUserAvgOrderByAggregateInput
    _max?: LaunderUserMaxOrderByAggregateInput
    _min?: LaunderUserMinOrderByAggregateInput
    _sum?: LaunderUserSumOrderByAggregateInput
  }

  export type LaunderUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaunderUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaunderUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaunderUserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    phone?: IntWithAggregatesFilter | number
    walletBalance?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryTopupHistoryWhereInput = {
    AND?: Enumerable<LaundryTopupHistoryWhereInput>
    OR?: Enumerable<LaundryTopupHistoryWhereInput>
    NOT?: Enumerable<LaundryTopupHistoryWhereInput>
    id?: IntFilter | number
    user?: XOR<LaunderUserRelationFilter, LaunderUserWhereInput>
    userId?: IntFilter | number
    value?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaundryTopupHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user?: LaunderUserOrderByWithRelationInput
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryTopupHistoryWhereUniqueInput = {
    id?: number
  }

  export type LaundryTopupHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryTopupHistoryCountOrderByAggregateInput
    _avg?: LaundryTopupHistoryAvgOrderByAggregateInput
    _max?: LaundryTopupHistoryMaxOrderByAggregateInput
    _min?: LaundryTopupHistoryMinOrderByAggregateInput
    _sum?: LaundryTopupHistorySumOrderByAggregateInput
  }

  export type LaundryTopupHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryTopupHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryTopupHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryTopupHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    value?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LaundryWashingHistoryWhereInput = {
    AND?: Enumerable<LaundryWashingHistoryWhereInput>
    OR?: Enumerable<LaundryWashingHistoryWhereInput>
    NOT?: Enumerable<LaundryWashingHistoryWhereInput>
    id?: IntFilter | number
    machine?: XOR<LaundryMachineInStoreRelationFilter, LaundryMachineInStoreWhereInput>
    program?: XOR<LaunderWashingProgramRelationFilter, LaunderWashingProgramWhereInput>
    machineId?: IntFilter | number
    programId?: IntFilter | number
    date?: DateTimeFilter | Date | string
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaundryWashingHistoryOrderByWithRelationInput = {
    id?: SortOrder
    machine?: LaundryMachineInStoreOrderByWithRelationInput
    program?: LaunderWashingProgramOrderByWithRelationInput
    machineId?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryWashingHistoryWhereUniqueInput = {
    id?: number
  }

  export type LaundryWashingHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaundryWashingHistoryCountOrderByAggregateInput
    _avg?: LaundryWashingHistoryAvgOrderByAggregateInput
    _max?: LaundryWashingHistoryMaxOrderByAggregateInput
    _min?: LaundryWashingHistoryMinOrderByAggregateInput
    _sum?: LaundryWashingHistorySumOrderByAggregateInput
  }

  export type LaundryWashingHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LaundryWashingHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LaundryWashingHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LaundryWashingHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    machineId?: IntWithAggregatesFilter | number
    programId?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    price?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryStudentWhereInput = {
    AND?: Enumerable<LibraryStudentWhereInput>
    OR?: Enumerable<LibraryStudentWhereInput>
    NOT?: Enumerable<LibraryStudentWhereInput>
    id?: IntFilter | number
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    requests?: LibraryRequestListRelationFilter
    borrowings?: LibraryBorrowingListRelationFilter
  }

  export type LibraryStudentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requests?: LibraryRequestOrderByRelationAggregateInput
    borrowings?: LibraryBorrowingOrderByRelationAggregateInput
  }

  export type LibraryStudentWhereUniqueInput = {
    id?: number
  }

  export type LibraryStudentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryStudentCountOrderByAggregateInput
    _avg?: LibraryStudentAvgOrderByAggregateInput
    _max?: LibraryStudentMaxOrderByAggregateInput
    _min?: LibraryStudentMinOrderByAggregateInput
    _sum?: LibraryStudentSumOrderByAggregateInput
  }

  export type LibraryStudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryStudentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryUniversityWhereInput = {
    AND?: Enumerable<LibraryUniversityWhereInput>
    OR?: Enumerable<LibraryUniversityWhereInput>
    NOT?: Enumerable<LibraryUniversityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    bookCopies?: LibraryBookCopyListRelationFilter
    fromRequests?: LibraryRequestListRelationFilter
    toRequests?: LibraryRequestListRelationFilter
    borrowings?: LibraryBorrowingListRelationFilter
  }

  export type LibraryUniversityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookCopies?: LibraryBookCopyOrderByRelationAggregateInput
    fromRequests?: LibraryRequestOrderByRelationAggregateInput
    toRequests?: LibraryRequestOrderByRelationAggregateInput
    borrowings?: LibraryBorrowingOrderByRelationAggregateInput
  }

  export type LibraryUniversityWhereUniqueInput = {
    id?: number
  }

  export type LibraryUniversityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryUniversityCountOrderByAggregateInput
    _avg?: LibraryUniversityAvgOrderByAggregateInput
    _max?: LibraryUniversityMaxOrderByAggregateInput
    _min?: LibraryUniversityMinOrderByAggregateInput
    _sum?: LibraryUniversitySumOrderByAggregateInput
  }

  export type LibraryUniversityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryUniversityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryCategoryWhereInput = {
    AND?: Enumerable<LibraryCategoryWhereInput>
    OR?: Enumerable<LibraryCategoryWhereInput>
    NOT?: Enumerable<LibraryCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    bookCategories?: LibraryBookCategoryListRelationFilter
  }

  export type LibraryCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookCategories?: LibraryBookCategoryOrderByRelationAggregateInput
  }

  export type LibraryCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryCategoryCountOrderByAggregateInput
    _avg?: LibraryCategoryAvgOrderByAggregateInput
    _max?: LibraryCategoryMaxOrderByAggregateInput
    _min?: LibraryCategoryMinOrderByAggregateInput
    _sum?: LibraryCategorySumOrderByAggregateInput
  }

  export type LibraryCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryAuthorWhereInput = {
    AND?: Enumerable<LibraryAuthorWhereInput>
    OR?: Enumerable<LibraryAuthorWhereInput>
    NOT?: Enumerable<LibraryAuthorWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    bookAuthors?: LibraryBookAuthorListRelationFilter
  }

  export type LibraryAuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookAuthors?: LibraryBookAuthorOrderByRelationAggregateInput
  }

  export type LibraryAuthorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LibraryAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryAuthorCountOrderByAggregateInput
    _avg?: LibraryAuthorAvgOrderByAggregateInput
    _max?: LibraryAuthorMaxOrderByAggregateInput
    _min?: LibraryAuthorMinOrderByAggregateInput
    _sum?: LibraryAuthorSumOrderByAggregateInput
  }

  export type LibraryAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookWhereInput = {
    AND?: Enumerable<LibraryBookWhereInput>
    OR?: Enumerable<LibraryBookWhereInput>
    NOT?: Enumerable<LibraryBookWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isbn?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    bookCategories?: LibraryBookCategoryListRelationFilter
    bookAuthors?: LibraryBookAuthorListRelationFilter
    bookCopies?: LibraryBookCopyListRelationFilter
    requests?: LibraryRequestListRelationFilter
    borrowings?: LibraryBorrowingListRelationFilter
  }

  export type LibraryBookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookCategories?: LibraryBookCategoryOrderByRelationAggregateInput
    bookAuthors?: LibraryBookAuthorOrderByRelationAggregateInput
    bookCopies?: LibraryBookCopyOrderByRelationAggregateInput
    requests?: LibraryRequestOrderByRelationAggregateInput
    borrowings?: LibraryBorrowingOrderByRelationAggregateInput
  }

  export type LibraryBookWhereUniqueInput = {
    id?: number
    isbn?: number
  }

  export type LibraryBookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCountOrderByAggregateInput
    _avg?: LibraryBookAvgOrderByAggregateInput
    _max?: LibraryBookMaxOrderByAggregateInput
    _min?: LibraryBookMinOrderByAggregateInput
    _sum?: LibraryBookSumOrderByAggregateInput
  }

  export type LibraryBookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isbn?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookCategoryWhereInput = {
    AND?: Enumerable<LibraryBookCategoryWhereInput>
    OR?: Enumerable<LibraryBookCategoryWhereInput>
    NOT?: Enumerable<LibraryBookCategoryWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    category?: XOR<LibraryCategoryRelationFilter, LibraryCategoryWhereInput>
    bookId?: IntFilter | number
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookCategoryOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    category?: LibraryCategoryOrderByWithRelationInput
    bookId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategoryWhereUniqueInput = {
    id?: number
  }

  export type LibraryBookCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCategoryCountOrderByAggregateInput
    _avg?: LibraryBookCategoryAvgOrderByAggregateInput
    _max?: LibraryBookCategoryMaxOrderByAggregateInput
    _min?: LibraryBookCategoryMinOrderByAggregateInput
    _sum?: LibraryBookCategorySumOrderByAggregateInput
  }

  export type LibraryBookCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    bookId?: IntWithAggregatesFilter | number
    categoryId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookAuthorWhereInput = {
    AND?: Enumerable<LibraryBookAuthorWhereInput>
    OR?: Enumerable<LibraryBookAuthorWhereInput>
    NOT?: Enumerable<LibraryBookAuthorWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    author?: XOR<LibraryAuthorRelationFilter, LibraryAuthorWhereInput>
    bookId?: IntFilter | number
    authorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookAuthorOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    author?: LibraryAuthorOrderByWithRelationInput
    bookId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorWhereUniqueInput = {
    id?: number
  }

  export type LibraryBookAuthorOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookAuthorCountOrderByAggregateInput
    _avg?: LibraryBookAuthorAvgOrderByAggregateInput
    _max?: LibraryBookAuthorMaxOrderByAggregateInput
    _min?: LibraryBookAuthorMinOrderByAggregateInput
    _sum?: LibraryBookAuthorSumOrderByAggregateInput
  }

  export type LibraryBookAuthorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookAuthorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    bookId?: IntWithAggregatesFilter | number
    authorId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBookCopyWhereInput = {
    AND?: Enumerable<LibraryBookCopyWhereInput>
    OR?: Enumerable<LibraryBookCopyWhereInput>
    NOT?: Enumerable<LibraryBookCopyWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    university?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    bookId?: IntFilter | number
    universityId?: IntFilter | number
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookCopyOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    university?: LibraryUniversityOrderByWithRelationInput
    bookId?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCopyWhereUniqueInput = {
    id?: number
  }

  export type LibraryBookCopyOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBookCopyCountOrderByAggregateInput
    _avg?: LibraryBookCopyAvgOrderByAggregateInput
    _max?: LibraryBookCopyMaxOrderByAggregateInput
    _min?: LibraryBookCopyMinOrderByAggregateInput
    _sum?: LibraryBookCopySumOrderByAggregateInput
  }

  export type LibraryBookCopyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBookCopyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    bookId?: IntWithAggregatesFilter | number
    universityId?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryRequestWhereInput = {
    AND?: Enumerable<LibraryRequestWhereInput>
    OR?: Enumerable<LibraryRequestWhereInput>
    NOT?: Enumerable<LibraryRequestWhereInput>
    id?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    student?: XOR<LibraryStudentRelationFilter, LibraryStudentWhereInput>
    fromUniversity?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    toUniversity?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    bookId?: IntFilter | number
    studentId?: IntFilter | number
    fromUniversityId?: IntFilter | number
    toUniversityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryRequestOrderByWithRelationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    student?: LibraryStudentOrderByWithRelationInput
    fromUniversity?: LibraryUniversityOrderByWithRelationInput
    toUniversity?: LibraryUniversityOrderByWithRelationInput
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryRequestWhereUniqueInput = {
    id?: number
  }

  export type LibraryRequestOrderByWithAggregationInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryRequestCountOrderByAggregateInput
    _avg?: LibraryRequestAvgOrderByAggregateInput
    _max?: LibraryRequestMaxOrderByAggregateInput
    _min?: LibraryRequestMinOrderByAggregateInput
    _sum?: LibraryRequestSumOrderByAggregateInput
  }

  export type LibraryRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    borrowDate?: DateTimeWithAggregatesFilter | Date | string
    returnDate?: DateTimeWithAggregatesFilter | Date | string
    bookId?: IntWithAggregatesFilter | number
    studentId?: IntWithAggregatesFilter | number
    fromUniversityId?: IntWithAggregatesFilter | number
    toUniversityId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LibraryBorrowingWhereInput = {
    AND?: Enumerable<LibraryBorrowingWhereInput>
    OR?: Enumerable<LibraryBorrowingWhereInput>
    NOT?: Enumerable<LibraryBorrowingWhereInput>
    id?: IntFilter | number
    book?: XOR<LibraryBookRelationFilter, LibraryBookWhereInput>
    student?: XOR<LibraryStudentRelationFilter, LibraryStudentWhereInput>
    university?: XOR<LibraryUniversityRelationFilter, LibraryUniversityWhereInput>
    bookId?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    actualReturnDate?: DateTimeFilter | Date | string
    studentId?: IntFilter | number
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBorrowingOrderByWithRelationInput = {
    id?: SortOrder
    book?: LibraryBookOrderByWithRelationInput
    student?: LibraryStudentOrderByWithRelationInput
    university?: LibraryUniversityOrderByWithRelationInput
    bookId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBorrowingWhereUniqueInput = {
    id?: number
  }

  export type LibraryBorrowingOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryBorrowingCountOrderByAggregateInput
    _avg?: LibraryBorrowingAvgOrderByAggregateInput
    _max?: LibraryBorrowingMaxOrderByAggregateInput
    _min?: LibraryBorrowingMinOrderByAggregateInput
    _sum?: LibraryBorrowingSumOrderByAggregateInput
  }

  export type LibraryBorrowingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LibraryBorrowingScalarWhereWithAggregatesInput>
    OR?: Enumerable<LibraryBorrowingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LibraryBorrowingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    bookId?: IntWithAggregatesFilter | number
    borrowDate?: DateTimeWithAggregatesFilter | Date | string
    returnDate?: DateTimeWithAggregatesFilter | Date | string
    actualReturnDate?: DateTimeWithAggregatesFilter | Date | string
    studentId?: IntWithAggregatesFilter | number
    universityId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TodoListWhereInput = {
    AND?: Enumerable<TodoListWhereInput>
    OR?: Enumerable<TodoListWhereInput>
    NOT?: Enumerable<TodoListWhereInput>
    id?: IntFilter | number
    task?: StringFilter | string
    status?: StringFilter | string
    note?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TodoListOrderByWithRelationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListWhereUniqueInput = {
    id?: number
  }

  export type TodoListOrderByWithAggregationInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TodoListCountOrderByAggregateInput
    _avg?: TodoListAvgOrderByAggregateInput
    _max?: TodoListMaxOrderByAggregateInput
    _min?: TodoListMinOrderByAggregateInput
    _sum?: TodoListSumOrderByAggregateInput
  }

  export type TodoListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TodoListScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    task?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    note?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BinKitchenCategoryCreateInput = {
    name: string
    menus?: BinKitchenMenuCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUncheckedCreateInput = {
    id?: number
    name: string
    menus?: BinKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    menus?: BinKitchenMenuUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    menus?: BinKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuCreateInput = {
    name: string
    image: string
    price: number
    category?: BinKitchenCategoryCreateNestedOneWithoutMenusInput
    orderItems?: BinKitchenOrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUncheckedCreateInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    orderItems?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: BinKitchenCategoryUpdateOneWithoutMenusNestedInput
    orderItems?: BinKitchenOrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuCreateManyInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderCreateInput = {
    status?: string
    tableId: number
    items?: BinKitchenOrderItemCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUncheckedCreateInput = {
    id?: number
    status?: string
    tableId: number
    items?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: BinKitchenOrderItemUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    items?: BinKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderCreateManyInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateInput = {
    menu: BinKitchenMenuCreateNestedOneWithoutOrderItemsInput
    order?: BinKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUpdateInput = {
    menu?: BinKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    order?: BinKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateManyInput = {
    id?: number
    menuId: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutCategoryInput
    rounds?: QuizRoundCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput
    rounds?: QuizRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutCategoryNestedInput
    rounds?: QuizRoundUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput
    rounds?: QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateInput = {
    questName: string
    category: QuizCategoryCreateNestedOneWithoutQuestionsInput
    answer: QuizChoiceCreateNestedOneWithoutQuestionAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: number
    questName: string
    categoryId: number
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    questName?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    answer?: QuizChoiceUpdateOneRequiredWithoutQuestionAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUncheckedUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: number
    questName: string
    categoryId: number
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    questName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceCreateInput = {
    choiceName: string
    questione?: QuizQuestionCreateNestedOneWithoutChoicesInput
    questionAnswer?: QuizQuestionCreateNestedOneWithoutAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUncheckedCreateInput = {
    id?: number
    choiceName: string
    questionId?: number | null
    questionAnswer?: QuizQuestionUncheckedCreateNestedOneWithoutAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUpdateInput = {
    choiceName?: StringFieldUpdateOperationsInput | string
    questione?: QuizQuestionUpdateOneWithoutChoicesNestedInput
    questionAnswer?: QuizQuestionUpdateOneWithoutAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceName?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswer?: QuizQuestionUncheckedUpdateOneWithoutAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceCreateManyInput = {
    id?: number
    choiceName: string
    questionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUpdateManyMutationInput = {
    choiceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceName?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionCreateInput = {
    userChoiceId: number
    question: QuizQuestionCreateNestedOneWithoutRoundQuestionsInput
    round: QuizRoundCreateNestedOneWithoutQuestionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUncheckedCreateInput = {
    id?: number
    userChoiceId: number
    questionId: number
    roundId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUpdateInput = {
    userChoiceId?: IntFieldUpdateOperationsInput | number
    question?: QuizQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput
    round?: QuizRoundUpdateOneRequiredWithoutQuestionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionCreateManyInput = {
    id?: number
    userChoiceId: number
    questionId: number
    roundId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUpdateManyMutationInput = {
    userChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundCreateInput = {
    user: string
    category: QuizCategoryCreateNestedOneWithoutRoundsInput
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizRoundQuestionCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUncheckedCreateInput = {
    id?: number
    user: string
    categoryId: number
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUpdateInput = {
    user?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutRoundsNestedInput
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizRoundQuestionUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundCreateManyInput = {
    id?: number
    user: string
    categoryId: number
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundUpdateManyMutationInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserCreateInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserCreateManyInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipCreateInput = {
    from: FacebookUserCreateNestedOneWithoutFromInput
    to: FacebookUserCreateNestedOneWithoutToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUpdateInput = {
    from?: FacebookUserUpdateOneRequiredWithoutFromNestedInput
    to?: FacebookUserUpdateOneRequiredWithoutToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageCreateInput = {
    from: FacebookUserCreateNestedOneWithoutDirectMessageFromInput
    to: FacebookUserCreateNestedOneWithoutDirectMessageToInput
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageUpdateInput = {
    from?: FacebookUserUpdateOneRequiredWithoutDirectMessageFromNestedInput
    to?: FacebookUserUpdateOneRequiredWithoutDirectMessageToNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLocationCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostCreateNestedManyWithoutLocationInput
  }

  export type FacebookLocationUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostUncheckedCreateNestedManyWithoutLocationInput
  }

  export type FacebookLocationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUpdateManyWithoutLocationNestedInput
  }

  export type FacebookLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type FacebookLocationCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLocationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashtagCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostCreateNestedManyWithoutHashtagInput
  }

  export type FacebookHashtagUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostUncheckedCreateNestedManyWithoutHashtagInput
  }

  export type FacebookHashtagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUpdateManyWithoutHashtagNestedInput
  }

  export type FacebookHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUncheckedUpdateManyWithoutHashtagNestedInput
  }

  export type FacebookHashtagCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashtagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeCreateInput = {
    type: FacebookLikeTypeEnum
    user: FacebookUserCreateNestedOneWithoutLikesInput
    posts?: FacebookPostCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUncheckedCreateInput = {
    id?: number
    type: FacebookLikeTypeEnum
    userId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUpdateInput = {
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    user?: FacebookUserUpdateOneRequiredWithoutLikesNestedInput
    posts?: FacebookPostUpdateOneWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    userId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeCreateManyInput = {
    id?: number
    type: FacebookLikeTypeEnum
    userId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUpdateManyMutationInput = {
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    userId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookShareTypeCreateInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutShareInput
    posts?: FacebookPostCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeUncheckedCreateInput = {
    id?: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutShareInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutShareNestedInput
    posts?: FacebookPostUpdateManyWithoutShareNestedInput
  }

  export type FacebookShareTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutShareNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FacebookShareTypeCreateManyInput = {
    id?: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookShareTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookShareTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookGroupCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutGroupInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutGroupInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInGroups?: FacebookUserInGroupUpdateManyWithoutGroupNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutGroupNestedInput
  }

  export type FacebookGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutGroupNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FacebookGroupCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupCreateInput = {
    user: FacebookUserCreateNestedOneWithoutUserInGroupsInput
    group: FacebookGroupCreateNestedOneWithoutUserInGroupsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUncheckedCreateInput = {
    id?: number
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUpdateInput = {
    user?: FacebookUserUpdateOneRequiredWithoutUserInGroupsNestedInput
    group?: FacebookGroupUpdateOneRequiredWithoutUserInGroupsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupCreateManyInput = {
    id?: number
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationCreateInput = {
    type: string
    userWall?: FacebookUserCreateNestedOneWithoutPostDestinationsInput
    group?: FacebookGroupCreateNestedOneWithoutPostDestinationsInput
    post?: FacebookPostCreateNestedOneWithoutPostDestionationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUncheckedCreateInput = {
    id?: number
    type: string
    userId: number
    groupId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    userWall?: FacebookUserUpdateOneWithoutPostDestinationsNestedInput
    group?: FacebookGroupUpdateOneWithoutPostDestinationsNestedInput
    post?: FacebookPostUpdateOneWithoutPostDestionationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationCreateManyInput = {
    id?: number
    type: string
    userId: number
    groupId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostCreateInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUpdateInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostCreateManyInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostCreateInput = {
    post: FacebookPostCreateNestedOneWithoutCommentPostsInput
    user: FacebookUserCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    commentTo?: FacebookCommentPostCreateNestedOneWithoutCommentPostsInput
    share: FacebookShareTypeCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUpdateInput = {
    post?: FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput
    user?: FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentTo?: FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput
    share?: FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostCreateManyInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserCreateInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserCreateManyInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostCreateInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagCreateNestedManyWithoutPostInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedCreateNestedManyWithoutPostInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUpdateInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUpdateManyWithoutPostNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedUpdateManyWithoutPostNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostCreateManyInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipCreateInput = {
    from: TwitterUserCreateNestedOneWithoutFollowingsInput
    to: TwitterUserCreateNestedOneWithoutFollowersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipUpdateInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFollowingsNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutFollowersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedCreateNestedManyWithoutHashtagInput
  }

  export type TwitterHashtagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedUpdateManyWithoutHashtagNestedInput
  }

  export type TwitterHashtagCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagCreateInput = {
    post: TwitterPostCreateNestedOneWithoutPostAndHashtagsInput
    hashtag: TwitterHashtagCreateNestedOneWithoutPostAndHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUncheckedCreateInput = {
    id?: number
    postId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUpdateInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostAndHashtagsNestedInput
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostAndHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagCreateManyInput = {
    id?: number
    postId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostCreateInput = {
    user: TwitterUserCreateNestedOneWithoutReplyPostsInput
    message: string
    image?: string | null
    post: TwitterPostCreateNestedOneWithoutReplyPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostUncheckedCreateInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostUpdateInput = {
    user?: TwitterUserUpdateOneRequiredWithoutReplyPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    post?: TwitterPostUpdateOneRequiredWithoutReplyPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostCreateManyInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageCreateInput = {
    from: TwitterUserCreateNestedOneWithoutDirectMessageFromInput
    to: TwitterUserCreateNestedOneWithoutDirectMessageToInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateInput = {
    id?: number
    fromUserId: number
    toUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUpdateInput = {
    from?: TwitterUserUpdateOneRequiredWithoutDirectMessageFromNestedInput
    to?: TwitterUserUpdateOneRequiredWithoutDirectMessageToNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageCreateManyInput = {
    id?: number
    fromUserId: number
    toUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserCreateInput = {
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserCreateManyInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleCreateInput = {
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutRoleInput
  }

  export type YoutubeRoleUncheckedCreateInput = {
    id?: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutRoleInput
  }

  export type YoutubeRoleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutRoleNestedInput
  }

  export type YoutubeRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type YoutubeRoleCreateManyInput = {
    id?: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeRoleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelCreateInput = {
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    videos?: YoutubeVideoCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateInput = {
    id?: number
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    videos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    videos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    videos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelCreateManyInput = {
    id?: number
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelsInput
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelsInput
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelsNestedInput
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelsNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoCreateInput = {
    channel: YoutubeChannelCreateNestedOneWithoutVideosInput
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentCreateNestedManyWithoutVideoInput
    reactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateInput = {
    id?: number
    channelId: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUpdateInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutVideosNestedInput
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoCreateManyInput = {
    id?: number
    channelId: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeVideoUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberCreateInput = {
    user: YoutubeUserCreateNestedOneWithoutSubscribersInput
    channel: YoutubeChannelCreateNestedOneWithoutSubscribersInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberUncheckedCreateInput = {
    id?: number
    userId: number
    channelId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberUpdateInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutSubscribersNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutSubscribersNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberCreateManyInput = {
    id?: number
    userId: number
    channelId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberUpdateManyMutationInput = {
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionCreateInput = {
    type: ReactionEnum
    user: YoutubeUserCreateNestedOneWithoutReactionsInput
    video: YoutubeVideoCreateNestedOneWithoutReactionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionUncheckedCreateInput = {
    id?: number
    type: ReactionEnum
    userId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionUpdateInput = {
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    user?: YoutubeUserUpdateOneRequiredWithoutReactionsNestedInput
    video?: YoutubeVideoUpdateOneRequiredWithoutReactionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionCreateManyInput = {
    id?: number
    type: ReactionEnum
    userId: number
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionUpdateManyMutationInput = {
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    userId?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentCreateInput = {
    video: YoutubeVideoCreateNestedOneWithoutCommentsInput
    user: YoutubeUserCreateNestedOneWithoutCommentsInput
    commentTo?: YoutubeCommentCreateNestedOneWithoutCommentPostsInput
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentUncheckedCreateInput = {
    id?: number
    videoId: number
    userId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentUpdateInput = {
    video?: YoutubeVideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: YoutubeUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: YoutubeCommentUpdateOneWithoutCommentPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentCreateManyInput = {
    id?: number
    videoId: number
    userId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderBranchInfoCreateInput = {
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreCreateNestedManyWithoutBranchInput
  }

  export type LaunderBranchInfoUncheckedCreateInput = {
    id?: number
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreUncheckedCreateNestedManyWithoutBranchInput
  }

  export type LaunderBranchInfoUpdateInput = {
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUpdateManyWithoutBranchNestedInput
  }

  export type LaunderBranchInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type LaunderBranchInfoCreateManyInput = {
    id?: number
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderBranchInfoUpdateManyMutationInput = {
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderBranchInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderMachineCreateInput = {
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreCreateNestedManyWithoutMachineInput
    serviceHistories?: LaunderServiceHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineUncheckedCreateInput = {
    id?: number
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreUncheckedCreateNestedManyWithoutMachineInput
    serviceHistories?: LaunderServiceHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineUpdateInput = {
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUpdateManyWithoutMachineNestedInput
    serviceHistories?: LaunderServiceHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaunderMachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUncheckedUpdateManyWithoutMachineNestedInput
    serviceHistories?: LaunderServiceHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderMachineCreateManyInput = {
    id?: number
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderMachineUpdateManyMutationInput = {
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderMachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMachineInStoreCreateInput = {
    branch: LaunderBranchInfoCreateNestedOneWithoutMachineInStoresInput
    machine: LaunderMachineCreateNestedOneWithoutMachineInStoresInput
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUncheckedCreateInput = {
    id?: number
    branchId: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUpdateInput = {
    branch?: LaunderBranchInfoUpdateOneRequiredWithoutMachineInStoresNestedInput
    machine?: LaunderMachineUpdateOneRequiredWithoutMachineInStoresNestedInput
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreCreateManyInput = {
    id?: number
    branchId: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMachineInStoreUpdateManyMutationInput = {
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMachineInStoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderTechnicianCreateInput = {
    firstName: string
    lastName: string
    image?: string | null
    phone: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceHistories?: LaunderServiceHistoryCreateNestedManyWithoutTechnicianInput
  }

  export type LaunderTechnicianUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    image?: string | null
    phone: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceHistories?: LaunderServiceHistoryUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type LaunderTechnicianUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceHistories?: LaunderServiceHistoryUpdateManyWithoutTechnicianNestedInput
  }

  export type LaunderTechnicianUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceHistories?: LaunderServiceHistoryUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type LaunderTechnicianCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    image?: string | null
    phone: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderTechnicianUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderTechnicianUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryCreateInput = {
    date: Date | string
    machine: LaunderMachineCreateNestedOneWithoutServiceHistoriesInput
    technician: LaunderTechnicianCreateNestedOneWithoutServiceHistoriesInput
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUncheckedCreateInput = {
    id?: number
    date: Date | string
    machineId: number
    technicianId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: LaunderMachineUpdateOneRequiredWithoutServiceHistoriesNestedInput
    technician?: LaunderTechnicianUpdateOneRequiredWithoutServiceHistoriesNestedInput
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    machineId?: IntFieldUpdateOperationsInput | number
    technicianId?: IntFieldUpdateOperationsInput | number
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryCreateManyInput = {
    id?: number
    date: Date | string
    machineId: number
    technicianId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    machineId?: IntFieldUpdateOperationsInput | number
    technicianId?: IntFieldUpdateOperationsInput | number
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderWashingProgramCreateInput = {
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutProgramInput
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramUncheckedCreateInput = {
    id?: number
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutProgramInput
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramUpdateInput = {
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutProgramNestedInput
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type LaunderWashingProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutProgramNestedInput
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LaunderWashingProgramCreateManyInput = {
    id?: number
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderWashingProgramUpdateManyMutationInput = {
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderWashingProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineCreateInput = {
    machine: LaundryMachineInStoreCreateNestedOneWithoutProgramInMachinesInput
    program: LaunderWashingProgramCreateNestedOneWithoutProgramInMachinesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUncheckedCreateInput = {
    id?: number
    machineId: number
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUpdateInput = {
    machine?: LaundryMachineInStoreUpdateOneRequiredWithoutProgramInMachinesNestedInput
    program?: LaunderWashingProgramUpdateOneRequiredWithoutProgramInMachinesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineCreateManyInput = {
    id?: number
    machineId: number
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderUserCreateInput = {
    username: string
    phone: number
    walletBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topupHistories?: LaundryTopupHistoryCreateNestedManyWithoutUserInput
  }

  export type LaunderUserUncheckedCreateInput = {
    id?: number
    username: string
    phone: number
    walletBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topupHistories?: LaundryTopupHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type LaunderUserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: LaundryTopupHistoryUpdateManyWithoutUserNestedInput
  }

  export type LaunderUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topupHistories?: LaundryTopupHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LaunderUserCreateManyInput = {
    id?: number
    username: string
    phone: number
    walletBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderUserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryCreateInput = {
    user: LaunderUserCreateNestedOneWithoutTopupHistoriesInput
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryUpdateInput = {
    user?: LaunderUserUpdateOneRequiredWithoutTopupHistoriesNestedInput
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryCreateManyInput = {
    id?: number
    userId: number
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryCreateInput = {
    machine: LaundryMachineInStoreCreateNestedOneWithoutWashingHistoriesInput
    program: LaunderWashingProgramCreateNestedOneWithoutWashingHistoriesInput
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryUncheckedCreateInput = {
    id?: number
    machineId: number
    programId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryUpdateInput = {
    machine?: LaundryMachineInStoreUpdateOneRequiredWithoutWashingHistoriesNestedInput
    program?: LaunderWashingProgramUpdateOneRequiredWithoutWashingHistoriesNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryCreateManyInput = {
    id?: number
    machineId: number
    programId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStudentCreateInput = {
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: LibraryRequestCreateNestedManyWithoutStudentInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: LibraryRequestUpdateManyWithoutStudentNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryStudentUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryStudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUniversityCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUncheckedUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUncheckedUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUniversityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUniversityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutCategoryInput
  }

  export type LibraryCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type LibraryCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type LibraryCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type LibraryCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryAuthorCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutAuthorInput
  }

  export type LibraryAuthorUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type LibraryAuthorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutAuthorNestedInput
  }

  export type LibraryAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type LibraryAuthorCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryAuthorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCreateInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
    requests?: LibraryRequestCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUncheckedUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookCreateManyInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryCreateInput = {
    book: LibraryBookCreateNestedOneWithoutBookCategoriesInput
    category: LibraryCategoryCreateNestedOneWithoutBookCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUncheckedCreateInput = {
    id?: number
    bookId: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookCategoriesNestedInput
    category?: LibraryCategoryUpdateOneRequiredWithoutBookCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryCreateManyInput = {
    id?: number
    bookId: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorCreateInput = {
    book: LibraryBookCreateNestedOneWithoutBookAuthorsInput
    author: LibraryAuthorCreateNestedOneWithoutBookAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUncheckedCreateInput = {
    id?: number
    bookId: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookAuthorsNestedInput
    author?: LibraryAuthorUpdateOneRequiredWithoutBookAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorCreateManyInput = {
    id?: number
    bookId: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyCreateInput = {
    book: LibraryBookCreateNestedOneWithoutBookCopiesInput
    university: LibraryUniversityCreateNestedOneWithoutBookCopiesInput
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUncheckedCreateInput = {
    id?: number
    bookId: number
    universityId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookCopiesNestedInput
    university?: LibraryUniversityUpdateOneRequiredWithoutBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyCreateManyInput = {
    id?: number
    bookId: number
    universityId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestCreateInput = {
    borrowDate: Date | string
    returnDate: Date | string
    book: LibraryBookCreateNestedOneWithoutRequestsInput
    student: LibraryStudentCreateNestedOneWithoutRequestsInput
    fromUniversity: LibraryUniversityCreateNestedOneWithoutFromRequestsInput
    toUniversity: LibraryUniversityCreateNestedOneWithoutToRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUpdateInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutRequestsNestedInput
    student?: LibraryStudentUpdateOneRequiredWithoutRequestsNestedInput
    fromUniversity?: LibraryUniversityUpdateOneRequiredWithoutFromRequestsNestedInput
    toUniversity?: LibraryUniversityUpdateOneRequiredWithoutToRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestCreateManyInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUpdateManyMutationInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingCreateInput = {
    book: LibraryBookCreateNestedOneWithoutBorrowingsInput
    student: LibraryStudentCreateNestedOneWithoutBorrowingsInput
    university: LibraryUniversityCreateNestedOneWithoutBorrowingsInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUncheckedCreateInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUpdateInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBorrowingsNestedInput
    student?: LibraryStudentUpdateOneRequiredWithoutBorrowingsNestedInput
    university?: LibraryUniversityUpdateOneRequiredWithoutBorrowingsNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingCreateManyInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUpdateManyMutationInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateInput = {
    task: string
    status?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUncheckedCreateInput = {
    id?: number
    task: string
    status?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListCreateManyInput = {
    id?: number
    task: string
    status?: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TodoListUpdateManyMutationInput = {
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    task?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BinKitchenMenuListRelationFilter = {
    every?: BinKitchenMenuWhereInput
    some?: BinKitchenMenuWhereInput
    none?: BinKitchenMenuWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BinKitchenMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BinKitchenCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BinKitchenCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type BinKitchenCategoryRelationFilter = {
    is?: BinKitchenCategoryWhereInput | null
    isNot?: BinKitchenCategoryWhereInput | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BinKitchenOrderItemListRelationFilter = {
    every?: BinKitchenOrderItemWhereInput
    some?: BinKitchenOrderItemWhereInput
    none?: BinKitchenOrderItemWhereInput
  }

  export type BinKitchenOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BinKitchenMenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BinKitchenMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    price?: SortOrder
    categoryName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenMenuSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BinKitchenOrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type BinKitchenOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
  }

  export type BinKitchenMenuRelationFilter = {
    is?: BinKitchenMenuWhereInput
    isNot?: BinKitchenMenuWhereInput
  }

  export type BinKitchenOrderRelationFilter = {
    is?: BinKitchenOrderWhereInput | null
    isNot?: BinKitchenOrderWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BinKitchenOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type BinKitchenOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BinKitchenOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizRoundListRelationFilter = {
    every?: QuizRoundWhereInput
    some?: QuizRoundWhereInput
    none?: QuizRoundWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizRoundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuizCategoryRelationFilter = {
    is?: QuizCategoryWhereInput
    isNot?: QuizCategoryWhereInput
  }

  export type QuizChoiceRelationFilter = {
    is?: QuizChoiceWhereInput
    isNot?: QuizChoiceWhereInput
  }

  export type QuizChoiceListRelationFilter = {
    every?: QuizChoiceWhereInput
    some?: QuizChoiceWhereInput
    none?: QuizChoiceWhereInput
  }

  export type QuizRoundQuestionListRelationFilter = {
    every?: QuizRoundQuestionWhereInput
    some?: QuizRoundQuestionWhereInput
    none?: QuizRoundQuestionWhereInput
  }

  export type QuizChoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizRoundQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questName?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questName?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questName?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    answerChoiceId?: SortOrder
  }

  export type QuizQuestionRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuizChoiceCountOrderByAggregateInput = {
    id?: SortOrder
    choiceName?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type QuizChoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    choiceName?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceMinOrderByAggregateInput = {
    id?: SortOrder
    choiceName?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizChoiceSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type QuizRoundRelationFilter = {
    is?: QuizRoundWhereInput
    isNot?: QuizRoundWhereInput
  }

  export type QuizRoundQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
  }

  export type QuizRoundQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    userChoiceId?: SortOrder
    questionId?: SortOrder
    roundId?: SortOrder
  }

  export type QuizRoundCountOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
  }

  export type QuizRoundMaxOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundMinOrderByAggregateInput = {
    id?: SortOrder
    user?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizRoundSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    score?: SortOrder
  }

  export type FacebookUserRelationshipListRelationFilter = {
    every?: FacebookUserRelationshipWhereInput
    some?: FacebookUserRelationshipWhereInput
    none?: FacebookUserRelationshipWhereInput
  }

  export type FacebookUserInGroupListRelationFilter = {
    every?: FacebookUserInGroupWhereInput
    some?: FacebookUserInGroupWhereInput
    none?: FacebookUserInGroupWhereInput
  }

  export type FacebookPostListRelationFilter = {
    every?: FacebookPostWhereInput
    some?: FacebookPostWhereInput
    none?: FacebookPostWhereInput
  }

  export type FacebookDirectMessageListRelationFilter = {
    every?: FacebookDirectMessageWhereInput
    some?: FacebookDirectMessageWhereInput
    none?: FacebookDirectMessageWhereInput
  }

  export type FacebookCommentPostListRelationFilter = {
    every?: FacebookCommentPostWhereInput
    some?: FacebookCommentPostWhereInput
    none?: FacebookCommentPostWhereInput
  }

  export type FacebookLikeListRelationFilter = {
    every?: FacebookLikeWhereInput
    some?: FacebookLikeWhereInput
    none?: FacebookLikeWhereInput
  }

  export type FacebookPostDestinationListRelationFilter = {
    every?: FacebookPostDestinationWhereInput
    some?: FacebookPostDestinationWhereInput
    none?: FacebookPostDestinationWhereInput
  }

  export type FacebookUserRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookUserInGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookDirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookCommentPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookPostDestinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacebookUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookUserRelationFilter = {
    is?: FacebookUserWhereInput
    isNot?: FacebookUserWhereInput
  }

  export type FacebookUserRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type FacebookUserRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserRelationshipSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type FacebookDirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookDirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type FacebookDirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookDirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookDirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FacebookLocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookHashtagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumFacebookLikeTypeEnumFilter = {
    equals?: FacebookLikeTypeEnum
    in?: Enumerable<FacebookLikeTypeEnum>
    notIn?: Enumerable<FacebookLikeTypeEnum>
    not?: NestedEnumFacebookLikeTypeEnumFilter | FacebookLikeTypeEnum
  }

  export type FacebookPostRelationFilter = {
    is?: FacebookPostWhereInput
    isNot?: FacebookPostWhereInput
  }

  export type FacebookLikeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type FacebookLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLikeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type EnumFacebookLikeTypeEnumWithAggregatesFilter = {
    equals?: FacebookLikeTypeEnum
    in?: Enumerable<FacebookLikeTypeEnum>
    notIn?: Enumerable<FacebookLikeTypeEnum>
    not?: NestedEnumFacebookLikeTypeEnumWithAggregatesFilter | FacebookLikeTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumFacebookLikeTypeEnumFilter
    _max?: NestedEnumFacebookLikeTypeEnumFilter
  }

  export type FacebookShareTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookShareTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookShareTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookShareTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookShareTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacebookGroupRelationFilter = {
    is?: FacebookGroupWhereInput | null
    isNot?: FacebookGroupWhereInput | null
  }

  export type FacebookUserInGroupCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserInGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type FacebookUserInGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserInGroupMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookUserInGroupSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type FacebookPostDestinationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostDestinationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
  }

  export type FacebookPostDestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostDestinationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostDestinationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    postId?: SortOrder
  }

  export type FacebookLocationRelationFilter = {
    is?: FacebookLocationWhereInput
    isNot?: FacebookLocationWhereInput
  }

  export type FacebookHashtagRelationFilter = {
    is?: FacebookHashtagWhereInput | null
    isNot?: FacebookHashtagWhereInput | null
  }

  export type FacebookShareTypeRelationFilter = {
    is?: FacebookShareTypeWhereInput
    isNot?: FacebookShareTypeWhereInput
  }

  export type FacebookPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
  }

  export type FacebookPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    hashtagId?: SortOrder
    shareToId?: SortOrder
  }

  export type FacebookCommentPostRelationFilter = {
    is?: FacebookCommentPostWhereInput | null
    isNot?: FacebookCommentPostWhereInput | null
  }

  export type FacebookCommentPostCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookCommentPostAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
  }

  export type FacebookCommentPostMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookCommentPostMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacebookCommentPostSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    commentToId?: SortOrder
    shareToId?: SortOrder
  }

  export type TwitterPostListRelationFilter = {
    every?: TwitterPostWhereInput
    some?: TwitterPostWhereInput
    none?: TwitterPostWhereInput
  }

  export type TwitterUserRelationshipListRelationFilter = {
    every?: TwitterUserRelationshipWhereInput
    some?: TwitterUserRelationshipWhereInput
    none?: TwitterUserRelationshipWhereInput
  }

  export type TwitterReplyPostListRelationFilter = {
    every?: TwitterReplyPostWhereInput
    some?: TwitterReplyPostWhereInput
    none?: TwitterReplyPostWhereInput
  }

  export type TwitterDirectMessageListRelationFilter = {
    every?: TwitterDirectMessageWhereInput
    some?: TwitterDirectMessageWhereInput
    none?: TwitterDirectMessageWhereInput
  }

  export type TwitterPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterUserRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterReplyPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterDirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterUserRelationFilter = {
    is?: TwitterUserWhereInput
    isNot?: TwitterUserWhereInput
  }

  export type TwitterPostAndHashtagListRelationFilter = {
    every?: TwitterPostAndHashtagWhereInput
    some?: TwitterPostAndHashtagWhereInput
    none?: TwitterPostAndHashtagWhereInput
  }

  export type TwitterPostAndHashtagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwitterPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TwitterUserRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserRelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterUserRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterUserRelationshipSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterHashtagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TwitterPostRelationFilter = {
    is?: TwitterPostWhereInput
    isNot?: TwitterPostWhereInput
  }

  export type TwitterHashtagRelationFilter = {
    is?: TwitterHashtagWhereInput
    isNot?: TwitterHashtagWhereInput
  }

  export type TwitterPostAndHashtagCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAndHashtagAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterPostAndHashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAndHashtagMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterPostAndHashtagSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    hashtagId?: SortOrder
  }

  export type TwitterReplyPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterReplyPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type TwitterReplyPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterReplyPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterReplyPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type TwitterDirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type TwitterDirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    message?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwitterDirectMessageSumOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
  }

  export type YoutubeUserToChannelListRelationFilter = {
    every?: YoutubeUserToChannelWhereInput
    some?: YoutubeUserToChannelWhereInput
    none?: YoutubeUserToChannelWhereInput
  }

  export type YoutubeSubscriberListRelationFilter = {
    every?: YoutubeSubscriberWhereInput
    some?: YoutubeSubscriberWhereInput
    none?: YoutubeSubscriberWhereInput
  }

  export type YoutubeReactionListRelationFilter = {
    every?: YoutubeReactionWhereInput
    some?: YoutubeReactionWhereInput
    none?: YoutubeReactionWhereInput
  }

  export type YoutubeCommentListRelationFilter = {
    every?: YoutubeCommentWhereInput
    some?: YoutubeCommentWhereInput
    none?: YoutubeCommentWhereInput
  }

  export type YoutubeUserToChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeSubscriberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeRoleCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeRoleMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeVideoListRelationFilter = {
    every?: YoutubeVideoWhereInput
    some?: YoutubeVideoWhereInput
    none?: YoutubeVideoWhereInput
  }

  export type YoutubeVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YoutubeChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    coverImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YoutubeUserRelationFilter = {
    is?: YoutubeUserWhereInput
    isNot?: YoutubeUserWhereInput
  }

  export type YoutubeRoleRelationFilter = {
    is?: YoutubeRoleWhereInput
    isNot?: YoutubeRoleWhereInput
  }

  export type YoutubeChannelRelationFilter = {
    is?: YoutubeChannelWhereInput
    isNot?: YoutubeChannelWhereInput
  }

  export type YoutubeUserToChannelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserToChannelAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
  }

  export type YoutubeUserToChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserToChannelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeUserToChannelSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    channelId?: SortOrder
  }

  export type YoutubeVideoCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    urlFile?: SortOrder
    coverImage?: SortOrder
    descriptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type YoutubeVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    urlFile?: SortOrder
    coverImage?: SortOrder
    descriptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeVideoMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    urlFile?: SortOrder
    coverImage?: SortOrder
    descriptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeVideoSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type YoutubeSubscriberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeSubscriberAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type YoutubeSubscriberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeSubscriberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    membership?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeSubscriberSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
  }

  export type EnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type YoutubeVideoRelationFilter = {
    is?: YoutubeVideoWhereInput
    isNot?: YoutubeVideoWhereInput
  }

  export type YoutubeReactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type YoutubeReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeReactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeReactionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
  }

  export type EnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type YoutubeCommentRelationFilter = {
    is?: YoutubeCommentWhereInput | null
    isNot?: YoutubeCommentWhereInput | null
  }

  export type YoutubeCommentCountOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    commentToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    commentToId?: SortOrder
  }

  export type YoutubeCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    commentToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeCommentMinOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    commentToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type YoutubeCommentSumOrderByAggregateInput = {
    id?: SortOrder
    videoId?: SortOrder
    userId?: SortOrder
    commentToId?: SortOrder
  }

  export type LaundryMachineInStoreListRelationFilter = {
    every?: LaundryMachineInStoreWhereInput
    some?: LaundryMachineInStoreWhereInput
    none?: LaundryMachineInStoreWhereInput
  }

  export type LaundryMachineInStoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaunderBranchInfoCountOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderBranchInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    areaSize?: SortOrder
  }

  export type LaunderBranchInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderBranchInfoMinOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    areaSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderBranchInfoSumOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    areaSize?: SortOrder
  }

  export type LaunderServiceHistoryListRelationFilter = {
    every?: LaunderServiceHistoryWhereInput
    some?: LaunderServiceHistoryWhereInput
    none?: LaunderServiceHistoryWhereInput
  }

  export type LaunderServiceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaunderMachineCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    Capacity?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderMachineAvgOrderByAggregateInput = {
    id?: SortOrder
    Capacity?: SortOrder
    serialNumber?: SortOrder
  }

  export type LaunderMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    Capacity?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderMachineMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    Capacity?: SortOrder
    type?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderMachineSumOrderByAggregateInput = {
    id?: SortOrder
    Capacity?: SortOrder
    serialNumber?: SortOrder
  }

  export type LaunderBranchInfoRelationFilter = {
    is?: LaunderBranchInfoWhereInput
    isNot?: LaunderBranchInfoWhereInput
  }

  export type LaunderMachineRelationFilter = {
    is?: LaunderMachineWhereInput
    isNot?: LaunderMachineWhereInput
  }

  export type LaunderProgramInMachineListRelationFilter = {
    every?: LaunderProgramInMachineWhereInput
    some?: LaunderProgramInMachineWhereInput
    none?: LaunderProgramInMachineWhereInput
  }

  export type LaundryWashingHistoryListRelationFilter = {
    every?: LaundryWashingHistoryWhereInput
    some?: LaundryWashingHistoryWhereInput
    none?: LaundryWashingHistoryWhereInput
  }

  export type LaunderProgramInMachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryWashingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaundryMachineInStoreCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
    mfd?: SortOrder
    Warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryMachineInStoreAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
  }

  export type LaundryMachineInStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
    mfd?: SortOrder
    Warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryMachineInStoreMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
    mfd?: SortOrder
    Warranty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryMachineInStoreSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    machineId?: SortOrder
  }

  export type LaunderTechnicianCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderTechnicianAvgOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
  }

  export type LaunderTechnicianMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderTechnicianMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderTechnicianSumOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
  }

  export type LaunderTechnicianRelationFilter = {
    is?: LaunderTechnicianWhereInput
    isNot?: LaunderTechnicianWhereInput
  }

  export type LaunderServiceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderServiceHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
  }

  export type LaunderServiceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderServiceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
    descriptions?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderServiceHistorySumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    technicianId?: SortOrder
  }

  export type LaunderWashingProgramCountOrderByAggregateInput = {
    id?: SortOrder
    program?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderWashingProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
  }

  export type LaunderWashingProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    program?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderWashingProgramMinOrderByAggregateInput = {
    id?: SortOrder
    program?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderWashingProgramSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    capacityLimit?: SortOrder
  }

  export type LaundryMachineInStoreRelationFilter = {
    is?: LaundryMachineInStoreWhereInput
    isNot?: LaundryMachineInStoreWhereInput
  }

  export type LaunderWashingProgramRelationFilter = {
    is?: LaunderWashingProgramWhereInput
    isNot?: LaunderWashingProgramWhereInput
  }

  export type LaunderProgramInMachineCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderProgramInMachineAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type LaunderProgramInMachineMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderProgramInMachineMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderProgramInMachineSumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
  }

  export type LaundryTopupHistoryListRelationFilter = {
    every?: LaundryTopupHistoryWhereInput
    some?: LaundryTopupHistoryWhereInput
    none?: LaundryTopupHistoryWhereInput
  }

  export type LaundryTopupHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaunderUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderUserAvgOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
  }

  export type LaunderUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunderUserSumOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    walletBalance?: SortOrder
  }

  export type LaunderUserRelationFilter = {
    is?: LaunderUserWhereInput
    isNot?: LaunderUserWhereInput
  }

  export type LaundryTopupHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryTopupHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type LaundryTopupHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryTopupHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryTopupHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type LaundryWashingHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryWashingHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    price?: SortOrder
  }

  export type LaundryWashingHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryWashingHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaundryWashingHistorySumOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    programId?: SortOrder
    price?: SortOrder
  }

  export type LibraryRequestListRelationFilter = {
    every?: LibraryRequestWhereInput
    some?: LibraryRequestWhereInput
    none?: LibraryRequestWhereInput
  }

  export type LibraryBorrowingListRelationFilter = {
    every?: LibraryBorrowingWhereInput
    some?: LibraryBorrowingWhereInput
    none?: LibraryBorrowingWhereInput
  }

  export type LibraryRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryBorrowingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryStudentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryStudentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryStudentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryStudentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryStudentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookCopyListRelationFilter = {
    every?: LibraryBookCopyWhereInput
    some?: LibraryBookCopyWhereInput
    none?: LibraryBookCopyWhereInput
  }

  export type LibraryBookCopyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryUniversityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryUniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryUniversitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookCategoryListRelationFilter = {
    every?: LibraryBookCategoryWhereInput
    some?: LibraryBookCategoryWhereInput
    none?: LibraryBookCategoryWhereInput
  }

  export type LibraryBookCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookAuthorListRelationFilter = {
    every?: LibraryBookAuthorWhereInput
    some?: LibraryBookAuthorWhereInput
    none?: LibraryBookAuthorWhereInput
  }

  export type LibraryBookAuthorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAuthorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LibraryBookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAvgOrderByAggregateInput = {
    id?: SortOrder
    isbn?: SortOrder
  }

  export type LibraryBookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isbn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookSumOrderByAggregateInput = {
    id?: SortOrder
    isbn?: SortOrder
  }

  export type LibraryBookRelationFilter = {
    is?: LibraryBookWhereInput
    isNot?: LibraryBookWhereInput
  }

  export type LibraryCategoryRelationFilter = {
    is?: LibraryCategoryWhereInput
    isNot?: LibraryCategoryWhereInput
  }

  export type LibraryBookCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
  }

  export type LibraryBookCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCategorySumOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    categoryId?: SortOrder
  }

  export type LibraryAuthorRelationFilter = {
    is?: LibraryAuthorWhereInput
    isNot?: LibraryAuthorWhereInput
  }

  export type LibraryBookAuthorCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorAvgOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
  }

  export type LibraryBookAuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookAuthorSumOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    authorId?: SortOrder
  }

  export type LibraryUniversityRelationFilter = {
    is?: LibraryUniversityWhereInput
    isNot?: LibraryUniversityWhereInput
  }

  export type LibraryBookCopyCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCopyAvgOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
  }

  export type LibraryBookCopyMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCopyMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBookCopySumOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    universityId?: SortOrder
  }

  export type LibraryStudentRelationFilter = {
    is?: LibraryStudentWhereInput
    isNot?: LibraryStudentWhereInput
  }

  export type LibraryRequestCountOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
  }

  export type LibraryRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryRequestMinOrderByAggregateInput = {
    id?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryRequestSumOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    fromUniversityId?: SortOrder
    toUniversityId?: SortOrder
  }

  export type LibraryBorrowingCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBorrowingAvgOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
  }

  export type LibraryBorrowingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBorrowingMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    borrowDate?: SortOrder
    returnDate?: SortOrder
    actualReturnDate?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryBorrowingSumOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    studentId?: SortOrder
    universityId?: SortOrder
  }

  export type TodoListCountOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TodoListMaxOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListMinOrderByAggregateInput = {
    id?: SortOrder
    task?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TodoListSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BinKitchenMenuCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
  }

  export type BinKitchenMenuUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BinKitchenMenuUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<BinKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    delete?: Enumerable<BinKitchenMenuWhereUniqueInput>
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    update?: Enumerable<BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BinKitchenMenuScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BinKitchenMenuUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BinKitchenMenuCreateWithoutCategoryInput>, Enumerable<BinKitchenMenuUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BinKitchenMenuCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BinKitchenMenuCreateManyCategoryInputEnvelope
    set?: Enumerable<BinKitchenMenuWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    delete?: Enumerable<BinKitchenMenuWhereUniqueInput>
    connect?: Enumerable<BinKitchenMenuWhereUniqueInput>
    update?: Enumerable<BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BinKitchenMenuScalarWhereInput>
  }

  export type BinKitchenCategoryCreateNestedOneWithoutMenusInput = {
    create?: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: BinKitchenCategoryCreateOrConnectWithoutMenusInput
    connect?: BinKitchenCategoryWhereUniqueInput
  }

  export type BinKitchenOrderItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BinKitchenCategoryUpdateOneWithoutMenusNestedInput = {
    create?: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
    connectOrCreate?: BinKitchenCategoryCreateOrConnectWithoutMenusInput
    upsert?: BinKitchenCategoryUpsertWithoutMenusInput
    disconnect?: boolean
    delete?: boolean
    connect?: BinKitchenCategoryWhereUniqueInput
    update?: XOR<BinKitchenCategoryUpdateWithoutMenusInput, BinKitchenCategoryUncheckedUpdateWithoutMenusInput>
  }

  export type BinKitchenOrderItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutMenuInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutMenuInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutMenuInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput>
    createMany?: BinKitchenOrderItemCreateManyMenuInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
  }

  export type BinKitchenOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<BinKitchenOrderItemCreateWithoutOrderInput>, Enumerable<BinKitchenOrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<BinKitchenOrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: BinKitchenOrderItemCreateManyOrderInputEnvelope
    set?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    disconnect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    delete?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    connect?: Enumerable<BinKitchenOrderItemWhereUniqueInput>
    update?: Enumerable<BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<BinKitchenOrderItemScalarWhereInput>
  }

  export type BinKitchenMenuCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<BinKitchenMenuCreateWithoutOrderItemsInput, BinKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: BinKitchenMenuCreateOrConnectWithoutOrderItemsInput
    connect?: BinKitchenMenuWhereUniqueInput
  }

  export type BinKitchenOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenOrderCreateOrConnectWithoutItemsInput
    connect?: BinKitchenOrderWhereUniqueInput
  }

  export type BinKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<BinKitchenMenuCreateWithoutOrderItemsInput, BinKitchenMenuUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: BinKitchenMenuCreateOrConnectWithoutOrderItemsInput
    upsert?: BinKitchenMenuUpsertWithoutOrderItemsInput
    connect?: BinKitchenMenuWhereUniqueInput
    update?: XOR<BinKitchenMenuUpdateWithoutOrderItemsInput, BinKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
  }

  export type BinKitchenOrderUpdateOneWithoutItemsNestedInput = {
    create?: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BinKitchenOrderCreateOrConnectWithoutItemsInput
    upsert?: BinKitchenOrderUpsertWithoutItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BinKitchenOrderWhereUniqueInput
    update?: XOR<BinKitchenOrderUpdateWithoutItemsInput, BinKitchenOrderUncheckedUpdateWithoutItemsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuizQuestionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
  }

  export type QuizRoundCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizRoundWhereUniqueInput>
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
  }

  export type QuizRoundUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    connect?: Enumerable<QuizRoundWhereUniqueInput>
  }

  export type QuizQuestionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizQuestionWhereUniqueInput>
    delete?: Enumerable<QuizQuestionWhereUniqueInput>
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
    update?: Enumerable<QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizQuestionScalarWhereInput>
  }

  export type QuizRoundUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizRoundWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundWhereUniqueInput>
    delete?: Enumerable<QuizRoundWhereUniqueInput>
    connect?: Enumerable<QuizRoundWhereUniqueInput>
    update?: Enumerable<QuizRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizRoundScalarWhereInput>
  }

  export type QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizQuestionCreateWithoutCategoryInput>, Enumerable<QuizQuestionUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizQuestionCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizQuestionCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizQuestionWhereUniqueInput>
    delete?: Enumerable<QuizQuestionWhereUniqueInput>
    connect?: Enumerable<QuizQuestionWhereUniqueInput>
    update?: Enumerable<QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizQuestionUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizQuestionScalarWhereInput>
  }

  export type QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<QuizRoundCreateWithoutCategoryInput>, Enumerable<QuizRoundUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<QuizRoundCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<QuizRoundUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: QuizRoundCreateManyCategoryInputEnvelope
    set?: Enumerable<QuizRoundWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundWhereUniqueInput>
    delete?: Enumerable<QuizRoundWhereUniqueInput>
    connect?: Enumerable<QuizRoundWhereUniqueInput>
    update?: Enumerable<QuizRoundUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<QuizRoundUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<QuizRoundScalarWhereInput>
  }

  export type QuizCategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCategoryCreateWithoutQuestionsInput, QuizCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuestionsInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type QuizChoiceCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<QuizChoiceCreateWithoutQuestionAnswerInput, QuizChoiceUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: QuizChoiceCreateOrConnectWithoutQuestionAnswerInput
    connect?: QuizChoiceWhereUniqueInput
  }

  export type QuizChoiceCreateNestedManyWithoutQuestioneInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestioneInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestioneInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestioneInput>
    createMany?: QuizChoiceCreateManyQuestioneInputEnvelope
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
  }

  export type QuizRoundQuestionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutQuestionInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutQuestionInput>
    createMany?: QuizRoundQuestionCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
  }

  export type QuizChoiceUncheckedCreateNestedManyWithoutQuestioneInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestioneInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestioneInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestioneInput>
    createMany?: QuizChoiceCreateManyQuestioneInputEnvelope
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
  }

  export type QuizRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutQuestionInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutQuestionInput>
    createMany?: QuizRoundQuestionCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutQuestionsInput, QuizCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutQuestionsInput
    upsert?: QuizCategoryUpsertWithoutQuestionsInput
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutQuestionsInput, QuizCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizChoiceUpdateOneRequiredWithoutQuestionAnswerNestedInput = {
    create?: XOR<QuizChoiceCreateWithoutQuestionAnswerInput, QuizChoiceUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: QuizChoiceCreateOrConnectWithoutQuestionAnswerInput
    upsert?: QuizChoiceUpsertWithoutQuestionAnswerInput
    connect?: QuizChoiceWhereUniqueInput
    update?: XOR<QuizChoiceUpdateWithoutQuestionAnswerInput, QuizChoiceUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type QuizChoiceUpdateManyWithoutQuestioneNestedInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestioneInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestioneInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestioneInput>
    upsert?: Enumerable<QuizChoiceUpsertWithWhereUniqueWithoutQuestioneInput>
    createMany?: QuizChoiceCreateManyQuestioneInputEnvelope
    set?: Enumerable<QuizChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizChoiceWhereUniqueInput>
    delete?: Enumerable<QuizChoiceWhereUniqueInput>
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
    update?: Enumerable<QuizChoiceUpdateWithWhereUniqueWithoutQuestioneInput>
    updateMany?: Enumerable<QuizChoiceUpdateManyWithWhereWithoutQuestioneInput>
    deleteMany?: Enumerable<QuizChoiceScalarWhereInput>
  }

  export type QuizRoundQuestionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutQuestionInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizRoundQuestionCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    delete?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    update?: Enumerable<QuizRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizRoundQuestionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizRoundQuestionScalarWhereInput>
  }

  export type QuizChoiceUncheckedUpdateManyWithoutQuestioneNestedInput = {
    create?: XOR<Enumerable<QuizChoiceCreateWithoutQuestioneInput>, Enumerable<QuizChoiceUncheckedCreateWithoutQuestioneInput>>
    connectOrCreate?: Enumerable<QuizChoiceCreateOrConnectWithoutQuestioneInput>
    upsert?: Enumerable<QuizChoiceUpsertWithWhereUniqueWithoutQuestioneInput>
    createMany?: QuizChoiceCreateManyQuestioneInputEnvelope
    set?: Enumerable<QuizChoiceWhereUniqueInput>
    disconnect?: Enumerable<QuizChoiceWhereUniqueInput>
    delete?: Enumerable<QuizChoiceWhereUniqueInput>
    connect?: Enumerable<QuizChoiceWhereUniqueInput>
    update?: Enumerable<QuizChoiceUpdateWithWhereUniqueWithoutQuestioneInput>
    updateMany?: Enumerable<QuizChoiceUpdateManyWithWhereWithoutQuestioneInput>
    deleteMany?: Enumerable<QuizChoiceScalarWhereInput>
  }

  export type QuizRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutQuestionInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuizRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuizRoundQuestionCreateManyQuestionInputEnvelope
    set?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    delete?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    update?: Enumerable<QuizRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuizRoundQuestionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuizRoundQuestionScalarWhereInput>
  }

  export type QuizQuestionCreateNestedOneWithoutChoicesInput = {
    create?: XOR<QuizQuestionCreateWithoutChoicesInput, QuizQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutChoicesInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswerInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionUncheckedCreateNestedOneWithoutAnswerInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswerInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizQuestionUpdateOneWithoutChoicesNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutChoicesInput, QuizQuestionUncheckedCreateWithoutChoicesInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutChoicesInput
    upsert?: QuizQuestionUpsertWithoutChoicesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutChoicesInput, QuizQuestionUncheckedUpdateWithoutChoicesInput>
  }

  export type QuizQuestionUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswerInput
    upsert?: QuizQuestionUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutAnswerInput, QuizQuestionUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizQuestionUncheckedUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswerInput
    upsert?: QuizQuestionUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutAnswerInput, QuizQuestionUncheckedUpdateWithoutAnswerInput>
  }

  export type QuizQuestionCreateNestedOneWithoutRoundQuestionsInput = {
    create?: XOR<QuizQuestionCreateWithoutRoundQuestionsInput, QuizQuestionUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutRoundQuestionsInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizRoundCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizRoundCreateWithoutQuestionsInput, QuizRoundUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizRoundCreateOrConnectWithoutQuestionsInput
    connect?: QuizRoundWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutRoundQuestionsInput, QuizQuestionUncheckedCreateWithoutRoundQuestionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutRoundQuestionsInput
    upsert?: QuizQuestionUpsertWithoutRoundQuestionsInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<QuizQuestionUpdateWithoutRoundQuestionsInput, QuizQuestionUncheckedUpdateWithoutRoundQuestionsInput>
  }

  export type QuizRoundUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizRoundCreateWithoutQuestionsInput, QuizRoundUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizRoundCreateOrConnectWithoutQuestionsInput
    upsert?: QuizRoundUpsertWithoutQuestionsInput
    connect?: QuizRoundWhereUniqueInput
    update?: XOR<QuizRoundUpdateWithoutQuestionsInput, QuizRoundUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizCategoryCreateNestedOneWithoutRoundsInput = {
    create?: XOR<QuizCategoryCreateWithoutRoundsInput, QuizCategoryUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutRoundsInput
    connect?: QuizCategoryWhereUniqueInput
  }

  export type QuizRoundQuestionCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutRoundInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutRoundInput>
    createMany?: QuizRoundQuestionCreateManyRoundInputEnvelope
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
  }

  export type QuizRoundQuestionUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutRoundInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutRoundInput>
    createMany?: QuizRoundQuestionCreateManyRoundInputEnvelope
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
  }

  export type QuizCategoryUpdateOneRequiredWithoutRoundsNestedInput = {
    create?: XOR<QuizCategoryCreateWithoutRoundsInput, QuizCategoryUncheckedCreateWithoutRoundsInput>
    connectOrCreate?: QuizCategoryCreateOrConnectWithoutRoundsInput
    upsert?: QuizCategoryUpsertWithoutRoundsInput
    connect?: QuizCategoryWhereUniqueInput
    update?: XOR<QuizCategoryUpdateWithoutRoundsInput, QuizCategoryUncheckedUpdateWithoutRoundsInput>
  }

  export type QuizRoundQuestionUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutRoundInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<QuizRoundQuestionUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: QuizRoundQuestionCreateManyRoundInputEnvelope
    set?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    delete?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    update?: Enumerable<QuizRoundQuestionUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<QuizRoundQuestionUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<QuizRoundQuestionScalarWhereInput>
  }

  export type QuizRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<Enumerable<QuizRoundQuestionCreateWithoutRoundInput>, Enumerable<QuizRoundQuestionUncheckedCreateWithoutRoundInput>>
    connectOrCreate?: Enumerable<QuizRoundQuestionCreateOrConnectWithoutRoundInput>
    upsert?: Enumerable<QuizRoundQuestionUpsertWithWhereUniqueWithoutRoundInput>
    createMany?: QuizRoundQuestionCreateManyRoundInputEnvelope
    set?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    disconnect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    delete?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    connect?: Enumerable<QuizRoundQuestionWhereUniqueInput>
    update?: Enumerable<QuizRoundQuestionUpdateWithWhereUniqueWithoutRoundInput>
    updateMany?: Enumerable<QuizRoundQuestionUpdateManyWithWhereWithoutRoundInput>
    deleteMany?: Enumerable<QuizRoundQuestionScalarWhereInput>
  }

  export type FacebookUserRelationshipCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutFromInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutFromInput>
    createMany?: FacebookUserRelationshipCreateManyFromInputEnvelope
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
  }

  export type FacebookUserRelationshipCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutToInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutToInput>
    createMany?: FacebookUserRelationshipCreateManyToInputEnvelope
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
  }

  export type FacebookUserInGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutUserInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutUserInput>
    createMany?: FacebookUserInGroupCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
  }

  export type FacebookPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutUserInput>, Enumerable<FacebookPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutUserInput>
    createMany?: FacebookPostCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookDirectMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutFromInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: FacebookDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
  }

  export type FacebookDirectMessageCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutToInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutToInput>
    createMany?: FacebookDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
  }

  export type FacebookCommentPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutUserInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutUserInput>
    createMany?: FacebookCommentPostCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutUserInput>, Enumerable<FacebookLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutUserInput>
    createMany?: FacebookLikeCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
  }

  export type FacebookPostDestinationCreateNestedManyWithoutUserWallInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutUserWallInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutUserWallInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutUserWallInput>
    createMany?: FacebookPostDestinationCreateManyUserWallInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutFromInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutFromInput>
    createMany?: FacebookUserRelationshipCreateManyFromInputEnvelope
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
  }

  export type FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutToInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutToInput>
    createMany?: FacebookUserRelationshipCreateManyToInputEnvelope
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
  }

  export type FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutUserInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutUserInput>
    createMany?: FacebookUserInGroupCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
  }

  export type FacebookPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutUserInput>, Enumerable<FacebookPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutUserInput>
    createMany?: FacebookPostCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutFromInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: FacebookDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
  }

  export type FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutToInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutToInput>
    createMany?: FacebookDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
  }

  export type FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutUserInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutUserInput>
    createMany?: FacebookCommentPostCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutUserInput>, Enumerable<FacebookLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutUserInput>
    createMany?: FacebookLikeCreateManyUserInputEnvelope
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
  }

  export type FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutUserWallInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutUserWallInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutUserWallInput>
    createMany?: FacebookPostDestinationCreateManyUserWallInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookUserRelationshipUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutFromInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FacebookUserRelationshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FacebookUserRelationshipCreateManyFromInputEnvelope
    set?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FacebookUserRelationshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FacebookUserRelationshipScalarWhereInput>
  }

  export type FacebookUserRelationshipUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutToInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FacebookUserRelationshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: FacebookUserRelationshipCreateManyToInputEnvelope
    set?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FacebookUserRelationshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FacebookUserRelationshipScalarWhereInput>
  }

  export type FacebookUserInGroupUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutUserInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookUserInGroupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookUserInGroupCreateManyUserInputEnvelope
    set?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    delete?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    update?: Enumerable<FacebookUserInGroupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookUserInGroupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookUserInGroupScalarWhereInput>
  }

  export type FacebookPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutUserInput>, Enumerable<FacebookPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookPostCreateManyUserInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookDirectMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutFromInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FacebookDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FacebookDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    delete?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    update?: Enumerable<FacebookDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FacebookDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FacebookDirectMessageScalarWhereInput>
  }

  export type FacebookDirectMessageUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutToInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FacebookDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: FacebookDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    delete?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    update?: Enumerable<FacebookDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FacebookDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FacebookDirectMessageScalarWhereInput>
  }

  export type FacebookCommentPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutUserInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookCommentPostCreateManyUserInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutUserInput>, Enumerable<FacebookLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookLikeCreateManyUserInputEnvelope
    set?: Enumerable<FacebookLikeWhereUniqueInput>
    disconnect?: Enumerable<FacebookLikeWhereUniqueInput>
    delete?: Enumerable<FacebookLikeWhereUniqueInput>
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
    update?: Enumerable<FacebookLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookLikeScalarWhereInput>
  }

  export type FacebookPostDestinationUpdateManyWithoutUserWallNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutUserWallInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutUserWallInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutUserWallInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutUserWallInput>
    createMany?: FacebookPostDestinationCreateManyUserWallInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutUserWallInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutUserWallInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutFromInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FacebookUserRelationshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FacebookUserRelationshipCreateManyFromInputEnvelope
    set?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FacebookUserRelationshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FacebookUserRelationshipScalarWhereInput>
  }

  export type FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FacebookUserRelationshipCreateWithoutToInput>, Enumerable<FacebookUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookUserRelationshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FacebookUserRelationshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: FacebookUserRelationshipCreateManyToInputEnvelope
    set?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    delete?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    connect?: Enumerable<FacebookUserRelationshipWhereUniqueInput>
    update?: Enumerable<FacebookUserRelationshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FacebookUserRelationshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FacebookUserRelationshipScalarWhereInput>
  }

  export type FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutUserInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookUserInGroupUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookUserInGroupCreateManyUserInputEnvelope
    set?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    delete?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    update?: Enumerable<FacebookUserInGroupUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookUserInGroupUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookUserInGroupScalarWhereInput>
  }

  export type FacebookPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutUserInput>, Enumerable<FacebookPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookPostCreateManyUserInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutFromInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FacebookDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FacebookDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    delete?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    update?: Enumerable<FacebookDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FacebookDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FacebookDirectMessageScalarWhereInput>
  }

  export type FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FacebookDirectMessageCreateWithoutToInput>, Enumerable<FacebookDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FacebookDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FacebookDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: FacebookDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    delete?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    connect?: Enumerable<FacebookDirectMessageWhereUniqueInput>
    update?: Enumerable<FacebookDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FacebookDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FacebookDirectMessageScalarWhereInput>
  }

  export type FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutUserInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookCommentPostCreateManyUserInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutUserInput>, Enumerable<FacebookLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FacebookLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FacebookLikeCreateManyUserInputEnvelope
    set?: Enumerable<FacebookLikeWhereUniqueInput>
    disconnect?: Enumerable<FacebookLikeWhereUniqueInput>
    delete?: Enumerable<FacebookLikeWhereUniqueInput>
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
    update?: Enumerable<FacebookLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FacebookLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FacebookLikeScalarWhereInput>
  }

  export type FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutUserWallInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutUserWallInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutUserWallInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutUserWallInput>
    createMany?: FacebookPostDestinationCreateManyUserWallInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutUserWallInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutUserWallInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutFromInput = {
    create?: XOR<FacebookUserCreateWithoutFromInput, FacebookUserUncheckedCreateWithoutFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFromInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutToInput = {
    create?: XOR<FacebookUserCreateWithoutToInput, FacebookUserUncheckedCreateWithoutToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutToInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutFromNestedInput = {
    create?: XOR<FacebookUserCreateWithoutFromInput, FacebookUserUncheckedCreateWithoutFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutFromInput
    upsert?: FacebookUserUpsertWithoutFromInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutFromInput, FacebookUserUncheckedUpdateWithoutFromInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutToNestedInput = {
    create?: XOR<FacebookUserCreateWithoutToInput, FacebookUserUncheckedCreateWithoutToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutToInput
    upsert?: FacebookUserUpsertWithoutToInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutToInput, FacebookUserUncheckedUpdateWithoutToInput>
  }

  export type FacebookUserCreateNestedOneWithoutDirectMessageFromInput = {
    create?: XOR<FacebookUserCreateWithoutDirectMessageFromInput, FacebookUserUncheckedCreateWithoutDirectMessageFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutDirectMessageFromInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutDirectMessageToInput = {
    create?: XOR<FacebookUserCreateWithoutDirectMessageToInput, FacebookUserUncheckedCreateWithoutDirectMessageToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutDirectMessageToInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutDirectMessageFromNestedInput = {
    create?: XOR<FacebookUserCreateWithoutDirectMessageFromInput, FacebookUserUncheckedCreateWithoutDirectMessageFromInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutDirectMessageFromInput
    upsert?: FacebookUserUpsertWithoutDirectMessageFromInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutDirectMessageFromInput, FacebookUserUncheckedUpdateWithoutDirectMessageFromInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutDirectMessageToNestedInput = {
    create?: XOR<FacebookUserCreateWithoutDirectMessageToInput, FacebookUserUncheckedCreateWithoutDirectMessageToInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutDirectMessageToInput
    upsert?: FacebookUserUpsertWithoutDirectMessageToInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutDirectMessageToInput, FacebookUserUncheckedUpdateWithoutDirectMessageToInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FacebookPostCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutLocationInput>, Enumerable<FacebookPostUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutLocationInput>
    createMany?: FacebookPostCreateManyLocationInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookPostUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutLocationInput>, Enumerable<FacebookPostUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutLocationInput>
    createMany?: FacebookPostCreateManyLocationInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookPostUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutLocationInput>, Enumerable<FacebookPostUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: FacebookPostCreateManyLocationInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookPostUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutLocationInput>, Enumerable<FacebookPostUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: FacebookPostCreateManyLocationInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookPostCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutHashtagInput>, Enumerable<FacebookPostUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutHashtagInput>
    createMany?: FacebookPostCreateManyHashtagInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookPostUncheckedCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutHashtagInput>, Enumerable<FacebookPostUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutHashtagInput>
    createMany?: FacebookPostCreateManyHashtagInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookPostUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutHashtagInput>, Enumerable<FacebookPostUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: FacebookPostCreateManyHashtagInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookPostUncheckedUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutHashtagInput>, Enumerable<FacebookPostUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: FacebookPostCreateManyHashtagInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutLikesInput = {
    create?: XOR<FacebookUserCreateWithoutLikesInput, FacebookUserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutLikesInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookPostCreateNestedOneWithoutLikesInput = {
    create?: XOR<FacebookPostCreateWithoutLikesInput, FacebookPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutLikesInput
    connect?: FacebookPostWhereUniqueInput
  }

  export type EnumFacebookLikeTypeEnumFieldUpdateOperationsInput = {
    set?: FacebookLikeTypeEnum
  }

  export type FacebookUserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FacebookUserCreateWithoutLikesInput, FacebookUserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutLikesInput
    upsert?: FacebookUserUpsertWithoutLikesInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutLikesInput, FacebookUserUncheckedUpdateWithoutLikesInput>
  }

  export type FacebookPostUpdateOneWithoutLikesNestedInput = {
    create?: XOR<FacebookPostCreateWithoutLikesInput, FacebookPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutLikesInput
    upsert?: FacebookPostUpsertWithoutLikesInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookPostWhereUniqueInput
    update?: XOR<FacebookPostUpdateWithoutLikesInput, FacebookPostUncheckedUpdateWithoutLikesInput>
  }

  export type FacebookCommentPostCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutShareInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutShareInput>
    createMany?: FacebookCommentPostCreateManyShareInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookPostCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutShareInput>, Enumerable<FacebookPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutShareInput>
    createMany?: FacebookPostCreateManyShareInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookCommentPostUncheckedCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutShareInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutShareInput>
    createMany?: FacebookCommentPostCreateManyShareInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookPostUncheckedCreateNestedManyWithoutShareInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutShareInput>, Enumerable<FacebookPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutShareInput>
    createMany?: FacebookPostCreateManyShareInputEnvelope
    connect?: Enumerable<FacebookPostWhereUniqueInput>
  }

  export type FacebookCommentPostUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutShareInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FacebookCommentPostCreateManyShareInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookPostUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutShareInput>, Enumerable<FacebookPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FacebookPostCreateManyShareInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookCommentPostUncheckedUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutShareInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FacebookCommentPostCreateManyShareInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookPostUncheckedUpdateManyWithoutShareNestedInput = {
    create?: XOR<Enumerable<FacebookPostCreateWithoutShareInput>, Enumerable<FacebookPostUncheckedCreateWithoutShareInput>>
    connectOrCreate?: Enumerable<FacebookPostCreateOrConnectWithoutShareInput>
    upsert?: Enumerable<FacebookPostUpsertWithWhereUniqueWithoutShareInput>
    createMany?: FacebookPostCreateManyShareInputEnvelope
    set?: Enumerable<FacebookPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostWhereUniqueInput>
    delete?: Enumerable<FacebookPostWhereUniqueInput>
    connect?: Enumerable<FacebookPostWhereUniqueInput>
    update?: Enumerable<FacebookPostUpdateWithWhereUniqueWithoutShareInput>
    updateMany?: Enumerable<FacebookPostUpdateManyWithWhereWithoutShareInput>
    deleteMany?: Enumerable<FacebookPostScalarWhereInput>
  }

  export type FacebookUserInGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutGroupInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutGroupInput>
    createMany?: FacebookUserInGroupCreateManyGroupInputEnvelope
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
  }

  export type FacebookPostDestinationCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutGroupInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutGroupInput>
    createMany?: FacebookPostDestinationCreateManyGroupInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookUserInGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutGroupInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutGroupInput>
    createMany?: FacebookUserInGroupCreateManyGroupInputEnvelope
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
  }

  export type FacebookPostDestinationUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutGroupInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutGroupInput>
    createMany?: FacebookPostDestinationCreateManyGroupInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookUserInGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutGroupInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FacebookUserInGroupUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FacebookUserInGroupCreateManyGroupInputEnvelope
    set?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    delete?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    update?: Enumerable<FacebookUserInGroupUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FacebookUserInGroupUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FacebookUserInGroupScalarWhereInput>
  }

  export type FacebookPostDestinationUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutGroupInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FacebookPostDestinationCreateManyGroupInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookUserInGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FacebookUserInGroupCreateWithoutGroupInput>, Enumerable<FacebookUserInGroupUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookUserInGroupCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FacebookUserInGroupUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FacebookUserInGroupCreateManyGroupInputEnvelope
    set?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    disconnect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    delete?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    connect?: Enumerable<FacebookUserInGroupWhereUniqueInput>
    update?: Enumerable<FacebookUserInGroupUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FacebookUserInGroupUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FacebookUserInGroupScalarWhereInput>
  }

  export type FacebookPostDestinationUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutGroupInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FacebookPostDestinationCreateManyGroupInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookUserCreateNestedOneWithoutUserInGroupsInput = {
    create?: XOR<FacebookUserCreateWithoutUserInGroupsInput, FacebookUserUncheckedCreateWithoutUserInGroupsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutUserInGroupsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookGroupCreateNestedOneWithoutUserInGroupsInput = {
    create?: XOR<FacebookGroupCreateWithoutUserInGroupsInput, FacebookGroupUncheckedCreateWithoutUserInGroupsInput>
    connectOrCreate?: FacebookGroupCreateOrConnectWithoutUserInGroupsInput
    connect?: FacebookGroupWhereUniqueInput
  }

  export type FacebookUserUpdateOneRequiredWithoutUserInGroupsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutUserInGroupsInput, FacebookUserUncheckedCreateWithoutUserInGroupsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutUserInGroupsInput
    upsert?: FacebookUserUpsertWithoutUserInGroupsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutUserInGroupsInput, FacebookUserUncheckedUpdateWithoutUserInGroupsInput>
  }

  export type FacebookGroupUpdateOneRequiredWithoutUserInGroupsNestedInput = {
    create?: XOR<FacebookGroupCreateWithoutUserInGroupsInput, FacebookGroupUncheckedCreateWithoutUserInGroupsInput>
    connectOrCreate?: FacebookGroupCreateOrConnectWithoutUserInGroupsInput
    upsert?: FacebookGroupUpsertWithoutUserInGroupsInput
    connect?: FacebookGroupWhereUniqueInput
    update?: XOR<FacebookGroupUpdateWithoutUserInGroupsInput, FacebookGroupUncheckedUpdateWithoutUserInGroupsInput>
  }

  export type FacebookUserCreateNestedOneWithoutPostDestinationsInput = {
    create?: XOR<FacebookUserCreateWithoutPostDestinationsInput, FacebookUserUncheckedCreateWithoutPostDestinationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostDestinationsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookGroupCreateNestedOneWithoutPostDestinationsInput = {
    create?: XOR<FacebookGroupCreateWithoutPostDestinationsInput, FacebookGroupUncheckedCreateWithoutPostDestinationsInput>
    connectOrCreate?: FacebookGroupCreateOrConnectWithoutPostDestinationsInput
    connect?: FacebookGroupWhereUniqueInput
  }

  export type FacebookPostCreateNestedOneWithoutPostDestionationsInput = {
    create?: XOR<FacebookPostCreateWithoutPostDestionationsInput, FacebookPostUncheckedCreateWithoutPostDestionationsInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutPostDestionationsInput
    connect?: FacebookPostWhereUniqueInput
  }

  export type FacebookUserUpdateOneWithoutPostDestinationsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutPostDestinationsInput, FacebookUserUncheckedCreateWithoutPostDestinationsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostDestinationsInput
    upsert?: FacebookUserUpsertWithoutPostDestinationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutPostDestinationsInput, FacebookUserUncheckedUpdateWithoutPostDestinationsInput>
  }

  export type FacebookGroupUpdateOneWithoutPostDestinationsNestedInput = {
    create?: XOR<FacebookGroupCreateWithoutPostDestinationsInput, FacebookGroupUncheckedCreateWithoutPostDestinationsInput>
    connectOrCreate?: FacebookGroupCreateOrConnectWithoutPostDestinationsInput
    upsert?: FacebookGroupUpsertWithoutPostDestinationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookGroupWhereUniqueInput
    update?: XOR<FacebookGroupUpdateWithoutPostDestinationsInput, FacebookGroupUncheckedUpdateWithoutPostDestinationsInput>
  }

  export type FacebookPostUpdateOneWithoutPostDestionationsNestedInput = {
    create?: XOR<FacebookPostCreateWithoutPostDestionationsInput, FacebookPostUncheckedCreateWithoutPostDestionationsInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutPostDestionationsInput
    upsert?: FacebookPostUpsertWithoutPostDestionationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookPostWhereUniqueInput
    update?: XOR<FacebookPostUpdateWithoutPostDestionationsInput, FacebookPostUncheckedUpdateWithoutPostDestionationsInput>
  }

  export type FacebookUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookLocationCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookLocationCreateWithoutPostsInput, FacebookLocationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookLocationCreateOrConnectWithoutPostsInput
    connect?: FacebookLocationWhereUniqueInput
  }

  export type FacebookHashtagCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookHashtagCreateWithoutPostsInput, FacebookHashtagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookHashtagCreateOrConnectWithoutPostsInput
    connect?: FacebookHashtagWhereUniqueInput
  }

  export type FacebookShareTypeCreateNestedOneWithoutPostsInput = {
    create?: XOR<FacebookShareTypeCreateWithoutPostsInput, FacebookShareTypeUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookShareTypeCreateOrConnectWithoutPostsInput
    connect?: FacebookShareTypeWhereUniqueInput
  }

  export type FacebookLikeCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutPostsInput>, Enumerable<FacebookLikeUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutPostsInput>
    createMany?: FacebookLikeCreateManyPostsInputEnvelope
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
  }

  export type FacebookCommentPostCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutPostInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutPostInput>
    createMany?: FacebookCommentPostCreateManyPostInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookPostDestinationCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutPostInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutPostInput>
    createMany?: FacebookPostDestinationCreateManyPostInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookLikeUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutPostsInput>, Enumerable<FacebookLikeUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutPostsInput>
    createMany?: FacebookLikeCreateManyPostsInputEnvelope
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
  }

  export type FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutPostInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutPostInput>
    createMany?: FacebookCommentPostCreateManyPostInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutPostInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutPostInput>
    createMany?: FacebookPostDestinationCreateManyPostInputEnvelope
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutPostsInput
    upsert?: FacebookUserUpsertWithoutPostsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
  }

  export type FacebookLocationUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FacebookLocationCreateWithoutPostsInput, FacebookLocationUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookLocationCreateOrConnectWithoutPostsInput
    upsert?: FacebookLocationUpsertWithoutPostsInput
    connect?: FacebookLocationWhereUniqueInput
    update?: XOR<FacebookLocationUpdateWithoutPostsInput, FacebookLocationUncheckedUpdateWithoutPostsInput>
  }

  export type FacebookHashtagUpdateOneWithoutPostsNestedInput = {
    create?: XOR<FacebookHashtagCreateWithoutPostsInput, FacebookHashtagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookHashtagCreateOrConnectWithoutPostsInput
    upsert?: FacebookHashtagUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookHashtagWhereUniqueInput
    update?: XOR<FacebookHashtagUpdateWithoutPostsInput, FacebookHashtagUncheckedUpdateWithoutPostsInput>
  }

  export type FacebookShareTypeUpdateOneWithoutPostsNestedInput = {
    create?: XOR<FacebookShareTypeCreateWithoutPostsInput, FacebookShareTypeUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FacebookShareTypeCreateOrConnectWithoutPostsInput
    upsert?: FacebookShareTypeUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookShareTypeWhereUniqueInput
    update?: XOR<FacebookShareTypeUpdateWithoutPostsInput, FacebookShareTypeUncheckedUpdateWithoutPostsInput>
  }

  export type FacebookLikeUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutPostsInput>, Enumerable<FacebookLikeUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<FacebookLikeUpsertWithWhereUniqueWithoutPostsInput>
    createMany?: FacebookLikeCreateManyPostsInputEnvelope
    set?: Enumerable<FacebookLikeWhereUniqueInput>
    disconnect?: Enumerable<FacebookLikeWhereUniqueInput>
    delete?: Enumerable<FacebookLikeWhereUniqueInput>
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
    update?: Enumerable<FacebookLikeUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<FacebookLikeUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<FacebookLikeScalarWhereInput>
  }

  export type FacebookCommentPostUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutPostInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FacebookCommentPostCreateManyPostInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookPostDestinationUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutPostInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FacebookPostDestinationCreateManyPostInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<Enumerable<FacebookLikeCreateWithoutPostsInput>, Enumerable<FacebookLikeUncheckedCreateWithoutPostsInput>>
    connectOrCreate?: Enumerable<FacebookLikeCreateOrConnectWithoutPostsInput>
    upsert?: Enumerable<FacebookLikeUpsertWithWhereUniqueWithoutPostsInput>
    createMany?: FacebookLikeCreateManyPostsInputEnvelope
    set?: Enumerable<FacebookLikeWhereUniqueInput>
    disconnect?: Enumerable<FacebookLikeWhereUniqueInput>
    delete?: Enumerable<FacebookLikeWhereUniqueInput>
    connect?: Enumerable<FacebookLikeWhereUniqueInput>
    update?: Enumerable<FacebookLikeUpdateWithWhereUniqueWithoutPostsInput>
    updateMany?: Enumerable<FacebookLikeUpdateManyWithWhereWithoutPostsInput>
    deleteMany?: Enumerable<FacebookLikeScalarWhereInput>
  }

  export type FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutPostInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FacebookCommentPostCreateManyPostInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<FacebookPostDestinationCreateWithoutPostInput>, Enumerable<FacebookPostDestinationUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<FacebookPostDestinationCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<FacebookPostDestinationUpsertWithWhereUniqueWithoutPostInput>
    createMany?: FacebookPostDestinationCreateManyPostInputEnvelope
    set?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    disconnect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    delete?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    connect?: Enumerable<FacebookPostDestinationWhereUniqueInput>
    update?: Enumerable<FacebookPostDestinationUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<FacebookPostDestinationUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<FacebookPostDestinationScalarWhereInput>
  }

  export type FacebookPostCreateNestedOneWithoutCommentPostsInput = {
    create?: XOR<FacebookPostCreateWithoutCommentPostsInput, FacebookPostUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutCommentPostsInput
    connect?: FacebookPostWhereUniqueInput
  }

  export type FacebookUserCreateNestedOneWithoutCommentPostsInput = {
    create?: XOR<FacebookUserCreateWithoutCommentPostsInput, FacebookUserUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentPostsInput
    connect?: FacebookUserWhereUniqueInput
  }

  export type FacebookCommentPostCreateNestedOneWithoutCommentPostsInput = {
    create?: XOR<FacebookCommentPostCreateWithoutCommentPostsInput, FacebookCommentPostUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookCommentPostCreateOrConnectWithoutCommentPostsInput
    connect?: FacebookCommentPostWhereUniqueInput
  }

  export type FacebookShareTypeCreateNestedOneWithoutCommentPostsInput = {
    create?: XOR<FacebookShareTypeCreateWithoutCommentPostsInput, FacebookShareTypeUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookShareTypeCreateOrConnectWithoutCommentPostsInput
    connect?: FacebookShareTypeWhereUniqueInput
  }

  export type FacebookCommentPostCreateNestedManyWithoutCommentToInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutCommentToInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutCommentToInput>
    createMany?: FacebookCommentPostCreateManyCommentToInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutCommentToInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutCommentToInput>
    createMany?: FacebookCommentPostCreateManyCommentToInputEnvelope
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
  }

  export type FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput = {
    create?: XOR<FacebookPostCreateWithoutCommentPostsInput, FacebookPostUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookPostCreateOrConnectWithoutCommentPostsInput
    upsert?: FacebookPostUpsertWithoutCommentPostsInput
    connect?: FacebookPostWhereUniqueInput
    update?: XOR<FacebookPostUpdateWithoutCommentPostsInput, FacebookPostUncheckedUpdateWithoutCommentPostsInput>
  }

  export type FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput = {
    create?: XOR<FacebookUserCreateWithoutCommentPostsInput, FacebookUserUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookUserCreateOrConnectWithoutCommentPostsInput
    upsert?: FacebookUserUpsertWithoutCommentPostsInput
    connect?: FacebookUserWhereUniqueInput
    update?: XOR<FacebookUserUpdateWithoutCommentPostsInput, FacebookUserUncheckedUpdateWithoutCommentPostsInput>
  }

  export type FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput = {
    create?: XOR<FacebookCommentPostCreateWithoutCommentPostsInput, FacebookCommentPostUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookCommentPostCreateOrConnectWithoutCommentPostsInput
    upsert?: FacebookCommentPostUpsertWithoutCommentPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FacebookCommentPostWhereUniqueInput
    update?: XOR<FacebookCommentPostUpdateWithoutCommentPostsInput, FacebookCommentPostUncheckedUpdateWithoutCommentPostsInput>
  }

  export type FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput = {
    create?: XOR<FacebookShareTypeCreateWithoutCommentPostsInput, FacebookShareTypeUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: FacebookShareTypeCreateOrConnectWithoutCommentPostsInput
    upsert?: FacebookShareTypeUpsertWithoutCommentPostsInput
    connect?: FacebookShareTypeWhereUniqueInput
    update?: XOR<FacebookShareTypeUpdateWithoutCommentPostsInput, FacebookShareTypeUncheckedUpdateWithoutCommentPostsInput>
  }

  export type FacebookCommentPostUpdateManyWithoutCommentToNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutCommentToInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutCommentToInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutCommentToInput>
    createMany?: FacebookCommentPostCreateManyCommentToInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutCommentToInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutCommentToInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput = {
    create?: XOR<Enumerable<FacebookCommentPostCreateWithoutCommentToInput>, Enumerable<FacebookCommentPostUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<FacebookCommentPostCreateOrConnectWithoutCommentToInput>
    upsert?: Enumerable<FacebookCommentPostUpsertWithWhereUniqueWithoutCommentToInput>
    createMany?: FacebookCommentPostCreateManyCommentToInputEnvelope
    set?: Enumerable<FacebookCommentPostWhereUniqueInput>
    disconnect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    delete?: Enumerable<FacebookCommentPostWhereUniqueInput>
    connect?: Enumerable<FacebookCommentPostWhereUniqueInput>
    update?: Enumerable<FacebookCommentPostUpdateWithWhereUniqueWithoutCommentToInput>
    updateMany?: Enumerable<FacebookCommentPostUpdateManyWithWhereWithoutCommentToInput>
    deleteMany?: Enumerable<FacebookCommentPostScalarWhereInput>
  }

  export type TwitterPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterUserRelationshipCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutFromInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutFromInput>
    createMany?: TwitterUserRelationshipCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
  }

  export type TwitterUserRelationshipCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutToInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutToInput>
    createMany?: TwitterUserRelationshipCreateManyToInputEnvelope
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
  }

  export type TwitterReplyPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutUserInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterReplyPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterDirectMessageCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterPostWhereUniqueInput>
  }

  export type TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutFromInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutFromInput>
    createMany?: TwitterUserRelationshipCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
  }

  export type TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutToInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutToInput>
    createMany?: TwitterUserRelationshipCreateManyToInputEnvelope
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
  }

  export type TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutUserInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutUserInput>
    createMany?: TwitterReplyPostCreateManyUserInputEnvelope
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
  }

  export type TwitterPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterUserRelationshipUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutFromInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterUserRelationshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterUserRelationshipCreateManyFromInputEnvelope
    set?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterUserRelationshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterUserRelationshipScalarWhereInput>
  }

  export type TwitterUserRelationshipUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutToInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterUserRelationshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterUserRelationshipCreateManyToInputEnvelope
    set?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterUserRelationshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterUserRelationshipScalarWhereInput>
  }

  export type TwitterReplyPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutUserInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterReplyPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterReplyPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterReplyPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    delete?: Enumerable<TwitterReplyPostWhereUniqueInput>
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    update?: Enumerable<TwitterReplyPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterReplyPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterReplyPostScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterDirectMessageUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterPostCreateWithoutUserInput>, Enumerable<TwitterPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostWhereUniqueInput>
    delete?: Enumerable<TwitterPostWhereUniqueInput>
    connect?: Enumerable<TwitterPostWhereUniqueInput>
    update?: Enumerable<TwitterPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterPostScalarWhereInput>
  }

  export type TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutFromInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterUserRelationshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterUserRelationshipCreateManyFromInputEnvelope
    set?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterUserRelationshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterUserRelationshipScalarWhereInput>
  }

  export type TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterUserRelationshipCreateWithoutToInput>, Enumerable<TwitterUserRelationshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterUserRelationshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterUserRelationshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterUserRelationshipCreateManyToInputEnvelope
    set?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    disconnect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    delete?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    connect?: Enumerable<TwitterUserRelationshipWhereUniqueInput>
    update?: Enumerable<TwitterUserRelationshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterUserRelationshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterUserRelationshipScalarWhereInput>
  }

  export type TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutUserInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TwitterReplyPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TwitterReplyPostCreateManyUserInputEnvelope
    set?: Enumerable<TwitterReplyPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    delete?: Enumerable<TwitterReplyPostWhereUniqueInput>
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    update?: Enumerable<TwitterReplyPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TwitterReplyPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TwitterReplyPostScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutFromInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: TwitterDirectMessageCreateManyFromInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<TwitterDirectMessageCreateWithoutToInput>, Enumerable<TwitterDirectMessageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<TwitterDirectMessageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput>
    createMany?: TwitterDirectMessageCreateManyToInputEnvelope
    set?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    disconnect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    delete?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    connect?: Enumerable<TwitterDirectMessageWhereUniqueInput>
    update?: Enumerable<TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<TwitterDirectMessageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<TwitterDirectMessageScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutPostsInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterPostAndHashtagCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutPostInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostAndHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
  }

  export type TwitterReplyPostCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutPostInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutPostInput>
    createMany?: TwitterReplyPostCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
  }

  export type TwitterPostAndHashtagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutPostInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutPostInput>
    createMany?: TwitterPostAndHashtagCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
  }

  export type TwitterReplyPostUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutPostInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutPostInput>
    createMany?: TwitterReplyPostCreateManyPostInputEnvelope
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutPostsInput
    upsert?: TwitterUserUpsertWithoutPostsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
  }

  export type TwitterPostAndHashtagUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutPostInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostAndHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostAndHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostAndHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostAndHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
  }

  export type TwitterReplyPostUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutPostInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterReplyPostUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterReplyPostCreateManyPostInputEnvelope
    set?: Enumerable<TwitterReplyPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    delete?: Enumerable<TwitterReplyPostWhereUniqueInput>
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    update?: Enumerable<TwitterReplyPostUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterReplyPostUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterReplyPostScalarWhereInput>
  }

  export type TwitterPostAndHashtagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutPostInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterPostAndHashtagUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterPostAndHashtagCreateManyPostInputEnvelope
    set?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostAndHashtagUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterPostAndHashtagUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
  }

  export type TwitterReplyPostUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<TwitterReplyPostCreateWithoutPostInput>, Enumerable<TwitterReplyPostUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<TwitterReplyPostCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<TwitterReplyPostUpsertWithWhereUniqueWithoutPostInput>
    createMany?: TwitterReplyPostCreateManyPostInputEnvelope
    set?: Enumerable<TwitterReplyPostWhereUniqueInput>
    disconnect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    delete?: Enumerable<TwitterReplyPostWhereUniqueInput>
    connect?: Enumerable<TwitterReplyPostWhereUniqueInput>
    update?: Enumerable<TwitterReplyPostUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<TwitterReplyPostUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<TwitterReplyPostScalarWhereInput>
  }

  export type TwitterUserCreateNestedOneWithoutFollowingsInput = {
    create?: XOR<TwitterUserCreateWithoutFollowingsInput, TwitterUserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowingsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<TwitterUserCreateWithoutFollowersInput, TwitterUserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowersInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutFollowingsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFollowingsInput, TwitterUserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowingsInput
    upsert?: TwitterUserUpsertWithoutFollowingsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFollowingsInput, TwitterUserUncheckedUpdateWithoutFollowingsInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<TwitterUserCreateWithoutFollowersInput, TwitterUserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutFollowersInput
    upsert?: TwitterUserUpsertWithoutFollowersInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutFollowersInput, TwitterUserUncheckedUpdateWithoutFollowersInput>
  }

  export type TwitterPostAndHashtagCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostAndHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
  }

  export type TwitterPostAndHashtagUncheckedCreateNestedManyWithoutHashtagInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutHashtagInput>
    createMany?: TwitterPostAndHashtagCreateManyHashtagInputEnvelope
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
  }

  export type TwitterPostAndHashtagUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostAndHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostAndHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostAndHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostAndHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
  }

  export type TwitterPostAndHashtagUncheckedUpdateManyWithoutHashtagNestedInput = {
    create?: XOR<Enumerable<TwitterPostAndHashtagCreateWithoutHashtagInput>, Enumerable<TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>>
    connectOrCreate?: Enumerable<TwitterPostAndHashtagCreateOrConnectWithoutHashtagInput>
    upsert?: Enumerable<TwitterPostAndHashtagUpsertWithWhereUniqueWithoutHashtagInput>
    createMany?: TwitterPostAndHashtagCreateManyHashtagInputEnvelope
    set?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    disconnect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    delete?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    connect?: Enumerable<TwitterPostAndHashtagWhereUniqueInput>
    update?: Enumerable<TwitterPostAndHashtagUpdateWithWhereUniqueWithoutHashtagInput>
    updateMany?: Enumerable<TwitterPostAndHashtagUpdateManyWithWhereWithoutHashtagInput>
    deleteMany?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
  }

  export type TwitterPostCreateNestedOneWithoutPostAndHashtagsInput = {
    create?: XOR<TwitterPostCreateWithoutPostAndHashtagsInput, TwitterPostUncheckedCreateWithoutPostAndHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostAndHashtagsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterHashtagCreateNestedOneWithoutPostAndHashtagsInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostAndHashtagsInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostAndHashtagsInput
    connect?: TwitterHashtagWhereUniqueInput
  }

  export type TwitterPostUpdateOneRequiredWithoutPostAndHashtagsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutPostAndHashtagsInput, TwitterPostUncheckedCreateWithoutPostAndHashtagsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutPostAndHashtagsInput
    upsert?: TwitterPostUpsertWithoutPostAndHashtagsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutPostAndHashtagsInput, TwitterPostUncheckedUpdateWithoutPostAndHashtagsInput>
  }

  export type TwitterHashtagUpdateOneRequiredWithoutPostAndHashtagsNestedInput = {
    create?: XOR<TwitterHashtagCreateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostAndHashtagsInput>
    connectOrCreate?: TwitterHashtagCreateOrConnectWithoutPostAndHashtagsInput
    upsert?: TwitterHashtagUpsertWithoutPostAndHashtagsInput
    connect?: TwitterHashtagWhereUniqueInput
    update?: XOR<TwitterHashtagUpdateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedUpdateWithoutPostAndHashtagsInput>
  }

  export type TwitterUserCreateNestedOneWithoutReplyPostsInput = {
    create?: XOR<TwitterUserCreateWithoutReplyPostsInput, TwitterUserUncheckedCreateWithoutReplyPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutReplyPostsInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterPostCreateNestedOneWithoutReplyPostsInput = {
    create?: XOR<TwitterPostCreateWithoutReplyPostsInput, TwitterPostUncheckedCreateWithoutReplyPostsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutReplyPostsInput
    connect?: TwitterPostWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutReplyPostsNestedInput = {
    create?: XOR<TwitterUserCreateWithoutReplyPostsInput, TwitterUserUncheckedCreateWithoutReplyPostsInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutReplyPostsInput
    upsert?: TwitterUserUpsertWithoutReplyPostsInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutReplyPostsInput, TwitterUserUncheckedUpdateWithoutReplyPostsInput>
  }

  export type TwitterPostUpdateOneRequiredWithoutReplyPostsNestedInput = {
    create?: XOR<TwitterPostCreateWithoutReplyPostsInput, TwitterPostUncheckedCreateWithoutReplyPostsInput>
    connectOrCreate?: TwitterPostCreateOrConnectWithoutReplyPostsInput
    upsert?: TwitterPostUpsertWithoutReplyPostsInput
    connect?: TwitterPostWhereUniqueInput
    update?: XOR<TwitterPostUpdateWithoutReplyPostsInput, TwitterPostUncheckedUpdateWithoutReplyPostsInput>
  }

  export type TwitterUserCreateNestedOneWithoutDirectMessageFromInput = {
    create?: XOR<TwitterUserCreateWithoutDirectMessageFromInput, TwitterUserUncheckedCreateWithoutDirectMessageFromInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutDirectMessageFromInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserCreateNestedOneWithoutDirectMessageToInput = {
    create?: XOR<TwitterUserCreateWithoutDirectMessageToInput, TwitterUserUncheckedCreateWithoutDirectMessageToInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutDirectMessageToInput
    connect?: TwitterUserWhereUniqueInput
  }

  export type TwitterUserUpdateOneRequiredWithoutDirectMessageFromNestedInput = {
    create?: XOR<TwitterUserCreateWithoutDirectMessageFromInput, TwitterUserUncheckedCreateWithoutDirectMessageFromInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutDirectMessageFromInput
    upsert?: TwitterUserUpsertWithoutDirectMessageFromInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutDirectMessageFromInput, TwitterUserUncheckedUpdateWithoutDirectMessageFromInput>
  }

  export type TwitterUserUpdateOneRequiredWithoutDirectMessageToNestedInput = {
    create?: XOR<TwitterUserCreateWithoutDirectMessageToInput, TwitterUserUncheckedCreateWithoutDirectMessageToInput>
    connectOrCreate?: TwitterUserCreateOrConnectWithoutDirectMessageToInput
    upsert?: TwitterUserUpsertWithoutDirectMessageToInput
    connect?: TwitterUserWhereUniqueInput
    update?: XOR<TwitterUserUpdateWithoutDirectMessageToInput, TwitterUserUncheckedUpdateWithoutDirectMessageToInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeSubscriberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutUserInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutUserInput>
    createMany?: YoutubeSubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
  }

  export type YoutubeReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeSubscriberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutUserInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutUserInput>
    createMany?: YoutubeSubscriberCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
  }

  export type YoutubeReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeSubscriberUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutUserInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeSubscriberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeSubscriberCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeSubscriberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeSubscriberScalarWhereInput>
  }

  export type YoutubeReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutUserInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeUserToChannelCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeSubscriberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutUserInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeSubscriberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeSubscriberCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeSubscriberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeSubscriberScalarWhereInput>
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutUserInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeReactionCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutUserInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: YoutubeCommentCreateManyUserInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutRoleInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: YoutubeUserToChannelCreateManyRoleInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeUserToChannelCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeVideoCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeSubscriberCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutChannelInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeSubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
  }

  export type YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
  }

  export type YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
  }

  export type YoutubeSubscriberUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutChannelInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutChannelInput>
    createMany?: YoutubeSubscriberCreateManyChannelInputEnvelope
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
  }

  export type YoutubeUserToChannelUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeSubscriberUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutChannelInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeSubscriberUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeSubscriberCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriberUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeSubscriberUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeSubscriberScalarWhereInput>
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeUserToChannelCreateWithoutChannelInput>, Enumerable<YoutubeUserToChannelUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeUserToChannelCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeUserToChannelCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    disconnect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    delete?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    connect?: Enumerable<YoutubeUserToChannelWhereUniqueInput>
    update?: Enumerable<YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeUserToChannelScalarWhereInput>
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeVideoCreateWithoutChannelInput>, Enumerable<YoutubeVideoUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeVideoCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeVideoCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeVideoWhereUniqueInput>
    disconnect?: Enumerable<YoutubeVideoWhereUniqueInput>
    delete?: Enumerable<YoutubeVideoWhereUniqueInput>
    connect?: Enumerable<YoutubeVideoWhereUniqueInput>
    update?: Enumerable<YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeVideoUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeVideoScalarWhereInput>
  }

  export type YoutubeSubscriberUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<Enumerable<YoutubeSubscriberCreateWithoutChannelInput>, Enumerable<YoutubeSubscriberUncheckedCreateWithoutChannelInput>>
    connectOrCreate?: Enumerable<YoutubeSubscriberCreateOrConnectWithoutChannelInput>
    upsert?: Enumerable<YoutubeSubscriberUpsertWithWhereUniqueWithoutChannelInput>
    createMany?: YoutubeSubscriberCreateManyChannelInputEnvelope
    set?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    disconnect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    delete?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    connect?: Enumerable<YoutubeSubscriberWhereUniqueInput>
    update?: Enumerable<YoutubeSubscriberUpdateWithWhereUniqueWithoutChannelInput>
    updateMany?: Enumerable<YoutubeSubscriberUpdateManyWithWhereWithoutChannelInput>
    deleteMany?: Enumerable<YoutubeSubscriberScalarWhereInput>
  }

  export type YoutubeUserCreateNestedOneWithoutUserToChannelsInput = {
    create?: XOR<YoutubeUserCreateWithoutUserToChannelsInput, YoutubeUserUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutUserToChannelsInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeRoleCreateNestedOneWithoutUserToChannelsInput = {
    create?: XOR<YoutubeRoleCreateWithoutUserToChannelsInput, YoutubeRoleUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeRoleCreateOrConnectWithoutUserToChannelsInput
    connect?: YoutubeRoleWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutUserToChannelsInput = {
    create?: XOR<YoutubeChannelCreateWithoutUserToChannelsInput, YoutubeChannelUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutUserToChannelsInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutUserToChannelsNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutUserToChannelsInput, YoutubeUserUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutUserToChannelsInput
    upsert?: YoutubeUserUpsertWithoutUserToChannelsInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutUserToChannelsInput, YoutubeUserUncheckedUpdateWithoutUserToChannelsInput>
  }

  export type YoutubeRoleUpdateOneRequiredWithoutUserToChannelsNestedInput = {
    create?: XOR<YoutubeRoleCreateWithoutUserToChannelsInput, YoutubeRoleUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeRoleCreateOrConnectWithoutUserToChannelsInput
    upsert?: YoutubeRoleUpsertWithoutUserToChannelsInput
    connect?: YoutubeRoleWhereUniqueInput
    update?: XOR<YoutubeRoleUpdateWithoutUserToChannelsInput, YoutubeRoleUncheckedUpdateWithoutUserToChannelsInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutUserToChannelsNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutUserToChannelsInput, YoutubeChannelUncheckedCreateWithoutUserToChannelsInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutUserToChannelsInput
    upsert?: YoutubeChannelUpsertWithoutUserToChannelsInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutUserToChannelsInput, YoutubeChannelUncheckedUpdateWithoutUserToChannelsInput>
  }

  export type YoutubeChannelCreateNestedOneWithoutVideosInput = {
    create?: XOR<YoutubeChannelCreateWithoutVideosInput, YoutubeChannelUncheckedCreateWithoutVideosInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutVideosInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeCommentCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeReactionCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutVideosInput, YoutubeChannelUncheckedCreateWithoutVideosInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutVideosInput
    upsert?: YoutubeChannelUpsertWithoutVideosInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutVideosInput, YoutubeChannelUncheckedUpdateWithoutVideosInput>
  }

  export type YoutubeCommentUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeReactionUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutVideoInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeCommentCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<YoutubeReactionCreateWithoutVideoInput>, Enumerable<YoutubeReactionUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<YoutubeReactionCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: YoutubeReactionCreateManyVideoInputEnvelope
    set?: Enumerable<YoutubeReactionWhereUniqueInput>
    disconnect?: Enumerable<YoutubeReactionWhereUniqueInput>
    delete?: Enumerable<YoutubeReactionWhereUniqueInput>
    connect?: Enumerable<YoutubeReactionWhereUniqueInput>
    update?: Enumerable<YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<YoutubeReactionUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<YoutubeReactionScalarWhereInput>
  }

  export type YoutubeUserCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<YoutubeUserCreateWithoutSubscribersInput, YoutubeUserUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutSubscribersInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeChannelCreateNestedOneWithoutSubscribersInput = {
    create?: XOR<YoutubeChannelCreateWithoutSubscribersInput, YoutubeChannelUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutSubscribersInput
    connect?: YoutubeChannelWhereUniqueInput
  }

  export type YoutubeUserUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutSubscribersInput, YoutubeUserUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutSubscribersInput
    upsert?: YoutubeUserUpsertWithoutSubscribersInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutSubscribersInput, YoutubeUserUncheckedUpdateWithoutSubscribersInput>
  }

  export type YoutubeChannelUpdateOneRequiredWithoutSubscribersNestedInput = {
    create?: XOR<YoutubeChannelCreateWithoutSubscribersInput, YoutubeChannelUncheckedCreateWithoutSubscribersInput>
    connectOrCreate?: YoutubeChannelCreateOrConnectWithoutSubscribersInput
    upsert?: YoutubeChannelUpsertWithoutSubscribersInput
    connect?: YoutubeChannelWhereUniqueInput
    update?: XOR<YoutubeChannelUpdateWithoutSubscribersInput, YoutubeChannelUncheckedUpdateWithoutSubscribersInput>
  }

  export type YoutubeUserCreateNestedOneWithoutReactionsInput = {
    create?: XOR<YoutubeUserCreateWithoutReactionsInput, YoutubeUserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutReactionsInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeVideoCreateNestedOneWithoutReactionsInput = {
    create?: XOR<YoutubeVideoCreateWithoutReactionsInput, YoutubeVideoUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutReactionsInput
    connect?: YoutubeVideoWhereUniqueInput
  }

  export type EnumReactionEnumFieldUpdateOperationsInput = {
    set?: ReactionEnum
  }

  export type YoutubeUserUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutReactionsInput, YoutubeUserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutReactionsInput
    upsert?: YoutubeUserUpsertWithoutReactionsInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutReactionsInput, YoutubeUserUncheckedUpdateWithoutReactionsInput>
  }

  export type YoutubeVideoUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<YoutubeVideoCreateWithoutReactionsInput, YoutubeVideoUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutReactionsInput
    upsert?: YoutubeVideoUpsertWithoutReactionsInput
    connect?: YoutubeVideoWhereUniqueInput
    update?: XOR<YoutubeVideoUpdateWithoutReactionsInput, YoutubeVideoUncheckedUpdateWithoutReactionsInput>
  }

  export type YoutubeVideoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<YoutubeVideoCreateWithoutCommentsInput, YoutubeVideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutCommentsInput
    connect?: YoutubeVideoWhereUniqueInput
  }

  export type YoutubeUserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<YoutubeUserCreateWithoutCommentsInput, YoutubeUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutCommentsInput
    connect?: YoutubeUserWhereUniqueInput
  }

  export type YoutubeCommentCreateNestedOneWithoutCommentPostsInput = {
    create?: XOR<YoutubeCommentCreateWithoutCommentPostsInput, YoutubeCommentUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: YoutubeCommentCreateOrConnectWithoutCommentPostsInput
    connect?: YoutubeCommentWhereUniqueInput
  }

  export type YoutubeCommentCreateNestedManyWithoutCommentToInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutCommentToInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutCommentToInput>
    createMany?: YoutubeCommentCreateManyCommentToInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeCommentUncheckedCreateNestedManyWithoutCommentToInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutCommentToInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutCommentToInput>
    createMany?: YoutubeCommentCreateManyCommentToInputEnvelope
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
  }

  export type YoutubeVideoUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<YoutubeVideoCreateWithoutCommentsInput, YoutubeVideoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YoutubeVideoCreateOrConnectWithoutCommentsInput
    upsert?: YoutubeVideoUpsertWithoutCommentsInput
    connect?: YoutubeVideoWhereUniqueInput
    update?: XOR<YoutubeVideoUpdateWithoutCommentsInput, YoutubeVideoUncheckedUpdateWithoutCommentsInput>
  }

  export type YoutubeUserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<YoutubeUserCreateWithoutCommentsInput, YoutubeUserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: YoutubeUserCreateOrConnectWithoutCommentsInput
    upsert?: YoutubeUserUpsertWithoutCommentsInput
    connect?: YoutubeUserWhereUniqueInput
    update?: XOR<YoutubeUserUpdateWithoutCommentsInput, YoutubeUserUncheckedUpdateWithoutCommentsInput>
  }

  export type YoutubeCommentUpdateOneWithoutCommentPostsNestedInput = {
    create?: XOR<YoutubeCommentCreateWithoutCommentPostsInput, YoutubeCommentUncheckedCreateWithoutCommentPostsInput>
    connectOrCreate?: YoutubeCommentCreateOrConnectWithoutCommentPostsInput
    upsert?: YoutubeCommentUpsertWithoutCommentPostsInput
    disconnect?: boolean
    delete?: boolean
    connect?: YoutubeCommentWhereUniqueInput
    update?: XOR<YoutubeCommentUpdateWithoutCommentPostsInput, YoutubeCommentUncheckedUpdateWithoutCommentPostsInput>
  }

  export type YoutubeCommentUpdateManyWithoutCommentToNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutCommentToInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutCommentToInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutCommentToInput>
    createMany?: YoutubeCommentCreateManyCommentToInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutCommentToInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutCommentToInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutCommentToNestedInput = {
    create?: XOR<Enumerable<YoutubeCommentCreateWithoutCommentToInput>, Enumerable<YoutubeCommentUncheckedCreateWithoutCommentToInput>>
    connectOrCreate?: Enumerable<YoutubeCommentCreateOrConnectWithoutCommentToInput>
    upsert?: Enumerable<YoutubeCommentUpsertWithWhereUniqueWithoutCommentToInput>
    createMany?: YoutubeCommentCreateManyCommentToInputEnvelope
    set?: Enumerable<YoutubeCommentWhereUniqueInput>
    disconnect?: Enumerable<YoutubeCommentWhereUniqueInput>
    delete?: Enumerable<YoutubeCommentWhereUniqueInput>
    connect?: Enumerable<YoutubeCommentWhereUniqueInput>
    update?: Enumerable<YoutubeCommentUpdateWithWhereUniqueWithoutCommentToInput>
    updateMany?: Enumerable<YoutubeCommentUpdateManyWithWhereWithoutCommentToInput>
    deleteMany?: Enumerable<YoutubeCommentScalarWhereInput>
  }

  export type LaundryMachineInStoreCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutBranchInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutBranchInput>
    createMany?: LaundryMachineInStoreCreateManyBranchInputEnvelope
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
  }

  export type LaundryMachineInStoreUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutBranchInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutBranchInput>
    createMany?: LaundryMachineInStoreCreateManyBranchInputEnvelope
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
  }

  export type LaundryMachineInStoreUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutBranchInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<LaundryMachineInStoreUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: LaundryMachineInStoreCreateManyBranchInputEnvelope
    set?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    disconnect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    delete?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    update?: Enumerable<LaundryMachineInStoreUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<LaundryMachineInStoreUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<LaundryMachineInStoreScalarWhereInput>
  }

  export type LaundryMachineInStoreUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutBranchInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutBranchInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutBranchInput>
    upsert?: Enumerable<LaundryMachineInStoreUpsertWithWhereUniqueWithoutBranchInput>
    createMany?: LaundryMachineInStoreCreateManyBranchInputEnvelope
    set?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    disconnect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    delete?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    update?: Enumerable<LaundryMachineInStoreUpdateWithWhereUniqueWithoutBranchInput>
    updateMany?: Enumerable<LaundryMachineInStoreUpdateManyWithWhereWithoutBranchInput>
    deleteMany?: Enumerable<LaundryMachineInStoreScalarWhereInput>
  }

  export type LaundryMachineInStoreCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutMachineInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutMachineInput>
    createMany?: LaundryMachineInStoreCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
  }

  export type LaunderServiceHistoryCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutMachineInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaunderServiceHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
  }

  export type LaundryMachineInStoreUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutMachineInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutMachineInput>
    createMany?: LaundryMachineInStoreCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
  }

  export type LaunderServiceHistoryUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutMachineInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaunderServiceHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
  }

  export type LaundryMachineInStoreUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutMachineInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryMachineInStoreUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryMachineInStoreCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    disconnect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    delete?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    update?: Enumerable<LaundryMachineInStoreUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryMachineInStoreUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryMachineInStoreScalarWhereInput>
  }

  export type LaunderServiceHistoryUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutMachineInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaunderServiceHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaunderServiceHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    delete?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    update?: Enumerable<LaunderServiceHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaunderServiceHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaunderServiceHistoryScalarWhereInput>
  }

  export type LaundryMachineInStoreUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryMachineInStoreCreateWithoutMachineInput>, Enumerable<LaundryMachineInStoreUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryMachineInStoreCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryMachineInStoreUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryMachineInStoreCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    disconnect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    delete?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    connect?: Enumerable<LaundryMachineInStoreWhereUniqueInput>
    update?: Enumerable<LaundryMachineInStoreUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryMachineInStoreUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryMachineInStoreScalarWhereInput>
  }

  export type LaunderServiceHistoryUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutMachineInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaunderServiceHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaunderServiceHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    delete?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    update?: Enumerable<LaunderServiceHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaunderServiceHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaunderServiceHistoryScalarWhereInput>
  }

  export type LaunderBranchInfoCreateNestedOneWithoutMachineInStoresInput = {
    create?: XOR<LaunderBranchInfoCreateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedCreateWithoutMachineInStoresInput>
    connectOrCreate?: LaunderBranchInfoCreateOrConnectWithoutMachineInStoresInput
    connect?: LaunderBranchInfoWhereUniqueInput
  }

  export type LaunderMachineCreateNestedOneWithoutMachineInStoresInput = {
    create?: XOR<LaunderMachineCreateWithoutMachineInStoresInput, LaunderMachineUncheckedCreateWithoutMachineInStoresInput>
    connectOrCreate?: LaunderMachineCreateOrConnectWithoutMachineInStoresInput
    connect?: LaunderMachineWhereUniqueInput
  }

  export type LaunderProgramInMachineCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutMachineInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutMachineInput>
    createMany?: LaunderProgramInMachineCreateManyMachineInputEnvelope
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
  }

  export type LaundryWashingHistoryCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutMachineInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaundryWashingHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
  }

  export type LaunderProgramInMachineUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutMachineInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutMachineInput>
    createMany?: LaunderProgramInMachineCreateManyMachineInputEnvelope
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
  }

  export type LaundryWashingHistoryUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutMachineInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutMachineInput>
    createMany?: LaundryWashingHistoryCreateManyMachineInputEnvelope
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
  }

  export type LaunderBranchInfoUpdateOneRequiredWithoutMachineInStoresNestedInput = {
    create?: XOR<LaunderBranchInfoCreateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedCreateWithoutMachineInStoresInput>
    connectOrCreate?: LaunderBranchInfoCreateOrConnectWithoutMachineInStoresInput
    upsert?: LaunderBranchInfoUpsertWithoutMachineInStoresInput
    connect?: LaunderBranchInfoWhereUniqueInput
    update?: XOR<LaunderBranchInfoUpdateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedUpdateWithoutMachineInStoresInput>
  }

  export type LaunderMachineUpdateOneRequiredWithoutMachineInStoresNestedInput = {
    create?: XOR<LaunderMachineCreateWithoutMachineInStoresInput, LaunderMachineUncheckedCreateWithoutMachineInStoresInput>
    connectOrCreate?: LaunderMachineCreateOrConnectWithoutMachineInStoresInput
    upsert?: LaunderMachineUpsertWithoutMachineInStoresInput
    connect?: LaunderMachineWhereUniqueInput
    update?: XOR<LaunderMachineUpdateWithoutMachineInStoresInput, LaunderMachineUncheckedUpdateWithoutMachineInStoresInput>
  }

  export type LaunderProgramInMachineUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutMachineInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaunderProgramInMachineUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaunderProgramInMachineCreateManyMachineInputEnvelope
    set?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    disconnect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    delete?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    update?: Enumerable<LaunderProgramInMachineUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaunderProgramInMachineUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaunderProgramInMachineScalarWhereInput>
  }

  export type LaundryWashingHistoryUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutMachineInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryWashingHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryWashingHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    update?: Enumerable<LaundryWashingHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryWashingHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryWashingHistoryScalarWhereInput>
  }

  export type LaunderProgramInMachineUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutMachineInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaunderProgramInMachineUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaunderProgramInMachineCreateManyMachineInputEnvelope
    set?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    disconnect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    delete?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    update?: Enumerable<LaunderProgramInMachineUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaunderProgramInMachineUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaunderProgramInMachineScalarWhereInput>
  }

  export type LaundryWashingHistoryUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutMachineInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutMachineInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutMachineInput>
    upsert?: Enumerable<LaundryWashingHistoryUpsertWithWhereUniqueWithoutMachineInput>
    createMany?: LaundryWashingHistoryCreateManyMachineInputEnvelope
    set?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    update?: Enumerable<LaundryWashingHistoryUpdateWithWhereUniqueWithoutMachineInput>
    updateMany?: Enumerable<LaundryWashingHistoryUpdateManyWithWhereWithoutMachineInput>
    deleteMany?: Enumerable<LaundryWashingHistoryScalarWhereInput>
  }

  export type LaunderServiceHistoryCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutTechnicianInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutTechnicianInput>
    createMany?: LaunderServiceHistoryCreateManyTechnicianInputEnvelope
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
  }

  export type LaunderServiceHistoryUncheckedCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutTechnicianInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutTechnicianInput>
    createMany?: LaunderServiceHistoryCreateManyTechnicianInputEnvelope
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
  }

  export type LaunderServiceHistoryUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutTechnicianInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutTechnicianInput>
    upsert?: Enumerable<LaunderServiceHistoryUpsertWithWhereUniqueWithoutTechnicianInput>
    createMany?: LaunderServiceHistoryCreateManyTechnicianInputEnvelope
    set?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    delete?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    update?: Enumerable<LaunderServiceHistoryUpdateWithWhereUniqueWithoutTechnicianInput>
    updateMany?: Enumerable<LaunderServiceHistoryUpdateManyWithWhereWithoutTechnicianInput>
    deleteMany?: Enumerable<LaunderServiceHistoryScalarWhereInput>
  }

  export type LaunderServiceHistoryUncheckedUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<Enumerable<LaunderServiceHistoryCreateWithoutTechnicianInput>, Enumerable<LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>>
    connectOrCreate?: Enumerable<LaunderServiceHistoryCreateOrConnectWithoutTechnicianInput>
    upsert?: Enumerable<LaunderServiceHistoryUpsertWithWhereUniqueWithoutTechnicianInput>
    createMany?: LaunderServiceHistoryCreateManyTechnicianInputEnvelope
    set?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    delete?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    connect?: Enumerable<LaunderServiceHistoryWhereUniqueInput>
    update?: Enumerable<LaunderServiceHistoryUpdateWithWhereUniqueWithoutTechnicianInput>
    updateMany?: Enumerable<LaunderServiceHistoryUpdateManyWithWhereWithoutTechnicianInput>
    deleteMany?: Enumerable<LaunderServiceHistoryScalarWhereInput>
  }

  export type LaunderMachineCreateNestedOneWithoutServiceHistoriesInput = {
    create?: XOR<LaunderMachineCreateWithoutServiceHistoriesInput, LaunderMachineUncheckedCreateWithoutServiceHistoriesInput>
    connectOrCreate?: LaunderMachineCreateOrConnectWithoutServiceHistoriesInput
    connect?: LaunderMachineWhereUniqueInput
  }

  export type LaunderTechnicianCreateNestedOneWithoutServiceHistoriesInput = {
    create?: XOR<LaunderTechnicianCreateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedCreateWithoutServiceHistoriesInput>
    connectOrCreate?: LaunderTechnicianCreateOrConnectWithoutServiceHistoriesInput
    connect?: LaunderTechnicianWhereUniqueInput
  }

  export type LaunderMachineUpdateOneRequiredWithoutServiceHistoriesNestedInput = {
    create?: XOR<LaunderMachineCreateWithoutServiceHistoriesInput, LaunderMachineUncheckedCreateWithoutServiceHistoriesInput>
    connectOrCreate?: LaunderMachineCreateOrConnectWithoutServiceHistoriesInput
    upsert?: LaunderMachineUpsertWithoutServiceHistoriesInput
    connect?: LaunderMachineWhereUniqueInput
    update?: XOR<LaunderMachineUpdateWithoutServiceHistoriesInput, LaunderMachineUncheckedUpdateWithoutServiceHistoriesInput>
  }

  export type LaunderTechnicianUpdateOneRequiredWithoutServiceHistoriesNestedInput = {
    create?: XOR<LaunderTechnicianCreateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedCreateWithoutServiceHistoriesInput>
    connectOrCreate?: LaunderTechnicianCreateOrConnectWithoutServiceHistoriesInput
    upsert?: LaunderTechnicianUpsertWithoutServiceHistoriesInput
    connect?: LaunderTechnicianWhereUniqueInput
    update?: XOR<LaunderTechnicianUpdateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedUpdateWithoutServiceHistoriesInput>
  }

  export type LaunderProgramInMachineCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutProgramInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutProgramInput>
    createMany?: LaunderProgramInMachineCreateManyProgramInputEnvelope
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
  }

  export type LaundryWashingHistoryCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutProgramInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutProgramInput>
    createMany?: LaundryWashingHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
  }

  export type LaunderProgramInMachineUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutProgramInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutProgramInput>
    createMany?: LaunderProgramInMachineCreateManyProgramInputEnvelope
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
  }

  export type LaundryWashingHistoryUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutProgramInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutProgramInput>
    createMany?: LaundryWashingHistoryCreateManyProgramInputEnvelope
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
  }

  export type LaunderProgramInMachineUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutProgramInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaunderProgramInMachineUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaunderProgramInMachineCreateManyProgramInputEnvelope
    set?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    disconnect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    delete?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    update?: Enumerable<LaunderProgramInMachineUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaunderProgramInMachineUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaunderProgramInMachineScalarWhereInput>
  }

  export type LaundryWashingHistoryUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutProgramInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryWashingHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryWashingHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    update?: Enumerable<LaundryWashingHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryWashingHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryWashingHistoryScalarWhereInput>
  }

  export type LaunderProgramInMachineUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaunderProgramInMachineCreateWithoutProgramInput>, Enumerable<LaunderProgramInMachineUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaunderProgramInMachineCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaunderProgramInMachineUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaunderProgramInMachineCreateManyProgramInputEnvelope
    set?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    disconnect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    delete?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    connect?: Enumerable<LaunderProgramInMachineWhereUniqueInput>
    update?: Enumerable<LaunderProgramInMachineUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaunderProgramInMachineUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaunderProgramInMachineScalarWhereInput>
  }

  export type LaundryWashingHistoryUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<LaundryWashingHistoryCreateWithoutProgramInput>, Enumerable<LaundryWashingHistoryUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<LaundryWashingHistoryCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<LaundryWashingHistoryUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: LaundryWashingHistoryCreateManyProgramInputEnvelope
    set?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryWashingHistoryWhereUniqueInput>
    update?: Enumerable<LaundryWashingHistoryUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<LaundryWashingHistoryUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<LaundryWashingHistoryScalarWhereInput>
  }

  export type LaundryMachineInStoreCreateNestedOneWithoutProgramInMachinesInput = {
    create?: XOR<LaundryMachineInStoreCreateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedCreateWithoutProgramInMachinesInput>
    connectOrCreate?: LaundryMachineInStoreCreateOrConnectWithoutProgramInMachinesInput
    connect?: LaundryMachineInStoreWhereUniqueInput
  }

  export type LaunderWashingProgramCreateNestedOneWithoutProgramInMachinesInput = {
    create?: XOR<LaunderWashingProgramCreateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedCreateWithoutProgramInMachinesInput>
    connectOrCreate?: LaunderWashingProgramCreateOrConnectWithoutProgramInMachinesInput
    connect?: LaunderWashingProgramWhereUniqueInput
  }

  export type LaundryMachineInStoreUpdateOneRequiredWithoutProgramInMachinesNestedInput = {
    create?: XOR<LaundryMachineInStoreCreateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedCreateWithoutProgramInMachinesInput>
    connectOrCreate?: LaundryMachineInStoreCreateOrConnectWithoutProgramInMachinesInput
    upsert?: LaundryMachineInStoreUpsertWithoutProgramInMachinesInput
    connect?: LaundryMachineInStoreWhereUniqueInput
    update?: XOR<LaundryMachineInStoreUpdateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedUpdateWithoutProgramInMachinesInput>
  }

  export type LaunderWashingProgramUpdateOneRequiredWithoutProgramInMachinesNestedInput = {
    create?: XOR<LaunderWashingProgramCreateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedCreateWithoutProgramInMachinesInput>
    connectOrCreate?: LaunderWashingProgramCreateOrConnectWithoutProgramInMachinesInput
    upsert?: LaunderWashingProgramUpsertWithoutProgramInMachinesInput
    connect?: LaunderWashingProgramWhereUniqueInput
    update?: XOR<LaunderWashingProgramUpdateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedUpdateWithoutProgramInMachinesInput>
  }

  export type LaundryTopupHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryTopupHistoryCreateWithoutUserInput>, Enumerable<LaundryTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryTopupHistoryCreateOrConnectWithoutUserInput>
    createMany?: LaundryTopupHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
  }

  export type LaundryTopupHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LaundryTopupHistoryCreateWithoutUserInput>, Enumerable<LaundryTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryTopupHistoryCreateOrConnectWithoutUserInput>
    createMany?: LaundryTopupHistoryCreateManyUserInputEnvelope
    connect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
  }

  export type LaundryTopupHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryTopupHistoryCreateWithoutUserInput>, Enumerable<LaundryTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryTopupHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryTopupHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryTopupHistoryCreateManyUserInputEnvelope
    set?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    update?: Enumerable<LaundryTopupHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryTopupHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryTopupHistoryScalarWhereInput>
  }

  export type LaundryTopupHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LaundryTopupHistoryCreateWithoutUserInput>, Enumerable<LaundryTopupHistoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LaundryTopupHistoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LaundryTopupHistoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LaundryTopupHistoryCreateManyUserInputEnvelope
    set?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    disconnect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    delete?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    connect?: Enumerable<LaundryTopupHistoryWhereUniqueInput>
    update?: Enumerable<LaundryTopupHistoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LaundryTopupHistoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LaundryTopupHistoryScalarWhereInput>
  }

  export type LaunderUserCreateNestedOneWithoutTopupHistoriesInput = {
    create?: XOR<LaunderUserCreateWithoutTopupHistoriesInput, LaunderUserUncheckedCreateWithoutTopupHistoriesInput>
    connectOrCreate?: LaunderUserCreateOrConnectWithoutTopupHistoriesInput
    connect?: LaunderUserWhereUniqueInput
  }

  export type LaunderUserUpdateOneRequiredWithoutTopupHistoriesNestedInput = {
    create?: XOR<LaunderUserCreateWithoutTopupHistoriesInput, LaunderUserUncheckedCreateWithoutTopupHistoriesInput>
    connectOrCreate?: LaunderUserCreateOrConnectWithoutTopupHistoriesInput
    upsert?: LaunderUserUpsertWithoutTopupHistoriesInput
    connect?: LaunderUserWhereUniqueInput
    update?: XOR<LaunderUserUpdateWithoutTopupHistoriesInput, LaunderUserUncheckedUpdateWithoutTopupHistoriesInput>
  }

  export type LaundryMachineInStoreCreateNestedOneWithoutWashingHistoriesInput = {
    create?: XOR<LaundryMachineInStoreCreateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedCreateWithoutWashingHistoriesInput>
    connectOrCreate?: LaundryMachineInStoreCreateOrConnectWithoutWashingHistoriesInput
    connect?: LaundryMachineInStoreWhereUniqueInput
  }

  export type LaunderWashingProgramCreateNestedOneWithoutWashingHistoriesInput = {
    create?: XOR<LaunderWashingProgramCreateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedCreateWithoutWashingHistoriesInput>
    connectOrCreate?: LaunderWashingProgramCreateOrConnectWithoutWashingHistoriesInput
    connect?: LaunderWashingProgramWhereUniqueInput
  }

  export type LaundryMachineInStoreUpdateOneRequiredWithoutWashingHistoriesNestedInput = {
    create?: XOR<LaundryMachineInStoreCreateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedCreateWithoutWashingHistoriesInput>
    connectOrCreate?: LaundryMachineInStoreCreateOrConnectWithoutWashingHistoriesInput
    upsert?: LaundryMachineInStoreUpsertWithoutWashingHistoriesInput
    connect?: LaundryMachineInStoreWhereUniqueInput
    update?: XOR<LaundryMachineInStoreUpdateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedUpdateWithoutWashingHistoriesInput>
  }

  export type LaunderWashingProgramUpdateOneRequiredWithoutWashingHistoriesNestedInput = {
    create?: XOR<LaunderWashingProgramCreateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedCreateWithoutWashingHistoriesInput>
    connectOrCreate?: LaunderWashingProgramCreateOrConnectWithoutWashingHistoriesInput
    upsert?: LaunderWashingProgramUpsertWithoutWashingHistoriesInput
    connect?: LaunderWashingProgramWhereUniqueInput
    update?: XOR<LaunderWashingProgramUpdateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedUpdateWithoutWashingHistoriesInput>
  }

  export type LibraryRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutStudentInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutStudentInput>
    createMany?: LibraryBorrowingCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutStudentInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutStudentInput>
    createMany?: LibraryBorrowingCreateManyStudentInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutStudentInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryBorrowingCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutStudentInput>, Enumerable<LibraryRequestUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryRequestCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutStudentInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: LibraryBorrowingCreateManyStudentInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryBookCopyCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutFromUniversityInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromUniversityInput>
    createMany?: LibraryRequestCreateManyFromUniversityInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutToUniversityInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToUniversityInput>
    createMany?: LibraryRequestCreateManyToUniversityInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutUniversityInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBorrowingCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutFromUniversityInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromUniversityInput>
    createMany?: LibraryRequestCreateManyFromUniversityInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutToUniversityInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToUniversityInput>
    createMany?: LibraryRequestCreateManyToUniversityInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutUniversityInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutUniversityInput>
    createMany?: LibraryBorrowingCreateManyUniversityInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryBookCopyUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutFromUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromUniversityInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutFromUniversityInput>
    createMany?: LibraryRequestCreateManyFromUniversityInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutFromUniversityInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutFromUniversityInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutToUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToUniversityInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutToUniversityInput>
    createMany?: LibraryRequestCreateManyToUniversityInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutToUniversityInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutToUniversityInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutUniversityInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBorrowingCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutUniversityInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBookCopyCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutFromUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutFromUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutFromUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutFromUniversityInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutFromUniversityInput>
    createMany?: LibraryRequestCreateManyFromUniversityInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutFromUniversityInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutFromUniversityInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutToUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutToUniversityInput>, Enumerable<LibraryRequestUncheckedCreateWithoutToUniversityInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutToUniversityInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutToUniversityInput>
    createMany?: LibraryRequestCreateManyToUniversityInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutToUniversityInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutToUniversityInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutUniversityInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutUniversityInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutUniversityInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutUniversityInput>
    createMany?: LibraryBorrowingCreateManyUniversityInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutUniversityInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutUniversityInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryBookCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutCategoryInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: LibraryBookCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
  }

  export type LibraryBookCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutCategoryInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: LibraryBookCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
  }

  export type LibraryBookCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutCategoryInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<LibraryBookCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: LibraryBookCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    delete?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    update?: Enumerable<LibraryBookCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<LibraryBookCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<LibraryBookCategoryScalarWhereInput>
  }

  export type LibraryBookCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutCategoryInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<LibraryBookCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: LibraryBookCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    delete?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    update?: Enumerable<LibraryBookCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<LibraryBookCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<LibraryBookCategoryScalarWhereInput>
  }

  export type LibraryBookAuthorCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: LibraryBookAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
  }

  export type LibraryBookAuthorUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutAuthorInput>
    createMany?: LibraryBookAuthorCreateManyAuthorInputEnvelope
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
  }

  export type LibraryBookAuthorUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<LibraryBookAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: LibraryBookAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<LibraryBookAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<LibraryBookAuthorScalarWhereInput>
  }

  export type LibraryBookAuthorUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutAuthorInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<LibraryBookAuthorUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: LibraryBookAuthorCreateManyAuthorInputEnvelope
    set?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookAuthorUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<LibraryBookAuthorUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<LibraryBookAuthorScalarWhereInput>
  }

  export type LibraryBookCategoryCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutBookInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCategoryCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
  }

  export type LibraryBookAuthorCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutBookInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookAuthorCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
  }

  export type LibraryBookCopyCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryRequestCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutBookInput>, Enumerable<LibraryRequestUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutBookInput>
    createMany?: LibraryRequestCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutBookInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutBookInput>
    createMany?: LibraryBorrowingCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutBookInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCategoryCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
  }

  export type LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutBookInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookAuthorCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
  }

  export type LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
  }

  export type LibraryRequestUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutBookInput>, Enumerable<LibraryRequestUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutBookInput>
    createMany?: LibraryRequestCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
  }

  export type LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutBookInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutBookInput>
    createMany?: LibraryBorrowingCreateManyBookInputEnvelope
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
  }

  export type LibraryBookCategoryUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutBookInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCategoryUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCategoryCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    delete?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    update?: Enumerable<LibraryBookCategoryUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCategoryUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCategoryScalarWhereInput>
  }

  export type LibraryBookAuthorUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutBookInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookAuthorUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookAuthorCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookAuthorUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookAuthorUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookAuthorScalarWhereInput>
  }

  export type LibraryBookCopyUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryRequestUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutBookInput>, Enumerable<LibraryRequestUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryRequestCreateManyBookInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutBookInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBorrowingCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCategoryCreateWithoutBookInput>, Enumerable<LibraryBookCategoryUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCategoryCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCategoryUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCategoryCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    delete?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    connect?: Enumerable<LibraryBookCategoryWhereUniqueInput>
    update?: Enumerable<LibraryBookCategoryUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCategoryUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCategoryScalarWhereInput>
  }

  export type LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookAuthorCreateWithoutBookInput>, Enumerable<LibraryBookAuthorUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookAuthorCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookAuthorUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookAuthorCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    delete?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    connect?: Enumerable<LibraryBookAuthorWhereUniqueInput>
    update?: Enumerable<LibraryBookAuthorUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookAuthorUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookAuthorScalarWhereInput>
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBookCopyCreateWithoutBookInput>, Enumerable<LibraryBookCopyUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBookCopyCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBookCopyCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBookCopyWhereUniqueInput>
    disconnect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    delete?: Enumerable<LibraryBookCopyWhereUniqueInput>
    connect?: Enumerable<LibraryBookCopyWhereUniqueInput>
    update?: Enumerable<LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBookCopyUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBookCopyScalarWhereInput>
  }

  export type LibraryRequestUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryRequestCreateWithoutBookInput>, Enumerable<LibraryRequestUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryRequestCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryRequestUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryRequestCreateManyBookInputEnvelope
    set?: Enumerable<LibraryRequestWhereUniqueInput>
    disconnect?: Enumerable<LibraryRequestWhereUniqueInput>
    delete?: Enumerable<LibraryRequestWhereUniqueInput>
    connect?: Enumerable<LibraryRequestWhereUniqueInput>
    update?: Enumerable<LibraryRequestUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryRequestUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryRequestScalarWhereInput>
  }

  export type LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<Enumerable<LibraryBorrowingCreateWithoutBookInput>, Enumerable<LibraryBorrowingUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<LibraryBorrowingCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<LibraryBorrowingUpsertWithWhereUniqueWithoutBookInput>
    createMany?: LibraryBorrowingCreateManyBookInputEnvelope
    set?: Enumerable<LibraryBorrowingWhereUniqueInput>
    disconnect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    delete?: Enumerable<LibraryBorrowingWhereUniqueInput>
    connect?: Enumerable<LibraryBorrowingWhereUniqueInput>
    update?: Enumerable<LibraryBorrowingUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<LibraryBorrowingUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<LibraryBorrowingScalarWhereInput>
  }

  export type LibraryBookCreateNestedOneWithoutBookCategoriesInput = {
    create?: XOR<LibraryBookCreateWithoutBookCategoriesInput, LibraryBookUncheckedCreateWithoutBookCategoriesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookCategoriesInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryCategoryCreateNestedOneWithoutBookCategoriesInput = {
    create?: XOR<LibraryCategoryCreateWithoutBookCategoriesInput, LibraryCategoryUncheckedCreateWithoutBookCategoriesInput>
    connectOrCreate?: LibraryCategoryCreateOrConnectWithoutBookCategoriesInput
    connect?: LibraryCategoryWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutBookCategoriesNestedInput = {
    create?: XOR<LibraryBookCreateWithoutBookCategoriesInput, LibraryBookUncheckedCreateWithoutBookCategoriesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookCategoriesInput
    upsert?: LibraryBookUpsertWithoutBookCategoriesInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutBookCategoriesInput, LibraryBookUncheckedUpdateWithoutBookCategoriesInput>
  }

  export type LibraryCategoryUpdateOneRequiredWithoutBookCategoriesNestedInput = {
    create?: XOR<LibraryCategoryCreateWithoutBookCategoriesInput, LibraryCategoryUncheckedCreateWithoutBookCategoriesInput>
    connectOrCreate?: LibraryCategoryCreateOrConnectWithoutBookCategoriesInput
    upsert?: LibraryCategoryUpsertWithoutBookCategoriesInput
    connect?: LibraryCategoryWhereUniqueInput
    update?: XOR<LibraryCategoryUpdateWithoutBookCategoriesInput, LibraryCategoryUncheckedUpdateWithoutBookCategoriesInput>
  }

  export type LibraryBookCreateNestedOneWithoutBookAuthorsInput = {
    create?: XOR<LibraryBookCreateWithoutBookAuthorsInput, LibraryBookUncheckedCreateWithoutBookAuthorsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookAuthorsInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryAuthorCreateNestedOneWithoutBookAuthorsInput = {
    create?: XOR<LibraryAuthorCreateWithoutBookAuthorsInput, LibraryAuthorUncheckedCreateWithoutBookAuthorsInput>
    connectOrCreate?: LibraryAuthorCreateOrConnectWithoutBookAuthorsInput
    connect?: LibraryAuthorWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutBookAuthorsNestedInput = {
    create?: XOR<LibraryBookCreateWithoutBookAuthorsInput, LibraryBookUncheckedCreateWithoutBookAuthorsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookAuthorsInput
    upsert?: LibraryBookUpsertWithoutBookAuthorsInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutBookAuthorsInput, LibraryBookUncheckedUpdateWithoutBookAuthorsInput>
  }

  export type LibraryAuthorUpdateOneRequiredWithoutBookAuthorsNestedInput = {
    create?: XOR<LibraryAuthorCreateWithoutBookAuthorsInput, LibraryAuthorUncheckedCreateWithoutBookAuthorsInput>
    connectOrCreate?: LibraryAuthorCreateOrConnectWithoutBookAuthorsInput
    upsert?: LibraryAuthorUpsertWithoutBookAuthorsInput
    connect?: LibraryAuthorWhereUniqueInput
    update?: XOR<LibraryAuthorUpdateWithoutBookAuthorsInput, LibraryAuthorUncheckedUpdateWithoutBookAuthorsInput>
  }

  export type LibraryBookCreateNestedOneWithoutBookCopiesInput = {
    create?: XOR<LibraryBookCreateWithoutBookCopiesInput, LibraryBookUncheckedCreateWithoutBookCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookCopiesInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutBookCopiesInput = {
    create?: XOR<LibraryUniversityCreateWithoutBookCopiesInput, LibraryUniversityUncheckedCreateWithoutBookCopiesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutBookCopiesInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutBookCopiesNestedInput = {
    create?: XOR<LibraryBookCreateWithoutBookCopiesInput, LibraryBookUncheckedCreateWithoutBookCopiesInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBookCopiesInput
    upsert?: LibraryBookUpsertWithoutBookCopiesInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutBookCopiesInput, LibraryBookUncheckedUpdateWithoutBookCopiesInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutBookCopiesNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutBookCopiesInput, LibraryUniversityUncheckedCreateWithoutBookCopiesInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutBookCopiesInput
    upsert?: LibraryUniversityUpsertWithoutBookCopiesInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutBookCopiesInput, LibraryUniversityUncheckedUpdateWithoutBookCopiesInput>
  }

  export type LibraryBookCreateNestedOneWithoutRequestsInput = {
    create?: XOR<LibraryBookCreateWithoutRequestsInput, LibraryBookUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutRequestsInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryStudentCreateNestedOneWithoutRequestsInput = {
    create?: XOR<LibraryStudentCreateWithoutRequestsInput, LibraryStudentUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutRequestsInput
    connect?: LibraryStudentWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutFromRequestsInput = {
    create?: XOR<LibraryUniversityCreateWithoutFromRequestsInput, LibraryUniversityUncheckedCreateWithoutFromRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutFromRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutToRequestsInput = {
    create?: XOR<LibraryUniversityCreateWithoutToRequestsInput, LibraryUniversityUncheckedCreateWithoutToRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutToRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<LibraryBookCreateWithoutRequestsInput, LibraryBookUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutRequestsInput
    upsert?: LibraryBookUpsertWithoutRequestsInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutRequestsInput, LibraryBookUncheckedUpdateWithoutRequestsInput>
  }

  export type LibraryStudentUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<LibraryStudentCreateWithoutRequestsInput, LibraryStudentUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutRequestsInput
    upsert?: LibraryStudentUpsertWithoutRequestsInput
    connect?: LibraryStudentWhereUniqueInput
    update?: XOR<LibraryStudentUpdateWithoutRequestsInput, LibraryStudentUncheckedUpdateWithoutRequestsInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutFromRequestsNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutFromRequestsInput, LibraryUniversityUncheckedCreateWithoutFromRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutFromRequestsInput
    upsert?: LibraryUniversityUpsertWithoutFromRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutFromRequestsInput, LibraryUniversityUncheckedUpdateWithoutFromRequestsInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutToRequestsNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutToRequestsInput, LibraryUniversityUncheckedCreateWithoutToRequestsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutToRequestsInput
    upsert?: LibraryUniversityUpsertWithoutToRequestsInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutToRequestsInput, LibraryUniversityUncheckedUpdateWithoutToRequestsInput>
  }

  export type LibraryBookCreateNestedOneWithoutBorrowingsInput = {
    create?: XOR<LibraryBookCreateWithoutBorrowingsInput, LibraryBookUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBorrowingsInput
    connect?: LibraryBookWhereUniqueInput
  }

  export type LibraryStudentCreateNestedOneWithoutBorrowingsInput = {
    create?: XOR<LibraryStudentCreateWithoutBorrowingsInput, LibraryStudentUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutBorrowingsInput
    connect?: LibraryStudentWhereUniqueInput
  }

  export type LibraryUniversityCreateNestedOneWithoutBorrowingsInput = {
    create?: XOR<LibraryUniversityCreateWithoutBorrowingsInput, LibraryUniversityUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutBorrowingsInput
    connect?: LibraryUniversityWhereUniqueInput
  }

  export type LibraryBookUpdateOneRequiredWithoutBorrowingsNestedInput = {
    create?: XOR<LibraryBookCreateWithoutBorrowingsInput, LibraryBookUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryBookCreateOrConnectWithoutBorrowingsInput
    upsert?: LibraryBookUpsertWithoutBorrowingsInput
    connect?: LibraryBookWhereUniqueInput
    update?: XOR<LibraryBookUpdateWithoutBorrowingsInput, LibraryBookUncheckedUpdateWithoutBorrowingsInput>
  }

  export type LibraryStudentUpdateOneRequiredWithoutBorrowingsNestedInput = {
    create?: XOR<LibraryStudentCreateWithoutBorrowingsInput, LibraryStudentUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryStudentCreateOrConnectWithoutBorrowingsInput
    upsert?: LibraryStudentUpsertWithoutBorrowingsInput
    connect?: LibraryStudentWhereUniqueInput
    update?: XOR<LibraryStudentUpdateWithoutBorrowingsInput, LibraryStudentUncheckedUpdateWithoutBorrowingsInput>
  }

  export type LibraryUniversityUpdateOneRequiredWithoutBorrowingsNestedInput = {
    create?: XOR<LibraryUniversityCreateWithoutBorrowingsInput, LibraryUniversityUncheckedCreateWithoutBorrowingsInput>
    connectOrCreate?: LibraryUniversityCreateOrConnectWithoutBorrowingsInput
    upsert?: LibraryUniversityUpsertWithoutBorrowingsInput
    connect?: LibraryUniversityWhereUniqueInput
    update?: XOR<LibraryUniversityUpdateWithoutBorrowingsInput, LibraryUniversityUncheckedUpdateWithoutBorrowingsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumFacebookLikeTypeEnumFilter = {
    equals?: FacebookLikeTypeEnum
    in?: Enumerable<FacebookLikeTypeEnum>
    notIn?: Enumerable<FacebookLikeTypeEnum>
    not?: NestedEnumFacebookLikeTypeEnumFilter | FacebookLikeTypeEnum
  }

  export type NestedEnumFacebookLikeTypeEnumWithAggregatesFilter = {
    equals?: FacebookLikeTypeEnum
    in?: Enumerable<FacebookLikeTypeEnum>
    notIn?: Enumerable<FacebookLikeTypeEnum>
    not?: NestedEnumFacebookLikeTypeEnumWithAggregatesFilter | FacebookLikeTypeEnum
    _count?: NestedIntFilter
    _min?: NestedEnumFacebookLikeTypeEnumFilter
    _max?: NestedEnumFacebookLikeTypeEnumFilter
  }

  export type NestedEnumReactionEnumFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumFilter | ReactionEnum
  }

  export type NestedEnumReactionEnumWithAggregatesFilter = {
    equals?: ReactionEnum
    in?: Enumerable<ReactionEnum>
    notIn?: Enumerable<ReactionEnum>
    not?: NestedEnumReactionEnumWithAggregatesFilter | ReactionEnum
    _count?: NestedIntFilter
    _min?: NestedEnumReactionEnumFilter
    _max?: NestedEnumReactionEnumFilter
  }

  export type BinKitchenMenuCreateWithoutCategoryInput = {
    name: string
    image: string
    price: number
    orderItems?: BinKitchenOrderItemCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    orderItems?: BinKitchenOrderItemUncheckedCreateNestedManyWithoutMenuInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuCreateOrConnectWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    create: XOR<BinKitchenMenuCreateWithoutCategoryInput, BinKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type BinKitchenMenuCreateManyCategoryInputEnvelope = {
    data: Enumerable<BinKitchenMenuCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenMenuUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    update: XOR<BinKitchenMenuUpdateWithoutCategoryInput, BinKitchenMenuUncheckedUpdateWithoutCategoryInput>
    create: XOR<BinKitchenMenuCreateWithoutCategoryInput, BinKitchenMenuUncheckedCreateWithoutCategoryInput>
  }

  export type BinKitchenMenuUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BinKitchenMenuWhereUniqueInput
    data: XOR<BinKitchenMenuUpdateWithoutCategoryInput, BinKitchenMenuUncheckedUpdateWithoutCategoryInput>
  }

  export type BinKitchenMenuUpdateManyWithWhereWithoutCategoryInput = {
    where: BinKitchenMenuScalarWhereInput
    data: XOR<BinKitchenMenuUpdateManyMutationInput, BinKitchenMenuUncheckedUpdateManyWithoutMenusInput>
  }

  export type BinKitchenMenuScalarWhereInput = {
    AND?: Enumerable<BinKitchenMenuScalarWhereInput>
    OR?: Enumerable<BinKitchenMenuScalarWhereInput>
    NOT?: Enumerable<BinKitchenMenuScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    image?: StringFilter | string
    price?: FloatFilter | number
    categoryName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenCategoryCreateWithoutMenusInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryUncheckedCreateWithoutMenusInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenCategoryCreateOrConnectWithoutMenusInput = {
    where: BinKitchenCategoryWhereUniqueInput
    create: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type BinKitchenOrderItemCreateWithoutMenuInput = {
    order?: BinKitchenOrderCreateNestedOneWithoutItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateWithoutMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemCreateOrConnectWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    create: XOR<BinKitchenOrderItemCreateWithoutMenuInput, BinKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type BinKitchenOrderItemCreateManyMenuInputEnvelope = {
    data: Enumerable<BinKitchenOrderItemCreateManyMenuInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenCategoryUpsertWithoutMenusInput = {
    update: XOR<BinKitchenCategoryUpdateWithoutMenusInput, BinKitchenCategoryUncheckedUpdateWithoutMenusInput>
    create: XOR<BinKitchenCategoryCreateWithoutMenusInput, BinKitchenCategoryUncheckedCreateWithoutMenusInput>
  }

  export type BinKitchenCategoryUpdateWithoutMenusInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenCategoryUncheckedUpdateWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    update: XOR<BinKitchenOrderItemUpdateWithoutMenuInput, BinKitchenOrderItemUncheckedUpdateWithoutMenuInput>
    create: XOR<BinKitchenOrderItemCreateWithoutMenuInput, BinKitchenOrderItemUncheckedCreateWithoutMenuInput>
  }

  export type BinKitchenOrderItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    data: XOR<BinKitchenOrderItemUpdateWithoutMenuInput, BinKitchenOrderItemUncheckedUpdateWithoutMenuInput>
  }

  export type BinKitchenOrderItemUpdateManyWithWhereWithoutMenuInput = {
    where: BinKitchenOrderItemScalarWhereInput
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type BinKitchenOrderItemScalarWhereInput = {
    AND?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    OR?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    NOT?: Enumerable<BinKitchenOrderItemScalarWhereInput>
    id?: IntFilter | number
    menuId?: IntFilter | number
    orderId?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    totalPrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BinKitchenOrderItemCreateWithoutOrderInput = {
    menu: BinKitchenMenuCreateNestedOneWithoutOrderItemsInput
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemCreateOrConnectWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    create: XOR<BinKitchenOrderItemCreateWithoutOrderInput, BinKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BinKitchenOrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<BinKitchenOrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type BinKitchenOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    update: XOR<BinKitchenOrderItemUpdateWithoutOrderInput, BinKitchenOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<BinKitchenOrderItemCreateWithoutOrderInput, BinKitchenOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type BinKitchenOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: BinKitchenOrderItemWhereUniqueInput
    data: XOR<BinKitchenOrderItemUpdateWithoutOrderInput, BinKitchenOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type BinKitchenOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: BinKitchenOrderItemScalarWhereInput
    data: XOR<BinKitchenOrderItemUpdateManyMutationInput, BinKitchenOrderItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type BinKitchenMenuCreateWithoutOrderItemsInput = {
    name: string
    image: string
    price: number
    category?: BinKitchenCategoryCreateNestedOneWithoutMenusInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    image: string
    price: number
    categoryName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuCreateOrConnectWithoutOrderItemsInput = {
    where: BinKitchenMenuWhereUniqueInput
    create: XOR<BinKitchenMenuCreateWithoutOrderItemsInput, BinKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type BinKitchenOrderCreateWithoutItemsInput = {
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    status?: string
    tableId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderCreateOrConnectWithoutItemsInput = {
    where: BinKitchenOrderWhereUniqueInput
    create: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenMenuUpsertWithoutOrderItemsInput = {
    update: XOR<BinKitchenMenuUpdateWithoutOrderItemsInput, BinKitchenMenuUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<BinKitchenMenuCreateWithoutOrderItemsInput, BinKitchenMenuUncheckedCreateWithoutOrderItemsInput>
  }

  export type BinKitchenMenuUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    category?: BinKitchenCategoryUpdateOneWithoutMenusNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUpsertWithoutItemsInput = {
    update: XOR<BinKitchenOrderUpdateWithoutItemsInput, BinKitchenOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<BinKitchenOrderCreateWithoutItemsInput, BinKitchenOrderUncheckedCreateWithoutItemsInput>
  }

  export type BinKitchenOrderUpdateWithoutItemsInput = {
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateWithoutCategoryInput = {
    questName: string
    answer: QuizChoiceCreateNestedOneWithoutQuestionAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutCategoryInput = {
    id?: number
    questName: string
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutCategoryInput, QuizQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuizQuestionCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizQuestionCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizRoundCreateWithoutCategoryInput = {
    user: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizRoundQuestionCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundUncheckedCreateWithoutCategoryInput = {
    id?: number
    user: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutRoundInput
  }

  export type QuizRoundCreateOrConnectWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    create: XOR<QuizRoundCreateWithoutCategoryInput, QuizRoundUncheckedCreateWithoutCategoryInput>
  }

  export type QuizRoundCreateManyCategoryInputEnvelope = {
    data: Enumerable<QuizRoundCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutCategoryInput, QuizQuestionUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizQuestionCreateWithoutCategoryInput, QuizQuestionUncheckedCreateWithoutCategoryInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutCategoryInput, QuizQuestionUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: Enumerable<QuizQuestionScalarWhereInput>
    OR?: Enumerable<QuizQuestionScalarWhereInput>
    NOT?: Enumerable<QuizQuestionScalarWhereInput>
    id?: IntFilter | number
    questName?: StringFilter | string
    categoryId?: IntFilter | number
    answerChoiceId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRoundUpsertWithWhereUniqueWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    update: XOR<QuizRoundUpdateWithoutCategoryInput, QuizRoundUncheckedUpdateWithoutCategoryInput>
    create: XOR<QuizRoundCreateWithoutCategoryInput, QuizRoundUncheckedCreateWithoutCategoryInput>
  }

  export type QuizRoundUpdateWithWhereUniqueWithoutCategoryInput = {
    where: QuizRoundWhereUniqueInput
    data: XOR<QuizRoundUpdateWithoutCategoryInput, QuizRoundUncheckedUpdateWithoutCategoryInput>
  }

  export type QuizRoundUpdateManyWithWhereWithoutCategoryInput = {
    where: QuizRoundScalarWhereInput
    data: XOR<QuizRoundUpdateManyMutationInput, QuizRoundUncheckedUpdateManyWithoutRoundsInput>
  }

  export type QuizRoundScalarWhereInput = {
    AND?: Enumerable<QuizRoundScalarWhereInput>
    OR?: Enumerable<QuizRoundScalarWhereInput>
    NOT?: Enumerable<QuizRoundScalarWhereInput>
    id?: IntFilter | number
    user?: StringFilter | string
    categoryId?: IntFilter | number
    score?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizCategoryCreateWithoutQuestionsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: QuizRoundCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rounds?: QuizRoundUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryCreateOrConnectWithoutQuestionsInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutQuestionsInput, QuizCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizChoiceCreateWithoutQuestionAnswerInput = {
    choiceName: string
    questione?: QuizQuestionCreateNestedOneWithoutChoicesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    choiceName: string
    questionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceCreateOrConnectWithoutQuestionAnswerInput = {
    where: QuizChoiceWhereUniqueInput
    create: XOR<QuizChoiceCreateWithoutQuestionAnswerInput, QuizChoiceUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type QuizChoiceCreateWithoutQuestioneInput = {
    choiceName: string
    questionAnswer?: QuizQuestionCreateNestedOneWithoutAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUncheckedCreateWithoutQuestioneInput = {
    id?: number
    choiceName: string
    questionAnswer?: QuizQuestionUncheckedCreateNestedOneWithoutAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceCreateOrConnectWithoutQuestioneInput = {
    where: QuizChoiceWhereUniqueInput
    create: XOR<QuizChoiceCreateWithoutQuestioneInput, QuizChoiceUncheckedCreateWithoutQuestioneInput>
  }

  export type QuizChoiceCreateManyQuestioneInputEnvelope = {
    data: Enumerable<QuizChoiceCreateManyQuestioneInput>
    skipDuplicates?: boolean
  }

  export type QuizRoundQuestionCreateWithoutQuestionInput = {
    userChoiceId: number
    round: QuizRoundCreateNestedOneWithoutQuestionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUncheckedCreateWithoutQuestionInput = {
    id?: number
    userChoiceId: number
    roundId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionCreateOrConnectWithoutQuestionInput = {
    where: QuizRoundQuestionWhereUniqueInput
    create: XOR<QuizRoundQuestionCreateWithoutQuestionInput, QuizRoundQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizRoundQuestionCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuizRoundQuestionCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuizCategoryUpsertWithoutQuestionsInput = {
    update: XOR<QuizCategoryUpdateWithoutQuestionsInput, QuizCategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCategoryCreateWithoutQuestionsInput, QuizCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizCategoryUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: QuizRoundUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rounds?: QuizRoundUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizChoiceUpsertWithoutQuestionAnswerInput = {
    update: XOR<QuizChoiceUpdateWithoutQuestionAnswerInput, QuizChoiceUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<QuizChoiceCreateWithoutQuestionAnswerInput, QuizChoiceUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type QuizChoiceUpdateWithoutQuestionAnswerInput = {
    choiceName?: StringFieldUpdateOperationsInput | string
    questione?: QuizQuestionUpdateOneWithoutChoicesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceName?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUpsertWithWhereUniqueWithoutQuestioneInput = {
    where: QuizChoiceWhereUniqueInput
    update: XOR<QuizChoiceUpdateWithoutQuestioneInput, QuizChoiceUncheckedUpdateWithoutQuestioneInput>
    create: XOR<QuizChoiceCreateWithoutQuestioneInput, QuizChoiceUncheckedCreateWithoutQuestioneInput>
  }

  export type QuizChoiceUpdateWithWhereUniqueWithoutQuestioneInput = {
    where: QuizChoiceWhereUniqueInput
    data: XOR<QuizChoiceUpdateWithoutQuestioneInput, QuizChoiceUncheckedUpdateWithoutQuestioneInput>
  }

  export type QuizChoiceUpdateManyWithWhereWithoutQuestioneInput = {
    where: QuizChoiceScalarWhereInput
    data: XOR<QuizChoiceUpdateManyMutationInput, QuizChoiceUncheckedUpdateManyWithoutChoicesInput>
  }

  export type QuizChoiceScalarWhereInput = {
    AND?: Enumerable<QuizChoiceScalarWhereInput>
    OR?: Enumerable<QuizChoiceScalarWhereInput>
    NOT?: Enumerable<QuizChoiceScalarWhereInput>
    id?: IntFilter | number
    choiceName?: StringFilter | string
    questionId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizRoundQuestionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizRoundQuestionWhereUniqueInput
    update: XOR<QuizRoundQuestionUpdateWithoutQuestionInput, QuizRoundQuestionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizRoundQuestionCreateWithoutQuestionInput, QuizRoundQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizRoundQuestionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizRoundQuestionWhereUniqueInput
    data: XOR<QuizRoundQuestionUpdateWithoutQuestionInput, QuizRoundQuestionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizRoundQuestionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizRoundQuestionScalarWhereInput
    data: XOR<QuizRoundQuestionUpdateManyMutationInput, QuizRoundQuestionUncheckedUpdateManyWithoutRoundQuestionsInput>
  }

  export type QuizRoundQuestionScalarWhereInput = {
    AND?: Enumerable<QuizRoundQuestionScalarWhereInput>
    OR?: Enumerable<QuizRoundQuestionScalarWhereInput>
    NOT?: Enumerable<QuizRoundQuestionScalarWhereInput>
    id?: IntFilter | number
    userChoiceId?: IntFilter | number
    questionId?: IntFilter | number
    roundId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuizQuestionCreateWithoutChoicesInput = {
    questName: string
    category: QuizCategoryCreateNestedOneWithoutQuestionsInput
    answer: QuizChoiceCreateNestedOneWithoutQuestionAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
    roundQuestions?: QuizRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutChoicesInput = {
    id?: number
    questName: string
    categoryId: number
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    roundQuestions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutChoicesInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutChoicesInput, QuizQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type QuizQuestionCreateWithoutAnswerInput = {
    questName: string
    category: QuizCategoryCreateNestedOneWithoutQuestionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutAnswerInput = {
    id?: number
    questName: string
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestioneInput
    roundQuestions?: QuizRoundQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutAnswerInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
  }

  export type QuizQuestionUpsertWithoutChoicesInput = {
    update: XOR<QuizQuestionUpdateWithoutChoicesInput, QuizQuestionUncheckedUpdateWithoutChoicesInput>
    create: XOR<QuizQuestionCreateWithoutChoicesInput, QuizQuestionUncheckedCreateWithoutChoicesInput>
  }

  export type QuizQuestionUpdateWithoutChoicesInput = {
    questName?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    answer?: QuizChoiceUpdateOneRequiredWithoutQuestionAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roundQuestions?: QuizRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roundQuestions?: QuizRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUpsertWithoutAnswerInput = {
    update: XOR<QuizQuestionUpdateWithoutAnswerInput, QuizQuestionUncheckedUpdateWithoutAnswerInput>
    create: XOR<QuizQuestionCreateWithoutAnswerInput, QuizQuestionUncheckedCreateWithoutAnswerInput>
  }

  export type QuizQuestionUpdateWithoutAnswerInput = {
    questName?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUncheckedUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateWithoutRoundQuestionsInput = {
    questName: string
    category: QuizCategoryCreateNestedOneWithoutQuestionsInput
    answer: QuizChoiceCreateNestedOneWithoutQuestionAnswerInput
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceCreateNestedManyWithoutQuestioneInput
  }

  export type QuizQuestionUncheckedCreateWithoutRoundQuestionsInput = {
    id?: number
    questName: string
    categoryId: number
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    choices?: QuizChoiceUncheckedCreateNestedManyWithoutQuestioneInput
  }

  export type QuizQuestionCreateOrConnectWithoutRoundQuestionsInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutRoundQuestionsInput, QuizQuestionUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type QuizRoundCreateWithoutQuestionsInput = {
    user: string
    category: QuizCategoryCreateNestedOneWithoutRoundsInput
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundUncheckedCreateWithoutQuestionsInput = {
    id?: number
    user: string
    categoryId: number
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundCreateOrConnectWithoutQuestionsInput = {
    where: QuizRoundWhereUniqueInput
    create: XOR<QuizRoundCreateWithoutQuestionsInput, QuizRoundUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizQuestionUpsertWithoutRoundQuestionsInput = {
    update: XOR<QuizQuestionUpdateWithoutRoundQuestionsInput, QuizQuestionUncheckedUpdateWithoutRoundQuestionsInput>
    create: XOR<QuizQuestionCreateWithoutRoundQuestionsInput, QuizQuestionUncheckedCreateWithoutRoundQuestionsInput>
  }

  export type QuizQuestionUpdateWithoutRoundQuestionsInput = {
    questName?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    answer?: QuizChoiceUpdateOneRequiredWithoutQuestionAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUpdateManyWithoutQuestioneNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutRoundQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUncheckedUpdateManyWithoutQuestioneNestedInput
  }

  export type QuizRoundUpsertWithoutQuestionsInput = {
    update: XOR<QuizRoundUpdateWithoutQuestionsInput, QuizRoundUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizRoundCreateWithoutQuestionsInput, QuizRoundUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizRoundUpdateWithoutQuestionsInput = {
    user?: StringFieldUpdateOperationsInput | string
    category?: QuizCategoryUpdateOneRequiredWithoutRoundsNestedInput
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCategoryCreateWithoutRoundsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryUncheckedCreateWithoutRoundsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type QuizCategoryCreateOrConnectWithoutRoundsInput = {
    where: QuizCategoryWhereUniqueInput
    create: XOR<QuizCategoryCreateWithoutRoundsInput, QuizCategoryUncheckedCreateWithoutRoundsInput>
  }

  export type QuizRoundQuestionCreateWithoutRoundInput = {
    userChoiceId: number
    question: QuizQuestionCreateNestedOneWithoutRoundQuestionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUncheckedCreateWithoutRoundInput = {
    id?: number
    userChoiceId: number
    questionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionCreateOrConnectWithoutRoundInput = {
    where: QuizRoundQuestionWhereUniqueInput
    create: XOR<QuizRoundQuestionCreateWithoutRoundInput, QuizRoundQuestionUncheckedCreateWithoutRoundInput>
  }

  export type QuizRoundQuestionCreateManyRoundInputEnvelope = {
    data: Enumerable<QuizRoundQuestionCreateManyRoundInput>
    skipDuplicates?: boolean
  }

  export type QuizCategoryUpsertWithoutRoundsInput = {
    update: XOR<QuizCategoryUpdateWithoutRoundsInput, QuizCategoryUncheckedUpdateWithoutRoundsInput>
    create: XOR<QuizCategoryCreateWithoutRoundsInput, QuizCategoryUncheckedCreateWithoutRoundsInput>
  }

  export type QuizCategoryUpdateWithoutRoundsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutCategoryNestedInput
  }

  export type QuizCategoryUncheckedUpdateWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type QuizRoundQuestionUpsertWithWhereUniqueWithoutRoundInput = {
    where: QuizRoundQuestionWhereUniqueInput
    update: XOR<QuizRoundQuestionUpdateWithoutRoundInput, QuizRoundQuestionUncheckedUpdateWithoutRoundInput>
    create: XOR<QuizRoundQuestionCreateWithoutRoundInput, QuizRoundQuestionUncheckedCreateWithoutRoundInput>
  }

  export type QuizRoundQuestionUpdateWithWhereUniqueWithoutRoundInput = {
    where: QuizRoundQuestionWhereUniqueInput
    data: XOR<QuizRoundQuestionUpdateWithoutRoundInput, QuizRoundQuestionUncheckedUpdateWithoutRoundInput>
  }

  export type QuizRoundQuestionUpdateManyWithWhereWithoutRoundInput = {
    where: QuizRoundQuestionScalarWhereInput
    data: XOR<QuizRoundQuestionUpdateManyMutationInput, QuizRoundQuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type FacebookUserRelationshipCreateWithoutFromInput = {
    to: FacebookUserCreateNestedOneWithoutToInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipCreateOrConnectWithoutFromInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    create: XOR<FacebookUserRelationshipCreateWithoutFromInput, FacebookUserRelationshipUncheckedCreateWithoutFromInput>
  }

  export type FacebookUserRelationshipCreateManyFromInputEnvelope = {
    data: Enumerable<FacebookUserRelationshipCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationshipCreateWithoutToInput = {
    from: FacebookUserCreateNestedOneWithoutFromInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipCreateOrConnectWithoutToInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    create: XOR<FacebookUserRelationshipCreateWithoutToInput, FacebookUserRelationshipUncheckedCreateWithoutToInput>
  }

  export type FacebookUserRelationshipCreateManyToInputEnvelope = {
    data: Enumerable<FacebookUserRelationshipCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserInGroupCreateWithoutUserInput = {
    group: FacebookGroupCreateNestedOneWithoutUserInGroupsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUncheckedCreateWithoutUserInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupCreateOrConnectWithoutUserInput = {
    where: FacebookUserInGroupWhereUniqueInput
    create: XOR<FacebookUserInGroupCreateWithoutUserInput, FacebookUserInGroupUncheckedCreateWithoutUserInput>
  }

  export type FacebookUserInGroupCreateManyUserInputEnvelope = {
    data: Enumerable<FacebookUserInGroupCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostCreateWithoutUserInput = {
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutUserInput = {
    id?: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutUserInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutUserInput, FacebookPostUncheckedCreateWithoutUserInput>
  }

  export type FacebookPostCreateManyUserInputEnvelope = {
    data: Enumerable<FacebookPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookDirectMessageCreateWithoutFromInput = {
    to: FacebookUserCreateNestedOneWithoutDirectMessageToInput
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageCreateOrConnectWithoutFromInput = {
    where: FacebookDirectMessageWhereUniqueInput
    create: XOR<FacebookDirectMessageCreateWithoutFromInput, FacebookDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type FacebookDirectMessageCreateManyFromInputEnvelope = {
    data: Enumerable<FacebookDirectMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type FacebookDirectMessageCreateWithoutToInput = {
    from: FacebookUserCreateNestedOneWithoutDirectMessageFromInput
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageCreateOrConnectWithoutToInput = {
    where: FacebookDirectMessageWhereUniqueInput
    create: XOR<FacebookDirectMessageCreateWithoutToInput, FacebookDirectMessageUncheckedCreateWithoutToInput>
  }

  export type FacebookDirectMessageCreateManyToInputEnvelope = {
    data: Enumerable<FacebookDirectMessageCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type FacebookCommentPostCreateWithoutUserInput = {
    post: FacebookPostCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    commentTo?: FacebookCommentPostCreateNestedOneWithoutCommentPostsInput
    share: FacebookShareTypeCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostCreateOrConnectWithoutUserInput = {
    where: FacebookCommentPostWhereUniqueInput
    create: XOR<FacebookCommentPostCreateWithoutUserInput, FacebookCommentPostUncheckedCreateWithoutUserInput>
  }

  export type FacebookCommentPostCreateManyUserInputEnvelope = {
    data: Enumerable<FacebookCommentPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookLikeCreateWithoutUserInput = {
    type: FacebookLikeTypeEnum
    posts?: FacebookPostCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUncheckedCreateWithoutUserInput = {
    id?: number
    type: FacebookLikeTypeEnum
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeCreateOrConnectWithoutUserInput = {
    where: FacebookLikeWhereUniqueInput
    create: XOR<FacebookLikeCreateWithoutUserInput, FacebookLikeUncheckedCreateWithoutUserInput>
  }

  export type FacebookLikeCreateManyUserInputEnvelope = {
    data: Enumerable<FacebookLikeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostDestinationCreateWithoutUserWallInput = {
    type: string
    group?: FacebookGroupCreateNestedOneWithoutPostDestinationsInput
    post?: FacebookPostCreateNestedOneWithoutPostDestionationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUncheckedCreateWithoutUserWallInput = {
    id?: number
    type: string
    groupId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateOrConnectWithoutUserWallInput = {
    where: FacebookPostDestinationWhereUniqueInput
    create: XOR<FacebookPostDestinationCreateWithoutUserWallInput, FacebookPostDestinationUncheckedCreateWithoutUserWallInput>
  }

  export type FacebookPostDestinationCreateManyUserWallInputEnvelope = {
    data: Enumerable<FacebookPostDestinationCreateManyUserWallInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserRelationshipUpsertWithWhereUniqueWithoutFromInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    update: XOR<FacebookUserRelationshipUpdateWithoutFromInput, FacebookUserRelationshipUncheckedUpdateWithoutFromInput>
    create: XOR<FacebookUserRelationshipCreateWithoutFromInput, FacebookUserRelationshipUncheckedCreateWithoutFromInput>
  }

  export type FacebookUserRelationshipUpdateWithWhereUniqueWithoutFromInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    data: XOR<FacebookUserRelationshipUpdateWithoutFromInput, FacebookUserRelationshipUncheckedUpdateWithoutFromInput>
  }

  export type FacebookUserRelationshipUpdateManyWithWhereWithoutFromInput = {
    where: FacebookUserRelationshipScalarWhereInput
    data: XOR<FacebookUserRelationshipUpdateManyMutationInput, FacebookUserRelationshipUncheckedUpdateManyWithoutFromInput>
  }

  export type FacebookUserRelationshipScalarWhereInput = {
    AND?: Enumerable<FacebookUserRelationshipScalarWhereInput>
    OR?: Enumerable<FacebookUserRelationshipScalarWhereInput>
    NOT?: Enumerable<FacebookUserRelationshipScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserRelationshipUpsertWithWhereUniqueWithoutToInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    update: XOR<FacebookUserRelationshipUpdateWithoutToInput, FacebookUserRelationshipUncheckedUpdateWithoutToInput>
    create: XOR<FacebookUserRelationshipCreateWithoutToInput, FacebookUserRelationshipUncheckedCreateWithoutToInput>
  }

  export type FacebookUserRelationshipUpdateWithWhereUniqueWithoutToInput = {
    where: FacebookUserRelationshipWhereUniqueInput
    data: XOR<FacebookUserRelationshipUpdateWithoutToInput, FacebookUserRelationshipUncheckedUpdateWithoutToInput>
  }

  export type FacebookUserRelationshipUpdateManyWithWhereWithoutToInput = {
    where: FacebookUserRelationshipScalarWhereInput
    data: XOR<FacebookUserRelationshipUpdateManyMutationInput, FacebookUserRelationshipUncheckedUpdateManyWithoutToInput>
  }

  export type FacebookUserInGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: FacebookUserInGroupWhereUniqueInput
    update: XOR<FacebookUserInGroupUpdateWithoutUserInput, FacebookUserInGroupUncheckedUpdateWithoutUserInput>
    create: XOR<FacebookUserInGroupCreateWithoutUserInput, FacebookUserInGroupUncheckedCreateWithoutUserInput>
  }

  export type FacebookUserInGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: FacebookUserInGroupWhereUniqueInput
    data: XOR<FacebookUserInGroupUpdateWithoutUserInput, FacebookUserInGroupUncheckedUpdateWithoutUserInput>
  }

  export type FacebookUserInGroupUpdateManyWithWhereWithoutUserInput = {
    where: FacebookUserInGroupScalarWhereInput
    data: XOR<FacebookUserInGroupUpdateManyMutationInput, FacebookUserInGroupUncheckedUpdateManyWithoutUserInGroupsInput>
  }

  export type FacebookUserInGroupScalarWhereInput = {
    AND?: Enumerable<FacebookUserInGroupScalarWhereInput>
    OR?: Enumerable<FacebookUserInGroupScalarWhereInput>
    NOT?: Enumerable<FacebookUserInGroupScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    groupId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookPostUpsertWithWhereUniqueWithoutUserInput = {
    where: FacebookPostWhereUniqueInput
    update: XOR<FacebookPostUpdateWithoutUserInput, FacebookPostUncheckedUpdateWithoutUserInput>
    create: XOR<FacebookPostCreateWithoutUserInput, FacebookPostUncheckedCreateWithoutUserInput>
  }

  export type FacebookPostUpdateWithWhereUniqueWithoutUserInput = {
    where: FacebookPostWhereUniqueInput
    data: XOR<FacebookPostUpdateWithoutUserInput, FacebookPostUncheckedUpdateWithoutUserInput>
  }

  export type FacebookPostUpdateManyWithWhereWithoutUserInput = {
    where: FacebookPostScalarWhereInput
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FacebookPostScalarWhereInput = {
    AND?: Enumerable<FacebookPostScalarWhereInput>
    OR?: Enumerable<FacebookPostScalarWhereInput>
    NOT?: Enumerable<FacebookPostScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    message?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    locationId?: IntFilter | number
    hashtagId?: IntFilter | number
    shareToId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookDirectMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: FacebookDirectMessageWhereUniqueInput
    update: XOR<FacebookDirectMessageUpdateWithoutFromInput, FacebookDirectMessageUncheckedUpdateWithoutFromInput>
    create: XOR<FacebookDirectMessageCreateWithoutFromInput, FacebookDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type FacebookDirectMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: FacebookDirectMessageWhereUniqueInput
    data: XOR<FacebookDirectMessageUpdateWithoutFromInput, FacebookDirectMessageUncheckedUpdateWithoutFromInput>
  }

  export type FacebookDirectMessageUpdateManyWithWhereWithoutFromInput = {
    where: FacebookDirectMessageScalarWhereInput
    data: XOR<FacebookDirectMessageUpdateManyMutationInput, FacebookDirectMessageUncheckedUpdateManyWithoutDirectMessageFromInput>
  }

  export type FacebookDirectMessageScalarWhereInput = {
    AND?: Enumerable<FacebookDirectMessageScalarWhereInput>
    OR?: Enumerable<FacebookDirectMessageScalarWhereInput>
    NOT?: Enumerable<FacebookDirectMessageScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    readStatus?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookDirectMessageUpsertWithWhereUniqueWithoutToInput = {
    where: FacebookDirectMessageWhereUniqueInput
    update: XOR<FacebookDirectMessageUpdateWithoutToInput, FacebookDirectMessageUncheckedUpdateWithoutToInput>
    create: XOR<FacebookDirectMessageCreateWithoutToInput, FacebookDirectMessageUncheckedCreateWithoutToInput>
  }

  export type FacebookDirectMessageUpdateWithWhereUniqueWithoutToInput = {
    where: FacebookDirectMessageWhereUniqueInput
    data: XOR<FacebookDirectMessageUpdateWithoutToInput, FacebookDirectMessageUncheckedUpdateWithoutToInput>
  }

  export type FacebookDirectMessageUpdateManyWithWhereWithoutToInput = {
    where: FacebookDirectMessageScalarWhereInput
    data: XOR<FacebookDirectMessageUpdateManyMutationInput, FacebookDirectMessageUncheckedUpdateManyWithoutDirectMessageToInput>
  }

  export type FacebookCommentPostUpsertWithWhereUniqueWithoutUserInput = {
    where: FacebookCommentPostWhereUniqueInput
    update: XOR<FacebookCommentPostUpdateWithoutUserInput, FacebookCommentPostUncheckedUpdateWithoutUserInput>
    create: XOR<FacebookCommentPostCreateWithoutUserInput, FacebookCommentPostUncheckedCreateWithoutUserInput>
  }

  export type FacebookCommentPostUpdateWithWhereUniqueWithoutUserInput = {
    where: FacebookCommentPostWhereUniqueInput
    data: XOR<FacebookCommentPostUpdateWithoutUserInput, FacebookCommentPostUncheckedUpdateWithoutUserInput>
  }

  export type FacebookCommentPostUpdateManyWithWhereWithoutUserInput = {
    where: FacebookCommentPostScalarWhereInput
    data: XOR<FacebookCommentPostUpdateManyMutationInput, FacebookCommentPostUncheckedUpdateManyWithoutCommentPostsInput>
  }

  export type FacebookCommentPostScalarWhereInput = {
    AND?: Enumerable<FacebookCommentPostScalarWhereInput>
    OR?: Enumerable<FacebookCommentPostScalarWhereInput>
    NOT?: Enumerable<FacebookCommentPostScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    userId?: IntFilter | number
    message?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    commentToId?: IntNullableFilter | number | null
    shareToId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: FacebookLikeWhereUniqueInput
    update: XOR<FacebookLikeUpdateWithoutUserInput, FacebookLikeUncheckedUpdateWithoutUserInput>
    create: XOR<FacebookLikeCreateWithoutUserInput, FacebookLikeUncheckedCreateWithoutUserInput>
  }

  export type FacebookLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: FacebookLikeWhereUniqueInput
    data: XOR<FacebookLikeUpdateWithoutUserInput, FacebookLikeUncheckedUpdateWithoutUserInput>
  }

  export type FacebookLikeUpdateManyWithWhereWithoutUserInput = {
    where: FacebookLikeScalarWhereInput
    data: XOR<FacebookLikeUpdateManyMutationInput, FacebookLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type FacebookLikeScalarWhereInput = {
    AND?: Enumerable<FacebookLikeScalarWhereInput>
    OR?: Enumerable<FacebookLikeScalarWhereInput>
    NOT?: Enumerable<FacebookLikeScalarWhereInput>
    id?: IntFilter | number
    type?: EnumFacebookLikeTypeEnumFilter | FacebookLikeTypeEnum
    userId?: IntFilter | number
    postId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookPostDestinationUpsertWithWhereUniqueWithoutUserWallInput = {
    where: FacebookPostDestinationWhereUniqueInput
    update: XOR<FacebookPostDestinationUpdateWithoutUserWallInput, FacebookPostDestinationUncheckedUpdateWithoutUserWallInput>
    create: XOR<FacebookPostDestinationCreateWithoutUserWallInput, FacebookPostDestinationUncheckedCreateWithoutUserWallInput>
  }

  export type FacebookPostDestinationUpdateWithWhereUniqueWithoutUserWallInput = {
    where: FacebookPostDestinationWhereUniqueInput
    data: XOR<FacebookPostDestinationUpdateWithoutUserWallInput, FacebookPostDestinationUncheckedUpdateWithoutUserWallInput>
  }

  export type FacebookPostDestinationUpdateManyWithWhereWithoutUserWallInput = {
    where: FacebookPostDestinationScalarWhereInput
    data: XOR<FacebookPostDestinationUpdateManyMutationInput, FacebookPostDestinationUncheckedUpdateManyWithoutPostDestinationsInput>
  }

  export type FacebookPostDestinationScalarWhereInput = {
    AND?: Enumerable<FacebookPostDestinationScalarWhereInput>
    OR?: Enumerable<FacebookPostDestinationScalarWhereInput>
    NOT?: Enumerable<FacebookPostDestinationScalarWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    userId?: IntFilter | number
    groupId?: IntFilter | number
    postId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FacebookUserCreateWithoutFromInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutFromInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutFromInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutFromInput, FacebookUserUncheckedCreateWithoutFromInput>
  }

  export type FacebookUserCreateWithoutToInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutToInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutToInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutToInput, FacebookUserUncheckedCreateWithoutToInput>
  }

  export type FacebookUserUpsertWithoutFromInput = {
    update: XOR<FacebookUserUpdateWithoutFromInput, FacebookUserUncheckedUpdateWithoutFromInput>
    create: XOR<FacebookUserCreateWithoutFromInput, FacebookUserUncheckedCreateWithoutFromInput>
  }

  export type FacebookUserUpdateWithoutFromInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUpsertWithoutToInput = {
    update: XOR<FacebookUserUpdateWithoutToInput, FacebookUserUncheckedUpdateWithoutToInput>
    create: XOR<FacebookUserCreateWithoutToInput, FacebookUserUncheckedCreateWithoutToInput>
  }

  export type FacebookUserUpdateWithoutToInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserCreateWithoutDirectMessageFromInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutDirectMessageFromInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutDirectMessageFromInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutDirectMessageFromInput, FacebookUserUncheckedCreateWithoutDirectMessageFromInput>
  }

  export type FacebookUserCreateWithoutDirectMessageToInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutDirectMessageToInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutDirectMessageToInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutDirectMessageToInput, FacebookUserUncheckedCreateWithoutDirectMessageToInput>
  }

  export type FacebookUserUpsertWithoutDirectMessageFromInput = {
    update: XOR<FacebookUserUpdateWithoutDirectMessageFromInput, FacebookUserUncheckedUpdateWithoutDirectMessageFromInput>
    create: XOR<FacebookUserCreateWithoutDirectMessageFromInput, FacebookUserUncheckedCreateWithoutDirectMessageFromInput>
  }

  export type FacebookUserUpdateWithoutDirectMessageFromInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutDirectMessageFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUpsertWithoutDirectMessageToInput = {
    update: XOR<FacebookUserUpdateWithoutDirectMessageToInput, FacebookUserUncheckedUpdateWithoutDirectMessageToInput>
    create: XOR<FacebookUserCreateWithoutDirectMessageToInput, FacebookUserUncheckedCreateWithoutDirectMessageToInput>
  }

  export type FacebookUserUpdateWithoutDirectMessageToInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutDirectMessageToInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookPostCreateWithoutLocationInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutLocationInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutLocationInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutLocationInput, FacebookPostUncheckedCreateWithoutLocationInput>
  }

  export type FacebookPostCreateManyLocationInputEnvelope = {
    data: Enumerable<FacebookPostCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostUpsertWithWhereUniqueWithoutLocationInput = {
    where: FacebookPostWhereUniqueInput
    update: XOR<FacebookPostUpdateWithoutLocationInput, FacebookPostUncheckedUpdateWithoutLocationInput>
    create: XOR<FacebookPostCreateWithoutLocationInput, FacebookPostUncheckedCreateWithoutLocationInput>
  }

  export type FacebookPostUpdateWithWhereUniqueWithoutLocationInput = {
    where: FacebookPostWhereUniqueInput
    data: XOR<FacebookPostUpdateWithoutLocationInput, FacebookPostUncheckedUpdateWithoutLocationInput>
  }

  export type FacebookPostUpdateManyWithWhereWithoutLocationInput = {
    where: FacebookPostScalarWhereInput
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FacebookPostCreateWithoutHashtagInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutHashtagInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutHashtagInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutHashtagInput, FacebookPostUncheckedCreateWithoutHashtagInput>
  }

  export type FacebookPostCreateManyHashtagInputEnvelope = {
    data: Enumerable<FacebookPostCreateManyHashtagInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostUpsertWithWhereUniqueWithoutHashtagInput = {
    where: FacebookPostWhereUniqueInput
    update: XOR<FacebookPostUpdateWithoutHashtagInput, FacebookPostUncheckedUpdateWithoutHashtagInput>
    create: XOR<FacebookPostCreateWithoutHashtagInput, FacebookPostUncheckedCreateWithoutHashtagInput>
  }

  export type FacebookPostUpdateWithWhereUniqueWithoutHashtagInput = {
    where: FacebookPostWhereUniqueInput
    data: XOR<FacebookPostUpdateWithoutHashtagInput, FacebookPostUncheckedUpdateWithoutHashtagInput>
  }

  export type FacebookPostUpdateManyWithWhereWithoutHashtagInput = {
    where: FacebookPostScalarWhereInput
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FacebookUserCreateWithoutLikesInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutLikesInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutLikesInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutLikesInput, FacebookUserUncheckedCreateWithoutLikesInput>
  }

  export type FacebookPostCreateWithoutLikesInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutLikesInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutLikesInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutLikesInput, FacebookPostUncheckedCreateWithoutLikesInput>
  }

  export type FacebookUserUpsertWithoutLikesInput = {
    update: XOR<FacebookUserUpdateWithoutLikesInput, FacebookUserUncheckedUpdateWithoutLikesInput>
    create: XOR<FacebookUserCreateWithoutLikesInput, FacebookUserUncheckedCreateWithoutLikesInput>
  }

  export type FacebookUserUpdateWithoutLikesInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookPostUpsertWithoutLikesInput = {
    update: XOR<FacebookPostUpdateWithoutLikesInput, FacebookPostUncheckedUpdateWithoutLikesInput>
    create: XOR<FacebookPostCreateWithoutLikesInput, FacebookPostUncheckedCreateWithoutLikesInput>
  }

  export type FacebookPostUpdateWithoutLikesInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookCommentPostCreateWithoutShareInput = {
    post: FacebookPostCreateNestedOneWithoutCommentPostsInput
    user: FacebookUserCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    commentTo?: FacebookCommentPostCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUncheckedCreateWithoutShareInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostCreateOrConnectWithoutShareInput = {
    where: FacebookCommentPostWhereUniqueInput
    create: XOR<FacebookCommentPostCreateWithoutShareInput, FacebookCommentPostUncheckedCreateWithoutShareInput>
  }

  export type FacebookCommentPostCreateManyShareInputEnvelope = {
    data: Enumerable<FacebookCommentPostCreateManyShareInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostCreateWithoutShareInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutShareInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutShareInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutShareInput, FacebookPostUncheckedCreateWithoutShareInput>
  }

  export type FacebookPostCreateManyShareInputEnvelope = {
    data: Enumerable<FacebookPostCreateManyShareInput>
    skipDuplicates?: boolean
  }

  export type FacebookCommentPostUpsertWithWhereUniqueWithoutShareInput = {
    where: FacebookCommentPostWhereUniqueInput
    update: XOR<FacebookCommentPostUpdateWithoutShareInput, FacebookCommentPostUncheckedUpdateWithoutShareInput>
    create: XOR<FacebookCommentPostCreateWithoutShareInput, FacebookCommentPostUncheckedCreateWithoutShareInput>
  }

  export type FacebookCommentPostUpdateWithWhereUniqueWithoutShareInput = {
    where: FacebookCommentPostWhereUniqueInput
    data: XOR<FacebookCommentPostUpdateWithoutShareInput, FacebookCommentPostUncheckedUpdateWithoutShareInput>
  }

  export type FacebookCommentPostUpdateManyWithWhereWithoutShareInput = {
    where: FacebookCommentPostScalarWhereInput
    data: XOR<FacebookCommentPostUpdateManyMutationInput, FacebookCommentPostUncheckedUpdateManyWithoutCommentPostsInput>
  }

  export type FacebookPostUpsertWithWhereUniqueWithoutShareInput = {
    where: FacebookPostWhereUniqueInput
    update: XOR<FacebookPostUpdateWithoutShareInput, FacebookPostUncheckedUpdateWithoutShareInput>
    create: XOR<FacebookPostCreateWithoutShareInput, FacebookPostUncheckedCreateWithoutShareInput>
  }

  export type FacebookPostUpdateWithWhereUniqueWithoutShareInput = {
    where: FacebookPostWhereUniqueInput
    data: XOR<FacebookPostUpdateWithoutShareInput, FacebookPostUncheckedUpdateWithoutShareInput>
  }

  export type FacebookPostUpdateManyWithWhereWithoutShareInput = {
    where: FacebookPostScalarWhereInput
    data: XOR<FacebookPostUpdateManyMutationInput, FacebookPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type FacebookUserInGroupCreateWithoutGroupInput = {
    user: FacebookUserCreateNestedOneWithoutUserInGroupsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUncheckedCreateWithoutGroupInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupCreateOrConnectWithoutGroupInput = {
    where: FacebookUserInGroupWhereUniqueInput
    create: XOR<FacebookUserInGroupCreateWithoutGroupInput, FacebookUserInGroupUncheckedCreateWithoutGroupInput>
  }

  export type FacebookUserInGroupCreateManyGroupInputEnvelope = {
    data: Enumerable<FacebookUserInGroupCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostDestinationCreateWithoutGroupInput = {
    type: string
    userWall?: FacebookUserCreateNestedOneWithoutPostDestinationsInput
    post?: FacebookPostCreateNestedOneWithoutPostDestionationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUncheckedCreateWithoutGroupInput = {
    id?: number
    type: string
    userId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateOrConnectWithoutGroupInput = {
    where: FacebookPostDestinationWhereUniqueInput
    create: XOR<FacebookPostDestinationCreateWithoutGroupInput, FacebookPostDestinationUncheckedCreateWithoutGroupInput>
  }

  export type FacebookPostDestinationCreateManyGroupInputEnvelope = {
    data: Enumerable<FacebookPostDestinationCreateManyGroupInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserInGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: FacebookUserInGroupWhereUniqueInput
    update: XOR<FacebookUserInGroupUpdateWithoutGroupInput, FacebookUserInGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<FacebookUserInGroupCreateWithoutGroupInput, FacebookUserInGroupUncheckedCreateWithoutGroupInput>
  }

  export type FacebookUserInGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: FacebookUserInGroupWhereUniqueInput
    data: XOR<FacebookUserInGroupUpdateWithoutGroupInput, FacebookUserInGroupUncheckedUpdateWithoutGroupInput>
  }

  export type FacebookUserInGroupUpdateManyWithWhereWithoutGroupInput = {
    where: FacebookUserInGroupScalarWhereInput
    data: XOR<FacebookUserInGroupUpdateManyMutationInput, FacebookUserInGroupUncheckedUpdateManyWithoutUserInGroupsInput>
  }

  export type FacebookPostDestinationUpsertWithWhereUniqueWithoutGroupInput = {
    where: FacebookPostDestinationWhereUniqueInput
    update: XOR<FacebookPostDestinationUpdateWithoutGroupInput, FacebookPostDestinationUncheckedUpdateWithoutGroupInput>
    create: XOR<FacebookPostDestinationCreateWithoutGroupInput, FacebookPostDestinationUncheckedCreateWithoutGroupInput>
  }

  export type FacebookPostDestinationUpdateWithWhereUniqueWithoutGroupInput = {
    where: FacebookPostDestinationWhereUniqueInput
    data: XOR<FacebookPostDestinationUpdateWithoutGroupInput, FacebookPostDestinationUncheckedUpdateWithoutGroupInput>
  }

  export type FacebookPostDestinationUpdateManyWithWhereWithoutGroupInput = {
    where: FacebookPostDestinationScalarWhereInput
    data: XOR<FacebookPostDestinationUpdateManyMutationInput, FacebookPostDestinationUncheckedUpdateManyWithoutPostDestinationsInput>
  }

  export type FacebookUserCreateWithoutUserInGroupsInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutUserInGroupsInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutUserInGroupsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutUserInGroupsInput, FacebookUserUncheckedCreateWithoutUserInGroupsInput>
  }

  export type FacebookGroupCreateWithoutUserInGroupsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupUncheckedCreateWithoutUserInGroupsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupCreateOrConnectWithoutUserInGroupsInput = {
    where: FacebookGroupWhereUniqueInput
    create: XOR<FacebookGroupCreateWithoutUserInGroupsInput, FacebookGroupUncheckedCreateWithoutUserInGroupsInput>
  }

  export type FacebookUserUpsertWithoutUserInGroupsInput = {
    update: XOR<FacebookUserUpdateWithoutUserInGroupsInput, FacebookUserUncheckedUpdateWithoutUserInGroupsInput>
    create: XOR<FacebookUserCreateWithoutUserInGroupsInput, FacebookUserUncheckedCreateWithoutUserInGroupsInput>
  }

  export type FacebookUserUpdateWithoutUserInGroupsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutUserInGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookGroupUpsertWithoutUserInGroupsInput = {
    update: XOR<FacebookGroupUpdateWithoutUserInGroupsInput, FacebookGroupUncheckedUpdateWithoutUserInGroupsInput>
    create: XOR<FacebookGroupCreateWithoutUserInGroupsInput, FacebookGroupUncheckedCreateWithoutUserInGroupsInput>
  }

  export type FacebookGroupUpdateWithoutUserInGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postDestinations?: FacebookPostDestinationUpdateManyWithoutGroupNestedInput
  }

  export type FacebookGroupUncheckedUpdateWithoutUserInGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FacebookUserCreateWithoutPostDestinationsInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
  }

  export type FacebookUserUncheckedCreateWithoutPostDestinationsInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type FacebookUserCreateOrConnectWithoutPostDestinationsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutPostDestinationsInput, FacebookUserUncheckedCreateWithoutPostDestinationsInput>
  }

  export type FacebookGroupCreateWithoutPostDestinationsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupUncheckedCreateWithoutPostDestinationsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type FacebookGroupCreateOrConnectWithoutPostDestinationsInput = {
    where: FacebookGroupWhereUniqueInput
    create: XOR<FacebookGroupCreateWithoutPostDestinationsInput, FacebookGroupUncheckedCreateWithoutPostDestinationsInput>
  }

  export type FacebookPostCreateWithoutPostDestionationsInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutPostDestionationsInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutPostDestionationsInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutPostDestionationsInput, FacebookPostUncheckedCreateWithoutPostDestionationsInput>
  }

  export type FacebookUserUpsertWithoutPostDestinationsInput = {
    update: XOR<FacebookUserUpdateWithoutPostDestinationsInput, FacebookUserUncheckedUpdateWithoutPostDestinationsInput>
    create: XOR<FacebookUserCreateWithoutPostDestinationsInput, FacebookUserUncheckedCreateWithoutPostDestinationsInput>
  }

  export type FacebookUserUpdateWithoutPostDestinationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutPostDestinationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FacebookGroupUpsertWithoutPostDestinationsInput = {
    update: XOR<FacebookGroupUpdateWithoutPostDestinationsInput, FacebookGroupUncheckedUpdateWithoutPostDestinationsInput>
    create: XOR<FacebookGroupCreateWithoutPostDestinationsInput, FacebookGroupUncheckedCreateWithoutPostDestinationsInput>
  }

  export type FacebookGroupUpdateWithoutPostDestinationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInGroups?: FacebookUserInGroupUpdateManyWithoutGroupNestedInput
  }

  export type FacebookGroupUncheckedUpdateWithoutPostDestinationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FacebookPostUpsertWithoutPostDestionationsInput = {
    update: XOR<FacebookPostUpdateWithoutPostDestionationsInput, FacebookPostUncheckedUpdateWithoutPostDestionationsInput>
    create: XOR<FacebookPostCreateWithoutPostDestionationsInput, FacebookPostUncheckedCreateWithoutPostDestionationsInput>
  }

  export type FacebookPostUpdateWithoutPostDestionationsInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutPostDestionationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookUserCreateWithoutPostsInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutUserInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutPostsInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutUserInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutPostsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type FacebookLocationCreateWithoutPostsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLocationUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLocationCreateOrConnectWithoutPostsInput = {
    where: FacebookLocationWhereUniqueInput
    create: XOR<FacebookLocationCreateWithoutPostsInput, FacebookLocationUncheckedCreateWithoutPostsInput>
  }

  export type FacebookHashtagCreateWithoutPostsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashtagUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookHashtagCreateOrConnectWithoutPostsInput = {
    where: FacebookHashtagWhereUniqueInput
    create: XOR<FacebookHashtagCreateWithoutPostsInput, FacebookHashtagUncheckedCreateWithoutPostsInput>
  }

  export type FacebookShareTypeCreateWithoutPostsInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeUncheckedCreateWithoutPostsInput = {
    id?: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeCreateOrConnectWithoutPostsInput = {
    where: FacebookShareTypeWhereUniqueInput
    create: XOR<FacebookShareTypeCreateWithoutPostsInput, FacebookShareTypeUncheckedCreateWithoutPostsInput>
  }

  export type FacebookLikeCreateWithoutPostsInput = {
    type: FacebookLikeTypeEnum
    user: FacebookUserCreateNestedOneWithoutLikesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUncheckedCreateWithoutPostsInput = {
    id?: number
    type: FacebookLikeTypeEnum
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeCreateOrConnectWithoutPostsInput = {
    where: FacebookLikeWhereUniqueInput
    create: XOR<FacebookLikeCreateWithoutPostsInput, FacebookLikeUncheckedCreateWithoutPostsInput>
  }

  export type FacebookLikeCreateManyPostsInputEnvelope = {
    data: Enumerable<FacebookLikeCreateManyPostsInput>
    skipDuplicates?: boolean
  }

  export type FacebookCommentPostCreateWithoutPostInput = {
    user: FacebookUserCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    commentTo?: FacebookCommentPostCreateNestedOneWithoutCommentPostsInput
    share: FacebookShareTypeCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostCreateOrConnectWithoutPostInput = {
    where: FacebookCommentPostWhereUniqueInput
    create: XOR<FacebookCommentPostCreateWithoutPostInput, FacebookCommentPostUncheckedCreateWithoutPostInput>
  }

  export type FacebookCommentPostCreateManyPostInputEnvelope = {
    data: Enumerable<FacebookCommentPostCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostDestinationCreateWithoutPostInput = {
    type: string
    userWall?: FacebookUserCreateNestedOneWithoutPostDestinationsInput
    group?: FacebookGroupCreateNestedOneWithoutPostDestinationsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationUncheckedCreateWithoutPostInput = {
    id?: number
    type: string
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateOrConnectWithoutPostInput = {
    where: FacebookPostDestinationWhereUniqueInput
    create: XOR<FacebookPostDestinationCreateWithoutPostInput, FacebookPostDestinationUncheckedCreateWithoutPostInput>
  }

  export type FacebookPostDestinationCreateManyPostInputEnvelope = {
    data: Enumerable<FacebookPostDestinationCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type FacebookUserUpsertWithoutPostsInput = {
    update: XOR<FacebookUserUpdateWithoutPostsInput, FacebookUserUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookUserCreateWithoutPostsInput, FacebookUserUncheckedCreateWithoutPostsInput>
  }

  export type FacebookUserUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutUserNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookLocationUpsertWithoutPostsInput = {
    update: XOR<FacebookLocationUpdateWithoutPostsInput, FacebookLocationUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookLocationCreateWithoutPostsInput, FacebookLocationUncheckedCreateWithoutPostsInput>
  }

  export type FacebookLocationUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLocationUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashtagUpsertWithoutPostsInput = {
    update: XOR<FacebookHashtagUpdateWithoutPostsInput, FacebookHashtagUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookHashtagCreateWithoutPostsInput, FacebookHashtagUncheckedCreateWithoutPostsInput>
  }

  export type FacebookHashtagUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookHashtagUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookShareTypeUpsertWithoutPostsInput = {
    update: XOR<FacebookShareTypeUpdateWithoutPostsInput, FacebookShareTypeUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookShareTypeCreateWithoutPostsInput, FacebookShareTypeUncheckedCreateWithoutPostsInput>
  }

  export type FacebookShareTypeUpdateWithoutPostsInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutShareNestedInput
  }

  export type FacebookShareTypeUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FacebookLikeUpsertWithWhereUniqueWithoutPostsInput = {
    where: FacebookLikeWhereUniqueInput
    update: XOR<FacebookLikeUpdateWithoutPostsInput, FacebookLikeUncheckedUpdateWithoutPostsInput>
    create: XOR<FacebookLikeCreateWithoutPostsInput, FacebookLikeUncheckedCreateWithoutPostsInput>
  }

  export type FacebookLikeUpdateWithWhereUniqueWithoutPostsInput = {
    where: FacebookLikeWhereUniqueInput
    data: XOR<FacebookLikeUpdateWithoutPostsInput, FacebookLikeUncheckedUpdateWithoutPostsInput>
  }

  export type FacebookLikeUpdateManyWithWhereWithoutPostsInput = {
    where: FacebookLikeScalarWhereInput
    data: XOR<FacebookLikeUpdateManyMutationInput, FacebookLikeUncheckedUpdateManyWithoutLikesInput>
  }

  export type FacebookCommentPostUpsertWithWhereUniqueWithoutPostInput = {
    where: FacebookCommentPostWhereUniqueInput
    update: XOR<FacebookCommentPostUpdateWithoutPostInput, FacebookCommentPostUncheckedUpdateWithoutPostInput>
    create: XOR<FacebookCommentPostCreateWithoutPostInput, FacebookCommentPostUncheckedCreateWithoutPostInput>
  }

  export type FacebookCommentPostUpdateWithWhereUniqueWithoutPostInput = {
    where: FacebookCommentPostWhereUniqueInput
    data: XOR<FacebookCommentPostUpdateWithoutPostInput, FacebookCommentPostUncheckedUpdateWithoutPostInput>
  }

  export type FacebookCommentPostUpdateManyWithWhereWithoutPostInput = {
    where: FacebookCommentPostScalarWhereInput
    data: XOR<FacebookCommentPostUpdateManyMutationInput, FacebookCommentPostUncheckedUpdateManyWithoutCommentPostsInput>
  }

  export type FacebookPostDestinationUpsertWithWhereUniqueWithoutPostInput = {
    where: FacebookPostDestinationWhereUniqueInput
    update: XOR<FacebookPostDestinationUpdateWithoutPostInput, FacebookPostDestinationUncheckedUpdateWithoutPostInput>
    create: XOR<FacebookPostDestinationCreateWithoutPostInput, FacebookPostDestinationUncheckedCreateWithoutPostInput>
  }

  export type FacebookPostDestinationUpdateWithWhereUniqueWithoutPostInput = {
    where: FacebookPostDestinationWhereUniqueInput
    data: XOR<FacebookPostDestinationUpdateWithoutPostInput, FacebookPostDestinationUncheckedUpdateWithoutPostInput>
  }

  export type FacebookPostDestinationUpdateManyWithWhereWithoutPostInput = {
    where: FacebookPostDestinationScalarWhereInput
    data: XOR<FacebookPostDestinationUpdateManyMutationInput, FacebookPostDestinationUncheckedUpdateManyWithoutPostDestionationsInput>
  }

  export type FacebookPostCreateWithoutCommentPostsInput = {
    user: FacebookUserCreateNestedOneWithoutPostsInput
    message?: string | null
    image?: string | null
    location: FacebookLocationCreateNestedOneWithoutPostsInput
    hashtag?: FacebookHashtagCreateNestedOneWithoutPostsInput
    share?: FacebookShareTypeCreateNestedOneWithoutPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeCreateNestedManyWithoutPostsInput
    postDestionations?: FacebookPostDestinationCreateNestedManyWithoutPostInput
  }

  export type FacebookPostUncheckedCreateWithoutCommentPostsInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutPostsInput
    postDestionations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutPostInput
  }

  export type FacebookPostCreateOrConnectWithoutCommentPostsInput = {
    where: FacebookPostWhereUniqueInput
    create: XOR<FacebookPostCreateWithoutCommentPostsInput, FacebookPostUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookUserCreateWithoutCommentPostsInput = {
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupCreateNestedManyWithoutUserInput
    posts?: FacebookPostCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageCreateNestedManyWithoutToInput
    likes?: FacebookLikeCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserUncheckedCreateWithoutCommentPostsInput = {
    id?: number
    username: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    from?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    to?: FacebookUserRelationshipUncheckedCreateNestedManyWithoutToInput
    userInGroups?: FacebookUserInGroupUncheckedCreateNestedManyWithoutUserInput
    posts?: FacebookPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: FacebookDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: FacebookDirectMessageUncheckedCreateNestedManyWithoutToInput
    likes?: FacebookLikeUncheckedCreateNestedManyWithoutUserInput
    postDestinations?: FacebookPostDestinationUncheckedCreateNestedManyWithoutUserWallInput
  }

  export type FacebookUserCreateOrConnectWithoutCommentPostsInput = {
    where: FacebookUserWhereUniqueInput
    create: XOR<FacebookUserCreateWithoutCommentPostsInput, FacebookUserUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookCommentPostCreateWithoutCommentPostsInput = {
    post: FacebookPostCreateNestedOneWithoutCommentPostsInput
    user: FacebookUserCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    commentTo?: FacebookCommentPostCreateNestedOneWithoutCommentPostsInput
    share: FacebookShareTypeCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostUncheckedCreateWithoutCommentPostsInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostCreateOrConnectWithoutCommentPostsInput = {
    where: FacebookCommentPostWhereUniqueInput
    create: XOR<FacebookCommentPostCreateWithoutCommentPostsInput, FacebookCommentPostUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookShareTypeCreateWithoutCommentPostsInput = {
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeUncheckedCreateWithoutCommentPostsInput = {
    id?: number
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: FacebookPostUncheckedCreateNestedManyWithoutShareInput
  }

  export type FacebookShareTypeCreateOrConnectWithoutCommentPostsInput = {
    where: FacebookShareTypeWhereUniqueInput
    create: XOR<FacebookShareTypeCreateWithoutCommentPostsInput, FacebookShareTypeUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookCommentPostCreateWithoutCommentToInput = {
    post: FacebookPostCreateNestedOneWithoutCommentPostsInput
    user: FacebookUserCreateNestedOneWithoutCommentPostsInput
    message?: string | null
    image?: string | null
    share: FacebookShareTypeCreateNestedOneWithoutCommentPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostUncheckedCreateWithoutCommentToInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: FacebookCommentPostUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type FacebookCommentPostCreateOrConnectWithoutCommentToInput = {
    where: FacebookCommentPostWhereUniqueInput
    create: XOR<FacebookCommentPostCreateWithoutCommentToInput, FacebookCommentPostUncheckedCreateWithoutCommentToInput>
  }

  export type FacebookCommentPostCreateManyCommentToInputEnvelope = {
    data: Enumerable<FacebookCommentPostCreateManyCommentToInput>
    skipDuplicates?: boolean
  }

  export type FacebookPostUpsertWithoutCommentPostsInput = {
    update: XOR<FacebookPostUpdateWithoutCommentPostsInput, FacebookPostUncheckedUpdateWithoutCommentPostsInput>
    create: XOR<FacebookPostCreateWithoutCommentPostsInput, FacebookPostUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookPostUpdateWithoutCommentPostsInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookUserUpsertWithoutCommentPostsInput = {
    update: XOR<FacebookUserUpdateWithoutCommentPostsInput, FacebookUserUncheckedUpdateWithoutCommentPostsInput>
    create: XOR<FacebookUserCreateWithoutCommentPostsInput, FacebookUserUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookUserUpdateWithoutCommentPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUpdateManyWithoutToNestedInput
    likes?: FacebookLikeUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookUserUncheckedUpdateWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: FacebookUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    to?: FacebookUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    userInGroups?: FacebookUserInGroupUncheckedUpdateManyWithoutUserNestedInput
    posts?: FacebookPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: FacebookDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: FacebookDirectMessageUncheckedUpdateManyWithoutToNestedInput
    likes?: FacebookLikeUncheckedUpdateManyWithoutUserNestedInput
    postDestinations?: FacebookPostDestinationUncheckedUpdateManyWithoutUserWallNestedInput
  }

  export type FacebookCommentPostUpsertWithoutCommentPostsInput = {
    update: XOR<FacebookCommentPostUpdateWithoutCommentPostsInput, FacebookCommentPostUncheckedUpdateWithoutCommentPostsInput>
    create: XOR<FacebookCommentPostCreateWithoutCommentPostsInput, FacebookCommentPostUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookCommentPostUpdateWithoutCommentPostsInput = {
    post?: FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput
    user?: FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentTo?: FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput
    share?: FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostUncheckedUpdateWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookShareTypeUpsertWithoutCommentPostsInput = {
    update: XOR<FacebookShareTypeUpdateWithoutCommentPostsInput, FacebookShareTypeUncheckedUpdateWithoutCommentPostsInput>
    create: XOR<FacebookShareTypeCreateWithoutCommentPostsInput, FacebookShareTypeUncheckedCreateWithoutCommentPostsInput>
  }

  export type FacebookShareTypeUpdateWithoutCommentPostsInput = {
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUpdateManyWithoutShareNestedInput
  }

  export type FacebookShareTypeUncheckedUpdateWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: FacebookPostUncheckedUpdateManyWithoutShareNestedInput
  }

  export type FacebookCommentPostUpsertWithWhereUniqueWithoutCommentToInput = {
    where: FacebookCommentPostWhereUniqueInput
    update: XOR<FacebookCommentPostUpdateWithoutCommentToInput, FacebookCommentPostUncheckedUpdateWithoutCommentToInput>
    create: XOR<FacebookCommentPostCreateWithoutCommentToInput, FacebookCommentPostUncheckedCreateWithoutCommentToInput>
  }

  export type FacebookCommentPostUpdateWithWhereUniqueWithoutCommentToInput = {
    where: FacebookCommentPostWhereUniqueInput
    data: XOR<FacebookCommentPostUpdateWithoutCommentToInput, FacebookCommentPostUncheckedUpdateWithoutCommentToInput>
  }

  export type FacebookCommentPostUpdateManyWithWhereWithoutCommentToInput = {
    where: FacebookCommentPostScalarWhereInput
    data: XOR<FacebookCommentPostUpdateManyMutationInput, FacebookCommentPostUncheckedUpdateManyWithoutCommentPostsInput>
  }

  export type TwitterPostCreateWithoutUserInput = {
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagCreateNestedManyWithoutPostInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedCreateNestedManyWithoutPostInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserRelationshipCreateWithoutFromInput = {
    to: TwitterUserCreateNestedOneWithoutFollowersInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipCreateOrConnectWithoutFromInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    create: XOR<TwitterUserRelationshipCreateWithoutFromInput, TwitterUserRelationshipUncheckedCreateWithoutFromInput>
  }

  export type TwitterUserRelationshipCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterUserRelationshipCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserRelationshipCreateWithoutToInput = {
    from: TwitterUserCreateNestedOneWithoutFollowingsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipCreateOrConnectWithoutToInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    create: XOR<TwitterUserRelationshipCreateWithoutToInput, TwitterUserRelationshipUncheckedCreateWithoutToInput>
  }

  export type TwitterUserRelationshipCreateManyToInputEnvelope = {
    data: Enumerable<TwitterUserRelationshipCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterReplyPostCreateWithoutUserInput = {
    message: string
    image?: string | null
    post: TwitterPostCreateNestedOneWithoutReplyPostsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostUncheckedCreateWithoutUserInput = {
    id?: number
    message: string
    image?: string | null
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostCreateOrConnectWithoutUserInput = {
    where: TwitterReplyPostWhereUniqueInput
    create: XOR<TwitterReplyPostCreateWithoutUserInput, TwitterReplyPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterReplyPostCreateManyUserInputEnvelope = {
    data: Enumerable<TwitterReplyPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutFromInput = {
    to: TwitterUserCreateNestedOneWithoutDirectMessageToInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutFromInput = {
    id?: number
    toUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateOrConnectWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageCreateManyFromInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type TwitterDirectMessageCreateWithoutToInput = {
    from: TwitterUserCreateNestedOneWithoutDirectMessageFromInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageUncheckedCreateWithoutToInput = {
    id?: number
    fromUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateOrConnectWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageCreateManyToInputEnvelope = {
    data: Enumerable<TwitterDirectMessageCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    update: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterPostCreateWithoutUserInput, TwitterPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterPostUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterPostWhereUniqueInput
    data: XOR<TwitterPostUpdateWithoutUserInput, TwitterPostUncheckedUpdateWithoutUserInput>
  }

  export type TwitterPostUpdateManyWithWhereWithoutUserInput = {
    where: TwitterPostScalarWhereInput
    data: XOR<TwitterPostUpdateManyMutationInput, TwitterPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type TwitterPostScalarWhereInput = {
    AND?: Enumerable<TwitterPostScalarWhereInput>
    OR?: Enumerable<TwitterPostScalarWhereInput>
    NOT?: Enumerable<TwitterPostScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterUserRelationshipUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    update: XOR<TwitterUserRelationshipUpdateWithoutFromInput, TwitterUserRelationshipUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterUserRelationshipCreateWithoutFromInput, TwitterUserRelationshipUncheckedCreateWithoutFromInput>
  }

  export type TwitterUserRelationshipUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    data: XOR<TwitterUserRelationshipUpdateWithoutFromInput, TwitterUserRelationshipUncheckedUpdateWithoutFromInput>
  }

  export type TwitterUserRelationshipUpdateManyWithWhereWithoutFromInput = {
    where: TwitterUserRelationshipScalarWhereInput
    data: XOR<TwitterUserRelationshipUpdateManyMutationInput, TwitterUserRelationshipUncheckedUpdateManyWithoutFollowingsInput>
  }

  export type TwitterUserRelationshipScalarWhereInput = {
    AND?: Enumerable<TwitterUserRelationshipScalarWhereInput>
    OR?: Enumerable<TwitterUserRelationshipScalarWhereInput>
    NOT?: Enumerable<TwitterUserRelationshipScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterUserRelationshipUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    update: XOR<TwitterUserRelationshipUpdateWithoutToInput, TwitterUserRelationshipUncheckedUpdateWithoutToInput>
    create: XOR<TwitterUserRelationshipCreateWithoutToInput, TwitterUserRelationshipUncheckedCreateWithoutToInput>
  }

  export type TwitterUserRelationshipUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterUserRelationshipWhereUniqueInput
    data: XOR<TwitterUserRelationshipUpdateWithoutToInput, TwitterUserRelationshipUncheckedUpdateWithoutToInput>
  }

  export type TwitterUserRelationshipUpdateManyWithWhereWithoutToInput = {
    where: TwitterUserRelationshipScalarWhereInput
    data: XOR<TwitterUserRelationshipUpdateManyMutationInput, TwitterUserRelationshipUncheckedUpdateManyWithoutFollowersInput>
  }

  export type TwitterReplyPostUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterReplyPostWhereUniqueInput
    update: XOR<TwitterReplyPostUpdateWithoutUserInput, TwitterReplyPostUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterReplyPostCreateWithoutUserInput, TwitterReplyPostUncheckedCreateWithoutUserInput>
  }

  export type TwitterReplyPostUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterReplyPostWhereUniqueInput
    data: XOR<TwitterReplyPostUpdateWithoutUserInput, TwitterReplyPostUncheckedUpdateWithoutUserInput>
  }

  export type TwitterReplyPostUpdateManyWithWhereWithoutUserInput = {
    where: TwitterReplyPostScalarWhereInput
    data: XOR<TwitterReplyPostUpdateManyMutationInput, TwitterReplyPostUncheckedUpdateManyWithoutReplyPostsInput>
  }

  export type TwitterReplyPostScalarWhereInput = {
    AND?: Enumerable<TwitterReplyPostScalarWhereInput>
    OR?: Enumerable<TwitterReplyPostScalarWhereInput>
    NOT?: Enumerable<TwitterReplyPostScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    postId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
    create: XOR<TwitterDirectMessageCreateWithoutFromInput, TwitterDirectMessageUncheckedCreateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutFromInput, TwitterDirectMessageUncheckedUpdateWithoutFromInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutFromInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutDirectMessageFromInput>
  }

  export type TwitterDirectMessageScalarWhereInput = {
    AND?: Enumerable<TwitterDirectMessageScalarWhereInput>
    OR?: Enumerable<TwitterDirectMessageScalarWhereInput>
    NOT?: Enumerable<TwitterDirectMessageScalarWhereInput>
    id?: IntFilter | number
    fromUserId?: IntFilter | number
    toUserId?: IntFilter | number
    message?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterDirectMessageUpsertWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    update: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
    create: XOR<TwitterDirectMessageCreateWithoutToInput, TwitterDirectMessageUncheckedCreateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateWithWhereUniqueWithoutToInput = {
    where: TwitterDirectMessageWhereUniqueInput
    data: XOR<TwitterDirectMessageUpdateWithoutToInput, TwitterDirectMessageUncheckedUpdateWithoutToInput>
  }

  export type TwitterDirectMessageUpdateManyWithWhereWithoutToInput = {
    where: TwitterDirectMessageScalarWhereInput
    data: XOR<TwitterDirectMessageUpdateManyMutationInput, TwitterDirectMessageUncheckedUpdateManyWithoutDirectMessageToInput>
  }

  export type TwitterUserCreateWithoutPostsInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutPostsInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutPostsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterPostAndHashtagCreateWithoutPostInput = {
    hashtag: TwitterHashtagCreateNestedOneWithoutPostAndHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUncheckedCreateWithoutPostInput = {
    id?: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagCreateOrConnectWithoutPostInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    create: XOR<TwitterPostAndHashtagCreateWithoutPostInput, TwitterPostAndHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostAndHashtagCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterPostAndHashtagCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterReplyPostCreateWithoutPostInput = {
    user: TwitterUserCreateNestedOneWithoutReplyPostsInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostCreateOrConnectWithoutPostInput = {
    where: TwitterReplyPostWhereUniqueInput
    create: XOR<TwitterReplyPostCreateWithoutPostInput, TwitterReplyPostUncheckedCreateWithoutPostInput>
  }

  export type TwitterReplyPostCreateManyPostInputEnvelope = {
    data: Enumerable<TwitterReplyPostCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type TwitterUserUpsertWithoutPostsInput = {
    update: XOR<TwitterUserUpdateWithoutPostsInput, TwitterUserUncheckedUpdateWithoutPostsInput>
    create: XOR<TwitterUserCreateWithoutPostsInput, TwitterUserUncheckedCreateWithoutPostsInput>
  }

  export type TwitterUserUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterPostAndHashtagUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    update: XOR<TwitterPostAndHashtagUpdateWithoutPostInput, TwitterPostAndHashtagUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterPostAndHashtagCreateWithoutPostInput, TwitterPostAndHashtagUncheckedCreateWithoutPostInput>
  }

  export type TwitterPostAndHashtagUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    data: XOR<TwitterPostAndHashtagUpdateWithoutPostInput, TwitterPostAndHashtagUncheckedUpdateWithoutPostInput>
  }

  export type TwitterPostAndHashtagUpdateManyWithWhereWithoutPostInput = {
    where: TwitterPostAndHashtagScalarWhereInput
    data: XOR<TwitterPostAndHashtagUpdateManyMutationInput, TwitterPostAndHashtagUncheckedUpdateManyWithoutPostAndHashtagsInput>
  }

  export type TwitterPostAndHashtagScalarWhereInput = {
    AND?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
    OR?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
    NOT?: Enumerable<TwitterPostAndHashtagScalarWhereInput>
    id?: IntFilter | number
    postId?: IntFilter | number
    hashtagId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TwitterReplyPostUpsertWithWhereUniqueWithoutPostInput = {
    where: TwitterReplyPostWhereUniqueInput
    update: XOR<TwitterReplyPostUpdateWithoutPostInput, TwitterReplyPostUncheckedUpdateWithoutPostInput>
    create: XOR<TwitterReplyPostCreateWithoutPostInput, TwitterReplyPostUncheckedCreateWithoutPostInput>
  }

  export type TwitterReplyPostUpdateWithWhereUniqueWithoutPostInput = {
    where: TwitterReplyPostWhereUniqueInput
    data: XOR<TwitterReplyPostUpdateWithoutPostInput, TwitterReplyPostUncheckedUpdateWithoutPostInput>
  }

  export type TwitterReplyPostUpdateManyWithWhereWithoutPostInput = {
    where: TwitterReplyPostScalarWhereInput
    data: XOR<TwitterReplyPostUpdateManyMutationInput, TwitterReplyPostUncheckedUpdateManyWithoutReplyPostsInput>
  }

  export type TwitterUserCreateWithoutFollowingsInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutFollowingsInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutFollowingsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFollowingsInput, TwitterUserUncheckedCreateWithoutFollowingsInput>
  }

  export type TwitterUserCreateWithoutFollowersInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutFollowersInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutFollowersInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutFollowersInput, TwitterUserUncheckedCreateWithoutFollowersInput>
  }

  export type TwitterUserUpsertWithoutFollowingsInput = {
    update: XOR<TwitterUserUpdateWithoutFollowingsInput, TwitterUserUncheckedUpdateWithoutFollowingsInput>
    create: XOR<TwitterUserCreateWithoutFollowingsInput, TwitterUserUncheckedCreateWithoutFollowingsInput>
  }

  export type TwitterUserUpdateWithoutFollowingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFollowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUpsertWithoutFollowersInput = {
    update: XOR<TwitterUserUpdateWithoutFollowersInput, TwitterUserUncheckedUpdateWithoutFollowersInput>
    create: XOR<TwitterUserCreateWithoutFollowersInput, TwitterUserUncheckedCreateWithoutFollowersInput>
  }

  export type TwitterUserUpdateWithoutFollowersInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterPostAndHashtagCreateWithoutHashtagInput = {
    post: TwitterPostCreateNestedOneWithoutPostAndHashtagsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagCreateOrConnectWithoutHashtagInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    create: XOR<TwitterPostAndHashtagCreateWithoutHashtagInput, TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostAndHashtagCreateManyHashtagInputEnvelope = {
    data: Enumerable<TwitterPostAndHashtagCreateManyHashtagInput>
    skipDuplicates?: boolean
  }

  export type TwitterPostAndHashtagUpsertWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    update: XOR<TwitterPostAndHashtagUpdateWithoutHashtagInput, TwitterPostAndHashtagUncheckedUpdateWithoutHashtagInput>
    create: XOR<TwitterPostAndHashtagCreateWithoutHashtagInput, TwitterPostAndHashtagUncheckedCreateWithoutHashtagInput>
  }

  export type TwitterPostAndHashtagUpdateWithWhereUniqueWithoutHashtagInput = {
    where: TwitterPostAndHashtagWhereUniqueInput
    data: XOR<TwitterPostAndHashtagUpdateWithoutHashtagInput, TwitterPostAndHashtagUncheckedUpdateWithoutHashtagInput>
  }

  export type TwitterPostAndHashtagUpdateManyWithWhereWithoutHashtagInput = {
    where: TwitterPostAndHashtagScalarWhereInput
    data: XOR<TwitterPostAndHashtagUpdateManyMutationInput, TwitterPostAndHashtagUncheckedUpdateManyWithoutPostAndHashtagsInput>
  }

  export type TwitterPostCreateWithoutPostAndHashtagsInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutPostAndHashtagsInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutPostAndHashtagsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutPostAndHashtagsInput, TwitterPostUncheckedCreateWithoutPostAndHashtagsInput>
  }

  export type TwitterHashtagCreateWithoutPostAndHashtagsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagUncheckedCreateWithoutPostAndHashtagsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterHashtagCreateOrConnectWithoutPostAndHashtagsInput = {
    where: TwitterHashtagWhereUniqueInput
    create: XOR<TwitterHashtagCreateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostAndHashtagsInput>
  }

  export type TwitterPostUpsertWithoutPostAndHashtagsInput = {
    update: XOR<TwitterPostUpdateWithoutPostAndHashtagsInput, TwitterPostUncheckedUpdateWithoutPostAndHashtagsInput>
    create: XOR<TwitterPostCreateWithoutPostAndHashtagsInput, TwitterPostUncheckedCreateWithoutPostAndHashtagsInput>
  }

  export type TwitterPostUpdateWithoutPostAndHashtagsInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replyPosts?: TwitterReplyPostUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutPostAndHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterHashtagUpsertWithoutPostAndHashtagsInput = {
    update: XOR<TwitterHashtagUpdateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedUpdateWithoutPostAndHashtagsInput>
    create: XOR<TwitterHashtagCreateWithoutPostAndHashtagsInput, TwitterHashtagUncheckedCreateWithoutPostAndHashtagsInput>
  }

  export type TwitterHashtagUpdateWithoutPostAndHashtagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterHashtagUncheckedUpdateWithoutPostAndHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserCreateWithoutReplyPostsInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutReplyPostsInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutReplyPostsInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutReplyPostsInput, TwitterUserUncheckedCreateWithoutReplyPostsInput>
  }

  export type TwitterPostCreateWithoutReplyPostsInput = {
    user: TwitterUserCreateNestedOneWithoutPostsInput
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagCreateNestedManyWithoutPostInput
  }

  export type TwitterPostUncheckedCreateWithoutReplyPostsInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedCreateNestedManyWithoutPostInput
  }

  export type TwitterPostCreateOrConnectWithoutReplyPostsInput = {
    where: TwitterPostWhereUniqueInput
    create: XOR<TwitterPostCreateWithoutReplyPostsInput, TwitterPostUncheckedCreateWithoutReplyPostsInput>
  }

  export type TwitterUserUpsertWithoutReplyPostsInput = {
    update: XOR<TwitterUserUpdateWithoutReplyPostsInput, TwitterUserUncheckedUpdateWithoutReplyPostsInput>
    create: XOR<TwitterUserCreateWithoutReplyPostsInput, TwitterUserUncheckedCreateWithoutReplyPostsInput>
  }

  export type TwitterUserUpdateWithoutReplyPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutReplyPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterPostUpsertWithoutReplyPostsInput = {
    update: XOR<TwitterPostUpdateWithoutReplyPostsInput, TwitterPostUncheckedUpdateWithoutReplyPostsInput>
    create: XOR<TwitterPostCreateWithoutReplyPostsInput, TwitterPostUncheckedCreateWithoutReplyPostsInput>
  }

  export type TwitterPostUpdateWithoutReplyPostsInput = {
    user?: TwitterUserUpdateOneRequiredWithoutPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutReplyPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterUserCreateWithoutDirectMessageFromInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageTo?: TwitterDirectMessageCreateNestedManyWithoutToInput
  }

  export type TwitterUserUncheckedCreateWithoutDirectMessageFromInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageTo?: TwitterDirectMessageUncheckedCreateNestedManyWithoutToInput
  }

  export type TwitterUserCreateOrConnectWithoutDirectMessageFromInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutDirectMessageFromInput, TwitterUserUncheckedCreateWithoutDirectMessageFromInput>
  }

  export type TwitterUserCreateWithoutDirectMessageToInput = {
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageCreateNestedManyWithoutFromInput
  }

  export type TwitterUserUncheckedCreateWithoutDirectMessageToInput = {
    id?: number
    username: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: TwitterPostUncheckedCreateNestedManyWithoutUserInput
    followings?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutFromInput
    followers?: TwitterUserRelationshipUncheckedCreateNestedManyWithoutToInput
    replyPosts?: TwitterReplyPostUncheckedCreateNestedManyWithoutUserInput
    directMessageFrom?: TwitterDirectMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type TwitterUserCreateOrConnectWithoutDirectMessageToInput = {
    where: TwitterUserWhereUniqueInput
    create: XOR<TwitterUserCreateWithoutDirectMessageToInput, TwitterUserUncheckedCreateWithoutDirectMessageToInput>
  }

  export type TwitterUserUpsertWithoutDirectMessageFromInput = {
    update: XOR<TwitterUserUpdateWithoutDirectMessageFromInput, TwitterUserUncheckedUpdateWithoutDirectMessageFromInput>
    create: XOR<TwitterUserCreateWithoutDirectMessageFromInput, TwitterUserUncheckedCreateWithoutDirectMessageFromInput>
  }

  export type TwitterUserUpdateWithoutDirectMessageFromInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageTo?: TwitterDirectMessageUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutDirectMessageFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageTo?: TwitterDirectMessageUncheckedUpdateManyWithoutToNestedInput
  }

  export type TwitterUserUpsertWithoutDirectMessageToInput = {
    update: XOR<TwitterUserUpdateWithoutDirectMessageToInput, TwitterUserUncheckedUpdateWithoutDirectMessageToInput>
    create: XOR<TwitterUserCreateWithoutDirectMessageToInput, TwitterUserUncheckedCreateWithoutDirectMessageToInput>
  }

  export type TwitterUserUpdateWithoutDirectMessageToInput = {
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUpdateManyWithoutFromNestedInput
  }

  export type TwitterUserUncheckedUpdateWithoutDirectMessageToInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: TwitterPostUncheckedUpdateManyWithoutUserNestedInput
    followings?: TwitterUserRelationshipUncheckedUpdateManyWithoutFromNestedInput
    followers?: TwitterUserRelationshipUncheckedUpdateManyWithoutToNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutUserNestedInput
    directMessageFrom?: TwitterDirectMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type YoutubeUserToChannelCreateWithoutUserInput = {
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelsInput
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeSubscriberCreateWithoutUserInput = {
    channel: YoutubeChannelCreateNestedOneWithoutSubscribersInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberUncheckedCreateWithoutUserInput = {
    id?: number
    channelId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberCreateOrConnectWithoutUserInput = {
    where: YoutubeSubscriberWhereUniqueInput
    create: XOR<YoutubeSubscriberCreateWithoutUserInput, YoutubeSubscriberUncheckedCreateWithoutUserInput>
  }

  export type YoutubeSubscriberCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeSubscriberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeReactionCreateWithoutUserInput = {
    type: ReactionEnum
    video: YoutubeVideoCreateNestedOneWithoutReactionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionUncheckedCreateWithoutUserInput = {
    id?: number
    type: ReactionEnum
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionCreateOrConnectWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    create: XOR<YoutubeReactionCreateWithoutUserInput, YoutubeReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeReactionCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeReactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeCommentCreateWithoutUserInput = {
    video: YoutubeVideoCreateNestedOneWithoutCommentsInput
    commentTo?: YoutubeCommentCreateNestedOneWithoutCommentPostsInput
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentUncheckedCreateWithoutUserInput = {
    id?: number
    videoId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentCreateOrConnectWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutUserInput, YoutubeCommentUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentCreateManyUserInputEnvelope = {
    data: Enumerable<YoutubeCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeUserToChannelCreateWithoutUserInput, YoutubeUserToChannelUncheckedCreateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutUserInput, YoutubeUserToChannelUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelsInput>
  }

  export type YoutubeUserToChannelScalarWhereInput = {
    AND?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    OR?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    NOT?: Enumerable<YoutubeUserToChannelScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    roleId?: IntFilter | number
    channelId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeSubscriberUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeSubscriberWhereUniqueInput
    update: XOR<YoutubeSubscriberUpdateWithoutUserInput, YoutubeSubscriberUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeSubscriberCreateWithoutUserInput, YoutubeSubscriberUncheckedCreateWithoutUserInput>
  }

  export type YoutubeSubscriberUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeSubscriberWhereUniqueInput
    data: XOR<YoutubeSubscriberUpdateWithoutUserInput, YoutubeSubscriberUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeSubscriberUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeSubscriberScalarWhereInput
    data: XOR<YoutubeSubscriberUpdateManyMutationInput, YoutubeSubscriberUncheckedUpdateManyWithoutSubscribersInput>
  }

  export type YoutubeSubscriberScalarWhereInput = {
    AND?: Enumerable<YoutubeSubscriberScalarWhereInput>
    OR?: Enumerable<YoutubeSubscriberScalarWhereInput>
    NOT?: Enumerable<YoutubeSubscriberScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    channelId?: IntFilter | number
    membership?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    update: XOR<YoutubeReactionUpdateWithoutUserInput, YoutubeReactionUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeReactionCreateWithoutUserInput, YoutubeReactionUncheckedCreateWithoutUserInput>
  }

  export type YoutubeReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeReactionWhereUniqueInput
    data: XOR<YoutubeReactionUpdateWithoutUserInput, YoutubeReactionUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeReactionUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeReactionScalarWhereInput
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyWithoutReactionsInput>
  }

  export type YoutubeReactionScalarWhereInput = {
    AND?: Enumerable<YoutubeReactionScalarWhereInput>
    OR?: Enumerable<YoutubeReactionScalarWhereInput>
    NOT?: Enumerable<YoutubeReactionScalarWhereInput>
    id?: IntFilter | number
    type?: EnumReactionEnumFilter | ReactionEnum
    userId?: IntFilter | number
    videoId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    update: XOR<YoutubeCommentUpdateWithoutUserInput, YoutubeCommentUncheckedUpdateWithoutUserInput>
    create: XOR<YoutubeCommentCreateWithoutUserInput, YoutubeCommentUncheckedCreateWithoutUserInput>
  }

  export type YoutubeCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: YoutubeCommentWhereUniqueInput
    data: XOR<YoutubeCommentUpdateWithoutUserInput, YoutubeCommentUncheckedUpdateWithoutUserInput>
  }

  export type YoutubeCommentUpdateManyWithWhereWithoutUserInput = {
    where: YoutubeCommentScalarWhereInput
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type YoutubeCommentScalarWhereInput = {
    AND?: Enumerable<YoutubeCommentScalarWhereInput>
    OR?: Enumerable<YoutubeCommentScalarWhereInput>
    NOT?: Enumerable<YoutubeCommentScalarWhereInput>
    id?: IntFilter | number
    videoId?: IntFilter | number
    userId?: IntFilter | number
    message?: StringFilter | string
    commentToId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeUserToChannelCreateWithoutRoleInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelsInput
    channel: YoutubeChannelCreateNestedOneWithoutUserToChannelsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutRoleInput, YoutubeUserToChannelUncheckedCreateWithoutRoleInput>
  }

  export type YoutubeUserToChannelCreateManyRoleInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutRoleInput, YoutubeUserToChannelUncheckedUpdateWithoutRoleInput>
    create: XOR<YoutubeUserToChannelCreateWithoutRoleInput, YoutubeUserToChannelUncheckedCreateWithoutRoleInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutRoleInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutRoleInput, YoutubeUserToChannelUncheckedUpdateWithoutRoleInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutRoleInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelsInput>
  }

  export type YoutubeUserToChannelCreateWithoutChannelInput = {
    user: YoutubeUserCreateNestedOneWithoutUserToChannelsInput
    role: YoutubeRoleCreateNestedOneWithoutUserToChannelsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUncheckedCreateWithoutChannelInput = {
    id?: number
    userId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelCreateOrConnectWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeUserToChannelCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeVideoCreateWithoutChannelInput = {
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentCreateNestedManyWithoutVideoInput
    reactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutChannelInput = {
    id?: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeVideoCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeSubscriberCreateWithoutChannelInput = {
    user: YoutubeUserCreateNestedOneWithoutSubscribersInput
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberUncheckedCreateWithoutChannelInput = {
    id?: number
    userId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberCreateOrConnectWithoutChannelInput = {
    where: YoutubeSubscriberWhereUniqueInput
    create: XOR<YoutubeSubscriberCreateWithoutChannelInput, YoutubeSubscriberUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeSubscriberCreateManyChannelInputEnvelope = {
    data: Enumerable<YoutubeSubscriberCreateManyChannelInput>
    skipDuplicates?: boolean
  }

  export type YoutubeUserToChannelUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    update: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeUserToChannelCreateWithoutChannelInput, YoutubeUserToChannelUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeUserToChannelWhereUniqueInput
    data: XOR<YoutubeUserToChannelUpdateWithoutChannelInput, YoutubeUserToChannelUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeUserToChannelUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeUserToChannelScalarWhereInput
    data: XOR<YoutubeUserToChannelUpdateManyMutationInput, YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelsInput>
  }

  export type YoutubeVideoUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    update: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeVideoCreateWithoutChannelInput, YoutubeVideoUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeVideoWhereUniqueInput
    data: XOR<YoutubeVideoUpdateWithoutChannelInput, YoutubeVideoUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeVideoUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeVideoScalarWhereInput
    data: XOR<YoutubeVideoUpdateManyMutationInput, YoutubeVideoUncheckedUpdateManyWithoutVideosInput>
  }

  export type YoutubeVideoScalarWhereInput = {
    AND?: Enumerable<YoutubeVideoScalarWhereInput>
    OR?: Enumerable<YoutubeVideoScalarWhereInput>
    NOT?: Enumerable<YoutubeVideoScalarWhereInput>
    id?: IntFilter | number
    channelId?: IntFilter | number
    name?: StringFilter | string
    urlFile?: StringFilter | string
    coverImage?: StringNullableFilter | string | null
    descriptions?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type YoutubeSubscriberUpsertWithWhereUniqueWithoutChannelInput = {
    where: YoutubeSubscriberWhereUniqueInput
    update: XOR<YoutubeSubscriberUpdateWithoutChannelInput, YoutubeSubscriberUncheckedUpdateWithoutChannelInput>
    create: XOR<YoutubeSubscriberCreateWithoutChannelInput, YoutubeSubscriberUncheckedCreateWithoutChannelInput>
  }

  export type YoutubeSubscriberUpdateWithWhereUniqueWithoutChannelInput = {
    where: YoutubeSubscriberWhereUniqueInput
    data: XOR<YoutubeSubscriberUpdateWithoutChannelInput, YoutubeSubscriberUncheckedUpdateWithoutChannelInput>
  }

  export type YoutubeSubscriberUpdateManyWithWhereWithoutChannelInput = {
    where: YoutubeSubscriberScalarWhereInput
    data: XOR<YoutubeSubscriberUpdateManyMutationInput, YoutubeSubscriberUncheckedUpdateManyWithoutSubscribersInput>
  }

  export type YoutubeUserCreateWithoutUserToChannelsInput = {
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutUserToChannelsInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutUserToChannelsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutUserToChannelsInput, YoutubeUserUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeRoleCreateWithoutUserToChannelsInput = {
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeRoleUncheckedCreateWithoutUserToChannelsInput = {
    id?: number
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeRoleCreateOrConnectWithoutUserToChannelsInput = {
    where: YoutubeRoleWhereUniqueInput
    create: XOR<YoutubeRoleCreateWithoutUserToChannelsInput, YoutubeRoleUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeChannelCreateWithoutUserToChannelsInput = {
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: YoutubeVideoCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutUserToChannelsInput = {
    id?: number
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutUserToChannelsInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutUserToChannelsInput, YoutubeChannelUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeUserUpsertWithoutUserToChannelsInput = {
    update: XOR<YoutubeUserUpdateWithoutUserToChannelsInput, YoutubeUserUncheckedUpdateWithoutUserToChannelsInput>
    create: XOR<YoutubeUserCreateWithoutUserToChannelsInput, YoutubeUserUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeUserUpdateWithoutUserToChannelsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: YoutubeSubscriberUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeRoleUpsertWithoutUserToChannelsInput = {
    update: XOR<YoutubeRoleUpdateWithoutUserToChannelsInput, YoutubeRoleUncheckedUpdateWithoutUserToChannelsInput>
    create: XOR<YoutubeRoleCreateWithoutUserToChannelsInput, YoutubeRoleUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeRoleUpdateWithoutUserToChannelsInput = {
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeRoleUncheckedUpdateWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeChannelUpsertWithoutUserToChannelsInput = {
    update: XOR<YoutubeChannelUpdateWithoutUserToChannelsInput, YoutubeChannelUncheckedUpdateWithoutUserToChannelsInput>
    create: XOR<YoutubeChannelCreateWithoutUserToChannelsInput, YoutubeChannelUncheckedCreateWithoutUserToChannelsInput>
  }

  export type YoutubeChannelUpdateWithoutUserToChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelCreateWithoutVideosInput = {
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutVideosInput = {
    id?: number
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutVideosInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutVideosInput, YoutubeChannelUncheckedCreateWithoutVideosInput>
  }

  export type YoutubeCommentCreateWithoutVideoInput = {
    user: YoutubeUserCreateNestedOneWithoutCommentsInput
    commentTo?: YoutubeCommentCreateNestedOneWithoutCommentPostsInput
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentUncheckedCreateWithoutVideoInput = {
    id?: number
    userId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentCreateOrConnectWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutVideoInput, YoutubeCommentUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeCommentCreateManyVideoInputEnvelope = {
    data: Enumerable<YoutubeCommentCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YoutubeReactionCreateWithoutVideoInput = {
    type: ReactionEnum
    user: YoutubeUserCreateNestedOneWithoutReactionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionUncheckedCreateWithoutVideoInput = {
    id?: number
    type: ReactionEnum
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionCreateOrConnectWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeReactionCreateManyVideoInputEnvelope = {
    data: Enumerable<YoutubeReactionCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type YoutubeChannelUpsertWithoutVideosInput = {
    update: XOR<YoutubeChannelUpdateWithoutVideosInput, YoutubeChannelUncheckedUpdateWithoutVideosInput>
    create: XOR<YoutubeChannelCreateWithoutVideosInput, YoutubeChannelUncheckedCreateWithoutVideosInput>
  }

  export type YoutubeChannelUpdateWithoutVideosInput = {
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeCommentUpsertWithWhereUniqueWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    update: XOR<YoutubeCommentUpdateWithoutVideoInput, YoutubeCommentUncheckedUpdateWithoutVideoInput>
    create: XOR<YoutubeCommentCreateWithoutVideoInput, YoutubeCommentUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeCommentUpdateWithWhereUniqueWithoutVideoInput = {
    where: YoutubeCommentWhereUniqueInput
    data: XOR<YoutubeCommentUpdateWithoutVideoInput, YoutubeCommentUncheckedUpdateWithoutVideoInput>
  }

  export type YoutubeCommentUpdateManyWithWhereWithoutVideoInput = {
    where: YoutubeCommentScalarWhereInput
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type YoutubeReactionUpsertWithWhereUniqueWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    update: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
    create: XOR<YoutubeReactionCreateWithoutVideoInput, YoutubeReactionUncheckedCreateWithoutVideoInput>
  }

  export type YoutubeReactionUpdateWithWhereUniqueWithoutVideoInput = {
    where: YoutubeReactionWhereUniqueInput
    data: XOR<YoutubeReactionUpdateWithoutVideoInput, YoutubeReactionUncheckedUpdateWithoutVideoInput>
  }

  export type YoutubeReactionUpdateManyWithWhereWithoutVideoInput = {
    where: YoutubeReactionScalarWhereInput
    data: XOR<YoutubeReactionUpdateManyMutationInput, YoutubeReactionUncheckedUpdateManyWithoutReactionsInput>
  }

  export type YoutubeUserCreateWithoutSubscribersInput = {
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutSubscribersInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutSubscribersInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutSubscribersInput, YoutubeUserUncheckedCreateWithoutSubscribersInput>
  }

  export type YoutubeChannelCreateWithoutSubscribersInput = {
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutChannelInput
    videos?: YoutubeVideoCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelUncheckedCreateWithoutSubscribersInput = {
    id?: number
    name: string
    descriptions: string
    image?: string | null
    coverImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutChannelInput
    videos?: YoutubeVideoUncheckedCreateNestedManyWithoutChannelInput
  }

  export type YoutubeChannelCreateOrConnectWithoutSubscribersInput = {
    where: YoutubeChannelWhereUniqueInput
    create: XOR<YoutubeChannelCreateWithoutSubscribersInput, YoutubeChannelUncheckedCreateWithoutSubscribersInput>
  }

  export type YoutubeUserUpsertWithoutSubscribersInput = {
    update: XOR<YoutubeUserUpdateWithoutSubscribersInput, YoutubeUserUncheckedUpdateWithoutSubscribersInput>
    create: XOR<YoutubeUserCreateWithoutSubscribersInput, YoutubeUserUncheckedCreateWithoutSubscribersInput>
  }

  export type YoutubeUserUpdateWithoutSubscribersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutSubscribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeChannelUpsertWithoutSubscribersInput = {
    update: XOR<YoutubeChannelUpdateWithoutSubscribersInput, YoutubeChannelUncheckedUpdateWithoutSubscribersInput>
    create: XOR<YoutubeChannelCreateWithoutSubscribersInput, YoutubeChannelUncheckedCreateWithoutSubscribersInput>
  }

  export type YoutubeChannelUpdateWithoutSubscribersInput = {
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutChannelNestedInput
    videos?: YoutubeVideoUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeChannelUncheckedUpdateWithoutSubscribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutChannelNestedInput
    videos?: YoutubeVideoUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type YoutubeUserCreateWithoutReactionsInput = {
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutReactionsInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutUserInput
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutReactionsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutReactionsInput, YoutubeUserUncheckedCreateWithoutReactionsInput>
  }

  export type YoutubeVideoCreateWithoutReactionsInput = {
    channel: YoutubeChannelCreateNestedOneWithoutVideosInput
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutReactionsInput = {
    id?: number
    channelId: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: YoutubeCommentUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutReactionsInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutReactionsInput, YoutubeVideoUncheckedCreateWithoutReactionsInput>
  }

  export type YoutubeUserUpsertWithoutReactionsInput = {
    update: XOR<YoutubeUserUpdateWithoutReactionsInput, YoutubeUserUncheckedUpdateWithoutReactionsInput>
    create: XOR<YoutubeUserCreateWithoutReactionsInput, YoutubeUserUncheckedCreateWithoutReactionsInput>
  }

  export type YoutubeUserUpdateWithoutReactionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutUserNestedInput
    comments?: YoutubeCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeVideoUpsertWithoutReactionsInput = {
    update: XOR<YoutubeVideoUpdateWithoutReactionsInput, YoutubeVideoUncheckedUpdateWithoutReactionsInput>
    create: XOR<YoutubeVideoCreateWithoutReactionsInput, YoutubeVideoUncheckedCreateWithoutReactionsInput>
  }

  export type YoutubeVideoUpdateWithoutReactionsInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutVideosNestedInput
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoCreateWithoutCommentsInput = {
    channel: YoutubeChannelCreateNestedOneWithoutVideosInput
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: YoutubeReactionCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoUncheckedCreateWithoutCommentsInput = {
    id?: number
    channelId: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutVideoInput
  }

  export type YoutubeVideoCreateOrConnectWithoutCommentsInput = {
    where: YoutubeVideoWhereUniqueInput
    create: XOR<YoutubeVideoCreateWithoutCommentsInput, YoutubeVideoUncheckedCreateWithoutCommentsInput>
  }

  export type YoutubeUserCreateWithoutCommentsInput = {
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserUncheckedCreateWithoutCommentsInput = {
    id?: number
    username: string
    email: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userToChannels?: YoutubeUserToChannelUncheckedCreateNestedManyWithoutUserInput
    subscribers?: YoutubeSubscriberUncheckedCreateNestedManyWithoutUserInput
    reactions?: YoutubeReactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type YoutubeUserCreateOrConnectWithoutCommentsInput = {
    where: YoutubeUserWhereUniqueInput
    create: XOR<YoutubeUserCreateWithoutCommentsInput, YoutubeUserUncheckedCreateWithoutCommentsInput>
  }

  export type YoutubeCommentCreateWithoutCommentPostsInput = {
    video: YoutubeVideoCreateNestedOneWithoutCommentsInput
    user: YoutubeUserCreateNestedOneWithoutCommentsInput
    commentTo?: YoutubeCommentCreateNestedOneWithoutCommentPostsInput
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentUncheckedCreateWithoutCommentPostsInput = {
    id?: number
    videoId: number
    userId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentCreateOrConnectWithoutCommentPostsInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutCommentPostsInput, YoutubeCommentUncheckedCreateWithoutCommentPostsInput>
  }

  export type YoutubeCommentCreateWithoutCommentToInput = {
    video: YoutubeVideoCreateNestedOneWithoutCommentsInput
    user: YoutubeUserCreateNestedOneWithoutCommentsInput
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentUncheckedCreateWithoutCommentToInput = {
    id?: number
    videoId: number
    userId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commentPosts?: YoutubeCommentUncheckedCreateNestedManyWithoutCommentToInput
  }

  export type YoutubeCommentCreateOrConnectWithoutCommentToInput = {
    where: YoutubeCommentWhereUniqueInput
    create: XOR<YoutubeCommentCreateWithoutCommentToInput, YoutubeCommentUncheckedCreateWithoutCommentToInput>
  }

  export type YoutubeCommentCreateManyCommentToInputEnvelope = {
    data: Enumerable<YoutubeCommentCreateManyCommentToInput>
    skipDuplicates?: boolean
  }

  export type YoutubeVideoUpsertWithoutCommentsInput = {
    update: XOR<YoutubeVideoUpdateWithoutCommentsInput, YoutubeVideoUncheckedUpdateWithoutCommentsInput>
    create: XOR<YoutubeVideoCreateWithoutCommentsInput, YoutubeVideoUncheckedCreateWithoutCommentsInput>
  }

  export type YoutubeVideoUpdateWithoutCommentsInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutVideosNestedInput
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeUserUpsertWithoutCommentsInput = {
    update: XOR<YoutubeUserUpdateWithoutCommentsInput, YoutubeUserUncheckedUpdateWithoutCommentsInput>
    create: XOR<YoutubeUserCreateWithoutCommentsInput, YoutubeUserUncheckedCreateWithoutCommentsInput>
  }

  export type YoutubeUserUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutUserNestedInput
  }

  export type YoutubeUserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userToChannels?: YoutubeUserToChannelUncheckedUpdateManyWithoutUserNestedInput
    subscribers?: YoutubeSubscriberUncheckedUpdateManyWithoutUserNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type YoutubeCommentUpsertWithoutCommentPostsInput = {
    update: XOR<YoutubeCommentUpdateWithoutCommentPostsInput, YoutubeCommentUncheckedUpdateWithoutCommentPostsInput>
    create: XOR<YoutubeCommentCreateWithoutCommentPostsInput, YoutubeCommentUncheckedCreateWithoutCommentPostsInput>
  }

  export type YoutubeCommentUpdateWithoutCommentPostsInput = {
    video?: YoutubeVideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: YoutubeUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: YoutubeCommentUpdateOneWithoutCommentPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUncheckedUpdateWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUpsertWithWhereUniqueWithoutCommentToInput = {
    where: YoutubeCommentWhereUniqueInput
    update: XOR<YoutubeCommentUpdateWithoutCommentToInput, YoutubeCommentUncheckedUpdateWithoutCommentToInput>
    create: XOR<YoutubeCommentCreateWithoutCommentToInput, YoutubeCommentUncheckedCreateWithoutCommentToInput>
  }

  export type YoutubeCommentUpdateWithWhereUniqueWithoutCommentToInput = {
    where: YoutubeCommentWhereUniqueInput
    data: XOR<YoutubeCommentUpdateWithoutCommentToInput, YoutubeCommentUncheckedUpdateWithoutCommentToInput>
  }

  export type YoutubeCommentUpdateManyWithWhereWithoutCommentToInput = {
    where: YoutubeCommentScalarWhereInput
    data: XOR<YoutubeCommentUpdateManyMutationInput, YoutubeCommentUncheckedUpdateManyWithoutCommentPostsInput>
  }

  export type LaundryMachineInStoreCreateWithoutBranchInput = {
    machine: LaunderMachineCreateNestedOneWithoutMachineInStoresInput
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUncheckedCreateWithoutBranchInput = {
    id?: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreCreateOrConnectWithoutBranchInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    create: XOR<LaundryMachineInStoreCreateWithoutBranchInput, LaundryMachineInStoreUncheckedCreateWithoutBranchInput>
  }

  export type LaundryMachineInStoreCreateManyBranchInputEnvelope = {
    data: Enumerable<LaundryMachineInStoreCreateManyBranchInput>
    skipDuplicates?: boolean
  }

  export type LaundryMachineInStoreUpsertWithWhereUniqueWithoutBranchInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    update: XOR<LaundryMachineInStoreUpdateWithoutBranchInput, LaundryMachineInStoreUncheckedUpdateWithoutBranchInput>
    create: XOR<LaundryMachineInStoreCreateWithoutBranchInput, LaundryMachineInStoreUncheckedCreateWithoutBranchInput>
  }

  export type LaundryMachineInStoreUpdateWithWhereUniqueWithoutBranchInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    data: XOR<LaundryMachineInStoreUpdateWithoutBranchInput, LaundryMachineInStoreUncheckedUpdateWithoutBranchInput>
  }

  export type LaundryMachineInStoreUpdateManyWithWhereWithoutBranchInput = {
    where: LaundryMachineInStoreScalarWhereInput
    data: XOR<LaundryMachineInStoreUpdateManyMutationInput, LaundryMachineInStoreUncheckedUpdateManyWithoutMachineInStoresInput>
  }

  export type LaundryMachineInStoreScalarWhereInput = {
    AND?: Enumerable<LaundryMachineInStoreScalarWhereInput>
    OR?: Enumerable<LaundryMachineInStoreScalarWhereInput>
    NOT?: Enumerable<LaundryMachineInStoreScalarWhereInput>
    id?: IntFilter | number
    branchId?: IntFilter | number
    machineId?: IntFilter | number
    mfd?: StringFilter | string
    Warranty?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaundryMachineInStoreCreateWithoutMachineInput = {
    branch: LaunderBranchInfoCreateNestedOneWithoutMachineInStoresInput
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUncheckedCreateWithoutMachineInput = {
    id?: number
    branchId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutMachineInput
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreCreateOrConnectWithoutMachineInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    create: XOR<LaundryMachineInStoreCreateWithoutMachineInput, LaundryMachineInStoreUncheckedCreateWithoutMachineInput>
  }

  export type LaundryMachineInStoreCreateManyMachineInputEnvelope = {
    data: Enumerable<LaundryMachineInStoreCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaunderServiceHistoryCreateWithoutMachineInput = {
    date: Date | string
    technician: LaunderTechnicianCreateNestedOneWithoutServiceHistoriesInput
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUncheckedCreateWithoutMachineInput = {
    id?: number
    date: Date | string
    technicianId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryCreateOrConnectWithoutMachineInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    create: XOR<LaunderServiceHistoryCreateWithoutMachineInput, LaunderServiceHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaunderServiceHistoryCreateManyMachineInputEnvelope = {
    data: Enumerable<LaunderServiceHistoryCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaundryMachineInStoreUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    update: XOR<LaundryMachineInStoreUpdateWithoutMachineInput, LaundryMachineInStoreUncheckedUpdateWithoutMachineInput>
    create: XOR<LaundryMachineInStoreCreateWithoutMachineInput, LaundryMachineInStoreUncheckedCreateWithoutMachineInput>
  }

  export type LaundryMachineInStoreUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    data: XOR<LaundryMachineInStoreUpdateWithoutMachineInput, LaundryMachineInStoreUncheckedUpdateWithoutMachineInput>
  }

  export type LaundryMachineInStoreUpdateManyWithWhereWithoutMachineInput = {
    where: LaundryMachineInStoreScalarWhereInput
    data: XOR<LaundryMachineInStoreUpdateManyMutationInput, LaundryMachineInStoreUncheckedUpdateManyWithoutMachineInStoresInput>
  }

  export type LaunderServiceHistoryUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    update: XOR<LaunderServiceHistoryUpdateWithoutMachineInput, LaunderServiceHistoryUncheckedUpdateWithoutMachineInput>
    create: XOR<LaunderServiceHistoryCreateWithoutMachineInput, LaunderServiceHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaunderServiceHistoryUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    data: XOR<LaunderServiceHistoryUpdateWithoutMachineInput, LaunderServiceHistoryUncheckedUpdateWithoutMachineInput>
  }

  export type LaunderServiceHistoryUpdateManyWithWhereWithoutMachineInput = {
    where: LaunderServiceHistoryScalarWhereInput
    data: XOR<LaunderServiceHistoryUpdateManyMutationInput, LaunderServiceHistoryUncheckedUpdateManyWithoutServiceHistoriesInput>
  }

  export type LaunderServiceHistoryScalarWhereInput = {
    AND?: Enumerable<LaunderServiceHistoryScalarWhereInput>
    OR?: Enumerable<LaunderServiceHistoryScalarWhereInput>
    NOT?: Enumerable<LaunderServiceHistoryScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    machineId?: IntFilter | number
    technicianId?: IntFilter | number
    descriptions?: StringFilter | string
    image?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaunderBranchInfoCreateWithoutMachineInStoresInput = {
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderBranchInfoUncheckedCreateWithoutMachineInStoresInput = {
    id?: number
    owner: string
    phone: number
    location: string
    areaSize: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderBranchInfoCreateOrConnectWithoutMachineInStoresInput = {
    where: LaunderBranchInfoWhereUniqueInput
    create: XOR<LaunderBranchInfoCreateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedCreateWithoutMachineInStoresInput>
  }

  export type LaunderMachineCreateWithoutMachineInStoresInput = {
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceHistories?: LaunderServiceHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineUncheckedCreateWithoutMachineInStoresInput = {
    id?: number
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceHistories?: LaunderServiceHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineCreateOrConnectWithoutMachineInStoresInput = {
    where: LaunderMachineWhereUniqueInput
    create: XOR<LaunderMachineCreateWithoutMachineInStoresInput, LaunderMachineUncheckedCreateWithoutMachineInStoresInput>
  }

  export type LaunderProgramInMachineCreateWithoutMachineInput = {
    program: LaunderWashingProgramCreateNestedOneWithoutProgramInMachinesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUncheckedCreateWithoutMachineInput = {
    id?: number
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineCreateOrConnectWithoutMachineInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    create: XOR<LaunderProgramInMachineCreateWithoutMachineInput, LaunderProgramInMachineUncheckedCreateWithoutMachineInput>
  }

  export type LaunderProgramInMachineCreateManyMachineInputEnvelope = {
    data: Enumerable<LaunderProgramInMachineCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaundryWashingHistoryCreateWithoutMachineInput = {
    program: LaunderWashingProgramCreateNestedOneWithoutWashingHistoriesInput
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryUncheckedCreateWithoutMachineInput = {
    id?: number
    programId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryCreateOrConnectWithoutMachineInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    create: XOR<LaundryWashingHistoryCreateWithoutMachineInput, LaundryWashingHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaundryWashingHistoryCreateManyMachineInputEnvelope = {
    data: Enumerable<LaundryWashingHistoryCreateManyMachineInput>
    skipDuplicates?: boolean
  }

  export type LaunderBranchInfoUpsertWithoutMachineInStoresInput = {
    update: XOR<LaunderBranchInfoUpdateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedUpdateWithoutMachineInStoresInput>
    create: XOR<LaunderBranchInfoCreateWithoutMachineInStoresInput, LaunderBranchInfoUncheckedCreateWithoutMachineInStoresInput>
  }

  export type LaunderBranchInfoUpdateWithoutMachineInStoresInput = {
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderBranchInfoUncheckedUpdateWithoutMachineInStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    areaSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderMachineUpsertWithoutMachineInStoresInput = {
    update: XOR<LaunderMachineUpdateWithoutMachineInStoresInput, LaunderMachineUncheckedUpdateWithoutMachineInStoresInput>
    create: XOR<LaunderMachineCreateWithoutMachineInStoresInput, LaunderMachineUncheckedCreateWithoutMachineInStoresInput>
  }

  export type LaunderMachineUpdateWithoutMachineInStoresInput = {
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceHistories?: LaunderServiceHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaunderMachineUncheckedUpdateWithoutMachineInStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceHistories?: LaunderServiceHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderProgramInMachineUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    update: XOR<LaunderProgramInMachineUpdateWithoutMachineInput, LaunderProgramInMachineUncheckedUpdateWithoutMachineInput>
    create: XOR<LaunderProgramInMachineCreateWithoutMachineInput, LaunderProgramInMachineUncheckedCreateWithoutMachineInput>
  }

  export type LaunderProgramInMachineUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    data: XOR<LaunderProgramInMachineUpdateWithoutMachineInput, LaunderProgramInMachineUncheckedUpdateWithoutMachineInput>
  }

  export type LaunderProgramInMachineUpdateManyWithWhereWithoutMachineInput = {
    where: LaunderProgramInMachineScalarWhereInput
    data: XOR<LaunderProgramInMachineUpdateManyMutationInput, LaunderProgramInMachineUncheckedUpdateManyWithoutProgramInMachinesInput>
  }

  export type LaunderProgramInMachineScalarWhereInput = {
    AND?: Enumerable<LaunderProgramInMachineScalarWhereInput>
    OR?: Enumerable<LaunderProgramInMachineScalarWhereInput>
    NOT?: Enumerable<LaunderProgramInMachineScalarWhereInput>
    id?: IntFilter | number
    machineId?: IntFilter | number
    programId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaundryWashingHistoryUpsertWithWhereUniqueWithoutMachineInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    update: XOR<LaundryWashingHistoryUpdateWithoutMachineInput, LaundryWashingHistoryUncheckedUpdateWithoutMachineInput>
    create: XOR<LaundryWashingHistoryCreateWithoutMachineInput, LaundryWashingHistoryUncheckedCreateWithoutMachineInput>
  }

  export type LaundryWashingHistoryUpdateWithWhereUniqueWithoutMachineInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    data: XOR<LaundryWashingHistoryUpdateWithoutMachineInput, LaundryWashingHistoryUncheckedUpdateWithoutMachineInput>
  }

  export type LaundryWashingHistoryUpdateManyWithWhereWithoutMachineInput = {
    where: LaundryWashingHistoryScalarWhereInput
    data: XOR<LaundryWashingHistoryUpdateManyMutationInput, LaundryWashingHistoryUncheckedUpdateManyWithoutWashingHistoriesInput>
  }

  export type LaundryWashingHistoryScalarWhereInput = {
    AND?: Enumerable<LaundryWashingHistoryScalarWhereInput>
    OR?: Enumerable<LaundryWashingHistoryScalarWhereInput>
    NOT?: Enumerable<LaundryWashingHistoryScalarWhereInput>
    id?: IntFilter | number
    machineId?: IntFilter | number
    programId?: IntFilter | number
    date?: DateTimeFilter | Date | string
    price?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaunderServiceHistoryCreateWithoutTechnicianInput = {
    date: Date | string
    machine: LaunderMachineCreateNestedOneWithoutServiceHistoriesInput
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput = {
    id?: number
    date: Date | string
    machineId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryCreateOrConnectWithoutTechnicianInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    create: XOR<LaunderServiceHistoryCreateWithoutTechnicianInput, LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>
  }

  export type LaunderServiceHistoryCreateManyTechnicianInputEnvelope = {
    data: Enumerable<LaunderServiceHistoryCreateManyTechnicianInput>
    skipDuplicates?: boolean
  }

  export type LaunderServiceHistoryUpsertWithWhereUniqueWithoutTechnicianInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    update: XOR<LaunderServiceHistoryUpdateWithoutTechnicianInput, LaunderServiceHistoryUncheckedUpdateWithoutTechnicianInput>
    create: XOR<LaunderServiceHistoryCreateWithoutTechnicianInput, LaunderServiceHistoryUncheckedCreateWithoutTechnicianInput>
  }

  export type LaunderServiceHistoryUpdateWithWhereUniqueWithoutTechnicianInput = {
    where: LaunderServiceHistoryWhereUniqueInput
    data: XOR<LaunderServiceHistoryUpdateWithoutTechnicianInput, LaunderServiceHistoryUncheckedUpdateWithoutTechnicianInput>
  }

  export type LaunderServiceHistoryUpdateManyWithWhereWithoutTechnicianInput = {
    where: LaunderServiceHistoryScalarWhereInput
    data: XOR<LaunderServiceHistoryUpdateManyMutationInput, LaunderServiceHistoryUncheckedUpdateManyWithoutServiceHistoriesInput>
  }

  export type LaunderMachineCreateWithoutServiceHistoriesInput = {
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineUncheckedCreateWithoutServiceHistoriesInput = {
    id?: number
    brand: string
    Capacity: number
    type: string
    serialNumber: number
    createdAt?: Date | string
    updatedAt?: Date | string
    machineInStores?: LaundryMachineInStoreUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaunderMachineCreateOrConnectWithoutServiceHistoriesInput = {
    where: LaunderMachineWhereUniqueInput
    create: XOR<LaunderMachineCreateWithoutServiceHistoriesInput, LaunderMachineUncheckedCreateWithoutServiceHistoriesInput>
  }

  export type LaunderTechnicianCreateWithoutServiceHistoriesInput = {
    firstName: string
    lastName: string
    image?: string | null
    phone: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderTechnicianUncheckedCreateWithoutServiceHistoriesInput = {
    id?: number
    firstName: string
    lastName: string
    image?: string | null
    phone: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderTechnicianCreateOrConnectWithoutServiceHistoriesInput = {
    where: LaunderTechnicianWhereUniqueInput
    create: XOR<LaunderTechnicianCreateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedCreateWithoutServiceHistoriesInput>
  }

  export type LaunderMachineUpsertWithoutServiceHistoriesInput = {
    update: XOR<LaunderMachineUpdateWithoutServiceHistoriesInput, LaunderMachineUncheckedUpdateWithoutServiceHistoriesInput>
    create: XOR<LaunderMachineCreateWithoutServiceHistoriesInput, LaunderMachineUncheckedCreateWithoutServiceHistoriesInput>
  }

  export type LaunderMachineUpdateWithoutServiceHistoriesInput = {
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUpdateManyWithoutMachineNestedInput
  }

  export type LaunderMachineUncheckedUpdateWithoutServiceHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    Capacity?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    serialNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machineInStores?: LaundryMachineInStoreUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderTechnicianUpsertWithoutServiceHistoriesInput = {
    update: XOR<LaunderTechnicianUpdateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedUpdateWithoutServiceHistoriesInput>
    create: XOR<LaunderTechnicianCreateWithoutServiceHistoriesInput, LaunderTechnicianUncheckedCreateWithoutServiceHistoriesInput>
  }

  export type LaunderTechnicianUpdateWithoutServiceHistoriesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderTechnicianUncheckedUpdateWithoutServiceHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineCreateWithoutProgramInput = {
    machine: LaundryMachineInStoreCreateNestedOneWithoutProgramInMachinesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUncheckedCreateWithoutProgramInput = {
    id?: number
    machineId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineCreateOrConnectWithoutProgramInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    create: XOR<LaunderProgramInMachineCreateWithoutProgramInput, LaunderProgramInMachineUncheckedCreateWithoutProgramInput>
  }

  export type LaunderProgramInMachineCreateManyProgramInputEnvelope = {
    data: Enumerable<LaunderProgramInMachineCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type LaundryWashingHistoryCreateWithoutProgramInput = {
    machine: LaundryMachineInStoreCreateNestedOneWithoutWashingHistoriesInput
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryUncheckedCreateWithoutProgramInput = {
    id?: number
    machineId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryCreateOrConnectWithoutProgramInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    create: XOR<LaundryWashingHistoryCreateWithoutProgramInput, LaundryWashingHistoryUncheckedCreateWithoutProgramInput>
  }

  export type LaundryWashingHistoryCreateManyProgramInputEnvelope = {
    data: Enumerable<LaundryWashingHistoryCreateManyProgramInput>
    skipDuplicates?: boolean
  }

  export type LaunderProgramInMachineUpsertWithWhereUniqueWithoutProgramInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    update: XOR<LaunderProgramInMachineUpdateWithoutProgramInput, LaunderProgramInMachineUncheckedUpdateWithoutProgramInput>
    create: XOR<LaunderProgramInMachineCreateWithoutProgramInput, LaunderProgramInMachineUncheckedCreateWithoutProgramInput>
  }

  export type LaunderProgramInMachineUpdateWithWhereUniqueWithoutProgramInput = {
    where: LaunderProgramInMachineWhereUniqueInput
    data: XOR<LaunderProgramInMachineUpdateWithoutProgramInput, LaunderProgramInMachineUncheckedUpdateWithoutProgramInput>
  }

  export type LaunderProgramInMachineUpdateManyWithWhereWithoutProgramInput = {
    where: LaunderProgramInMachineScalarWhereInput
    data: XOR<LaunderProgramInMachineUpdateManyMutationInput, LaunderProgramInMachineUncheckedUpdateManyWithoutProgramInMachinesInput>
  }

  export type LaundryWashingHistoryUpsertWithWhereUniqueWithoutProgramInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    update: XOR<LaundryWashingHistoryUpdateWithoutProgramInput, LaundryWashingHistoryUncheckedUpdateWithoutProgramInput>
    create: XOR<LaundryWashingHistoryCreateWithoutProgramInput, LaundryWashingHistoryUncheckedCreateWithoutProgramInput>
  }

  export type LaundryWashingHistoryUpdateWithWhereUniqueWithoutProgramInput = {
    where: LaundryWashingHistoryWhereUniqueInput
    data: XOR<LaundryWashingHistoryUpdateWithoutProgramInput, LaundryWashingHistoryUncheckedUpdateWithoutProgramInput>
  }

  export type LaundryWashingHistoryUpdateManyWithWhereWithoutProgramInput = {
    where: LaundryWashingHistoryScalarWhereInput
    data: XOR<LaundryWashingHistoryUpdateManyMutationInput, LaundryWashingHistoryUncheckedUpdateManyWithoutWashingHistoriesInput>
  }

  export type LaundryMachineInStoreCreateWithoutProgramInMachinesInput = {
    branch: LaunderBranchInfoCreateNestedOneWithoutMachineInStoresInput
    machine: LaunderMachineCreateNestedOneWithoutMachineInStoresInput
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUncheckedCreateWithoutProgramInMachinesInput = {
    id?: number
    branchId: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreCreateOrConnectWithoutProgramInMachinesInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    create: XOR<LaundryMachineInStoreCreateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedCreateWithoutProgramInMachinesInput>
  }

  export type LaunderWashingProgramCreateWithoutProgramInMachinesInput = {
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    washingHistories?: LaundryWashingHistoryCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramUncheckedCreateWithoutProgramInMachinesInput = {
    id?: number
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    washingHistories?: LaundryWashingHistoryUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramCreateOrConnectWithoutProgramInMachinesInput = {
    where: LaunderWashingProgramWhereUniqueInput
    create: XOR<LaunderWashingProgramCreateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedCreateWithoutProgramInMachinesInput>
  }

  export type LaundryMachineInStoreUpsertWithoutProgramInMachinesInput = {
    update: XOR<LaundryMachineInStoreUpdateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedUpdateWithoutProgramInMachinesInput>
    create: XOR<LaundryMachineInStoreCreateWithoutProgramInMachinesInput, LaundryMachineInStoreUncheckedCreateWithoutProgramInMachinesInput>
  }

  export type LaundryMachineInStoreUpdateWithoutProgramInMachinesInput = {
    branch?: LaunderBranchInfoUpdateOneRequiredWithoutMachineInStoresNestedInput
    machine?: LaunderMachineUpdateOneRequiredWithoutMachineInStoresNestedInput
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateWithoutProgramInMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderWashingProgramUpsertWithoutProgramInMachinesInput = {
    update: XOR<LaunderWashingProgramUpdateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedUpdateWithoutProgramInMachinesInput>
    create: XOR<LaunderWashingProgramCreateWithoutProgramInMachinesInput, LaunderWashingProgramUncheckedCreateWithoutProgramInMachinesInput>
  }

  export type LaunderWashingProgramUpdateWithoutProgramInMachinesInput = {
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutProgramNestedInput
  }

  export type LaunderWashingProgramUncheckedUpdateWithoutProgramInMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LaundryTopupHistoryCreateWithoutUserInput = {
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryCreateOrConnectWithoutUserInput = {
    where: LaundryTopupHistoryWhereUniqueInput
    create: XOR<LaundryTopupHistoryCreateWithoutUserInput, LaundryTopupHistoryUncheckedCreateWithoutUserInput>
  }

  export type LaundryTopupHistoryCreateManyUserInputEnvelope = {
    data: Enumerable<LaundryTopupHistoryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LaundryTopupHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: LaundryTopupHistoryWhereUniqueInput
    update: XOR<LaundryTopupHistoryUpdateWithoutUserInput, LaundryTopupHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<LaundryTopupHistoryCreateWithoutUserInput, LaundryTopupHistoryUncheckedCreateWithoutUserInput>
  }

  export type LaundryTopupHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: LaundryTopupHistoryWhereUniqueInput
    data: XOR<LaundryTopupHistoryUpdateWithoutUserInput, LaundryTopupHistoryUncheckedUpdateWithoutUserInput>
  }

  export type LaundryTopupHistoryUpdateManyWithWhereWithoutUserInput = {
    where: LaundryTopupHistoryScalarWhereInput
    data: XOR<LaundryTopupHistoryUpdateManyMutationInput, LaundryTopupHistoryUncheckedUpdateManyWithoutTopupHistoriesInput>
  }

  export type LaundryTopupHistoryScalarWhereInput = {
    AND?: Enumerable<LaundryTopupHistoryScalarWhereInput>
    OR?: Enumerable<LaundryTopupHistoryScalarWhereInput>
    NOT?: Enumerable<LaundryTopupHistoryScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    value?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LaunderUserCreateWithoutTopupHistoriesInput = {
    username: string
    phone: number
    walletBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderUserUncheckedCreateWithoutTopupHistoriesInput = {
    id?: number
    username: string
    phone: number
    walletBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderUserCreateOrConnectWithoutTopupHistoriesInput = {
    where: LaunderUserWhereUniqueInput
    create: XOR<LaunderUserCreateWithoutTopupHistoriesInput, LaunderUserUncheckedCreateWithoutTopupHistoriesInput>
  }

  export type LaunderUserUpsertWithoutTopupHistoriesInput = {
    update: XOR<LaunderUserUpdateWithoutTopupHistoriesInput, LaunderUserUncheckedUpdateWithoutTopupHistoriesInput>
    create: XOR<LaunderUserCreateWithoutTopupHistoriesInput, LaunderUserUncheckedCreateWithoutTopupHistoriesInput>
  }

  export type LaunderUserUpdateWithoutTopupHistoriesInput = {
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderUserUncheckedUpdateWithoutTopupHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    phone?: IntFieldUpdateOperationsInput | number
    walletBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMachineInStoreCreateWithoutWashingHistoriesInput = {
    branch: LaunderBranchInfoCreateNestedOneWithoutMachineInStoresInput
    machine: LaunderMachineCreateNestedOneWithoutMachineInStoresInput
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreUncheckedCreateWithoutWashingHistoriesInput = {
    id?: number
    branchId: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutMachineInput
  }

  export type LaundryMachineInStoreCreateOrConnectWithoutWashingHistoriesInput = {
    where: LaundryMachineInStoreWhereUniqueInput
    create: XOR<LaundryMachineInStoreCreateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedCreateWithoutWashingHistoriesInput>
  }

  export type LaunderWashingProgramCreateWithoutWashingHistoriesInput = {
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramUncheckedCreateWithoutWashingHistoriesInput = {
    id?: number
    program: string
    price: number
    duration: number
    capacityLimit: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programInMachines?: LaunderProgramInMachineUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LaunderWashingProgramCreateOrConnectWithoutWashingHistoriesInput = {
    where: LaunderWashingProgramWhereUniqueInput
    create: XOR<LaunderWashingProgramCreateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedCreateWithoutWashingHistoriesInput>
  }

  export type LaundryMachineInStoreUpsertWithoutWashingHistoriesInput = {
    update: XOR<LaundryMachineInStoreUpdateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedUpdateWithoutWashingHistoriesInput>
    create: XOR<LaundryMachineInStoreCreateWithoutWashingHistoriesInput, LaundryMachineInStoreUncheckedCreateWithoutWashingHistoriesInput>
  }

  export type LaundryMachineInStoreUpdateWithoutWashingHistoriesInput = {
    branch?: LaunderBranchInfoUpdateOneRequiredWithoutMachineInStoresNestedInput
    machine?: LaunderMachineUpdateOneRequiredWithoutMachineInStoresNestedInput
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateWithoutWashingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderWashingProgramUpsertWithoutWashingHistoriesInput = {
    update: XOR<LaunderWashingProgramUpdateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedUpdateWithoutWashingHistoriesInput>
    create: XOR<LaunderWashingProgramCreateWithoutWashingHistoriesInput, LaunderWashingProgramUncheckedCreateWithoutWashingHistoriesInput>
  }

  export type LaunderWashingProgramUpdateWithoutWashingHistoriesInput = {
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutProgramNestedInput
  }

  export type LaunderWashingProgramUncheckedUpdateWithoutWashingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    program?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    capacityLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LibraryRequestCreateWithoutStudentInput = {
    borrowDate: Date | string
    returnDate: Date | string
    book: LibraryBookCreateNestedOneWithoutRequestsInput
    fromUniversity: LibraryUniversityCreateNestedOneWithoutFromRequestsInput
    toUniversity: LibraryUniversityCreateNestedOneWithoutToRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutStudentInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateOrConnectWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutStudentInput, LibraryRequestUncheckedCreateWithoutStudentInput>
  }

  export type LibraryRequestCreateManyStudentInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type LibraryBorrowingCreateWithoutStudentInput = {
    book: LibraryBookCreateNestedOneWithoutBorrowingsInput
    university: LibraryUniversityCreateNestedOneWithoutBorrowingsInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUncheckedCreateWithoutStudentInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateOrConnectWithoutStudentInput = {
    where: LibraryBorrowingWhereUniqueInput
    create: XOR<LibraryBorrowingCreateWithoutStudentInput, LibraryBorrowingUncheckedCreateWithoutStudentInput>
  }

  export type LibraryBorrowingCreateManyStudentInputEnvelope = {
    data: Enumerable<LibraryBorrowingCreateManyStudentInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutStudentInput, LibraryRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<LibraryRequestCreateWithoutStudentInput, LibraryRequestUncheckedCreateWithoutStudentInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutStudentInput, LibraryRequestUncheckedUpdateWithoutStudentInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutStudentInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type LibraryRequestScalarWhereInput = {
    AND?: Enumerable<LibraryRequestScalarWhereInput>
    OR?: Enumerable<LibraryRequestScalarWhereInput>
    NOT?: Enumerable<LibraryRequestScalarWhereInput>
    id?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    bookId?: IntFilter | number
    studentId?: IntFilter | number
    fromUniversityId?: IntFilter | number
    toUniversityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBorrowingUpsertWithWhereUniqueWithoutStudentInput = {
    where: LibraryBorrowingWhereUniqueInput
    update: XOR<LibraryBorrowingUpdateWithoutStudentInput, LibraryBorrowingUncheckedUpdateWithoutStudentInput>
    create: XOR<LibraryBorrowingCreateWithoutStudentInput, LibraryBorrowingUncheckedCreateWithoutStudentInput>
  }

  export type LibraryBorrowingUpdateWithWhereUniqueWithoutStudentInput = {
    where: LibraryBorrowingWhereUniqueInput
    data: XOR<LibraryBorrowingUpdateWithoutStudentInput, LibraryBorrowingUncheckedUpdateWithoutStudentInput>
  }

  export type LibraryBorrowingUpdateManyWithWhereWithoutStudentInput = {
    where: LibraryBorrowingScalarWhereInput
    data: XOR<LibraryBorrowingUpdateManyMutationInput, LibraryBorrowingUncheckedUpdateManyWithoutBorrowingsInput>
  }

  export type LibraryBorrowingScalarWhereInput = {
    AND?: Enumerable<LibraryBorrowingScalarWhereInput>
    OR?: Enumerable<LibraryBorrowingScalarWhereInput>
    NOT?: Enumerable<LibraryBorrowingScalarWhereInput>
    id?: IntFilter | number
    bookId?: IntFilter | number
    borrowDate?: DateTimeFilter | Date | string
    returnDate?: DateTimeFilter | Date | string
    actualReturnDate?: DateTimeFilter | Date | string
    studentId?: IntFilter | number
    universityId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookCopyCreateWithoutUniversityInput = {
    book: LibraryBookCreateNestedOneWithoutBookCopiesInput
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUncheckedCreateWithoutUniversityInput = {
    id?: number
    bookId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyCreateOrConnectWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutUniversityInput, LibraryBookCopyUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBookCopyCreateManyUniversityInputEnvelope = {
    data: Enumerable<LibraryBookCopyCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutFromUniversityInput = {
    borrowDate: Date | string
    returnDate: Date | string
    book: LibraryBookCreateNestedOneWithoutRequestsInput
    student: LibraryStudentCreateNestedOneWithoutRequestsInput
    toUniversity: LibraryUniversityCreateNestedOneWithoutToRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutFromUniversityInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateOrConnectWithoutFromUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutFromUniversityInput, LibraryRequestUncheckedCreateWithoutFromUniversityInput>
  }

  export type LibraryRequestCreateManyFromUniversityInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyFromUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutToUniversityInput = {
    borrowDate: Date | string
    returnDate: Date | string
    book: LibraryBookCreateNestedOneWithoutRequestsInput
    student: LibraryStudentCreateNestedOneWithoutRequestsInput
    fromUniversity: LibraryUniversityCreateNestedOneWithoutFromRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutToUniversityInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    fromUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateOrConnectWithoutToUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutToUniversityInput, LibraryRequestUncheckedCreateWithoutToUniversityInput>
  }

  export type LibraryRequestCreateManyToUniversityInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyToUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryBorrowingCreateWithoutUniversityInput = {
    book: LibraryBookCreateNestedOneWithoutBorrowingsInput
    student: LibraryStudentCreateNestedOneWithoutBorrowingsInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUncheckedCreateWithoutUniversityInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateOrConnectWithoutUniversityInput = {
    where: LibraryBorrowingWhereUniqueInput
    create: XOR<LibraryBorrowingCreateWithoutUniversityInput, LibraryBorrowingUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBorrowingCreateManyUniversityInputEnvelope = {
    data: Enumerable<LibraryBorrowingCreateManyUniversityInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCopyUpsertWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    update: XOR<LibraryBookCopyUpdateWithoutUniversityInput, LibraryBookCopyUncheckedUpdateWithoutUniversityInput>
    create: XOR<LibraryBookCopyCreateWithoutUniversityInput, LibraryBookCopyUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBookCopyUpdateWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBookCopyWhereUniqueInput
    data: XOR<LibraryBookCopyUpdateWithoutUniversityInput, LibraryBookCopyUncheckedUpdateWithoutUniversityInput>
  }

  export type LibraryBookCopyUpdateManyWithWhereWithoutUniversityInput = {
    where: LibraryBookCopyScalarWhereInput
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyWithoutBookCopiesInput>
  }

  export type LibraryBookCopyScalarWhereInput = {
    AND?: Enumerable<LibraryBookCopyScalarWhereInput>
    OR?: Enumerable<LibraryBookCopyScalarWhereInput>
    NOT?: Enumerable<LibraryBookCopyScalarWhereInput>
    id?: IntFilter | number
    bookId?: IntFilter | number
    universityId?: IntFilter | number
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutFromUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutFromUniversityInput, LibraryRequestUncheckedUpdateWithoutFromUniversityInput>
    create: XOR<LibraryRequestCreateWithoutFromUniversityInput, LibraryRequestUncheckedCreateWithoutFromUniversityInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutFromUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutFromUniversityInput, LibraryRequestUncheckedUpdateWithoutFromUniversityInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutFromUniversityInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutFromRequestsInput>
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutToUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutToUniversityInput, LibraryRequestUncheckedUpdateWithoutToUniversityInput>
    create: XOR<LibraryRequestCreateWithoutToUniversityInput, LibraryRequestUncheckedCreateWithoutToUniversityInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutToUniversityInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutToUniversityInput, LibraryRequestUncheckedUpdateWithoutToUniversityInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutToUniversityInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutToRequestsInput>
  }

  export type LibraryBorrowingUpsertWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBorrowingWhereUniqueInput
    update: XOR<LibraryBorrowingUpdateWithoutUniversityInput, LibraryBorrowingUncheckedUpdateWithoutUniversityInput>
    create: XOR<LibraryBorrowingCreateWithoutUniversityInput, LibraryBorrowingUncheckedCreateWithoutUniversityInput>
  }

  export type LibraryBorrowingUpdateWithWhereUniqueWithoutUniversityInput = {
    where: LibraryBorrowingWhereUniqueInput
    data: XOR<LibraryBorrowingUpdateWithoutUniversityInput, LibraryBorrowingUncheckedUpdateWithoutUniversityInput>
  }

  export type LibraryBorrowingUpdateManyWithWhereWithoutUniversityInput = {
    where: LibraryBorrowingScalarWhereInput
    data: XOR<LibraryBorrowingUpdateManyMutationInput, LibraryBorrowingUncheckedUpdateManyWithoutBorrowingsInput>
  }

  export type LibraryBookCategoryCreateWithoutCategoryInput = {
    book: LibraryBookCreateNestedOneWithoutBookCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryCreateOrConnectWithoutCategoryInput = {
    where: LibraryBookCategoryWhereUniqueInput
    create: XOR<LibraryBookCategoryCreateWithoutCategoryInput, LibraryBookCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type LibraryBookCategoryCreateManyCategoryInputEnvelope = {
    data: Enumerable<LibraryBookCategoryCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: LibraryBookCategoryWhereUniqueInput
    update: XOR<LibraryBookCategoryUpdateWithoutCategoryInput, LibraryBookCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<LibraryBookCategoryCreateWithoutCategoryInput, LibraryBookCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type LibraryBookCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: LibraryBookCategoryWhereUniqueInput
    data: XOR<LibraryBookCategoryUpdateWithoutCategoryInput, LibraryBookCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type LibraryBookCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: LibraryBookCategoryScalarWhereInput
    data: XOR<LibraryBookCategoryUpdateManyMutationInput, LibraryBookCategoryUncheckedUpdateManyWithoutBookCategoriesInput>
  }

  export type LibraryBookCategoryScalarWhereInput = {
    AND?: Enumerable<LibraryBookCategoryScalarWhereInput>
    OR?: Enumerable<LibraryBookCategoryScalarWhereInput>
    NOT?: Enumerable<LibraryBookCategoryScalarWhereInput>
    id?: IntFilter | number
    bookId?: IntFilter | number
    categoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookAuthorCreateWithoutAuthorInput = {
    book: LibraryBookCreateNestedOneWithoutBookAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUncheckedCreateWithoutAuthorInput = {
    id?: number
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorCreateOrConnectWithoutAuthorInput = {
    where: LibraryBookAuthorWhereUniqueInput
    create: XOR<LibraryBookAuthorCreateWithoutAuthorInput, LibraryBookAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type LibraryBookAuthorCreateManyAuthorInputEnvelope = {
    data: Enumerable<LibraryBookAuthorCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookAuthorUpsertWithWhereUniqueWithoutAuthorInput = {
    where: LibraryBookAuthorWhereUniqueInput
    update: XOR<LibraryBookAuthorUpdateWithoutAuthorInput, LibraryBookAuthorUncheckedUpdateWithoutAuthorInput>
    create: XOR<LibraryBookAuthorCreateWithoutAuthorInput, LibraryBookAuthorUncheckedCreateWithoutAuthorInput>
  }

  export type LibraryBookAuthorUpdateWithWhereUniqueWithoutAuthorInput = {
    where: LibraryBookAuthorWhereUniqueInput
    data: XOR<LibraryBookAuthorUpdateWithoutAuthorInput, LibraryBookAuthorUncheckedUpdateWithoutAuthorInput>
  }

  export type LibraryBookAuthorUpdateManyWithWhereWithoutAuthorInput = {
    where: LibraryBookAuthorScalarWhereInput
    data: XOR<LibraryBookAuthorUpdateManyMutationInput, LibraryBookAuthorUncheckedUpdateManyWithoutBookAuthorsInput>
  }

  export type LibraryBookAuthorScalarWhereInput = {
    AND?: Enumerable<LibraryBookAuthorScalarWhereInput>
    OR?: Enumerable<LibraryBookAuthorScalarWhereInput>
    NOT?: Enumerable<LibraryBookAuthorScalarWhereInput>
    id?: IntFilter | number
    bookId?: IntFilter | number
    authorId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type LibraryBookCategoryCreateWithoutBookInput = {
    category: LibraryCategoryCreateNestedOneWithoutBookCategoriesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUncheckedCreateWithoutBookInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryCreateOrConnectWithoutBookInput = {
    where: LibraryBookCategoryWhereUniqueInput
    create: XOR<LibraryBookCategoryCreateWithoutBookInput, LibraryBookCategoryUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCategoryCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBookCategoryCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookAuthorCreateWithoutBookInput = {
    author: LibraryAuthorCreateNestedOneWithoutBookAuthorsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUncheckedCreateWithoutBookInput = {
    id?: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorCreateOrConnectWithoutBookInput = {
    where: LibraryBookAuthorWhereUniqueInput
    create: XOR<LibraryBookAuthorCreateWithoutBookInput, LibraryBookAuthorUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookAuthorCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBookAuthorCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCopyCreateWithoutBookInput = {
    university: LibraryUniversityCreateNestedOneWithoutBookCopiesInput
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUncheckedCreateWithoutBookInput = {
    id?: number
    universityId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyCreateOrConnectWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    create: XOR<LibraryBookCopyCreateWithoutBookInput, LibraryBookCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCopyCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBookCopyCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryRequestCreateWithoutBookInput = {
    borrowDate: Date | string
    returnDate: Date | string
    student: LibraryStudentCreateNestedOneWithoutRequestsInput
    fromUniversity: LibraryUniversityCreateNestedOneWithoutFromRequestsInput
    toUniversity: LibraryUniversityCreateNestedOneWithoutToRequestsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUncheckedCreateWithoutBookInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateOrConnectWithoutBookInput = {
    where: LibraryRequestWhereUniqueInput
    create: XOR<LibraryRequestCreateWithoutBookInput, LibraryRequestUncheckedCreateWithoutBookInput>
  }

  export type LibraryRequestCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryRequestCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBorrowingCreateWithoutBookInput = {
    student: LibraryStudentCreateNestedOneWithoutBorrowingsInput
    university: LibraryUniversityCreateNestedOneWithoutBorrowingsInput
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingUncheckedCreateWithoutBookInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateOrConnectWithoutBookInput = {
    where: LibraryBorrowingWhereUniqueInput
    create: XOR<LibraryBorrowingCreateWithoutBookInput, LibraryBorrowingUncheckedCreateWithoutBookInput>
  }

  export type LibraryBorrowingCreateManyBookInputEnvelope = {
    data: Enumerable<LibraryBorrowingCreateManyBookInput>
    skipDuplicates?: boolean
  }

  export type LibraryBookCategoryUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCategoryWhereUniqueInput
    update: XOR<LibraryBookCategoryUpdateWithoutBookInput, LibraryBookCategoryUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBookCategoryCreateWithoutBookInput, LibraryBookCategoryUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCategoryUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCategoryWhereUniqueInput
    data: XOR<LibraryBookCategoryUpdateWithoutBookInput, LibraryBookCategoryUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBookCategoryUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBookCategoryScalarWhereInput
    data: XOR<LibraryBookCategoryUpdateManyMutationInput, LibraryBookCategoryUncheckedUpdateManyWithoutBookCategoriesInput>
  }

  export type LibraryBookAuthorUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBookAuthorWhereUniqueInput
    update: XOR<LibraryBookAuthorUpdateWithoutBookInput, LibraryBookAuthorUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBookAuthorCreateWithoutBookInput, LibraryBookAuthorUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookAuthorUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBookAuthorWhereUniqueInput
    data: XOR<LibraryBookAuthorUpdateWithoutBookInput, LibraryBookAuthorUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBookAuthorUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBookAuthorScalarWhereInput
    data: XOR<LibraryBookAuthorUpdateManyMutationInput, LibraryBookAuthorUncheckedUpdateManyWithoutBookAuthorsInput>
  }

  export type LibraryBookCopyUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    update: XOR<LibraryBookCopyUpdateWithoutBookInput, LibraryBookCopyUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBookCopyCreateWithoutBookInput, LibraryBookCopyUncheckedCreateWithoutBookInput>
  }

  export type LibraryBookCopyUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBookCopyWhereUniqueInput
    data: XOR<LibraryBookCopyUpdateWithoutBookInput, LibraryBookCopyUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBookCopyUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBookCopyScalarWhereInput
    data: XOR<LibraryBookCopyUpdateManyMutationInput, LibraryBookCopyUncheckedUpdateManyWithoutBookCopiesInput>
  }

  export type LibraryRequestUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryRequestWhereUniqueInput
    update: XOR<LibraryRequestUpdateWithoutBookInput, LibraryRequestUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryRequestCreateWithoutBookInput, LibraryRequestUncheckedCreateWithoutBookInput>
  }

  export type LibraryRequestUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryRequestWhereUniqueInput
    data: XOR<LibraryRequestUpdateWithoutBookInput, LibraryRequestUncheckedUpdateWithoutBookInput>
  }

  export type LibraryRequestUpdateManyWithWhereWithoutBookInput = {
    where: LibraryRequestScalarWhereInput
    data: XOR<LibraryRequestUpdateManyMutationInput, LibraryRequestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type LibraryBorrowingUpsertWithWhereUniqueWithoutBookInput = {
    where: LibraryBorrowingWhereUniqueInput
    update: XOR<LibraryBorrowingUpdateWithoutBookInput, LibraryBorrowingUncheckedUpdateWithoutBookInput>
    create: XOR<LibraryBorrowingCreateWithoutBookInput, LibraryBorrowingUncheckedCreateWithoutBookInput>
  }

  export type LibraryBorrowingUpdateWithWhereUniqueWithoutBookInput = {
    where: LibraryBorrowingWhereUniqueInput
    data: XOR<LibraryBorrowingUpdateWithoutBookInput, LibraryBorrowingUncheckedUpdateWithoutBookInput>
  }

  export type LibraryBorrowingUpdateManyWithWhereWithoutBookInput = {
    where: LibraryBorrowingScalarWhereInput
    data: XOR<LibraryBorrowingUpdateManyMutationInput, LibraryBorrowingUncheckedUpdateManyWithoutBorrowingsInput>
  }

  export type LibraryBookCreateWithoutBookCategoriesInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
    requests?: LibraryRequestCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutBookCategoriesInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutBookCategoriesInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutBookCategoriesInput, LibraryBookUncheckedCreateWithoutBookCategoriesInput>
  }

  export type LibraryCategoryCreateWithoutBookCategoriesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryUncheckedCreateWithoutBookCategoriesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCategoryCreateOrConnectWithoutBookCategoriesInput = {
    where: LibraryCategoryWhereUniqueInput
    create: XOR<LibraryCategoryCreateWithoutBookCategoriesInput, LibraryCategoryUncheckedCreateWithoutBookCategoriesInput>
  }

  export type LibraryBookUpsertWithoutBookCategoriesInput = {
    update: XOR<LibraryBookUpdateWithoutBookCategoriesInput, LibraryBookUncheckedUpdateWithoutBookCategoriesInput>
    create: XOR<LibraryBookCreateWithoutBookCategoriesInput, LibraryBookUncheckedCreateWithoutBookCategoriesInput>
  }

  export type LibraryBookUpdateWithoutBookCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutBookCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUncheckedUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryCategoryUpsertWithoutBookCategoriesInput = {
    update: XOR<LibraryCategoryUpdateWithoutBookCategoriesInput, LibraryCategoryUncheckedUpdateWithoutBookCategoriesInput>
    create: XOR<LibraryCategoryCreateWithoutBookCategoriesInput, LibraryCategoryUncheckedCreateWithoutBookCategoriesInput>
  }

  export type LibraryCategoryUpdateWithoutBookCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCategoryUncheckedUpdateWithoutBookCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCreateWithoutBookAuthorsInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
    requests?: LibraryRequestCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutBookAuthorsInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutBookAuthorsInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutBookAuthorsInput, LibraryBookUncheckedCreateWithoutBookAuthorsInput>
  }

  export type LibraryAuthorCreateWithoutBookAuthorsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryAuthorUncheckedCreateWithoutBookAuthorsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryAuthorCreateOrConnectWithoutBookAuthorsInput = {
    where: LibraryAuthorWhereUniqueInput
    create: XOR<LibraryAuthorCreateWithoutBookAuthorsInput, LibraryAuthorUncheckedCreateWithoutBookAuthorsInput>
  }

  export type LibraryBookUpsertWithoutBookAuthorsInput = {
    update: XOR<LibraryBookUpdateWithoutBookAuthorsInput, LibraryBookUncheckedUpdateWithoutBookAuthorsInput>
    create: XOR<LibraryBookCreateWithoutBookAuthorsInput, LibraryBookUncheckedCreateWithoutBookAuthorsInput>
  }

  export type LibraryBookUpdateWithoutBookAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutBookAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUncheckedUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryAuthorUpsertWithoutBookAuthorsInput = {
    update: XOR<LibraryAuthorUpdateWithoutBookAuthorsInput, LibraryAuthorUncheckedUpdateWithoutBookAuthorsInput>
    create: XOR<LibraryAuthorCreateWithoutBookAuthorsInput, LibraryAuthorUncheckedCreateWithoutBookAuthorsInput>
  }

  export type LibraryAuthorUpdateWithoutBookAuthorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryAuthorUncheckedUpdateWithoutBookAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCreateWithoutBookCopiesInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutBookInput
    requests?: LibraryRequestCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutBookCopiesInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutBookCopiesInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutBookCopiesInput, LibraryBookUncheckedCreateWithoutBookCopiesInput>
  }

  export type LibraryUniversityCreateWithoutBookCopiesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromRequests?: LibraryRequestCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityUncheckedCreateWithoutBookCopiesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityCreateOrConnectWithoutBookCopiesInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutBookCopiesInput, LibraryUniversityUncheckedCreateWithoutBookCopiesInput>
  }

  export type LibraryBookUpsertWithoutBookCopiesInput = {
    update: XOR<LibraryBookUpdateWithoutBookCopiesInput, LibraryBookUncheckedUpdateWithoutBookCopiesInput>
    create: XOR<LibraryBookCreateWithoutBookCopiesInput, LibraryBookUncheckedCreateWithoutBookCopiesInput>
  }

  export type LibraryBookUpdateWithoutBookCopiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUncheckedUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryUniversityUpsertWithoutBookCopiesInput = {
    update: XOR<LibraryUniversityUpdateWithoutBookCopiesInput, LibraryUniversityUncheckedUpdateWithoutBookCopiesInput>
    create: XOR<LibraryUniversityCreateWithoutBookCopiesInput, LibraryUniversityUncheckedCreateWithoutBookCopiesInput>
  }

  export type LibraryUniversityUpdateWithoutBookCopiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromRequests?: LibraryRequestUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromRequests?: LibraryRequestUncheckedUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUncheckedUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryBookCreateWithoutRequestsInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutRequestsInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutRequestsInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutRequestsInput, LibraryBookUncheckedCreateWithoutRequestsInput>
  }

  export type LibraryStudentCreateWithoutRequestsInput = {
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowings?: LibraryBorrowingCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutRequestsInput = {
    id?: number
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutRequestsInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutRequestsInput, LibraryStudentUncheckedCreateWithoutRequestsInput>
  }

  export type LibraryUniversityCreateWithoutFromRequestsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    toRequests?: LibraryRequestCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityUncheckedCreateWithoutFromRequestsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    toRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToUniversityInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityCreateOrConnectWithoutFromRequestsInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutFromRequestsInput, LibraryUniversityUncheckedCreateWithoutFromRequestsInput>
  }

  export type LibraryUniversityCreateWithoutToRequestsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestCreateNestedManyWithoutFromUniversityInput
    borrowings?: LibraryBorrowingCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityUncheckedCreateWithoutToRequestsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromUniversityInput
    borrowings?: LibraryBorrowingUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type LibraryUniversityCreateOrConnectWithoutToRequestsInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutToRequestsInput, LibraryUniversityUncheckedCreateWithoutToRequestsInput>
  }

  export type LibraryBookUpsertWithoutRequestsInput = {
    update: XOR<LibraryBookUpdateWithoutRequestsInput, LibraryBookUncheckedUpdateWithoutRequestsInput>
    create: XOR<LibraryBookCreateWithoutRequestsInput, LibraryBookUncheckedCreateWithoutRequestsInput>
  }

  export type LibraryBookUpdateWithoutRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryStudentUpsertWithoutRequestsInput = {
    update: XOR<LibraryStudentUpdateWithoutRequestsInput, LibraryStudentUncheckedUpdateWithoutRequestsInput>
    create: XOR<LibraryStudentCreateWithoutRequestsInput, LibraryStudentUncheckedCreateWithoutRequestsInput>
  }

  export type LibraryStudentUpdateWithoutRequestsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowings?: LibraryBorrowingUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryUniversityUpsertWithoutFromRequestsInput = {
    update: XOR<LibraryUniversityUpdateWithoutFromRequestsInput, LibraryUniversityUncheckedUpdateWithoutFromRequestsInput>
    create: XOR<LibraryUniversityCreateWithoutFromRequestsInput, LibraryUniversityUncheckedCreateWithoutFromRequestsInput>
  }

  export type LibraryUniversityUpdateWithoutFromRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    toRequests?: LibraryRequestUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutFromRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    toRequests?: LibraryRequestUncheckedUpdateManyWithoutToUniversityNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityUpsertWithoutToRequestsInput = {
    update: XOR<LibraryUniversityUpdateWithoutToRequestsInput, LibraryUniversityUncheckedUpdateWithoutToRequestsInput>
    create: XOR<LibraryUniversityCreateWithoutToRequestsInput, LibraryUniversityUncheckedCreateWithoutToRequestsInput>
  }

  export type LibraryUniversityUpdateWithoutToRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUpdateManyWithoutFromUniversityNestedInput
    borrowings?: LibraryBorrowingUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutToRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUncheckedUpdateManyWithoutFromUniversityNestedInput
    borrowings?: LibraryBorrowingUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LibraryBookCreateWithoutBorrowingsInput = {
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutBookInput
    requests?: LibraryRequestCreateNestedManyWithoutBookInput
  }

  export type LibraryBookUncheckedCreateWithoutBorrowingsInput = {
    id?: number
    name: string
    isbn: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCategories?: LibraryBookCategoryUncheckedCreateNestedManyWithoutBookInput
    bookAuthors?: LibraryBookAuthorUncheckedCreateNestedManyWithoutBookInput
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutBookInput
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutBookInput
  }

  export type LibraryBookCreateOrConnectWithoutBorrowingsInput = {
    where: LibraryBookWhereUniqueInput
    create: XOR<LibraryBookCreateWithoutBorrowingsInput, LibraryBookUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryStudentCreateWithoutBorrowingsInput = {
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: LibraryRequestCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentUncheckedCreateWithoutBorrowingsInput = {
    id?: number
    firstName: string
    lastName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: LibraryRequestUncheckedCreateNestedManyWithoutStudentInput
  }

  export type LibraryStudentCreateOrConnectWithoutBorrowingsInput = {
    where: LibraryStudentWhereUniqueInput
    create: XOR<LibraryStudentCreateWithoutBorrowingsInput, LibraryStudentUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryUniversityCreateWithoutBorrowingsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestCreateNestedManyWithoutToUniversityInput
  }

  export type LibraryUniversityUncheckedCreateWithoutBorrowingsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookCopies?: LibraryBookCopyUncheckedCreateNestedManyWithoutUniversityInput
    fromRequests?: LibraryRequestUncheckedCreateNestedManyWithoutFromUniversityInput
    toRequests?: LibraryRequestUncheckedCreateNestedManyWithoutToUniversityInput
  }

  export type LibraryUniversityCreateOrConnectWithoutBorrowingsInput = {
    where: LibraryUniversityWhereUniqueInput
    create: XOR<LibraryUniversityCreateWithoutBorrowingsInput, LibraryUniversityUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryBookUpsertWithoutBorrowingsInput = {
    update: XOR<LibraryBookUpdateWithoutBorrowingsInput, LibraryBookUncheckedUpdateWithoutBorrowingsInput>
    create: XOR<LibraryBookCreateWithoutBorrowingsInput, LibraryBookUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryBookUpdateWithoutBorrowingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUpdateManyWithoutBookNestedInput
  }

  export type LibraryBookUncheckedUpdateWithoutBorrowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isbn?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCategories?: LibraryBookCategoryUncheckedUpdateManyWithoutBookNestedInput
    bookAuthors?: LibraryBookAuthorUncheckedUpdateManyWithoutBookNestedInput
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutBookNestedInput
    requests?: LibraryRequestUncheckedUpdateManyWithoutBookNestedInput
  }

  export type LibraryStudentUpsertWithoutBorrowingsInput = {
    update: XOR<LibraryStudentUpdateWithoutBorrowingsInput, LibraryStudentUncheckedUpdateWithoutBorrowingsInput>
    create: XOR<LibraryStudentCreateWithoutBorrowingsInput, LibraryStudentUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryStudentUpdateWithoutBorrowingsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: LibraryRequestUpdateManyWithoutStudentNestedInput
  }

  export type LibraryStudentUncheckedUpdateWithoutBorrowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: LibraryRequestUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LibraryUniversityUpsertWithoutBorrowingsInput = {
    update: XOR<LibraryUniversityUpdateWithoutBorrowingsInput, LibraryUniversityUncheckedUpdateWithoutBorrowingsInput>
    create: XOR<LibraryUniversityCreateWithoutBorrowingsInput, LibraryUniversityUncheckedCreateWithoutBorrowingsInput>
  }

  export type LibraryUniversityUpdateWithoutBorrowingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUpdateManyWithoutToUniversityNestedInput
  }

  export type LibraryUniversityUncheckedUpdateWithoutBorrowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookCopies?: LibraryBookCopyUncheckedUpdateManyWithoutUniversityNestedInput
    fromRequests?: LibraryRequestUncheckedUpdateManyWithoutFromUniversityNestedInput
    toRequests?: LibraryRequestUncheckedUpdateManyWithoutToUniversityNestedInput
  }

  export type BinKitchenMenuCreateManyCategoryInput = {
    id?: number
    name: string
    image: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenMenuUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: BinKitchenOrderItemUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    orderItems?: BinKitchenOrderItemUncheckedUpdateManyWithoutMenuNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenMenuUncheckedUpdateManyWithoutMenusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateManyMenuInput = {
    id?: number
    orderId?: number | null
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUpdateWithoutMenuInput = {
    order?: BinKitchenOrderUpdateOneWithoutItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateWithoutMenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemCreateManyOrderInput = {
    id?: number
    menuId: number
    quantity: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinKitchenOrderItemUpdateWithoutOrderInput = {
    menu?: BinKitchenMenuUpdateOneRequiredWithoutOrderItemsNestedInput
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinKitchenOrderItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    menuId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyCategoryInput = {
    id?: number
    questName: string
    answerChoiceId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundCreateManyCategoryInput = {
    id?: number
    user: string
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateWithoutCategoryInput = {
    questName?: StringFieldUpdateOperationsInput | string
    answer?: QuizChoiceUpdateOneRequiredWithoutQuestionAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    choices?: QuizChoiceUncheckedUpdateManyWithoutQuestioneNestedInput
    roundQuestions?: QuizRoundQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    questName?: StringFieldUpdateOperationsInput | string
    answerChoiceId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundUpdateWithoutCategoryInput = {
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizRoundQuestionUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizRoundQuestionUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type QuizRoundUncheckedUpdateManyWithoutRoundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceCreateManyQuestioneInput = {
    id?: number
    choiceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionCreateManyQuestionInput = {
    id?: number
    userChoiceId: number
    roundId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizChoiceUpdateWithoutQuestioneInput = {
    choiceName?: StringFieldUpdateOperationsInput | string
    questionAnswer?: QuizQuestionUpdateOneWithoutAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateWithoutQuestioneInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceName?: StringFieldUpdateOperationsInput | string
    questionAnswer?: QuizQuestionUncheckedUpdateOneWithoutAnswerNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizChoiceUncheckedUpdateManyWithoutChoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    choiceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUpdateWithoutQuestionInput = {
    userChoiceId?: IntFieldUpdateOperationsInput | number
    round?: QuizRoundUpdateOneRequiredWithoutQuestionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateManyWithoutRoundQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionCreateManyRoundInput = {
    id?: number
    userChoiceId: number
    questionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizRoundQuestionUpdateWithoutRoundInput = {
    userChoiceId?: IntFieldUpdateOperationsInput | number
    question?: QuizQuestionUpdateOneRequiredWithoutRoundQuestionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizRoundQuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userChoiceId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipCreateManyFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipCreateManyToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupCreateManyUserInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostCreateManyUserInput = {
    id?: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageCreateManyFromInput = {
    id?: number
    toUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookDirectMessageCreateManyToInput = {
    id?: number
    fromUserId: number
    message: string
    image?: string | null
    readStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostCreateManyUserInput = {
    id?: number
    postId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeCreateManyUserInput = {
    id?: number
    type: FacebookLikeTypeEnum
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateManyUserWallInput = {
    id?: number
    type: string
    groupId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserRelationshipUpdateWithoutFromInput = {
    to?: FacebookUserUpdateOneRequiredWithoutToNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateManyWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUpdateWithoutToInput = {
    from?: FacebookUserUpdateOneRequiredWithoutFromNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserRelationshipUncheckedUpdateManyWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUpdateWithoutUserInput = {
    group?: FacebookGroupUpdateOneRequiredWithoutUserInGroupsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUncheckedUpdateManyWithoutUserInGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostUpdateWithoutUserInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUpdateWithoutFromInput = {
    to?: FacebookUserUpdateOneRequiredWithoutDirectMessageToNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateManyWithoutDirectMessageFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUpdateWithoutToInput = {
    from?: FacebookUserUpdateOneRequiredWithoutDirectMessageFromNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookDirectMessageUncheckedUpdateManyWithoutDirectMessageToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostUpdateWithoutUserInput = {
    post?: FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentTo?: FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput
    share?: FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateManyWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUpdateWithoutUserInput = {
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    posts?: FacebookPostUpdateOneWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUncheckedUpdateManyWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUpdateWithoutUserWallInput = {
    type?: StringFieldUpdateOperationsInput | string
    group?: FacebookGroupUpdateOneWithoutPostDestinationsNestedInput
    post?: FacebookPostUpdateOneWithoutPostDestionationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateWithoutUserWallInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateManyWithoutPostDestinationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostCreateManyLocationInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    hashtagId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostUpdateWithoutLocationInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashtagId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostCreateManyHashtagInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostUpdateWithoutHashtagInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    share?: FacebookShareTypeUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookCommentPostCreateManyShareInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostCreateManyShareInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    locationId: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostUpdateWithoutShareInput = {
    post?: FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput
    user?: FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentTo?: FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateWithoutShareInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookPostUpdateWithoutShareInput = {
    user?: FacebookUserUpdateOneRequiredWithoutPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: FacebookLocationUpdateOneRequiredWithoutPostsNestedInput
    hashtag?: FacebookHashtagUpdateOneWithoutPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUpdateManyWithoutPostNestedInput
  }

  export type FacebookPostUncheckedUpdateWithoutShareInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: FacebookLikeUncheckedUpdateManyWithoutPostsNestedInput
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutPostNestedInput
    postDestionations?: FacebookPostDestinationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FacebookUserInGroupCreateManyGroupInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateManyGroupInput = {
    id?: number
    type: string
    userId: number
    postId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookUserInGroupUpdateWithoutGroupInput = {
    user?: FacebookUserUpdateOneRequiredWithoutUserInGroupsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookUserInGroupUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUpdateWithoutGroupInput = {
    type?: StringFieldUpdateOperationsInput | string
    userWall?: FacebookUserUpdateOneWithoutPostDestinationsNestedInput
    post?: FacebookPostUpdateOneWithoutPostDestionationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeCreateManyPostsInput = {
    id?: number
    type: FacebookLikeTypeEnum
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostCreateManyPostInput = {
    id?: number
    userId: number
    message?: string | null
    image?: string | null
    commentToId?: number | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookPostDestinationCreateManyPostInput = {
    id?: number
    type: string
    userId: number
    groupId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookLikeUpdateWithoutPostsInput = {
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    user?: FacebookUserUpdateOneRequiredWithoutLikesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookLikeUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumFacebookLikeTypeEnumFieldUpdateOperationsInput | FacebookLikeTypeEnum
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostUpdateWithoutPostInput = {
    user?: FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentTo?: FacebookCommentPostUpdateOneWithoutCommentPostsNestedInput
    share?: FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookPostDestinationUpdateWithoutPostInput = {
    type?: StringFieldUpdateOperationsInput | string
    userWall?: FacebookUserUpdateOneWithoutPostDestinationsNestedInput
    group?: FacebookGroupUpdateOneWithoutPostDestinationsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookPostDestinationUncheckedUpdateManyWithoutPostDestionationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacebookCommentPostCreateManyCommentToInput = {
    id?: number
    postId: number
    userId: number
    message?: string | null
    image?: string | null
    shareToId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacebookCommentPostUpdateWithoutCommentToInput = {
    post?: FacebookPostUpdateOneRequiredWithoutCommentPostsNestedInput
    user?: FacebookUserUpdateOneRequiredWithoutCommentPostsNestedInput
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    share?: FacebookShareTypeUpdateOneRequiredWithoutCommentPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUpdateManyWithoutCommentToNestedInput
  }

  export type FacebookCommentPostUncheckedUpdateWithoutCommentToInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    shareToId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: FacebookCommentPostUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type TwitterPostCreateManyUserInput = {
    id?: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipCreateManyFromInput = {
    id?: number
    toUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterUserRelationshipCreateManyToInput = {
    id?: number
    fromUserId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostCreateManyUserInput = {
    id?: number
    message: string
    image?: string | null
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateManyFromInput = {
    id?: number
    toUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterDirectMessageCreateManyToInput = {
    id?: number
    fromUserId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUpdateManyWithoutPostNestedInput
    replyPosts?: TwitterReplyPostUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postAndHashtags?: TwitterPostAndHashtagUncheckedUpdateManyWithoutPostNestedInput
    replyPosts?: TwitterReplyPostUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TwitterPostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUpdateWithoutFromInput = {
    to?: TwitterUserUpdateOneRequiredWithoutFollowersNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateManyWithoutFollowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUpdateWithoutToInput = {
    from?: TwitterUserUpdateOneRequiredWithoutFollowingsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterUserRelationshipUncheckedUpdateManyWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUpdateWithoutUserInput = {
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    post?: TwitterPostUpdateOneRequiredWithoutReplyPostsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUncheckedUpdateManyWithoutReplyPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUpdateWithoutFromInput = {
    to?: TwitterUserUpdateOneRequiredWithoutDirectMessageToNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutDirectMessageFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUpdateWithoutToInput = {
    from?: TwitterUserUpdateOneRequiredWithoutDirectMessageFromNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterDirectMessageUncheckedUpdateManyWithoutDirectMessageToInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUserId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagCreateManyPostInput = {
    id?: number
    hashtagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterReplyPostCreateManyPostInput = {
    id?: number
    userId: number
    message: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUpdateWithoutPostInput = {
    hashtag?: TwitterHashtagUpdateOneRequiredWithoutPostAndHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagUncheckedUpdateManyWithoutPostAndHashtagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hashtagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUpdateWithoutPostInput = {
    user?: TwitterUserUpdateOneRequiredWithoutReplyPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterReplyPostUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagCreateManyHashtagInput = {
    id?: number
    postId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterPostAndHashtagUpdateWithoutHashtagInput = {
    post?: TwitterPostUpdateOneRequiredWithoutPostAndHashtagsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterPostAndHashtagUncheckedUpdateWithoutHashtagInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyUserInput = {
    id?: number
    roleId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberCreateManyUserInput = {
    id?: number
    channelId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionCreateManyUserInput = {
    id?: number
    type: ReactionEnum
    videoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentCreateManyUserInput = {
    id?: number
    videoId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateWithoutUserInput = {
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelsNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateManyWithoutUserToChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUpdateWithoutUserInput = {
    channel?: YoutubeChannelUpdateOneRequiredWithoutSubscribersNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUncheckedUpdateManyWithoutSubscribersInput = {
    id?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUpdateWithoutUserInput = {
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    video?: YoutubeVideoUpdateOneRequiredWithoutReactionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateManyWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    videoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentUpdateWithoutUserInput = {
    video?: YoutubeVideoUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: YoutubeCommentUpdateOneWithoutCommentPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyRoleInput = {
    id?: number
    userId: number
    channelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateWithoutRoleInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelsNestedInput
    channel?: YoutubeChannelUpdateOneRequiredWithoutUserToChannelsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    channelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelCreateManyChannelInput = {
    id?: number
    userId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeVideoCreateManyChannelInput = {
    id?: number
    name: string
    urlFile: string
    coverImage?: string | null
    descriptions?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeSubscriberCreateManyChannelInput = {
    id?: number
    userId: number
    membership: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeUserToChannelUpdateWithoutChannelInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutUserToChannelsNestedInput
    role?: YoutubeRoleUpdateOneRequiredWithoutUserToChannelsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeUserToChannelUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeVideoUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUpdateManyWithoutVideoNestedInput
    reactions?: YoutubeReactionUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: YoutubeCommentUncheckedUpdateManyWithoutVideoNestedInput
    reactions?: YoutubeReactionUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type YoutubeVideoUncheckedUpdateManyWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    urlFile?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    descriptions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUpdateWithoutChannelInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutSubscribersNestedInput
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeSubscriberUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    membership?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentCreateManyVideoInput = {
    id?: number
    userId: number
    message: string
    commentToId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeReactionCreateManyVideoInput = {
    id?: number
    type: ReactionEnum
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentUpdateWithoutVideoInput = {
    user?: YoutubeUserUpdateOneRequiredWithoutCommentsNestedInput
    commentTo?: YoutubeCommentUpdateOneWithoutCommentPostsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    commentToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeReactionUpdateWithoutVideoInput = {
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    user?: YoutubeUserUpdateOneRequiredWithoutReactionsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeReactionUncheckedUpdateWithoutVideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumReactionEnumFieldUpdateOperationsInput | ReactionEnum
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YoutubeCommentCreateManyCommentToInput = {
    id?: number
    videoId: number
    userId: number
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type YoutubeCommentUpdateWithoutCommentToInput = {
    video?: YoutubeVideoUpdateOneRequiredWithoutCommentsNestedInput
    user?: YoutubeUserUpdateOneRequiredWithoutCommentsNestedInput
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateWithoutCommentToInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentPosts?: YoutubeCommentUncheckedUpdateManyWithoutCommentToNestedInput
  }

  export type YoutubeCommentUncheckedUpdateManyWithoutCommentPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMachineInStoreCreateManyBranchInput = {
    id?: number
    machineId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMachineInStoreUpdateWithoutBranchInput = {
    machine?: LaunderMachineUpdateOneRequiredWithoutMachineInStoresNestedInput
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateManyWithoutMachineInStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryMachineInStoreCreateManyMachineInput = {
    id?: number
    branchId: number
    mfd: string
    Warranty: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryCreateManyMachineInput = {
    id?: number
    date: Date | string
    technicianId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryMachineInStoreUpdateWithoutMachineInput = {
    branch?: LaunderBranchInfoUpdateOneRequiredWithoutMachineInStoresNestedInput
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUpdateManyWithoutMachineNestedInput
  }

  export type LaundryMachineInStoreUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    mfd?: StringFieldUpdateOperationsInput | string
    Warranty?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programInMachines?: LaunderProgramInMachineUncheckedUpdateManyWithoutMachineNestedInput
    washingHistories?: LaundryWashingHistoryUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type LaunderServiceHistoryUpdateWithoutMachineInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    technician?: LaunderTechnicianUpdateOneRequiredWithoutServiceHistoriesNestedInput
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    technicianId?: IntFieldUpdateOperationsInput | number
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryUncheckedUpdateManyWithoutServiceHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    technicianId?: IntFieldUpdateOperationsInput | number
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineCreateManyMachineInput = {
    id?: number
    programId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryCreateManyMachineInput = {
    id?: number
    programId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUpdateWithoutMachineInput = {
    program?: LaunderWashingProgramUpdateOneRequiredWithoutProgramInMachinesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineUncheckedUpdateManyWithoutProgramInMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUpdateWithoutMachineInput = {
    program?: LaunderWashingProgramUpdateOneRequiredWithoutWashingHistoriesNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUncheckedUpdateManyWithoutWashingHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryCreateManyTechnicianInput = {
    id?: number
    date: Date | string
    machineId: number
    descriptions: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderServiceHistoryUpdateWithoutTechnicianInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: LaunderMachineUpdateOneRequiredWithoutServiceHistoriesNestedInput
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderServiceHistoryUncheckedUpdateWithoutTechnicianInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    machineId?: IntFieldUpdateOperationsInput | number
    descriptions?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineCreateManyProgramInput = {
    id?: number
    machineId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryWashingHistoryCreateManyProgramInput = {
    id?: number
    machineId: number
    date: Date | string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunderProgramInMachineUpdateWithoutProgramInput = {
    machine?: LaundryMachineInStoreUpdateOneRequiredWithoutProgramInMachinesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunderProgramInMachineUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUpdateWithoutProgramInput = {
    machine?: LaundryMachineInStoreUpdateOneRequiredWithoutWashingHistoriesNestedInput
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryWashingHistoryUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryCreateManyUserInput = {
    id?: number
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaundryTopupHistoryUpdateWithoutUserInput = {
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaundryTopupHistoryUncheckedUpdateManyWithoutTopupHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestCreateManyStudentInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateManyStudentInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestUpdateWithoutStudentInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutRequestsNestedInput
    fromUniversity?: LibraryUniversityUpdateOneRequiredWithoutFromRequestsNestedInput
    toUniversity?: LibraryUniversityUpdateOneRequiredWithoutToRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateManyWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUpdateWithoutStudentInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBorrowingsNestedInput
    university?: LibraryUniversityUpdateOneRequiredWithoutBorrowingsNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateManyWithoutBorrowingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyCreateManyUniversityInput = {
    id?: number
    bookId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateManyFromUniversityInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateManyToUniversityInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    bookId: number
    studentId: number
    fromUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateManyUniversityInput = {
    id?: number
    bookId: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyUpdateWithoutUniversityInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateManyWithoutBookCopiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUpdateWithoutFromUniversityInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutRequestsNestedInput
    student?: LibraryStudentUpdateOneRequiredWithoutRequestsNestedInput
    toUniversity?: LibraryUniversityUpdateOneRequiredWithoutToRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutFromUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateManyWithoutFromRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUpdateWithoutToUniversityInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: LibraryBookUpdateOneRequiredWithoutRequestsNestedInput
    student?: LibraryStudentUpdateOneRequiredWithoutRequestsNestedInput
    fromUniversity?: LibraryUniversityUpdateOneRequiredWithoutFromRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutToUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateManyWithoutToRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUpdateWithoutUniversityInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBorrowingsNestedInput
    student?: LibraryStudentUpdateOneRequiredWithoutBorrowingsNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateWithoutUniversityInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryCreateManyCategoryInput = {
    id?: number
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUpdateWithoutCategoryInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateManyWithoutBookCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorCreateManyAuthorInput = {
    id?: number
    bookId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorUpdateWithoutAuthorInput = {
    book?: LibraryBookUpdateOneRequiredWithoutBookAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateManyWithoutBookAuthorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryCreateManyBookInput = {
    id?: number
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookAuthorCreateManyBookInput = {
    id?: number
    authorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCopyCreateManyBookInput = {
    id?: number
    universityId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryRequestCreateManyBookInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    studentId: number
    fromUniversityId: number
    toUniversityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBorrowingCreateManyBookInput = {
    id?: number
    borrowDate: Date | string
    returnDate: Date | string
    actualReturnDate: Date | string
    studentId: number
    universityId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryBookCategoryUpdateWithoutBookInput = {
    category?: LibraryCategoryUpdateOneRequiredWithoutBookCategoriesNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCategoryUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUpdateWithoutBookInput = {
    author?: LibraryAuthorUpdateOneRequiredWithoutBookAuthorsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookAuthorUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUpdateWithoutBookInput = {
    university?: LibraryUniversityUpdateOneRequiredWithoutBookCopiesNestedInput
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBookCopyUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUpdateWithoutBookInput = {
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: LibraryStudentUpdateOneRequiredWithoutRequestsNestedInput
    fromUniversity?: LibraryUniversityUpdateOneRequiredWithoutFromRequestsNestedInput
    toUniversity?: LibraryUniversityUpdateOneRequiredWithoutToRequestsNestedInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryRequestUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: IntFieldUpdateOperationsInput | number
    fromUniversityId?: IntFieldUpdateOperationsInput | number
    toUniversityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUpdateWithoutBookInput = {
    student?: LibraryStudentUpdateOneRequiredWithoutBorrowingsNestedInput
    university?: LibraryUniversityUpdateOneRequiredWithoutBorrowingsNestedInput
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryBorrowingUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    borrowDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualReturnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: IntFieldUpdateOperationsInput | number
    universityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}